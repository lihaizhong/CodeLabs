/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./app.json?package=app":
/*!******************************!*\
  !*** ./app.json?package=app ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const NOOP=()=>{}; setInterval(NOOP, 1000);\r\nglobal.__globalComponents = [];\r\nglobal.__qaRoute = 'app';\r\n__webpack_require__(/*! ./app.js */ \"./app.js\");\r\nglobal.__qaRoute = 'miniprogram_npm/weui-miniprogram/cells/cells';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./miniprogram_npm/weui-miniprogram/cells/cells.js */ \"./miniprogram_npm/weui-miniprogram/cells/cells.js\");\r\nglobal.__qaRoute = 'miniprogram_npm/weui-miniprogram/cell/cell';\r\nglobal.usingComponents = [\"miniprogram_npm/weui-miniprogram/cells/cells\"];\r\n__webpack_require__(/*! ./miniprogram_npm/weui-miniprogram/cell/cell.js */ \"./miniprogram_npm/weui-miniprogram/cell/cell.js\");\r\nglobal.__qaRoute = 'pages/index/index';\r\nglobal.usingComponents = [\"miniprogram_npm/weui-miniprogram/cells/cells\",\"miniprogram_npm/weui-miniprogram/cell/cell\"];\r\n__webpack_require__(/*! ./pages/index/index.js */ \"./pages/index/index.js\");\r\nglobal.__qaRoute = 'components/animation/index';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./components/animation/index.js */ \"./components/animation/index.js\");\r\nglobal.__qaRoute = 'pages/svga/index';\r\nglobal.usingComponents = [\"components/animation/index\"];\r\n__webpack_require__(/*! ./pages/svga/index.js */ \"./pages/svga/index.js\");\r\nglobal.__qaRoute = 'components/animation2/index';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./components/animation2/index.js */ \"./components/animation2/index.js\");\r\nglobal.__qaRoute = 'pages/svga2/index';\r\nglobal.usingComponents = [\"components/animation2/index\"];\r\n__webpack_require__(/*! ./pages/svga2/index.js */ \"./pages/svga2/index.js\");\r\nglobal.__qaRoute = 'components/poster/index';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./components/poster/index.js */ \"./components/poster/index.js\");\r\nglobal.__qaRoute = 'pages/poster/index';\r\nglobal.usingComponents = [\"components/poster/index\"];\r\n__webpack_require__(/*! ./pages/poster/index.js */ \"./pages/poster/index.js\");\r\nglobal.__qaRoute = 'pages/webview/index';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./pages/webview/index.js */ \"./pages/webview/index.js\");\r\nglobal.__qaRoute = 'pages/apng/index';\r\nglobal.usingComponents = [];\r\n__webpack_require__(/*! ./pages/apng/index.js */ \"./pages/apng/index.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAuanNvbj9wYWNrYWdlPWFwcC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vYXBwLmpzb24/NjI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBOT09QPSgpPT57fTsgc2V0SW50ZXJ2YWwoTk9PUCwgMTAwMCk7XHJcbmdsb2JhbC5fX2dsb2JhbENvbXBvbmVudHMgPSBbXTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdhcHAnO1xyXG5yZXF1aXJlKCcuL2FwcC5qcycpO1xyXG5nbG9iYWwuX19xYVJvdXRlID0gJ21pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGxzL2NlbGxzJztcclxuZ2xvYmFsLnVzaW5nQ29tcG9uZW50cyA9IFtdO1xyXG5yZXF1aXJlKCcuL21pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGxzL2NlbGxzLmpzJyk7XHJcbmdsb2JhbC5fX3FhUm91dGUgPSAnbWluaXByb2dyYW1fbnBtL3dldWktbWluaXByb2dyYW0vY2VsbC9jZWxsJztcclxuZ2xvYmFsLnVzaW5nQ29tcG9uZW50cyA9IFtcIm1pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGxzL2NlbGxzXCJdO1xyXG5yZXF1aXJlKCcuL21pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGwvY2VsbC5qcycpO1xyXG5nbG9iYWwuX19xYVJvdXRlID0gJ3BhZ2VzL2luZGV4L2luZGV4JztcclxuZ2xvYmFsLnVzaW5nQ29tcG9uZW50cyA9IFtcIm1pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGxzL2NlbGxzXCIsXCJtaW5pcHJvZ3JhbV9ucG0vd2V1aS1taW5pcHJvZ3JhbS9jZWxsL2NlbGxcIl07XHJcbnJlcXVpcmUoJy4vcGFnZXMvaW5kZXgvaW5kZXguanMnKTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdjb21wb25lbnRzL2FuaW1hdGlvbi9pbmRleCc7XHJcbmdsb2JhbC51c2luZ0NvbXBvbmVudHMgPSBbXTtcclxucmVxdWlyZSgnLi9jb21wb25lbnRzL2FuaW1hdGlvbi9pbmRleC5qcycpO1xyXG5nbG9iYWwuX19xYVJvdXRlID0gJ3BhZ2VzL3N2Z2EvaW5kZXgnO1xyXG5nbG9iYWwudXNpbmdDb21wb25lbnRzID0gW1wiY29tcG9uZW50cy9hbmltYXRpb24vaW5kZXhcIl07XHJcbnJlcXVpcmUoJy4vcGFnZXMvc3ZnYS9pbmRleC5qcycpO1xyXG5nbG9iYWwuX19xYVJvdXRlID0gJ2NvbXBvbmVudHMvYW5pbWF0aW9uMi9pbmRleCc7XHJcbmdsb2JhbC51c2luZ0NvbXBvbmVudHMgPSBbXTtcclxucmVxdWlyZSgnLi9jb21wb25lbnRzL2FuaW1hdGlvbjIvaW5kZXguanMnKTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdwYWdlcy9zdmdhMi9pbmRleCc7XHJcbmdsb2JhbC51c2luZ0NvbXBvbmVudHMgPSBbXCJjb21wb25lbnRzL2FuaW1hdGlvbjIvaW5kZXhcIl07XHJcbnJlcXVpcmUoJy4vcGFnZXMvc3ZnYTIvaW5kZXguanMnKTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdjb21wb25lbnRzL3Bvc3Rlci9pbmRleCc7XHJcbmdsb2JhbC51c2luZ0NvbXBvbmVudHMgPSBbXTtcclxucmVxdWlyZSgnLi9jb21wb25lbnRzL3Bvc3Rlci9pbmRleC5qcycpO1xyXG5nbG9iYWwuX19xYVJvdXRlID0gJ3BhZ2VzL3Bvc3Rlci9pbmRleCc7XHJcbmdsb2JhbC51c2luZ0NvbXBvbmVudHMgPSBbXCJjb21wb25lbnRzL3Bvc3Rlci9pbmRleFwiXTtcclxucmVxdWlyZSgnLi9wYWdlcy9wb3N0ZXIvaW5kZXguanMnKTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdwYWdlcy93ZWJ2aWV3L2luZGV4JztcclxuZ2xvYmFsLnVzaW5nQ29tcG9uZW50cyA9IFtdO1xyXG5yZXF1aXJlKCcuL3BhZ2VzL3dlYnZpZXcvaW5kZXguanMnKTtcclxuZ2xvYmFsLl9fcWFSb3V0ZSA9ICdwYWdlcy9hcG5nL2luZGV4JztcclxuZ2xvYmFsLnVzaW5nQ29tcG9uZW50cyA9IFtdO1xyXG5yZXF1aXJlKCcuL3BhZ2VzL2FwbmcvaW5kZXguanMnKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app.json?package=app\n");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _urlSearchParams = _interopRequireDefault(__webpack_require__(/*! @ungap/url-search-params */ \"./miniprogram_npm/@ungap/url-search-params/cjs/index.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nApp({\n  onLaunch() {},\n  onPageNotFound(e) {\n    const {\n      path,\n      query\n    } = e;\n    if (path === 'pages/index') {\n      const params = new _urlSearchParams.default(query);\n      const url = `${path}/index?${params.toString()}`;\n      console.warn('未找到页面，正在重定向到', url);\n      has.navigateTo({\n        url\n      });\n    } else {\n      console.error('未找到页面', e);\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vYXBwLmpzP2Q4NzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXJsU2VhcmNoUGFyYW1zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbkFwcCh7XG4gIG9uTGF1bmNoKCkge30sXG4gIG9uUGFnZU5vdEZvdW5kKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoLFxuICAgICAgcXVlcnlcbiAgICB9ID0gZTtcbiAgICBpZiAocGF0aCA9PT0gJ3BhZ2VzL2luZGV4Jykge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IF91cmxTZWFyY2hQYXJhbXMuZGVmYXVsdChxdWVyeSk7XG4gICAgICBjb25zdCB1cmwgPSBgJHtwYXRofS9pbmRleD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gICAgICBjb25zb2xlLndhcm4oJ+acquaJvuWIsOmhtemdou+8jOato+WcqOmHjeWumuWQkeWIsCcsIHVybCk7XG4gICAgICBoYXMubmF2aWdhdGVUbyh7XG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+acquaJvuWIsOmhtemdoicsIGUpO1xuICAgIH1cbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app.js\n");

/***/ }),

/***/ "./components/animation/index.js":
/*!***************************************!*\
  !*** ./components/animation/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _fuckSvga = __webpack_require__(/*! ../../utils/fuck-svga */ \"./utils/fuck-svga.js\");\nvar _fuckBenchmark = __webpack_require__(/*! ../../utils/fuck-benchmark */ \"./utils/fuck-benchmark.js\");\nvar _ReadyGo = _interopRequireDefault(__webpack_require__(/*! ../../utils/ReadyGo */ \"./utils/ReadyGo.js\"));\nvar _EnhancedWorker = __webpack_require__(/*! ../../utils/EnhancedWorker */ \"./utils/EnhancedWorker.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nlet player, observer;\nconst playerAwait = async scope => {\n  player = new _fuckSvga.Player();\n  player.onStart = async () => {\n    _fuckBenchmark.benchmark.mark(\"持续时间\");\n    _fuckBenchmark.benchmark.mark(\"总消耗时间\");\n    const bucket = await videoManager.get();\n    _fuckBenchmark.benchmark.log(\"---- START ----\", \"每帧期望消耗时长\", 1000 / bucket.entity.fps, \"预期总消耗时长\", bucket.entity.frames / bucket.entity.fps * 1000);\n  };\n  player.onProcess = (percent, frame) => {\n    _fuckBenchmark.benchmark.log(\"---- UPDATE ----\", \"当前进度\", percent, \"当前帧\", frame);\n    _fuckBenchmark.benchmark.mark(\"持续时间\");\n  };\n  player.onResume = () => {\n    _fuckBenchmark.benchmark.log(\"---- RESUME ----\");\n  };\n  player.onPause = () => {\n    _fuckBenchmark.benchmark.log(\"---- PAUSE ----\");\n  };\n  player.onStop = () => {\n    _fuckBenchmark.benchmark.log(\"---- STOP ----\");\n  };\n  player.onEnd = () => {\n    _fuckBenchmark.benchmark.log(\"---- END ----\");\n    _fuckBenchmark.benchmark.mark(\"总消耗时间\");\n    _fuckBenchmark.benchmark.reset(\"持续时间\");\n    _fuckBenchmark.benchmark.reset(\"总消耗时间\");\n  };\n  await player.setConfig({\n    container: \"#palette\",\n    loop: 1,\n    playMode: \"forwards\",\n    fillMode: \"backwards\",\n    contentMode: \"aspect-fit\"\n  }, scope);\n  _fuckBenchmark.benchmark.time(\"创建 100 个 Image 元素的总时长\", () => {\n    for (let i = 0; i < 100; i++) {\n      player.painter.F.createImage();\n    }\n  });\n  observer = has.createIntersectionObserver(scope, {\n    thresholds: [0, 0.5, 1],\n    initialRatio: 0,\n    nativeMode: true\n  });\n  observer.relativeToViewport().observe(\"#palette\", ({\n    intersectionRatio\n  }) => {\n    if (intersectionRatio > 0) {\n      player.resume();\n    } else {\n      player.pause();\n    }\n  });\n};\nconst worker = new _EnhancedWorker.EnhancedWorker();\nconst readyGo = new _ReadyGo.default();\nconst videoManager = new _fuckSvga.VideoManager(\"fast\", {\n  preprocess: async bucket => {\n    const {\n      local,\n      remote\n    } = _fuckSvga.platform;\n    if (await local.exists(bucket.local)) {\n      return local.read(bucket.local);\n    }\n    const buff = await remote.fetch(bucket.origin);\n    return new Promise(resolve => {\n      worker.once(bucket.origin, data => resolve(data));\n      worker.emit(bucket.origin, buff);\n    });\n  },\n  postprocess: (bucket, data) => _fuckSvga.Parser.parseVideo(data, bucket.origin, false)\n});\nComponent({\n  properties: {\n    current: {\n      type: Number,\n      value: 0\n    },\n    sources: {\n      type: Array,\n      value: []\n    }\n  },\n  observers: {\n    current(value) {\n      _fuckBenchmark.benchmark.log(\"当前动效位置\", value);\n      readyGo.ready(this.initialize.bind(this));\n    }\n  },\n  lifetimes: {\n    ready() {\n      Promise.all([worker.open(), playerAwait(this)]).then(() => {\n        const urls = this.properties.sources.map(item => typeof item === \"string\" ? item : item.url);\n        _fuckBenchmark.benchmark.log(\"准备资源中\");\n        return videoManager.prepare(urls);\n      }).then(() => {\n        _fuckBenchmark.benchmark.log(\"组件准备就绪\");\n        readyGo.go();\n      });\n    },\n    detached() {\n      var _player, _observer;\n      readyGo.reset();\n      videoManager.clear();\n      worker.close();\n      (_player = player) === null || _player === void 0 || _player.destroy();\n      (_observer = observer) === null || _observer === void 0 || _observer.disconnect();\n      player = null;\n      observer = null;\n    }\n  },\n  data: {\n    message: \"\"\n  },\n  methods: {\n    async initialize() {\n      try {\n        const {\n          current,\n          sources\n        } = this.properties;\n        const source = sources[current];\n        const bucket = await videoManager.go(current);\n        if (typeof source === \"object\" && source !== null && source.replace) {\n          const editor = new _fuckSvga.VideoEditor(player.painter, player.resource, bucket.entity);\n          this.setData({\n            message: \"文件编辑中\"\n          });\n          await _fuckBenchmark.benchmark.time(\"replace images\", () => Promise.all(Object.keys(source.replace).map(key => editor.setImage(key, source.replace[key]))));\n        }\n        this.setData({\n          message: \"资源装载中...\"\n        });\n        _fuckBenchmark.benchmark.log(source, bucket);\n        await _fuckBenchmark.benchmark.time(\"mount\", () => player.mount(bucket.entity));\n        // player.stepToPercentage(0.3);\n        player.start();\n        this.setData({\n          message: \"\"\n        });\n      } catch (ex) {\n        console.error(\"svga初始化失败\", ex);\n        this.setData({\n          message: ex.message + \"\\n\" + ex.stack\n        });\n      }\n    },\n    handlePlay() {\n      var _player2;\n      (_player2 = player) === null || _player2 === void 0 || _player2.start();\n    },\n    handleResume() {\n      var _player3;\n      (_player3 = player) === null || _player3 === void 0 || _player3.resume();\n    },\n    handlePause() {\n      var _player4;\n      (_player4 = player) === null || _player4 === void 0 || _player4.pause();\n    },\n    handleStop() {\n      var _player5;\n      (_player5 = player) === null || _player5 === void 0 || _player5.stop();\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2FuaW1hdGlvbi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL2NvbXBvbmVudHMvYW5pbWF0aW9uL2luZGV4LmpzP2RkNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZnVja1N2Z2EgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZnVjay1zdmdhXCIpO1xudmFyIF9mdWNrQmVuY2htYXJrID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2Z1Y2stYmVuY2htYXJrXCIpO1xudmFyIF9SZWFkeUdvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvUmVhZHlHb1wiKSk7XG52YXIgX0VuaGFuY2VkV29ya2VyID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0VuaGFuY2VkV29ya2VyXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxubGV0IHBsYXllciwgb2JzZXJ2ZXI7XG5jb25zdCBwbGF5ZXJBd2FpdCA9IGFzeW5jIHNjb3BlID0+IHtcbiAgcGxheWVyID0gbmV3IF9mdWNrU3ZnYS5QbGF5ZXIoKTtcbiAgcGxheWVyLm9uU3RhcnQgPSBhc3luYyAoKSA9PiB7XG4gICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLm1hcmsoXCLmjIHnu63ml7bpl7RcIik7XG4gICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLm1hcmsoXCLmgLvmtojogJfml7bpl7RcIik7XG4gICAgY29uc3QgYnVja2V0ID0gYXdhaXQgdmlkZW9NYW5hZ2VyLmdldCgpO1xuICAgIF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay5sb2coXCItLS0tIFNUQVJUIC0tLS1cIiwgXCLmr4/luKfmnJ/mnJvmtojogJfml7bplb9cIiwgMTAwMCAvIGJ1Y2tldC5lbnRpdHkuZnBzLCBcIumihOacn+aAu+a2iOiAl+aXtumVv1wiLCBidWNrZXQuZW50aXR5LmZyYW1lcyAvIGJ1Y2tldC5lbnRpdHkuZnBzICogMTAwMCk7XG4gIH07XG4gIHBsYXllci5vblByb2Nlc3MgPSAocGVyY2VudCwgZnJhbWUpID0+IHtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwiLS0tLSBVUERBVEUgLS0tLVwiLCBcIuW9k+WJjei/m+W6plwiLCBwZXJjZW50LCBcIuW9k+WJjeW4p1wiLCBmcmFtZSk7XG4gICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLm1hcmsoXCLmjIHnu63ml7bpl7RcIik7XG4gIH07XG4gIHBsYXllci5vblJlc3VtZSA9ICgpID0+IHtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwiLS0tLSBSRVNVTUUgLS0tLVwiKTtcbiAgfTtcbiAgcGxheWVyLm9uUGF1c2UgPSAoKSA9PiB7XG4gICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLmxvZyhcIi0tLS0gUEFVU0UgLS0tLVwiKTtcbiAgfTtcbiAgcGxheWVyLm9uU3RvcCA9ICgpID0+IHtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwiLS0tLSBTVE9QIC0tLS1cIik7XG4gIH07XG4gIHBsYXllci5vbkVuZCA9ICgpID0+IHtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwiLS0tLSBFTkQgLS0tLVwiKTtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubWFyayhcIuaAu+a2iOiAl+aXtumXtFwiKTtcbiAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsucmVzZXQoXCLmjIHnu63ml7bpl7RcIik7XG4gICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLnJlc2V0KFwi5oC75raI6ICX5pe26Ze0XCIpO1xuICB9O1xuICBhd2FpdCBwbGF5ZXIuc2V0Q29uZmlnKHtcbiAgICBjb250YWluZXI6IFwiI3BhbGV0dGVcIixcbiAgICBsb29wOiAxLFxuICAgIHBsYXlNb2RlOiBcImZvcndhcmRzXCIsXG4gICAgZmlsbE1vZGU6IFwiYmFja3dhcmRzXCIsXG4gICAgY29udGVudE1vZGU6IFwiYXNwZWN0LWZpdFwiXG4gIH0sIHNjb3BlKTtcbiAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLnRpbWUoXCLliJvlu7ogMTAwIOS4qiBJbWFnZSDlhYPntKDnmoTmgLvml7bplb9cIiwgKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgIHBsYXllci5wYWludGVyLkYuY3JlYXRlSW1hZ2UoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlciA9IGhhcy5jcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlcihzY29wZSwge1xuICAgIHRocmVzaG9sZHM6IFswLCAwLjUsIDFdLFxuICAgIGluaXRpYWxSYXRpbzogMCxcbiAgICBuYXRpdmVNb2RlOiB0cnVlXG4gIH0pO1xuICBvYnNlcnZlci5yZWxhdGl2ZVRvVmlld3BvcnQoKS5vYnNlcnZlKFwiI3BhbGV0dGVcIiwgKHtcbiAgICBpbnRlcnNlY3Rpb25SYXRpb1xuICB9KSA9PiB7XG4gICAgaWYgKGludGVyc2VjdGlvblJhdGlvID4gMCkge1xuICAgICAgcGxheWVyLnJlc3VtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IHdvcmtlciA9IG5ldyBfRW5oYW5jZWRXb3JrZXIuRW5oYW5jZWRXb3JrZXIoKTtcbmNvbnN0IHJlYWR5R28gPSBuZXcgX1JlYWR5R28uZGVmYXVsdCgpO1xuY29uc3QgdmlkZW9NYW5hZ2VyID0gbmV3IF9mdWNrU3ZnYS5WaWRlb01hbmFnZXIoXCJmYXN0XCIsIHtcbiAgcHJlcHJvY2VzczogYXN5bmMgYnVja2V0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsb2NhbCxcbiAgICAgIHJlbW90ZVxuICAgIH0gPSBfZnVja1N2Z2EucGxhdGZvcm07XG4gICAgaWYgKGF3YWl0IGxvY2FsLmV4aXN0cyhidWNrZXQubG9jYWwpKSB7XG4gICAgICByZXR1cm4gbG9jYWwucmVhZChidWNrZXQubG9jYWwpO1xuICAgIH1cbiAgICBjb25zdCBidWZmID0gYXdhaXQgcmVtb3RlLmZldGNoKGJ1Y2tldC5vcmlnaW4pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHdvcmtlci5vbmNlKGJ1Y2tldC5vcmlnaW4sIGRhdGEgPT4gcmVzb2x2ZShkYXRhKSk7XG4gICAgICB3b3JrZXIuZW1pdChidWNrZXQub3JpZ2luLCBidWZmKTtcbiAgICB9KTtcbiAgfSxcbiAgcG9zdHByb2Nlc3M6IChidWNrZXQsIGRhdGEpID0+IF9mdWNrU3ZnYS5QYXJzZXIucGFyc2VWaWRlbyhkYXRhLCBidWNrZXQub3JpZ2luLCBmYWxzZSlcbn0pO1xuQ29tcG9uZW50KHtcbiAgcHJvcGVydGllczoge1xuICAgIGN1cnJlbnQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICBzb3VyY2VzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbHVlOiBbXVxuICAgIH1cbiAgfSxcbiAgb2JzZXJ2ZXJzOiB7XG4gICAgY3VycmVudCh2YWx1ZSkge1xuICAgICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLmxvZyhcIuW9k+WJjeWKqOaViOS9jee9rlwiLCB2YWx1ZSk7XG4gICAgICByZWFkeUdvLnJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0sXG4gIGxpZmV0aW1lczoge1xuICAgIHJlYWR5KCkge1xuICAgICAgUHJvbWlzZS5hbGwoW3dvcmtlci5vcGVuKCksIHBsYXllckF3YWl0KHRoaXMpXSkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVybHMgPSB0aGlzLnByb3BlcnRpZXMuc291cmNlcy5tYXAoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IGl0ZW0gOiBpdGVtLnVybCk7XG4gICAgICAgIF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay5sb2coXCLlh4blpIfotYTmupDkuK1cIik7XG4gICAgICAgIHJldHVybiB2aWRlb01hbmFnZXIucHJlcGFyZSh1cmxzKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwi57uE5Lu25YeG5aSH5bCx57uqXCIpO1xuICAgICAgICByZWFkeUdvLmdvKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRldGFjaGVkKCkge1xuICAgICAgdmFyIF9wbGF5ZXIsIF9vYnNlcnZlcjtcbiAgICAgIHJlYWR5R28ucmVzZXQoKTtcbiAgICAgIHZpZGVvTWFuYWdlci5jbGVhcigpO1xuICAgICAgd29ya2VyLmNsb3NlKCk7XG4gICAgICAoX3BsYXllciA9IHBsYXllcikgPT09IG51bGwgfHwgX3BsYXllciA9PT0gdm9pZCAwIHx8IF9wbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgKF9vYnNlcnZlciA9IG9ic2VydmVyKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgcGxheWVyID0gbnVsbDtcbiAgICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IHtcbiAgICBtZXNzYWdlOiBcIlwiXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgc291cmNlc1xuICAgICAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2N1cnJlbnRdO1xuICAgICAgICBjb25zdCBidWNrZXQgPSBhd2FpdCB2aWRlb01hbmFnZXIuZ28oY3VycmVudCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcIm9iamVjdFwiICYmIHNvdXJjZSAhPT0gbnVsbCAmJiBzb3VyY2UucmVwbGFjZSkge1xuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IG5ldyBfZnVja1N2Z2EuVmlkZW9FZGl0b3IocGxheWVyLnBhaW50ZXIsIHBsYXllci5yZXNvdXJjZSwgYnVja2V0LmVudGl0eSk7XG4gICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwi5paH5Lu257yW6L6R5LitXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsudGltZShcInJlcGxhY2UgaW1hZ2VzXCIsICgpID0+IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHNvdXJjZS5yZXBsYWNlKS5tYXAoa2V5ID0+IGVkaXRvci5zZXRJbWFnZShrZXksIHNvdXJjZS5yZXBsYWNlW2tleV0pKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogXCLotYTmupDoo4Xovb3kuK0uLi5cIlxuICAgICAgICB9KTtcbiAgICAgICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLmxvZyhzb3VyY2UsIGJ1Y2tldCk7XG4gICAgICAgIGF3YWl0IF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay50aW1lKFwibW91bnRcIiwgKCkgPT4gcGxheWVyLm1vdW50KGJ1Y2tldC5lbnRpdHkpKTtcbiAgICAgICAgLy8gcGxheWVyLnN0ZXBUb1BlcmNlbnRhZ2UoMC4zKTtcbiAgICAgICAgcGxheWVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdmdh5Yid5aeL5YyW5aSx6LSlXCIsIGV4KTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICBtZXNzYWdlOiBleC5tZXNzYWdlICsgXCJcXG5cIiArIGV4LnN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlUGxheSgpIHtcbiAgICAgIHZhciBfcGxheWVyMjtcbiAgICAgIChfcGxheWVyMiA9IHBsYXllcikgPT09IG51bGwgfHwgX3BsYXllcjIgPT09IHZvaWQgMCB8fCBfcGxheWVyMi5zdGFydCgpO1xuICAgIH0sXG4gICAgaGFuZGxlUmVzdW1lKCkge1xuICAgICAgdmFyIF9wbGF5ZXIzO1xuICAgICAgKF9wbGF5ZXIzID0gcGxheWVyKSA9PT0gbnVsbCB8fCBfcGxheWVyMyA9PT0gdm9pZCAwIHx8IF9wbGF5ZXIzLnJlc3VtZSgpO1xuICAgIH0sXG4gICAgaGFuZGxlUGF1c2UoKSB7XG4gICAgICB2YXIgX3BsYXllcjQ7XG4gICAgICAoX3BsYXllcjQgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXI0ID09PSB2b2lkIDAgfHwgX3BsYXllcjQucGF1c2UoKTtcbiAgICB9LFxuICAgIGhhbmRsZVN0b3AoKSB7XG4gICAgICB2YXIgX3BsYXllcjU7XG4gICAgICAoX3BsYXllcjUgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXI1ID09PSB2b2lkIDAgfHwgX3BsYXllcjUuc3RvcCgpO1xuICAgIH1cbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/animation/index.js\n");

/***/ }),

/***/ "./components/animation2/index.js":
/*!****************************************!*\
  !*** ./components/animation2/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _svga2dfire = _interopRequireDefault(__webpack_require__(/*! ../../utils/svga-2dfire */ \"./utils/svga-2dfire.js\"));\nvar _ReadyGo = _interopRequireDefault(__webpack_require__(/*! ../../utils/ReadyGo */ \"./utils/ReadyGo.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst {\n  Parser,\n  Player\n} = _svga2dfire.default;\nlet player;\nlet parser;\nconst readyGo = new _ReadyGo.default();\nComponent({\n  properties: {\n    url: {\n      type: String,\n      value: \"\"\n    }\n  },\n  observers: {\n    url(value) {\n      if (value !== \"\") {\n        readyGo.ready(this.initialize.bind(this));\n      }\n    }\n  },\n  lifetimes: {\n    async ready() {\n      parser = new Parser();\n      player = new Player();\n      await player.setCanvas(\"#palette\", this);\n      player.loops = 1;\n      player.playMode = \"fallbacks\";\n      player.fillMode = \"forwards\";\n      player.onPercentage((percent, frame) => {\n        console.log('当前进度', percent, frame);\n        console.log('---- UPDATE ----');\n      });\n      player.onFinished(() => {\n        console.log('---- END ----');\n      });\n      readyGo.go();\n    },\n    detached() {\n      var _player, _player2;\n      readyGo.reset();\n      (_player = player) === null || _player === void 0 || _player.stopAnimation();\n      (_player2 = player) === null || _player2 === void 0 || _player2.clear();\n      player = null;\n      parser = null;\n    }\n  },\n  data: {\n    message: \"\"\n  },\n  methods: {\n    async initialize() {\n      try {\n        this.setData({\n          message: \"准备下载资源\"\n        });\n        const videoItem = await parser.load(this.properties.url);\n        this.setData({\n          message: \"下载资源成功\"\n        });\n        console.log(this.properties.url, videoItem);\n        await player.setVideoItem(videoItem);\n        this.setData({\n          message: \"资源装载成功\"\n        });\n        // player.stepToPercentage(0.3);\n        player.startAnimation();\n        this.setData({\n          message: \"\"\n        });\n      } catch (ex) {\n        console.error(\"svga初始化失败！\", ex);\n        this.setData({\n          message: ex.message + \"\\n\" + ex.stack\n        });\n      }\n    },\n    handlePlay() {\n      var _player3;\n      (_player3 = player) === null || _player3 === void 0 || _player3.startAnimation();\n    },\n    handleResume() {\n      var _player4;\n      (_player4 = player) === null || _player4 === void 0 || _player4.startAnimation();\n    },\n    handlePause() {\n      var _player5;\n      (_player5 = player) === null || _player5 === void 0 || _player5.pauseAnimation();\n    },\n    handleStop() {\n      var _player6;\n      (_player6 = player) === null || _player6 === void 0 || _player6.stopAnimation();\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2FuaW1hdGlvbjIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL2NvbXBvbmVudHMvYW5pbWF0aW9uMi9pbmRleC5qcz81Mzg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3N2Z2EyZGZpcmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdmdhLTJkZmlyZVwiKSk7XG52YXIgX1JlYWR5R28gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9SZWFkeUdvXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbmNvbnN0IHtcbiAgUGFyc2VyLFxuICBQbGF5ZXJcbn0gPSBfc3ZnYTJkZmlyZS5kZWZhdWx0O1xubGV0IHBsYXllcjtcbmxldCBwYXJzZXI7XG5jb25zdCByZWFkeUdvID0gbmV3IF9SZWFkeUdvLmRlZmF1bHQoKTtcbkNvbXBvbmVudCh7XG4gIHByb3BlcnRpZXM6IHtcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiBcIlwiXG4gICAgfVxuICB9LFxuICBvYnNlcnZlcnM6IHtcbiAgICB1cmwodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICByZWFkeUdvLnJlYWR5KHRoaXMuaW5pdGlhbGl6ZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGxpZmV0aW1lczoge1xuICAgIGFzeW5jIHJlYWR5KCkge1xuICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgICAgcGxheWVyID0gbmV3IFBsYXllcigpO1xuICAgICAgYXdhaXQgcGxheWVyLnNldENhbnZhcyhcIiNwYWxldHRlXCIsIHRoaXMpO1xuICAgICAgcGxheWVyLmxvb3BzID0gMTtcbiAgICAgIHBsYXllci5wbGF5TW9kZSA9IFwiZmFsbGJhY2tzXCI7XG4gICAgICBwbGF5ZXIuZmlsbE1vZGUgPSBcImZvcndhcmRzXCI7XG4gICAgICBwbGF5ZXIub25QZXJjZW50YWdlKChwZXJjZW50LCBmcmFtZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn5b2T5YmN6L+b5bqmJywgcGVyY2VudCwgZnJhbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygnLS0tLSBVUERBVEUgLS0tLScpO1xuICAgICAgfSk7XG4gICAgICBwbGF5ZXIub25GaW5pc2hlZCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCctLS0tIEVORCAtLS0tJyk7XG4gICAgICB9KTtcbiAgICAgIHJlYWR5R28uZ28oKTtcbiAgICB9LFxuICAgIGRldGFjaGVkKCkge1xuICAgICAgdmFyIF9wbGF5ZXIsIF9wbGF5ZXIyO1xuICAgICAgcmVhZHlHby5yZXNldCgpO1xuICAgICAgKF9wbGF5ZXIgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXIgPT09IHZvaWQgMCB8fCBfcGxheWVyLnN0b3BBbmltYXRpb24oKTtcbiAgICAgIChfcGxheWVyMiA9IHBsYXllcikgPT09IG51bGwgfHwgX3BsYXllcjIgPT09IHZvaWQgMCB8fCBfcGxheWVyMi5jbGVhcigpO1xuICAgICAgcGxheWVyID0gbnVsbDtcbiAgICAgIHBhcnNlciA9IG51bGw7XG4gICAgfVxuICB9LFxuICBkYXRhOiB7XG4gICAgbWVzc2FnZTogXCJcIlxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogXCLlh4blpIfkuIvovb3otYTmupBcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdmlkZW9JdGVtID0gYXdhaXQgcGFyc2VyLmxvYWQodGhpcy5wcm9wZXJ0aWVzLnVybCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogXCLkuIvovb3otYTmupDmiJDlip9cIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wcm9wZXJ0aWVzLnVybCwgdmlkZW9JdGVtKTtcbiAgICAgICAgYXdhaXQgcGxheWVyLnNldFZpZGVvSXRlbSh2aWRlb0l0ZW0pO1xuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwi6LWE5rqQ6KOF6L295oiQ5YqfXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHBsYXllci5zdGVwVG9QZXJjZW50YWdlKDAuMyk7XG4gICAgICAgIHBsYXllci5zdGFydEFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3ZnYeWIneWni+WMluWksei0pe+8gVwiLCBleCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogZXgubWVzc2FnZSArIFwiXFxuXCIgKyBleC5zdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVBsYXkoKSB7XG4gICAgICB2YXIgX3BsYXllcjM7XG4gICAgICAoX3BsYXllcjMgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXIzID09PSB2b2lkIDAgfHwgX3BsYXllcjMuc3RhcnRBbmltYXRpb24oKTtcbiAgICB9LFxuICAgIGhhbmRsZVJlc3VtZSgpIHtcbiAgICAgIHZhciBfcGxheWVyNDtcbiAgICAgIChfcGxheWVyNCA9IHBsYXllcikgPT09IG51bGwgfHwgX3BsYXllcjQgPT09IHZvaWQgMCB8fCBfcGxheWVyNC5zdGFydEFuaW1hdGlvbigpO1xuICAgIH0sXG4gICAgaGFuZGxlUGF1c2UoKSB7XG4gICAgICB2YXIgX3BsYXllcjU7XG4gICAgICAoX3BsYXllcjUgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXI1ID09PSB2b2lkIDAgfHwgX3BsYXllcjUucGF1c2VBbmltYXRpb24oKTtcbiAgICB9LFxuICAgIGhhbmRsZVN0b3AoKSB7XG4gICAgICB2YXIgX3BsYXllcjY7XG4gICAgICAoX3BsYXllcjYgPSBwbGF5ZXIpID09PSBudWxsIHx8IF9wbGF5ZXI2ID09PSB2b2lkIDAgfHwgX3BsYXllcjYuc3RvcEFuaW1hdGlvbigpO1xuICAgIH1cbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/animation2/index.js\n");

/***/ }),

/***/ "./components/poster/index.js":
/*!************************************!*\
  !*** ./components/poster/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _fuckSvga = __webpack_require__(/*! ../../utils/fuck-svga */ \"./utils/fuck-svga.js\");\nvar _ReadyGo = _interopRequireDefault(__webpack_require__(/*! ../../utils/ReadyGo */ \"./utils/ReadyGo.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst readyGo = new _ReadyGo.default();\nlet poster;\nComponent({\n  properties: {\n    current: {\n      type: Number,\n      value: 0\n    },\n    sources: {\n      type: Array,\n      value: []\n    },\n    frame: {\n      type: Number,\n      value: 0\n    }\n  },\n  observers: {\n    current(value) {\n      if (typeof value === \"number\") {\n        readyGo.ready(this.initialize.bind(this));\n      }\n    }\n  },\n  lifetimes: {\n    async ready() {\n      const {\n        windowWidth: width,\n        windowHeight: height\n      } = has.getSystemInfoSync();\n      poster = new _fuckSvga.Poster(width, height);\n      await poster.setConfig(\"#palette\", this);\n      readyGo.go();\n    },\n    detached() {\n      var _poster;\n      readyGo.reset();\n      (_poster = poster) === null || _poster === void 0 || _poster.destroy();\n    }\n  },\n  data: {\n    source: \"\",\n    message: \"\"\n  },\n  methods: {\n    async initialize() {\n      const {\n        current,\n        sources,\n        frame\n      } = this.properties;\n      const source = sources[current];\n      let videoItem;\n      try {\n        this.setData({\n          message: \"准备下载资源\"\n        });\n        if (typeof source === \"string\") {\n          videoItem = await _fuckSvga.Parser.load(source);\n        } else {\n          videoItem = await _fuckSvga.Parser.load(source.url);\n          const editor = new VideoEditor(player.painter, player.resource, bucket.entity);\n          this.setData({\n            message: \"文件编辑中\"\n          });\n          await benchmark.time(\"replace images\", () => Promise.all(Object.keys(source.replace).map(key => editor.setImage(key, source.replace[key]))));\n        }\n        this.setData({\n          message: \"下载资源成功\"\n        });\n        await poster.mount(videoItem, frame);\n        this.setData({\n          message: \"资源装载成功\"\n        });\n        poster.draw();\n        const imageData = poster.toImageData();\n        this.setData({\n          source: (0, _fuckSvga.createImageDataUrl)(imageData)\n        });\n        this.setData({\n          message: \"\"\n        });\n      } catch (ex) {\n        console.error(\"svga初始化失败！\", ex);\n        this.setData({\n          message: ex.message + \"\\n\" + ex.stack\n        });\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3Bvc3Rlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL2NvbXBvbmVudHMvcG9zdGVyL2luZGV4LmpzPzQ2NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZnVja1N2Z2EgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZnVjay1zdmdhXCIpO1xudmFyIF9SZWFkeUdvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvUmVhZHlHb1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5jb25zdCByZWFkeUdvID0gbmV3IF9SZWFkeUdvLmRlZmF1bHQoKTtcbmxldCBwb3N0ZXI7XG5Db21wb25lbnQoe1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgY3VycmVudDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHNvdXJjZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgdmFsdWU6IFtdXG4gICAgfSxcbiAgICBmcmFtZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDBcbiAgICB9XG4gIH0sXG4gIG9ic2VydmVyczoge1xuICAgIGN1cnJlbnQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmVhZHlHby5yZWFkeSh0aGlzLmluaXRpYWxpemUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBsaWZldGltZXM6IHtcbiAgICBhc3luYyByZWFkeSgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2luZG93V2lkdGg6IHdpZHRoLFxuICAgICAgICB3aW5kb3dIZWlnaHQ6IGhlaWdodFxuICAgICAgfSA9IGhhcy5nZXRTeXN0ZW1JbmZvU3luYygpO1xuICAgICAgcG9zdGVyID0gbmV3IF9mdWNrU3ZnYS5Qb3N0ZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICBhd2FpdCBwb3N0ZXIuc2V0Q29uZmlnKFwiI3BhbGV0dGVcIiwgdGhpcyk7XG4gICAgICByZWFkeUdvLmdvKCk7XG4gICAgfSxcbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgIHZhciBfcG9zdGVyO1xuICAgICAgcmVhZHlHby5yZXNldCgpO1xuICAgICAgKF9wb3N0ZXIgPSBwb3N0ZXIpID09PSBudWxsIHx8IF9wb3N0ZXIgPT09IHZvaWQgMCB8fCBfcG9zdGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IHtcbiAgICBzb3VyY2U6IFwiXCIsXG4gICAgbWVzc2FnZTogXCJcIlxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgZnJhbWVcbiAgICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2N1cnJlbnRdO1xuICAgICAgbGV0IHZpZGVvSXRlbTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogXCLlh4blpIfkuIvovb3otYTmupBcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2aWRlb0l0ZW0gPSBhd2FpdCBfZnVja1N2Z2EuUGFyc2VyLmxvYWQoc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWRlb0l0ZW0gPSBhd2FpdCBfZnVja1N2Z2EuUGFyc2VyLmxvYWQoc291cmNlLnVybCk7XG4gICAgICAgICAgY29uc3QgZWRpdG9yID0gbmV3IFZpZGVvRWRpdG9yKHBsYXllci5wYWludGVyLCBwbGF5ZXIucmVzb3VyY2UsIGJ1Y2tldC5lbnRpdHkpO1xuICAgICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIuaWh+S7tue8lui+keS4rVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgYmVuY2htYXJrLnRpbWUoXCJyZXBsYWNlIGltYWdlc1wiLCAoKSA9PiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhzb3VyY2UucmVwbGFjZSkubWFwKGtleSA9PiBlZGl0b3Iuc2V0SW1hZ2Uoa2V5LCBzb3VyY2UucmVwbGFjZVtrZXldKSkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwi5LiL6L296LWE5rqQ5oiQ5YqfXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHBvc3Rlci5tb3VudCh2aWRlb0l0ZW0sIGZyYW1lKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIui1hOa6kOijhei9veaIkOWKn1wiXG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0ZXIuZHJhdygpO1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBwb3N0ZXIudG9JbWFnZURhdGEoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICBzb3VyY2U6ICgwLCBfZnVja1N2Z2EuY3JlYXRlSW1hZ2VEYXRhVXJsKShpbWFnZURhdGEpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3ZnYeWIneWni+WMluWksei0pe+8gVwiLCBleCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgbWVzc2FnZTogZXgubWVzc2FnZSArIFwiXFxuXCIgKyBleC5zdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/poster/index.js\n");

/***/ }),

/***/ "./miniprogram_npm/weui-miniprogram/_commons/0.js":
/*!********************************************************!*\
  !*** ./miniprogram_npm/weui-miniprogram/_commons/0.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar globalThis = void 0,\n  self = void 0;\nmodule.exports = function (e) {\n  var t = {},\n    r = {\n      0: 0\n    };\n  function n(r) {\n    if (t[r]) return t[r].exports;\n    var o = t[r] = {\n      i: r,\n      l: !1,\n      exports: {}\n    };\n    return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n  }\n  return n.m = e, n.c = t, n.d = function (e, t, r) {\n    n.o(e, t) || Object.defineProperty(e, t, {\n      enumerable: !0,\n      get: r\n    });\n  }, n.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, n.t = function (e, t) {\n    if (1 & t && (e = n(e)), 8 & t) return e;\n    if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n    var r = Object.create(null);\n    if (n.r(r), Object.defineProperty(r, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(r, o, function (t) {\n      return e[t];\n    }.bind(null, o));\n    return r;\n  }, n.n = function (e) {\n    var t = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return n.d(t, \"a\", t), t;\n  }, n.o = function (e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  }, n.p = \"\", n.oe = function (e) {\n    process.nextTick(function () {\n      throw e;\n    });\n  }, function (t) {\n    for (var o, u, l, i, f, c, a, p, s, d, b, y = 0, g = 0, h = []; y < t.length; ++y) {\n      for (i = (l = t[y]).ids, c = l.modules, a = l.entries || [], o = 0; o < i.length; o++) f = i[o], r[f] = 0;\n      for (p in c) Object.prototype.hasOwnProperty.call(c, p) && (e[p] = c[p]);\n      h.push.apply(h, a || []);\n    }\n    for (; g < h.length; g++) {\n      for (s = h[g], d = !0, o = 1; o < s.length; o++) b = s[o], 0 !== r[b] && (d = !1);\n      d && (h.splice(g--, 1), u = n(n.s = s[0]));\n    }\n    return u;\n  };\n}([]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9taW5pcHJvZ3JhbV9ucG0vd2V1aS1taW5pcHJvZ3JhbS9fY29tbW9ucy8wLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vbWluaXByb2dyYW1fbnBtL3dldWktbWluaXByb2dyYW0vX2NvbW1vbnMvMC5qcz9lYjMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFsVGhpcyA9IHZvaWQgMCxcbiAgc2VsZiA9IHZvaWQgMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIHQgPSB7fSxcbiAgICByID0ge1xuICAgICAgMDogMFxuICAgIH07XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIGlmICh0W3JdKSByZXR1cm4gdFtyXS5leHBvcnRzO1xuICAgIHZhciBvID0gdFtyXSA9IHtcbiAgICAgIGk6IHIsXG4gICAgICBsOiAhMSxcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICByZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cywgbywgby5leHBvcnRzLCBuKSwgby5sID0gITAsIG8uZXhwb3J0cztcbiAgfVxuICByZXR1cm4gbi5tID0gZSwgbi5jID0gdCwgbi5kID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICBuLm8oZSwgdCkgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHQsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiByXG4gICAgfSk7XG4gIH0sIG4uciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICB2YWx1ZTogXCJNb2R1bGVcIlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiAhMFxuICAgIH0pO1xuICB9LCBuLnQgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIGlmICgxICYgdCAmJiAoZSA9IG4oZSkpLCA4ICYgdCkgcmV0dXJuIGU7XG4gICAgaWYgKDQgJiB0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciByID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAobi5yKHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJkZWZhdWx0XCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgdmFsdWU6IGVcbiAgICB9KSwgMiAmIHQgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgZm9yICh2YXIgbyBpbiBlKSBuLmQociwgbywgZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBlW3RdO1xuICAgIH0uYmluZChudWxsLCBvKSk7XG4gICAgcmV0dXJuIHI7XG4gIH0sIG4ubiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHQgPSBlICYmIGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlLmRlZmF1bHQ7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgcmV0dXJuIG4uZCh0LCBcImFcIiwgdCksIHQ7XG4gIH0sIG4ubyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KTtcbiAgfSwgbi5wID0gXCJcIiwgbi5vZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAodCkge1xuICAgIGZvciAodmFyIG8sIHUsIGwsIGksIGYsIGMsIGEsIHAsIHMsIGQsIGIsIHkgPSAwLCBnID0gMCwgaCA9IFtdOyB5IDwgdC5sZW5ndGg7ICsreSkge1xuICAgICAgZm9yIChpID0gKGwgPSB0W3ldKS5pZHMsIGMgPSBsLm1vZHVsZXMsIGEgPSBsLmVudHJpZXMgfHwgW10sIG8gPSAwOyBvIDwgaS5sZW5ndGg7IG8rKykgZiA9IGlbb10sIHJbZl0gPSAwO1xuICAgICAgZm9yIChwIGluIGMpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLCBwKSAmJiAoZVtwXSA9IGNbcF0pO1xuICAgICAgaC5wdXNoLmFwcGx5KGgsIGEgfHwgW10pO1xuICAgIH1cbiAgICBmb3IgKDsgZyA8IGgubGVuZ3RoOyBnKyspIHtcbiAgICAgIGZvciAocyA9IGhbZ10sIGQgPSAhMCwgbyA9IDE7IG8gPCBzLmxlbmd0aDsgbysrKSBiID0gc1tvXSwgMCAhPT0gcltiXSAmJiAoZCA9ICExKTtcbiAgICAgIGQgJiYgKGguc3BsaWNlKGctLSwgMSksIHUgPSBuKG4ucyA9IHNbMF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH07XG59KFtdKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./miniprogram_npm/weui-miniprogram/_commons/0.js\n");

/***/ }),

/***/ "./miniprogram_npm/weui-miniprogram/cell/cell.js":
/*!*******************************************************!*\
  !*** ./miniprogram_npm/weui-miniprogram/cell/cell.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar globalThis = void 0,\n  self = void 0;\nmodule.exports = __webpack_require__(/*! ../_commons/0.js */ \"./miniprogram_npm/weui-miniprogram/_commons/0.js\")([{\n  ids: [3],\n  modules: {\n    6: function (e, t, o) {\n      e.exports = o(74);\n    },\n    74: function (e, t) {\n      Component({\n        options: {\n          multipleSlots: !0\n        },\n        properties: {\n          hover: {\n            type: Boolean,\n            value: !1\n          },\n          link: {\n            type: Boolean,\n            value: !1\n          },\n          extClass: {\n            type: String,\n            value: \"\"\n          },\n          iconClass: {\n            type: String,\n            value: \"\"\n          },\n          bodyClass: {\n            type: String,\n            value: \"\"\n          },\n          icon: {\n            type: String,\n            value: \"\"\n          },\n          title: {\n            type: String,\n            value: \"\"\n          },\n          value: {\n            type: String,\n            value: \"\"\n          },\n          showError: {\n            type: Boolean,\n            value: !1\n          },\n          prop: {\n            type: String,\n            value: \"\"\n          },\n          url: {\n            type: String,\n            value: \"\"\n          },\n          footerClass: {\n            type: String,\n            value: \"\"\n          },\n          footer: {\n            type: String,\n            value: \"\"\n          },\n          inline: {\n            type: Boolean,\n            value: !0\n          },\n          hasHeader: {\n            type: Boolean,\n            value: !0\n          },\n          hasFooter: {\n            type: Boolean,\n            value: !0\n          },\n          hasBody: {\n            type: Boolean,\n            value: !0\n          },\n          extHoverClass: {\n            type: String,\n            value: \"\"\n          },\n          ariaRole: {\n            type: String,\n            value: \"\"\n          }\n        },\n        relations: {\n          \"../form/form\": {\n            type: \"ancestor\"\n          },\n          \"../cells/cells\": {\n            type: \"ancestor\"\n          }\n        },\n        data: {\n          inForm: !1\n        },\n        methods: {\n          setError: function (e) {\n            this.setData({\n              error: e || !1\n            });\n          },\n          setInForm: function () {\n            this.setData({\n              inForm: !0\n            });\n          },\n          setOuterClass: function (e) {\n            this.setData({\n              outerClass: e\n            });\n          },\n          navigateTo: function () {\n            var e = this,\n              t = this.data;\n            t.url && t.link && has.navigateTo({\n              url: t.url,\n              success: function (t) {\n                e.triggerEvent(\"navigatesuccess\", t, {});\n              },\n              fail: function (t) {\n                e.triggerEvent(\"navigateerror\", t, {});\n              }\n            });\n          }\n        }\n      });\n    }\n  },\n  entries: [[6, 0]]\n}]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9taW5pcHJvZ3JhbV9ucG0vd2V1aS1taW5pcHJvZ3JhbS9jZWxsL2NlbGwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL21pbmlwcm9ncmFtX25wbS93ZXVpLW1pbmlwcm9ncmFtL2NlbGwvY2VsbC5qcz8xN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFsVGhpcyA9IHZvaWQgMCxcbiAgc2VsZiA9IHZvaWQgMDtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL19jb21tb25zLzAuanNcIikoW3tcbiAgaWRzOiBbM10sXG4gIG1vZHVsZXM6IHtcbiAgICA2OiBmdW5jdGlvbiAoZSwgdCwgbykge1xuICAgICAgZS5leHBvcnRzID0gbyg3NCk7XG4gICAgfSxcbiAgICA3NDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIENvbXBvbmVudCh7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBtdWx0aXBsZVNsb3RzOiAhMFxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dENsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWNvbkNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaG93RXJyb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3A6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb290ZXJDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvb3Rlcjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlubGluZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzSGVhZGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNGb290ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc0JvZHk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dEhvdmVyQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcmlhUm9sZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aW9uczoge1xuICAgICAgICAgIFwiLi4vZm9ybS9mb3JtXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYW5jZXN0b3JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIuLi9jZWxscy9jZWxsc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFuY2VzdG9yXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbkZvcm06ICExXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICBzZXRFcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICAgIGVycm9yOiBlIHx8ICExXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldEluRm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgICAgaW5Gb3JtOiAhMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRPdXRlckNsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgICAgb3V0ZXJDbGFzczogZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0ZVRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICAgIHQgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB0LnVybCAmJiB0LmxpbmsgJiYgaGFzLm5hdmlnYXRlVG8oe1xuICAgICAgICAgICAgICB1cmw6IHQudXJsLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGUudHJpZ2dlckV2ZW50KFwibmF2aWdhdGVzdWNjZXNzXCIsIHQsIHt9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBlLnRyaWdnZXJFdmVudChcIm5hdmlnYXRlZXJyb3JcIiwgdCwge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZW50cmllczogW1s2LCAwXV1cbn1dKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./miniprogram_npm/weui-miniprogram/cell/cell.js\n");

/***/ }),

/***/ "./miniprogram_npm/weui-miniprogram/cells/cells.js":
/*!*********************************************************!*\
  !*** ./miniprogram_npm/weui-miniprogram/cells/cells.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar globalThis = void 0,\n  self = void 0;\nmodule.exports = __webpack_require__(/*! ../_commons/0.js */ \"./miniprogram_npm/weui-miniprogram/_commons/0.js\")([{\n  ids: [4],\n  modules: {\n    7: function (t, e, s) {\n      t.exports = s(82);\n    },\n    82: function (t, e) {\n      Component({\n        options: {\n          multipleSlots: !0\n        },\n        properties: {\n          title: {\n            type: String,\n            value: \"\"\n          },\n          extClass: {\n            type: String,\n            value: \"\"\n          },\n          footer: {\n            type: String,\n            value: \"\"\n          },\n          ariaRole: {\n            type: String,\n            value: \"\"\n          }\n        },\n        data: {\n          firstItem: null,\n          checkboxCount: 0,\n          checkboxIsMulti: !1,\n          outerClass: \"\",\n          childClass: \"\"\n        },\n        relations: {\n          \"../cell/cell\": {\n            type: \"descendant\",\n            linked: function (t) {\n              this.data.firstItem || (this.data.firstItem = t), t !== this.data.firstItem && t.setOuterClass(\"weui-cell_wxss\");\n            }\n          },\n          \"../form-page/form-page\": {\n            type: \"ancestor\"\n          },\n          \"../checkbox-group/checkbox-group\": {\n            type: \"descendant\",\n            linked: function (t) {\n              this.setData({\n                checkboxCount: this.data.checkboxCount + 1,\n                checkboxIsMulti: t.data.multi\n              });\n            },\n            unlinked: function (t) {\n              this.setData({\n                checkboxCount: this.data.checkboxCount - 1,\n                checkboxIsMulti: t.data.multi\n              });\n            }\n          }\n        },\n        methods: {\n          setCellMulti: function (t) {\n            this.setData({\n              checkboxIsMulti: t\n            });\n          },\n          setCellsClass: function (t) {\n            this.setData({\n              childClass: t\n            });\n          },\n          setOuterClass: function (t) {\n            this.setData({\n              outerClass: t\n            });\n          }\n        }\n      });\n    }\n  },\n  entries: [[7, 0]]\n}]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9taW5pcHJvZ3JhbV9ucG0vd2V1aS1taW5pcHJvZ3JhbS9jZWxscy9jZWxscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vbWluaXByb2dyYW1fbnBtL3dldWktbWluaXByb2dyYW0vY2VsbHMvY2VsbHMuanM/N2IxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbFRoaXMgPSB2b2lkIDAsXG4gIHNlbGYgPSB2b2lkIDA7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9fY29tbW9ucy8wLmpzXCIpKFt7XG4gIGlkczogWzRdLFxuICBtb2R1bGVzOiB7XG4gICAgNzogZnVuY3Rpb24gKHQsIGUsIHMpIHtcbiAgICAgIHQuZXhwb3J0cyA9IHMoODIpO1xuICAgIH0sXG4gICAgODI6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBDb21wb25lbnQoe1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgbXVsdGlwbGVTbG90czogITBcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0Q2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb290ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcmlhUm9sZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBmaXJzdEl0ZW06IG51bGwsXG4gICAgICAgICAgY2hlY2tib3hDb3VudDogMCxcbiAgICAgICAgICBjaGVja2JveElzTXVsdGk6ICExLFxuICAgICAgICAgIG91dGVyQ2xhc3M6IFwiXCIsXG4gICAgICAgICAgY2hpbGRDbGFzczogXCJcIlxuICAgICAgICB9LFxuICAgICAgICByZWxhdGlvbnM6IHtcbiAgICAgICAgICBcIi4uL2NlbGwvY2VsbFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImRlc2NlbmRhbnRcIixcbiAgICAgICAgICAgIGxpbmtlZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5kYXRhLmZpcnN0SXRlbSB8fCAodGhpcy5kYXRhLmZpcnN0SXRlbSA9IHQpLCB0ICE9PSB0aGlzLmRhdGEuZmlyc3RJdGVtICYmIHQuc2V0T3V0ZXJDbGFzcyhcIndldWktY2VsbF93eHNzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIuLi9mb3JtLXBhZ2UvZm9ybS1wYWdlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYW5jZXN0b3JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIuLi9jaGVja2JveC1ncm91cC9jaGVja2JveC1ncm91cFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImRlc2NlbmRhbnRcIixcbiAgICAgICAgICAgIGxpbmtlZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgICAgICBjaGVja2JveENvdW50OiB0aGlzLmRhdGEuY2hlY2tib3hDb3VudCArIDEsXG4gICAgICAgICAgICAgICAgY2hlY2tib3hJc011bHRpOiB0LmRhdGEubXVsdGlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5saW5rZWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgY2hlY2tib3hDb3VudDogdGhpcy5kYXRhLmNoZWNrYm94Q291bnQgLSAxLFxuICAgICAgICAgICAgICAgIGNoZWNrYm94SXNNdWx0aTogdC5kYXRhLm11bHRpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgIHNldENlbGxNdWx0aTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICAgIGNoZWNrYm94SXNNdWx0aTogdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRDZWxsc0NsYXNzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgICAgY2hpbGRDbGFzczogdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXRPdXRlckNsYXNzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgICAgb3V0ZXJDbGFzczogdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGVudHJpZXM6IFtbNywgMF1dXG59XSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./miniprogram_npm/weui-miniprogram/cells/cells.js\n");

/***/ }),

/***/ "./pages/apng/index.js":
/*!*****************************!*\
  !*** ./pages/apng/index.js ***!
  \*****************************/
/***/ (() => {

"use strict";
eval("\n\nPage({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9hcG5nL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vcGFnZXMvYXBuZy9pbmRleC5qcz9mMmNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5QYWdlKHt9KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/apng/index.js\n");

/***/ }),

/***/ "./pages/index/index.js":
/*!******************************!*\
  !*** ./pages/index/index.js ***!
  \******************************/
/***/ (() => {

"use strict";
eval("\n\nif (typeof has.createSharedArrayBuffer === \"function\") {\n  const sharedArrayBuffer = has.createSharedArrayBuffer(128);\n  console.log('sharedArrayBuffer', sharedArrayBuffer);\n} else {\n  console.warn('not support createSharedArrayBuffer');\n}\nif (typeof SharedArrayBuffer === \"function\") {\n  const sharedArrayBuffer = new SharedArrayBuffer(128);\n  console.log('sharedArrayBuffer', sharedArrayBuffer);\n} else {\n  console.warn('not support SharedArrayBuffer');\n}\nPage({\n  data: {\n    btnList: [{\n      text: \"跳转SVGA动画库(官方版)\",\n      path: \"/pages/svga2/index\"\n    }, {\n      text: \"跳转SVGA动画库(自研版)\",\n      path: \"/pages/svga/index\"\n    }, {\n      text: \"跳转SVGA海报(自研版)\",\n      path: \"/pages/poster/index\"\n    }, {\n      text: \"跳转Webview\",\n      path: \"/pages/webview/index\"\n    }, {\n      text: \"跳转APNG动画\",\n      path: \"/pages/apng/index\"\n    }]\n  },\n  handleNavigateTo(e) {\n    const {\n      url\n    } = e.currentTarget.dataset;\n    if (url) {\n      has.navigateTo({\n        url\n      });\n    } else {\n      console.error(\"未获取到跳转路径\", e);\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vcGFnZXMvaW5kZXgvaW5kZXguanM/MGM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZiBoYXMuY3JlYXRlU2hhcmVkQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBjb25zdCBzaGFyZWRBcnJheUJ1ZmZlciA9IGhhcy5jcmVhdGVTaGFyZWRBcnJheUJ1ZmZlcigxMjgpO1xuICBjb25zb2xlLmxvZygnc2hhcmVkQXJyYXlCdWZmZXInLCBzaGFyZWRBcnJheUJ1ZmZlcik7XG59IGVsc2Uge1xuICBjb25zb2xlLndhcm4oJ25vdCBzdXBwb3J0IGNyZWF0ZVNoYXJlZEFycmF5QnVmZmVyJyk7XG59XG5pZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgY29uc3Qgc2hhcmVkQXJyYXlCdWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMTI4KTtcbiAgY29uc29sZS5sb2coJ3NoYXJlZEFycmF5QnVmZmVyJywgc2hhcmVkQXJyYXlCdWZmZXIpO1xufSBlbHNlIHtcbiAgY29uc29sZS53YXJuKCdub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlcicpO1xufVxuUGFnZSh7XG4gIGRhdGE6IHtcbiAgICBidG5MaXN0OiBbe1xuICAgICAgdGV4dDogXCLot7PovaxTVkdB5Yqo55S75bqTKOWumOaWueeJiClcIixcbiAgICAgIHBhdGg6IFwiL3BhZ2VzL3N2Z2EyL2luZGV4XCJcbiAgICB9LCB7XG4gICAgICB0ZXh0OiBcIui3s+i9rFNWR0HliqjnlLvlupMo6Ieq56CU54mIKVwiLFxuICAgICAgcGF0aDogXCIvcGFnZXMvc3ZnYS9pbmRleFwiXG4gICAgfSwge1xuICAgICAgdGV4dDogXCLot7PovaxTVkdB5rW35oqlKOiHqueglOeJiClcIixcbiAgICAgIHBhdGg6IFwiL3BhZ2VzL3Bvc3Rlci9pbmRleFwiXG4gICAgfSwge1xuICAgICAgdGV4dDogXCLot7PovaxXZWJ2aWV3XCIsXG4gICAgICBwYXRoOiBcIi9wYWdlcy93ZWJ2aWV3L2luZGV4XCJcbiAgICB9LCB7XG4gICAgICB0ZXh0OiBcIui3s+i9rEFQTkfliqjnlLtcIixcbiAgICAgIHBhdGg6IFwiL3BhZ2VzL2FwbmcvaW5kZXhcIlxuICAgIH1dXG4gIH0sXG4gIGhhbmRsZU5hdmlnYXRlVG8oZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVybFxuICAgIH0gPSBlLmN1cnJlbnRUYXJnZXQuZGF0YXNldDtcbiAgICBpZiAodXJsKSB7XG4gICAgICBoYXMubmF2aWdhdGVUbyh7XG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLmnKrojrflj5bliLDot7Povazot6/lvoRcIiwgZSk7XG4gICAgfVxuICB9XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index/index.js\n");

/***/ }),

/***/ "./pages/poster/index.js":
/*!*******************************!*\
  !*** ./pages/poster/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _constants = __webpack_require__(/*! ../../utils/constants */ \"./utils/constants.js\");\nPage({\n  data: {\n    sources: [_constants.posterSources][0],\n    current: 0\n  },\n  handleSwitchAtRandom() {\n    const {\n      sources\n    } = this.data;\n    const {\n      ranIndex\n    } = (0, _constants.getOneAtRandom)(sources.length);\n    this.setData({\n      current: ranIndex\n    });\n  },\n  handleSwitchPrev() {\n    const {\n      current,\n      sources\n    } = this.data;\n    let prev = current - 1;\n    if (prev < 0) {\n      prev = sources.length - 1;\n    }\n    this.setData({\n      current: prev\n    });\n  },\n  handleSwitchNext() {\n    const {\n      current,\n      sources\n    } = this.data;\n    let next = current + 1;\n    if (next > sources.length - 1) {\n      next = 0;\n    }\n    this.setData({\n      current: next\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9wb3N0ZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL3BhZ2VzL3Bvc3Rlci9pbmRleC5qcz9hMTU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9jb25zdGFudHNcIik7XG5QYWdlKHtcbiAgZGF0YToge1xuICAgIHNvdXJjZXM6IFtfY29uc3RhbnRzLnBvc3RlclNvdXJjZXNdWzBdLFxuICAgIGN1cnJlbnQ6IDBcbiAgfSxcbiAgaGFuZGxlU3dpdGNoQXRSYW5kb20oKSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlc1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgcmFuSW5kZXhcbiAgICB9ID0gKDAsIF9jb25zdGFudHMuZ2V0T25lQXRSYW5kb20pKHNvdXJjZXMubGVuZ3RoKTtcbiAgICB0aGlzLnNldERhdGEoe1xuICAgICAgY3VycmVudDogcmFuSW5kZXhcbiAgICB9KTtcbiAgfSxcbiAgaGFuZGxlU3dpdGNoUHJldigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50LFxuICAgICAgc291cmNlc1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IHByZXYgPSBjdXJyZW50IC0gMTtcbiAgICBpZiAocHJldiA8IDApIHtcbiAgICAgIHByZXYgPSBzb3VyY2VzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICBjdXJyZW50OiBwcmV2XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZVN3aXRjaE5leHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudCxcbiAgICAgIHNvdXJjZXNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGxldCBuZXh0ID0gY3VycmVudCArIDE7XG4gICAgaWYgKG5leHQgPiBzb3VyY2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5leHQgPSAwO1xuICAgIH1cbiAgICB0aGlzLnNldERhdGEoe1xuICAgICAgY3VycmVudDogbmV4dFxuICAgIH0pO1xuICB9XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/poster/index.js\n");

/***/ }),

/***/ "./pages/svga/index.js":
/*!*****************************!*\
  !*** ./pages/svga/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _constants = __webpack_require__(/*! ../../utils/constants */ \"./utils/constants.js\");\nPage({\n  data: {\n    sources: [_constants.svgaSources, _constants.svgaCustomSources, _constants.yySources, _constants.svgaLargeSources, _constants.svgaHugeSources][3],\n    current: 0\n  },\n  handleSwitchAtRandom() {\n    const {\n      sources\n    } = this.data;\n    const {\n      ranIndex\n    } = (0, _constants.getOneAtRandom)(sources.length);\n    this.setData({\n      current: ranIndex\n    });\n  },\n  handleSwitchPrev() {\n    const {\n      current,\n      sources\n    } = this.data;\n    let prev = current - 1;\n    if (prev < 0) {\n      prev = sources.length - 1;\n    }\n    this.setData({\n      current: prev\n    });\n  },\n  handleSwitchNext() {\n    const {\n      current,\n      sources\n    } = this.data;\n    let next = current + 1;\n    if (next > sources.length - 1) {\n      next = 0;\n    }\n    this.setData({\n      current: next\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zdmdhL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi9wYWdlcy9zdmdhL2luZGV4LmpzPzhkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2NvbnN0YW50c1wiKTtcblBhZ2Uoe1xuICBkYXRhOiB7XG4gICAgc291cmNlczogW19jb25zdGFudHMuc3ZnYVNvdXJjZXMsIF9jb25zdGFudHMuc3ZnYUN1c3RvbVNvdXJjZXMsIF9jb25zdGFudHMueXlTb3VyY2VzLCBfY29uc3RhbnRzLnN2Z2FMYXJnZVNvdXJjZXMsIF9jb25zdGFudHMuc3ZnYUh1Z2VTb3VyY2VzXVszXSxcbiAgICBjdXJyZW50OiAwXG4gIH0sXG4gIGhhbmRsZVN3aXRjaEF0UmFuZG9tKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZXNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHJhbkluZGV4XG4gICAgfSA9ICgwLCBfY29uc3RhbnRzLmdldE9uZUF0UmFuZG9tKShzb3VyY2VzLmxlbmd0aCk7XG4gICAgdGhpcy5zZXREYXRhKHtcbiAgICAgIGN1cnJlbnQ6IHJhbkluZGV4XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZVN3aXRjaFByZXYoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudCxcbiAgICAgIHNvdXJjZXNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGxldCBwcmV2ID0gY3VycmVudCAtIDE7XG4gICAgaWYgKHByZXYgPCAwKSB7XG4gICAgICBwcmV2ID0gc291cmNlcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICB0aGlzLnNldERhdGEoe1xuICAgICAgY3VycmVudDogcHJldlxuICAgIH0pO1xuICB9LFxuICBoYW5kbGVTd2l0Y2hOZXh0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBzb3VyY2VzXG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgbmV4dCA9IGN1cnJlbnQgKyAxO1xuICAgIGlmIChuZXh0ID4gc291cmNlcy5sZW5ndGggLSAxKSB7XG4gICAgICBuZXh0ID0gMDtcbiAgICB9XG4gICAgdGhpcy5zZXREYXRhKHtcbiAgICAgIGN1cnJlbnQ6IG5leHRcbiAgICB9KTtcbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/svga/index.js\n");

/***/ }),

/***/ "./pages/svga2/index.js":
/*!******************************!*\
  !*** ./pages/svga2/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _constants = __webpack_require__(/*! ../../utils/constants */ \"./utils/constants.js\");\n// const sources = [\n//   'http://10.1.133.197:5151/svga/序列1.svga',\n//   'http://10.1.133.197:5151/svga/序列2.svga',\n//   'http://10.1.133.197:5151/svga/序列3.svga'\n// ]\nconst sources = _constants.svgaSources;\nPage({\n  data: {\n    url: \"\",\n    current: 0\n  },\n  handleSwitchAtRandom() {\n    const {\n      ranIndex,\n      url\n    } = (0, _constants.getOneAtRandom)();\n    this.setData({\n      url,\n      current: ranIndex\n    });\n  },\n  handleSwitchPrev() {\n    const {\n      current\n    } = this.data;\n    let prev = current - 1;\n    if (prev < 0) {\n      prev = _constants.svgaSources.length - 1;\n    }\n    this.setData({\n      url: sources[prev],\n      current: prev\n    });\n  },\n  handleSwitchNext() {\n    const {\n      current\n    } = this.data;\n    let next = current + 1;\n    if (next > sources.length - 1) {\n      next = 0;\n    }\n    this.setData({\n      url: sources[next],\n      current: next\n    });\n  },\n  onLoad() {\n    // this.handleSwitchAtRandom();\n    const current = 0;\n    this.setData({\n      current,\n      url: sources[current]\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zdmdhMi9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi9wYWdlcy9zdmdhMi9pbmRleC5qcz83MzdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9jb25zdGFudHNcIik7XG4vLyBjb25zdCBzb3VyY2VzID0gW1xuLy8gICAnaHR0cDovLzEwLjEuMTMzLjE5Nzo1MTUxL3N2Z2Ev5bqP5YiXMS5zdmdhJyxcbi8vICAgJ2h0dHA6Ly8xMC4xLjEzMy4xOTc6NTE1MS9zdmdhL+W6j+WIlzIuc3ZnYScsXG4vLyAgICdodHRwOi8vMTAuMS4xMzMuMTk3OjUxNTEvc3ZnYS/luo/liJczLnN2Z2EnXG4vLyBdXG5jb25zdCBzb3VyY2VzID0gX2NvbnN0YW50cy5zdmdhU291cmNlcztcblBhZ2Uoe1xuICBkYXRhOiB7XG4gICAgdXJsOiBcIlwiLFxuICAgIGN1cnJlbnQ6IDBcbiAgfSxcbiAgaGFuZGxlU3dpdGNoQXRSYW5kb20oKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmFuSW5kZXgsXG4gICAgICB1cmxcbiAgICB9ID0gKDAsIF9jb25zdGFudHMuZ2V0T25lQXRSYW5kb20pKCk7XG4gICAgdGhpcy5zZXREYXRhKHtcbiAgICAgIHVybCxcbiAgICAgIGN1cnJlbnQ6IHJhbkluZGV4XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZVN3aXRjaFByZXYoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IHByZXYgPSBjdXJyZW50IC0gMTtcbiAgICBpZiAocHJldiA8IDApIHtcbiAgICAgIHByZXYgPSBfY29uc3RhbnRzLnN2Z2FTb3VyY2VzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICB1cmw6IHNvdXJjZXNbcHJldl0sXG4gICAgICBjdXJyZW50OiBwcmV2XG4gICAgfSk7XG4gIH0sXG4gIGhhbmRsZVN3aXRjaE5leHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgbGV0IG5leHQgPSBjdXJyZW50ICsgMTtcbiAgICBpZiAobmV4dCA+IHNvdXJjZXMubGVuZ3RoIC0gMSkge1xuICAgICAgbmV4dCA9IDA7XG4gICAgfVxuICAgIHRoaXMuc2V0RGF0YSh7XG4gICAgICB1cmw6IHNvdXJjZXNbbmV4dF0sXG4gICAgICBjdXJyZW50OiBuZXh0XG4gICAgfSk7XG4gIH0sXG4gIG9uTG9hZCgpIHtcbiAgICAvLyB0aGlzLmhhbmRsZVN3aXRjaEF0UmFuZG9tKCk7XG4gICAgY29uc3QgY3VycmVudCA9IDA7XG4gICAgdGhpcy5zZXREYXRhKHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICB1cmw6IHNvdXJjZXNbY3VycmVudF1cbiAgICB9KTtcbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/svga2/index.js\n");

/***/ }),

/***/ "./pages/webview/index.js":
/*!********************************!*\
  !*** ./pages/webview/index.js ***!
  \********************************/
/***/ (() => {

"use strict";
eval("\n\nPage({\n  data: {\n    src: \"\"\n  },\n  onLoad() {\n    this.setData({\n      src: \"http://localhost:3000/navigate-to-miniprogram\"\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy93ZWJ2aWV3L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pbmlwcm9ncmFtLXdlYXBwLy4vcGFnZXMvd2Vidmlldy9pbmRleC5qcz8wNjY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5QYWdlKHtcbiAgZGF0YToge1xuICAgIHNyYzogXCJcIlxuICB9LFxuICBvbkxvYWQoKSB7XG4gICAgdGhpcy5zZXREYXRhKHtcbiAgICAgIHNyYzogXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvbmF2aWdhdGUtdG8tbWluaXByb2dyYW1cIlxuICAgIH0pO1xuICB9XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/webview/index.js\n");

/***/ }),

/***/ "./utils/EnhancedWorker.js":
/*!*********************************!*\
  !*** ./utils/EnhancedWorker.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.EnhancedWorker = void 0;\nvar _fuckBenchmark = __webpack_require__(/*! ./fuck-benchmark */ \"./utils/fuck-benchmark.js\");\nclass EnhancedWorker {\n  constructor() {\n    this.worker;\n    this.listeners = new Map();\n  }\n\n  /**\n   * @private\n   * 创建 Worker\n   */\n  createWorker() {\n    this.worker = has.createWorker(\"workers/index.js\", {\n      useExperimentalWorker: true\n    });\n    // 监听 worker 消息响应。\n    this.worker.onMessage(result => {\n      const {\n        method,\n        data\n      } = result || {};\n      const handler = this.listeners.get(method);\n      const {\n        fn,\n        options\n      } = handler;\n      fn(data);\n      if (options.once) {\n        this.listeners.delete(method);\n      }\n      _fuckBenchmark.benchmark.stop(`${method} 解压时间`);\n    });\n\n    // 实验模式可能会出现 worker 被杀的情况，需要重新创建 worker\n    this.worker.onProcessKilled(() => {\n      _fuckBenchmark.benchmark.log(\"worker killed\");\n      this.createWorker();\n    });\n  }\n\n  /**\n   * 下载并启动 Worker\n   * @returns \n   */\n  async open() {\n    return new Promise((resolve, reject) => {\n      const task = has.preDownloadSubpackage({\n        packageType: \"workers\",\n        success: res => {\n          _fuckBenchmark.benchmark.log(\"load worker success\", res);\n          // 创建 worker。 如果 worker 分包没下载完就调 createWorker 的话将报错\n          this.createWorker();\n          resolve();\n        },\n        fail: res => {\n          _fuckBenchmark.benchmark.log(\"load worker fail\", res);\n          reject(res);\n        }\n      });\n      task.onProgressUpdate(res => {\n        // 可通过 onProgressUpdate 接口监听下载进度\n        _fuckBenchmark.benchmark.log(\"【workers download progress】\", res.progress, res.totalBytesWritten, res.totalBytesExpectedToWrite);\n      });\n    });\n  }\n\n  /**\n   * 一次绑定事件\n   * @param {*} method \n   * @param {*} fn \n   */\n  once(method, fn) {\n    this.listeners.set(method, {\n      fn: data => fn === null || fn === void 0 ? void 0 : fn(data),\n      options: {\n        once: true\n      }\n    });\n  }\n\n  /**\n   * 永久绑定事件\n   * @param {*} method \n   * @param {*} fn \n   */\n  on(method, fn) {\n    this.listeners.set(method, {\n      fn: data => fn === null || fn === void 0 ? void 0 : fn(data),\n      options: {\n        once: false\n      }\n    });\n  }\n\n  /**\n   * 移除绑定事件\n   * @param {*} method \n   */\n  off(method) {\n    this.listeners.delete(method);\n  }\n\n  /**\n   * 触发事件\n   * @param {*} method \n   * @param {*} data \n   */\n  emit(method, data) {\n    _fuckBenchmark.benchmark.start(`${method} 解压时间`);\n    this.worker.postMessage({\n      method,\n      data\n    });\n  }\n\n  /**\n   * 关闭 Worker\n   */\n  close() {\n    var _this$worker;\n    this.listeners.clear();\n    (_this$worker = this.worker) === null || _this$worker === void 0 || _this$worker.terminate();\n  }\n}\nexports.EnhancedWorker = EnhancedWorker;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9FbmhhbmNlZFdvcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi91dGlscy9FbmhhbmNlZFdvcmtlci5qcz8xZWFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FbmhhbmNlZFdvcmtlciA9IHZvaWQgMDtcbnZhciBfZnVja0JlbmNobWFyayA9IHJlcXVpcmUoXCIuL2Z1Y2stYmVuY2htYXJrXCIpO1xuY2xhc3MgRW5oYW5jZWRXb3JrZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmtlcjtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiDliJvlu7ogV29ya2VyXG4gICAqL1xuICBjcmVhdGVXb3JrZXIoKSB7XG4gICAgdGhpcy53b3JrZXIgPSBoYXMuY3JlYXRlV29ya2VyKFwid29ya2Vycy9pbmRleC5qc1wiLCB7XG4gICAgICB1c2VFeHBlcmltZW50YWxXb3JrZXI6IHRydWVcbiAgICB9KTtcbiAgICAvLyDnm5HlkKwgd29ya2VyIOa2iOaBr+WTjeW6lOOAglxuICAgIHRoaXMud29ya2VyLm9uTWVzc2FnZShyZXN1bHQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSByZXN1bHQgfHwge307XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5saXN0ZW5lcnMuZ2V0KG1ldGhvZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZuLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gaGFuZGxlcjtcbiAgICAgIGZuKGRhdGEpO1xuICAgICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgIH1cbiAgICAgIF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay5zdG9wKGAke21ldGhvZH0g6Kej5Y6L5pe26Ze0YCk7XG4gICAgfSk7XG5cbiAgICAvLyDlrp7pqozmqKHlvI/lj6/og73kvJrlh7rnjrAgd29ya2VyIOiiq+adgOeahOaDheWGte+8jOmcgOimgemHjeaWsOWIm+W7uiB3b3JrZXJcbiAgICB0aGlzLndvcmtlci5vblByb2Nlc3NLaWxsZWQoKCkgPT4ge1xuICAgICAgX2Z1Y2tCZW5jaG1hcmsuYmVuY2htYXJrLmxvZyhcIndvcmtlciBraWxsZWRcIik7XG4gICAgICB0aGlzLmNyZWF0ZVdvcmtlcigpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIOS4i+i9veW5tuWQr+WKqCBXb3JrZXJcbiAgICogQHJldHVybnMgXG4gICAqL1xuICBhc3luYyBvcGVuKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0YXNrID0gaGFzLnByZURvd25sb2FkU3VicGFja2FnZSh7XG4gICAgICAgIHBhY2thZ2VUeXBlOiBcIndvcmtlcnNcIixcbiAgICAgICAgc3VjY2VzczogcmVzID0+IHtcbiAgICAgICAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwibG9hZCB3b3JrZXIgc3VjY2Vzc1wiLCByZXMpO1xuICAgICAgICAgIC8vIOWIm+W7uiB3b3JrZXLjgIIg5aaC5p6cIHdvcmtlciDliIbljIXmsqHkuIvovb3lrozlsLHosIMgY3JlYXRlV29ya2VyIOeahOivneWwhuaKpemUmVxuICAgICAgICAgIHRoaXMuY3JlYXRlV29ya2VyKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBmYWlsOiByZXMgPT4ge1xuICAgICAgICAgIF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay5sb2coXCJsb2FkIHdvcmtlciBmYWlsXCIsIHJlcyk7XG4gICAgICAgICAgcmVqZWN0KHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGFzay5vblByb2dyZXNzVXBkYXRlKHJlcyA9PiB7XG4gICAgICAgIC8vIOWPr+mAmui/hyBvblByb2dyZXNzVXBkYXRlIOaOpeWPo+ebkeWQrOS4i+i9vei/m+W6plxuICAgICAgICBfZnVja0JlbmNobWFyay5iZW5jaG1hcmsubG9nKFwi44CQd29ya2VycyBkb3dubG9hZCBwcm9ncmVzc+OAkVwiLCByZXMucHJvZ3Jlc3MsIHJlcy50b3RhbEJ5dGVzV3JpdHRlbiwgcmVzLnRvdGFsQnl0ZXNFeHBlY3RlZFRvV3JpdGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICog5LiA5qyh57uR5a6a5LqL5Lu2XG4gICAqIEBwYXJhbSB7Kn0gbWV0aG9kIFxuICAgKiBAcGFyYW0geyp9IGZuIFxuICAgKi9cbiAgb25jZShtZXRob2QsIGZuKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuc2V0KG1ldGhvZCwge1xuICAgICAgZm46IGRhdGEgPT4gZm4gPT09IG51bGwgfHwgZm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZuKGRhdGEpLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICog5rC45LmF57uR5a6a5LqL5Lu2XG4gICAqIEBwYXJhbSB7Kn0gbWV0aG9kIFxuICAgKiBAcGFyYW0geyp9IGZuIFxuICAgKi9cbiAgb24obWV0aG9kLCBmbikge1xuICAgIHRoaXMubGlzdGVuZXJzLnNldChtZXRob2QsIHtcbiAgICAgIGZuOiBkYXRhID0+IGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbihkYXRhKSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiDnp7vpmaTnu5Hlrprkuovku7ZcbiAgICogQHBhcmFtIHsqfSBtZXRob2QgXG4gICAqL1xuICBvZmYobWV0aG9kKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKG1ldGhvZCk7XG4gIH1cblxuICAvKipcbiAgICog6Kem5Y+R5LqL5Lu2XG4gICAqIEBwYXJhbSB7Kn0gbWV0aG9kIFxuICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAqL1xuICBlbWl0KG1ldGhvZCwgZGF0YSkge1xuICAgIF9mdWNrQmVuY2htYXJrLmJlbmNobWFyay5zdGFydChgJHttZXRob2R9IOino+WOi+aXtumXtGApO1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiDlhbPpl60gV29ya2VyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgX3RoaXMkd29ya2VyO1xuICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgKF90aGlzJHdvcmtlciA9IHRoaXMud29ya2VyKSA9PT0gbnVsbCB8fCBfdGhpcyR3b3JrZXIgPT09IHZvaWQgMCB8fCBfdGhpcyR3b3JrZXIudGVybWluYXRlKCk7XG4gIH1cbn1cbmV4cG9ydHMuRW5oYW5jZWRXb3JrZXIgPSBFbmhhbmNlZFdvcmtlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/EnhancedWorker.js\n");

/***/ }),

/***/ "./utils/ReadyGo.js":
/*!**************************!*\
  !*** ./utils/ReadyGo.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nvar _isReady = /*#__PURE__*/new WeakMap();\nvar _list = /*#__PURE__*/new WeakMap();\nclass ReadyGo {\n  constructor() {\n    _classPrivateFieldInitSpec(this, _isReady, void 0);\n    _classPrivateFieldInitSpec(this, _list, void 0);\n    _classPrivateFieldSet(_isReady, this, false);\n    _classPrivateFieldSet(_list, this, new Set());\n  }\n  has() {\n    return _classPrivateFieldGet(_list, this).size !== 0;\n  }\n  ready(callback) {\n    if (_classPrivateFieldGet(_isReady, this)) {\n      callback();\n    } else {\n      _classPrivateFieldGet(_list, this).add(callback);\n    }\n  }\n  go() {\n    _classPrivateFieldSet(_isReady, this, true);\n    _classPrivateFieldGet(_list, this).forEach(callback => callback());\n    _classPrivateFieldSet(_list, this, new Set());\n  }\n  reset() {\n    _classPrivateFieldSet(_isReady, this, false);\n    _classPrivateFieldSet(_list, this, new Set());\n  }\n}\nexports[\"default\"] = ReadyGo;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9SZWFkeUdvLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL3V0aWxzL1JlYWR5R28uanM/NjUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKGUsIHQsIGEpIHsgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpOyB9XG5mdW5jdGlvbiBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSB7IGlmICh0LmhhcyhlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQocywgYSkgeyByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpOyB9XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQocywgYSwgcikgeyByZXR1cm4gcy5zZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSksIHIpLCByOyB9XG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3NCcmFuZChlLCB0LCBuKSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlID09PSB0IDogZS5oYXModCkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHQgOiBuOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IG9uIHRoaXMgb2JqZWN0XCIpOyB9XG52YXIgX2lzUmVhZHkgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfbGlzdCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuY2xhc3MgUmVhZHlHbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9pc1JlYWR5LCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKHRoaXMsIF9saXN0LCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfaXNSZWFkeSwgdGhpcywgZmFsc2UpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfbGlzdCwgdGhpcywgbmV3IFNldCgpKTtcbiAgfVxuICBoYXMoKSB7XG4gICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldChfbGlzdCwgdGhpcykuc2l6ZSAhPT0gMDtcbiAgfVxuICByZWFkeShjYWxsYmFjaykge1xuICAgIGlmIChfY2xhc3NQcml2YXRlRmllbGRHZXQoX2lzUmVhZHksIHRoaXMpKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQoX2xpc3QsIHRoaXMpLmFkZChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGdvKCkge1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfaXNSZWFkeSwgdGhpcywgdHJ1ZSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KF9saXN0LCB0aGlzKS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldChfbGlzdCwgdGhpcywgbmV3IFNldCgpKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX2lzUmVhZHksIHRoaXMsIGZhbHNlKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQoX2xpc3QsIHRoaXMsIG5ldyBTZXQoKSk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWR5R287Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/ReadyGo.js\n");

/***/ }),

/***/ "./utils/constants.js":
/*!****************************!*\
  !*** ./utils/constants.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getOneAtRandom = getOneAtRandom;\nexports.yySources = exports.svgaSources = exports.svgaLargeSources = exports.svgaHugeSources = exports.svgaCustomSources = exports.posterSources = void 0;\n// const LOCAL_SVGA_URL = \"http://10.1.131.177:3536/svga\";\nconst LOCAL_SVGA_URL = \"http://192.168.1.29:3536/svga\";\nconst REMOTE_SVGA_URL = 'https://assets.2dfire.com/frontend';\nconst svgaSources = exports.svgaSources = [\"9ce0cce7205fbebba380ed44879e5660.svga\", \"1ddb590515d196f07c411794633e4406.svga\", \"9a96c2c0fbe8ec39f0a192e3e1303d22.svga\", \"c4b3c4f8a05070352e036e869fc58b2f.svga\", \"a14788e60808428413f2b5cf984864b4.svga\", \"53266274807cd8e715c1433de8f400e9.svga\", \"95c40b88e02b1947a745fafaebf28fad.svga\", \"c78088a384285e18d9e9e38299b49e28.svga\", \"4e3768eb16c3ea7bafea3d75f1ff61e0.svga\", \"c06ba39b86a51fef584b4324d5511b8e.svga\", \"58f182116152001e79df1c0c78229e3b.svga\", \"5104feee82c9877c6e297f961010b5b7.svga\", \"6941a7b097a9e0b7bcdc4556c784e9e8.svga\", \"6481dcd75c34604731f1b2e77c02ece7.svga\", \"825015b9418620078ed09fece72d2b9c.svga\", \"ba8d3752c99154d7aa25f8e959cbd102.svga\", \"582d3f48ce07aaf5f12462ec34184021.svga\", \"24b50bd34845b070d051053e9814a658.svga\", \"cae7dd790cc423100372bb8b9de4064f.svga\", \"446179f5d94dd92165e24122f6ee0e13.svga\", \"3af554cafda2c7be95953c661e3a5d8f.svga\", \"a505eba87fabb8988ac920bb4b265cdc.svga\", \"567b81b194546668bb32f783ecae0902.svga\", \"4b3213a4df25d397786016b1bf0e0c01.svga\", \"88bcb99b38a0367866e646db9439437c.svga\", \"a7789d4a7b6e1d88e3a3a451b60eb2a0.svga\", \"ec33f22852725891476961fb62512f0c.svga\", \"0c4ba4b393af35bd0e030f08f48bc5c6.svga\", \"e5466a98c43cef9fae1151d8cf0a4269.svga\", \"56d381d396d5319c80492d2bc77c6fa5.svga\", \"34f8221e7b8a50cb562d7e675deafeb9.svga\", \"059c107da06c599dc49340280bde2bba.svga\", \"73bb57f6697de3069c02d6d9a3f1da63.svga\", \"5048039becf37d1a6ba56256aaf6c5a4.svga\", \"004ffa6820b48816c1ca789a6645e4c8.svga\", \"f922b9de74d15bd2c87c1e4cde5173be.svga\", \"6b9c17410cf3d11732a230174fedc9ad.svga\", \"15895fb79f97705094de089db31f3010.svga\", \"e8e0420a1208962d5a81772bfeb42351.svga\", \"ed15d1b5000314b76016005b5b202b09.svga\", \"23990e59a42fc9977937879e118fccd3.svga\", \"f3f502aa447602ddf3ce08ef9ef58f51.svga\", \"2698b666a73b9f0088271219269d31d4.svga\", \"b5f2308f9afcca6bcbfb18f88f06251f.svga\", \"fea4ce9565e726e1f0f6d1a46f381fe3.svga\", \"870e733803774fd432acbfbd721c1d2c.svga\", \"97e422a1a6a53d12f8d1b01248ef8fae.svga\", \"02ad1a44da1f90ae0c310454637aa8d6.svga\", \"644c8278a0b4638747666c7ea169c337.svga\", \"e3f209a5b492fbbef27343b3a1ebc5dc.svga\", \"c0cb9c1bdcd67ad51f8c8237ae1f746d.svga\", \"46291021b61f2d677f06841b84a443ce.svga\", \"e5ed31cec6b576cd67df0271b69320aa.svga\", \"ad6d6a788bb88520f908bb0fe04a75ca.svga\", \"45eadf03bee2013daa407fd4b91e29f5.svga\"].map(filename => `${REMOTE_SVGA_URL}/${filename}`);\nconst svgaCustomSources = exports.svgaCustomSources = [{\n  filename: \"custom.svga\",\n  replace: {\n    qrcode_001: \"custom_qrcode_001.png\",\n    qrcode_002: \"custom_qrcode_002.png\",\n    bj_001: \"custom_bj_001.png\",\n    bj_002: \"custom_bj_002.png\"\n  }\n}, {\n  filename: \"replace_001.svga\",\n  replace: {\n    qrcode_001: \"replace_001.png\"\n  }\n}, {\n  filename: \"replace_002.svga\",\n  replace: {\n    qrcode_001: \"replace_002.png\"\n  }\n}].map(item => {\n  const {\n    filename,\n    replace\n  } = item;\n  return {\n    filename,\n    url: `${LOCAL_SVGA_URL}/custom/${filename}`,\n    replace: Object.keys(replace).reduce((values, key) => {\n      values[key] = `${LOCAL_SVGA_URL}/custom/${replace[key]}`;\n      return values;\n    }, {})\n  };\n});\nconst svgaLargeSources = exports.svgaLargeSources = [\"frame00.svga\", \"frame01.svga\", \"frame02.svga\", \"frame03.svga\"].map(filename => `${LOCAL_SVGA_URL}/large/${filename}`);\nconst yySources = exports.yySources = [\"angel.svga\", \"EmptyState.svga\", \"halloween.svga\", \"HamburgerArrow.svga\", \"kingset.svga\", \"matteBitmap.svga\", \"matteRect.svga\", \"PinJump.svga\", \"posche.svga\", \"rose.svga\", \"TwitterHeart.svga\", \"Walkthrough.svga\"].map(filename => `${LOCAL_SVGA_URL}/yy/${filename}`);\nconst svgaHugeSources = exports.svgaHugeSources = [\"frame01.svga\", \"frame02.svga\", \"frame03.svga\"].map(filename => `${LOCAL_SVGA_URL}/huge/${filename}`);\nconst posterSources = exports.posterSources = [\"微信认证授权码-纯净版.svga\", \"微信认证授权码.svga\", \"支付宝认证授权码-纯净版.svga\", \"支付宝认证授权码.svga\"].map(filename => `${LOCAL_SVGA_URL}/poster/${filename}`);\nfunction getOneAtRandom(size) {\n  return {\n    ranIndex: Math.floor(Math.random() * size)\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL3V0aWxzL2NvbnN0YW50cy5qcz8xODRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRPbmVBdFJhbmRvbSA9IGdldE9uZUF0UmFuZG9tO1xuZXhwb3J0cy55eVNvdXJjZXMgPSBleHBvcnRzLnN2Z2FTb3VyY2VzID0gZXhwb3J0cy5zdmdhTGFyZ2VTb3VyY2VzID0gZXhwb3J0cy5zdmdhSHVnZVNvdXJjZXMgPSBleHBvcnRzLnN2Z2FDdXN0b21Tb3VyY2VzID0gZXhwb3J0cy5wb3N0ZXJTb3VyY2VzID0gdm9pZCAwO1xuLy8gY29uc3QgTE9DQUxfU1ZHQV9VUkwgPSBcImh0dHA6Ly8xMC4xLjEzMS4xNzc6MzUzNi9zdmdhXCI7XG5jb25zdCBMT0NBTF9TVkdBX1VSTCA9IFwiaHR0cDovLzE5Mi4xNjguMS4yOTozNTM2L3N2Z2FcIjtcbmNvbnN0IFJFTU9URV9TVkdBX1VSTCA9ICdodHRwczovL2Fzc2V0cy4yZGZpcmUuY29tL2Zyb250ZW5kJztcbmNvbnN0IHN2Z2FTb3VyY2VzID0gZXhwb3J0cy5zdmdhU291cmNlcyA9IFtcIjljZTBjY2U3MjA1ZmJlYmJhMzgwZWQ0NDg3OWU1NjYwLnN2Z2FcIiwgXCIxZGRiNTkwNTE1ZDE5NmYwN2M0MTE3OTQ2MzNlNDQwNi5zdmdhXCIsIFwiOWE5NmMyYzBmYmU4ZWMzOWYwYTE5MmUzZTEzMDNkMjIuc3ZnYVwiLCBcImM0YjNjNGY4YTA1MDcwMzUyZTAzNmU4NjlmYzU4YjJmLnN2Z2FcIiwgXCJhMTQ3ODhlNjA4MDg0Mjg0MTNmMmI1Y2Y5ODQ4NjRiNC5zdmdhXCIsIFwiNTMyNjYyNzQ4MDdjZDhlNzE1YzE0MzNkZThmNDAwZTkuc3ZnYVwiLCBcIjk1YzQwYjg4ZTAyYjE5NDdhNzQ1ZmFmYWViZjI4ZmFkLnN2Z2FcIiwgXCJjNzgwODhhMzg0Mjg1ZTE4ZDllOWUzODI5OWI0OWUyOC5zdmdhXCIsIFwiNGUzNzY4ZWIxNmMzZWE3YmFmZWEzZDc1ZjFmZjYxZTAuc3ZnYVwiLCBcImMwNmJhMzliODZhNTFmZWY1ODRiNDMyNGQ1NTExYjhlLnN2Z2FcIiwgXCI1OGYxODIxMTYxNTIwMDFlNzlkZjFjMGM3ODIyOWUzYi5zdmdhXCIsIFwiNTEwNGZlZWU4MmM5ODc3YzZlMjk3Zjk2MTAxMGI1Yjcuc3ZnYVwiLCBcIjY5NDFhN2IwOTdhOWUwYjdiY2RjNDU1NmM3ODRlOWU4LnN2Z2FcIiwgXCI2NDgxZGNkNzVjMzQ2MDQ3MzFmMWIyZTc3YzAyZWNlNy5zdmdhXCIsIFwiODI1MDE1Yjk0MTg2MjAwNzhlZDA5ZmVjZTcyZDJiOWMuc3ZnYVwiLCBcImJhOGQzNzUyYzk5MTU0ZDdhYTI1ZjhlOTU5Y2JkMTAyLnN2Z2FcIiwgXCI1ODJkM2Y0OGNlMDdhYWY1ZjEyNDYyZWMzNDE4NDAyMS5zdmdhXCIsIFwiMjRiNTBiZDM0ODQ1YjA3MGQwNTEwNTNlOTgxNGE2NTguc3ZnYVwiLCBcImNhZTdkZDc5MGNjNDIzMTAwMzcyYmI4YjlkZTQwNjRmLnN2Z2FcIiwgXCI0NDYxNzlmNWQ5NGRkOTIxNjVlMjQxMjJmNmVlMGUxMy5zdmdhXCIsIFwiM2FmNTU0Y2FmZGEyYzdiZTk1OTUzYzY2MWUzYTVkOGYuc3ZnYVwiLCBcImE1MDVlYmE4N2ZhYmI4OTg4YWM5MjBiYjRiMjY1Y2RjLnN2Z2FcIiwgXCI1NjdiODFiMTk0NTQ2NjY4YmIzMmY3ODNlY2FlMDkwMi5zdmdhXCIsIFwiNGIzMjEzYTRkZjI1ZDM5Nzc4NjAxNmIxYmYwZTBjMDEuc3ZnYVwiLCBcIjg4YmNiOTliMzhhMDM2Nzg2NmU2NDZkYjk0Mzk0MzdjLnN2Z2FcIiwgXCJhNzc4OWQ0YTdiNmUxZDg4ZTNhM2E0NTFiNjBlYjJhMC5zdmdhXCIsIFwiZWMzM2YyMjg1MjcyNTg5MTQ3Njk2MWZiNjI1MTJmMGMuc3ZnYVwiLCBcIjBjNGJhNGIzOTNhZjM1YmQwZTAzMGYwOGY0OGJjNWM2LnN2Z2FcIiwgXCJlNTQ2NmE5OGM0M2NlZjlmYWUxMTUxZDhjZjBhNDI2OS5zdmdhXCIsIFwiNTZkMzgxZDM5NmQ1MzE5YzgwNDkyZDJiYzc3YzZmYTUuc3ZnYVwiLCBcIjM0ZjgyMjFlN2I4YTUwY2I1NjJkN2U2NzVkZWFmZWI5LnN2Z2FcIiwgXCIwNTljMTA3ZGEwNmM1OTlkYzQ5MzQwMjgwYmRlMmJiYS5zdmdhXCIsIFwiNzNiYjU3ZjY2OTdkZTMwNjljMDJkNmQ5YTNmMWRhNjMuc3ZnYVwiLCBcIjUwNDgwMzliZWNmMzdkMWE2YmE1NjI1NmFhZjZjNWE0LnN2Z2FcIiwgXCIwMDRmZmE2ODIwYjQ4ODE2YzFjYTc4OWE2NjQ1ZTRjOC5zdmdhXCIsIFwiZjkyMmI5ZGU3NGQxNWJkMmM4N2MxZTRjZGU1MTczYmUuc3ZnYVwiLCBcIjZiOWMxNzQxMGNmM2QxMTczMmEyMzAxNzRmZWRjOWFkLnN2Z2FcIiwgXCIxNTg5NWZiNzlmOTc3MDUwOTRkZTA4OWRiMzFmMzAxMC5zdmdhXCIsIFwiZThlMDQyMGExMjA4OTYyZDVhODE3NzJiZmViNDIzNTEuc3ZnYVwiLCBcImVkMTVkMWI1MDAwMzE0Yjc2MDE2MDA1YjViMjAyYjA5LnN2Z2FcIiwgXCIyMzk5MGU1OWE0MmZjOTk3NzkzNzg3OWUxMThmY2NkMy5zdmdhXCIsIFwiZjNmNTAyYWE0NDc2MDJkZGYzY2UwOGVmOWVmNThmNTEuc3ZnYVwiLCBcIjI2OThiNjY2YTczYjlmMDA4ODI3MTIxOTI2OWQzMWQ0LnN2Z2FcIiwgXCJiNWYyMzA4ZjlhZmNjYTZiY2JmYjE4Zjg4ZjA2MjUxZi5zdmdhXCIsIFwiZmVhNGNlOTU2NWU3MjZlMWYwZjZkMWE0NmYzODFmZTMuc3ZnYVwiLCBcIjg3MGU3MzM4MDM3NzRmZDQzMmFjYmZiZDcyMWMxZDJjLnN2Z2FcIiwgXCI5N2U0MjJhMWE2YTUzZDEyZjhkMWIwMTI0OGVmOGZhZS5zdmdhXCIsIFwiMDJhZDFhNDRkYTFmOTBhZTBjMzEwNDU0NjM3YWE4ZDYuc3ZnYVwiLCBcIjY0NGM4Mjc4YTBiNDYzODc0NzY2NmM3ZWExNjljMzM3LnN2Z2FcIiwgXCJlM2YyMDlhNWI0OTJmYmJlZjI3MzQzYjNhMWViYzVkYy5zdmdhXCIsIFwiYzBjYjljMWJkY2Q2N2FkNTFmOGM4MjM3YWUxZjc0NmQuc3ZnYVwiLCBcIjQ2MjkxMDIxYjYxZjJkNjc3ZjA2ODQxYjg0YTQ0M2NlLnN2Z2FcIiwgXCJlNWVkMzFjZWM2YjU3NmNkNjdkZjAyNzFiNjkzMjBhYS5zdmdhXCIsIFwiYWQ2ZDZhNzg4YmI4ODUyMGY5MDhiYjBmZTA0YTc1Y2Euc3ZnYVwiLCBcIjQ1ZWFkZjAzYmVlMjAxM2RhYTQwN2ZkNGI5MWUyOWY1LnN2Z2FcIl0ubWFwKGZpbGVuYW1lID0+IGAke1JFTU9URV9TVkdBX1VSTH0vJHtmaWxlbmFtZX1gKTtcbmNvbnN0IHN2Z2FDdXN0b21Tb3VyY2VzID0gZXhwb3J0cy5zdmdhQ3VzdG9tU291cmNlcyA9IFt7XG4gIGZpbGVuYW1lOiBcImN1c3RvbS5zdmdhXCIsXG4gIHJlcGxhY2U6IHtcbiAgICBxcmNvZGVfMDAxOiBcImN1c3RvbV9xcmNvZGVfMDAxLnBuZ1wiLFxuICAgIHFyY29kZV8wMDI6IFwiY3VzdG9tX3FyY29kZV8wMDIucG5nXCIsXG4gICAgYmpfMDAxOiBcImN1c3RvbV9ial8wMDEucG5nXCIsXG4gICAgYmpfMDAyOiBcImN1c3RvbV9ial8wMDIucG5nXCJcbiAgfVxufSwge1xuICBmaWxlbmFtZTogXCJyZXBsYWNlXzAwMS5zdmdhXCIsXG4gIHJlcGxhY2U6IHtcbiAgICBxcmNvZGVfMDAxOiBcInJlcGxhY2VfMDAxLnBuZ1wiXG4gIH1cbn0sIHtcbiAgZmlsZW5hbWU6IFwicmVwbGFjZV8wMDIuc3ZnYVwiLFxuICByZXBsYWNlOiB7XG4gICAgcXJjb2RlXzAwMTogXCJyZXBsYWNlXzAwMi5wbmdcIlxuICB9XG59XS5tYXAoaXRlbSA9PiB7XG4gIGNvbnN0IHtcbiAgICBmaWxlbmFtZSxcbiAgICByZXBsYWNlXG4gIH0gPSBpdGVtO1xuICByZXR1cm4ge1xuICAgIGZpbGVuYW1lLFxuICAgIHVybDogYCR7TE9DQUxfU1ZHQV9VUkx9L2N1c3RvbS8ke2ZpbGVuYW1lfWAsXG4gICAgcmVwbGFjZTogT2JqZWN0LmtleXMocmVwbGFjZSkucmVkdWNlKCh2YWx1ZXMsIGtleSkgPT4ge1xuICAgICAgdmFsdWVzW2tleV0gPSBgJHtMT0NBTF9TVkdBX1VSTH0vY3VzdG9tLyR7cmVwbGFjZVtrZXldfWA7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sIHt9KVxuICB9O1xufSk7XG5jb25zdCBzdmdhTGFyZ2VTb3VyY2VzID0gZXhwb3J0cy5zdmdhTGFyZ2VTb3VyY2VzID0gW1wiZnJhbWUwMC5zdmdhXCIsIFwiZnJhbWUwMS5zdmdhXCIsIFwiZnJhbWUwMi5zdmdhXCIsIFwiZnJhbWUwMy5zdmdhXCJdLm1hcChmaWxlbmFtZSA9PiBgJHtMT0NBTF9TVkdBX1VSTH0vbGFyZ2UvJHtmaWxlbmFtZX1gKTtcbmNvbnN0IHl5U291cmNlcyA9IGV4cG9ydHMueXlTb3VyY2VzID0gW1wiYW5nZWwuc3ZnYVwiLCBcIkVtcHR5U3RhdGUuc3ZnYVwiLCBcImhhbGxvd2Vlbi5zdmdhXCIsIFwiSGFtYnVyZ2VyQXJyb3cuc3ZnYVwiLCBcImtpbmdzZXQuc3ZnYVwiLCBcIm1hdHRlQml0bWFwLnN2Z2FcIiwgXCJtYXR0ZVJlY3Quc3ZnYVwiLCBcIlBpbkp1bXAuc3ZnYVwiLCBcInBvc2NoZS5zdmdhXCIsIFwicm9zZS5zdmdhXCIsIFwiVHdpdHRlckhlYXJ0LnN2Z2FcIiwgXCJXYWxrdGhyb3VnaC5zdmdhXCJdLm1hcChmaWxlbmFtZSA9PiBgJHtMT0NBTF9TVkdBX1VSTH0veXkvJHtmaWxlbmFtZX1gKTtcbmNvbnN0IHN2Z2FIdWdlU291cmNlcyA9IGV4cG9ydHMuc3ZnYUh1Z2VTb3VyY2VzID0gW1wiZnJhbWUwMS5zdmdhXCIsIFwiZnJhbWUwMi5zdmdhXCIsIFwiZnJhbWUwMy5zdmdhXCJdLm1hcChmaWxlbmFtZSA9PiBgJHtMT0NBTF9TVkdBX1VSTH0vaHVnZS8ke2ZpbGVuYW1lfWApO1xuY29uc3QgcG9zdGVyU291cmNlcyA9IGV4cG9ydHMucG9zdGVyU291cmNlcyA9IFtcIuW+ruS/oeiupOivgeaOiOadg+eggS3nuq/lh4DniYguc3ZnYVwiLCBcIuW+ruS/oeiupOivgeaOiOadg+eggS5zdmdhXCIsIFwi5pSv5LuY5a6d6K6k6K+B5o6I5p2D56CBLee6r+WHgOeJiC5zdmdhXCIsIFwi5pSv5LuY5a6d6K6k6K+B5o6I5p2D56CBLnN2Z2FcIl0ubWFwKGZpbGVuYW1lID0+IGAke0xPQ0FMX1NWR0FfVVJMfS9wb3N0ZXIvJHtmaWxlbmFtZX1gKTtcbmZ1bmN0aW9uIGdldE9uZUF0UmFuZG9tKHNpemUpIHtcbiAgcmV0dXJuIHtcbiAgICByYW5JbmRleDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSlcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/constants.js\n");

/***/ }),

/***/ "./utils/fuck-benchmark.js":
/*!*********************************!*\
  !*** ./utils/fuck-benchmark.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n(function (g, f) {\n   true ? f(exports) : 0;\n})(void 0, function (exports) {\n  'use strict';\n\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _assertThisInitialized(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n  function asyncGeneratorStep(n, t, e, r, o, a, c) {\n    try {\n      var i = n[a](c),\n        u = i.value;\n    } catch (n) {\n      return void e(n);\n    }\n    i.done ? t(u) : Promise.resolve(u).then(r, o);\n  }\n  function _asyncToGenerator(n) {\n    return function () {\n      var t = this,\n        e = arguments;\n      return new Promise(function (r, o) {\n        var a = n.apply(t, e);\n        function _next(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n        }\n        function _throw(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n        }\n        _next(void 0);\n      });\n    };\n  }\n  function _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n  }\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n      writable: false\n    }), e;\n  }\n  function _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n        t && (r = t);\n        var n = 0,\n          F = function () {};\n        return {\n          s: F,\n          n: function () {\n            return n >= r.length ? {\n              done: true\n            } : {\n              done: false,\n              value: r[n++]\n            };\n          },\n          e: function (r) {\n            throw r;\n          },\n          f: F\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o,\n      a = true,\n      u = false;\n    return {\n      s: function () {\n        t = t.call(r);\n      },\n      n: function () {\n        var r = t.next();\n        return a = r.done, r;\n      },\n      e: function (r) {\n        u = true, o = r;\n      },\n      f: function () {\n        try {\n          a || null == t.return || t.return();\n        } finally {\n          if (u) throw o;\n        }\n      }\n    };\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    }) : e[r] = t, e;\n  }\n  function _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n  }\n  function _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: true,\n        configurable: true\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: false\n    }), e && _setPrototypeOf(t, e);\n  }\n  function _isNativeReflectConstruct() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function () {\n      return !!t;\n    })();\n  }\n  function _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n  }\n  function _regenerator() {\n    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\n    var e,\n      t,\n      r = \"function\" == typeof Symbol ? Symbol : {},\n      n = r.iterator || \"@@iterator\",\n      o = r.toStringTag || \"@@toStringTag\";\n    function i(r, n, o, i) {\n      var c = n && n.prototype instanceof Generator ? n : Generator,\n        u = Object.create(c.prototype);\n      return _regeneratorDefine(u, \"_invoke\", function (r, n, o) {\n        var i,\n          c,\n          u,\n          f = 0,\n          p = o || [],\n          y = false,\n          G = {\n            p: 0,\n            n: 0,\n            v: e,\n            a: d,\n            f: d.bind(e, 4),\n            d: function (t, r) {\n              return i = t, c = 0, u = e, G.n = r, a;\n            }\n          };\n        function d(r, n) {\n          for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {\n            var o,\n              i = p[t],\n              d = G.p,\n              l = i[2];\n            r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));\n          }\n          if (o || r > 1) return a;\n          throw y = true, n;\n        }\n        return function (o, p, l) {\n          if (f > 1) throw TypeError(\"Generator is already running\");\n          for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {\n            i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);\n            try {\n              if (f = 2, i) {\n                if (c || (o = \"next\"), t = i[o]) {\n                  if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\");\n                  if (!t.done) return t;\n                  u = t.value, c < 2 && (c = 0);\n                } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1);\n                i = e;\n              } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;\n            } catch (t) {\n              i = e, c = 1, u = t;\n            } finally {\n              f = 1;\n            }\n          }\n          return {\n            value: t,\n            done: y\n          };\n        };\n      }(r, o, i), true), u;\n    }\n    var a = {};\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    t = Object.getPrototypeOf;\n    var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {\n        return this;\n      }), t),\n      u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);\n    function f(e) {\n      return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e;\n    }\n    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine(u), _regeneratorDefine(u, o, \"Generator\"), _regeneratorDefine(u, n, function () {\n      return this;\n    }), _regeneratorDefine(u, \"toString\", function () {\n      return \"[object Generator]\";\n    }), (_regenerator = function () {\n      return {\n        w: i,\n        m: f\n      };\n    })();\n  }\n  function _regeneratorDefine(e, r, n, t) {\n    var i = Object.defineProperty;\n    try {\n      i({}, \"\", {});\n    } catch (e) {\n      i = 0;\n    }\n    _regeneratorDefine = function (e, r, n, t) {\n      if (r) i ? i(e, r, {\n        value: n,\n        enumerable: !t,\n        configurable: !t,\n        writable: !t\n      }) : e[r] = n;else {\n        function o(r, n) {\n          _regeneratorDefine(e, r, function (e) {\n            return this._invoke(r, n, e);\n          });\n        }\n        o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2);\n      }\n    }, _regeneratorDefine(e, r, n, t);\n  }\n  function _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r);\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  } /******************************************************************************\n    Copyright (c) Microsoft Corporation.\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n  typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n  };\n  var noop = function noop() {};\n  function delay(callback, interval) {\n    return new Promise(function (resolve) {\n      return setTimeout(function () {\n        return resolve(callback());\n      }, interval);\n    });\n  }\n  function retry(_x) {\n    return _retry.apply(this, arguments);\n  } // 使用静态缓冲区，避免重复创建\n  function _retry() {\n    _retry = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(fn) {\n      var intervals,\n        times,\n        _args4 = arguments,\n        _t5;\n      return _regenerator().w(function (_context4) {\n        while (1) switch (_context4.p = _context4.n) {\n          case 0:\n            intervals = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : [];\n            times = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : 0;\n            _context4.p = 1;\n            return _context4.a(2, fn());\n          case 2:\n            _context4.p = 2;\n            _t5 = _context4.v;\n            if (!(times >= intervals.length)) {\n              _context4.n = 3;\n              break;\n            }\n            throw _t5;\n          case 3:\n            return _context4.a(2, delay(function () {\n              return retry(fn, intervals, ++times);\n            }, intervals[times]));\n        }\n      }, _callee4, null, [[1, 2]]);\n    }));\n    return _retry.apply(this, arguments);\n  }\n  var OctopusPlatform = /*#__PURE__*/function () {\n    function OctopusPlatform(plugins, version) {\n      _classCallCheck(this, OctopusPlatform);\n      /**\n       * 插件列表\n       */\n      _defineProperty(this, \"plugins\", []);\n      /**\n       * 平台版本\n       */\n      _defineProperty(this, \"platformVersion\", \"0.1.3\");\n      /**\n       * 应用版本\n       */\n      _defineProperty(this, \"version\", \"\");\n      /**\n       * 全局变量\n       */\n      _defineProperty(this, \"globals\", {\n        env: \"unknown\",\n        br: null,\n        dpr: 1,\n        system: \"\"\n      });\n      _defineProperty(this, \"noop\", noop);\n      _defineProperty(this, \"retry\", retry);\n      this.version = version || \"\";\n      this.plugins = plugins;\n      this.globals.env = this.autoEnv();\n    }\n    return _createClass(OctopusPlatform, [{\n      key: \"init\",\n      value: function init() {\n        var globals = this.globals,\n          plugins = this.plugins;\n        var collection = new Map();\n        var names = [];\n        var installedPlugins = new Set();\n        globals.br = this.useBridge();\n        globals.dpr = this.usePixelRatio();\n        globals.system = this.useSystem();\n        var _iterator = _createForOfIteratorHelper(plugins),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var plugin = _step.value;\n            names.push(plugin.name);\n            collection.set(plugin.name, plugin);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.usePlugins(collection, names, installedPlugins);\n        installedPlugins.clear();\n      }\n    }, {\n      key: \"autoEnv\",\n      value: function autoEnv() {\n        if (typeof window !== \"undefined\") {\n          return \"h5\";\n        }\n        // FIXME：由于抖音场景支持wx对象，所以需要放在wx对象之前检查\n        if (typeof tt !== \"undefined\") {\n          return \"tt\";\n        }\n        if (typeof my !== \"undefined\") {\n          return \"alipay\";\n        }\n        if (typeof wx !== \"undefined\") {\n          return \"weapp\";\n        }\n        if (typeof has !== \"undefined\") {\n          return \"harmony\";\n        }\n        throw new Error(\"Unsupported platform！\");\n      }\n    }, {\n      key: \"useBridge\",\n      value: function useBridge() {\n        switch (this.globals.env) {\n          case \"alipay\":\n            return my;\n          case \"tt\":\n            return tt;\n          case \"weapp\":\n            return wx;\n        }\n        return globalThis;\n      }\n    }, {\n      key: \"usePixelRatio\",\n      value: function usePixelRatio() {\n        var _this$globals = this.globals,\n          env = _this$globals.env,\n          br = _this$globals.br;\n        if (env === \"h5\") {\n          return devicePixelRatio;\n        }\n        if (\"getWindowInfo\" in br) {\n          return br.getWindowInfo().pixelRatio;\n        }\n        if (\"getSystemInfoSync\" in br) {\n          return br.getSystemInfoSync().pixelRatio;\n        }\n        return 1;\n      }\n    }, {\n      key: \"useSystem\",\n      value: function useSystem() {\n        var env = this.globals.env;\n        var system;\n        switch (env) {\n          case \"weapp\":\n            system = wx.getDeviceInfo().platform;\n            break;\n          case \"alipay\":\n            system = my.getDeviceBaseInfo().platform;\n            break;\n          case \"tt\":\n            system = has.getDeviceInfoSync().platform;\n            break;\n          case \"harmony\":\n            system = has.getSystemInfoSync().platform;\n            break;\n          case \"h5\":\n            if (\"userAgentData\" in navigator) {\n              // @ts-ignore\n              system = navigator.userAgentData.platform;\n            } else {\n              var UA = navigator.userAgent;\n              if (/(Android|Adr)/i.test(UA)) {\n                system = \"android\";\n              } else if (/\\(i[^;]+;( U;)? CPU.+Mac OS X/i.test(UA)) {\n                system = \"ios\";\n              } else if (/HarmonyOS/i.test(UA)) {\n                system = \"harmony\";\n              } else {\n                system = \"unknown\";\n              }\n            }\n            break;\n          default:\n            system = \"unknown\";\n        }\n        return system.toLowerCase();\n      }\n    }, {\n      key: \"usePlugins\",\n      value: function usePlugins(plugins, pluginNames, installedPlugins) {\n        var _iterator2 = _createForOfIteratorHelper(pluginNames),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var pluginName = _step2.value;\n            if (!plugins.has(pluginName)) {\n              throw new Error(\"Plugin \".concat(pluginName, \" not found\"));\n            }\n            if (installedPlugins.has(pluginName)) {\n              return;\n            }\n            var plugin = plugins.get(pluginName);\n            // 递归调用依赖\n            if (Array.isArray(plugin.dependencies)) {\n              var _iterator3 = _createForOfIteratorHelper(plugin.dependencies),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _plugins$get;\n                  var dependency = _step3.value;\n                  if (typeof ((_plugins$get = plugins.get(dependency)) === null || _plugins$get === void 0 ? void 0 : _plugins$get.install) !== \"function\") {\n                    throw new Error(\"Plugin \".concat(pluginName, \" depends on plugin \").concat(dependency, \", but \").concat(dependency, \" is not found\"));\n                  }\n                }\n                // 递归加载依赖\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              this.usePlugins(plugins, plugin.dependencies, installedPlugins);\n            }\n            this.installPlugin(plugin);\n            installedPlugins.add(pluginName);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }, {\n      key: \"switch\",\n      value: function _switch(env) {\n        this.globals.env = env;\n        this.init();\n      }\n    }]);\n  }();\n  /**\n   * 定义平台插件\n   */\n  var definePlugin = function definePlugin(plugin) {\n    return plugin;\n  };\n  function installPlugin(platform, plugin) {\n    var value = plugin.install.call(platform);\n    Object.defineProperty(platform, plugin.name, {\n      get: function get() {\n        return value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n  }\n  var pluginNow = definePlugin({\n    name: \"now\",\n    install: function install() {\n      var _this$globals7 = this.globals,\n        env = _this$globals7.env,\n        br = _this$globals7.br;\n      // performance可以提供更高精度的时间测量，且不受系统时间的调整（如更改系统时间或同步时间）的影响\n      var perf = env === \"h5\" || env === \"tt\" ? performance : br.getPerformance();\n      if (typeof (perf === null || perf === void 0 ? void 0 : perf.now) === \"function\") {\n        // 支付宝小程序的performance.now()获取的是当前时间戳，单位是微秒。\n        if (perf.now() - Date.now() > 1) {\n          return function () {\n            return perf.now() / 1000;\n          };\n        }\n        // H5环境下，performance.now()获取的不是当前时间戳，而是从页面加载开始的时间戳，单位是毫秒。\n        return function () {\n          return perf.now();\n        };\n      }\n      return function () {\n        return Date.now();\n      };\n    }\n  });\n  var EnhancedPlatform = /*#__PURE__*/function (_OctopusPlatform) {\n    function EnhancedPlatform() {\n      var _this;\n      _classCallCheck(this, EnhancedPlatform);\n      _this = _callSuper(this, EnhancedPlatform, [[pluginNow], \"1.1.1\"]);\n      _this.init();\n      return _this;\n    }\n    _inherits(EnhancedPlatform, _OctopusPlatform);\n    return _createClass(EnhancedPlatform, [{\n      key: \"installPlugin\",\n      value: function installPlugin$1(plugin) {\n        installPlugin(this, plugin);\n      }\n    }]);\n  }(OctopusPlatform);\n  var platform = new EnhancedPlatform();\n  var logBadge = [\"%cBENCHMARK\", \"padding: 2px 4px; background: #68B984; color: #FFFFFF; border-radius: 4px;\"];\n  var infoBadge = [\"%cBENCHMARK\", \"padding: 2px 4px; background: #89CFF0; color: #FFFFFF; border-radius: 4px;\"];\n  var Stopwatch = /*#__PURE__*/function () {\n    function Stopwatch() {\n      _classCallCheck(this, Stopwatch);\n      this.timeLabels = new Map();\n      this.markLabels = new Map();\n    }\n    return _createClass(Stopwatch, [{\n      key: \"start\",\n      value: function start(label) {\n        this.timeLabels.set(label, platform.now());\n      }\n    }, {\n      key: \"stop\",\n      value: function stop(label) {\n        var nowTime = platform.now();\n        var timeLabels = this.timeLabels;\n        if (timeLabels.has(label)) {\n          console.log(\"\".concat(label, \": \").concat(nowTime - timeLabels.get(label), \" ms\"));\n          timeLabels.delete(label);\n        }\n      }\n    }, {\n      key: \"mark\",\n      value: function mark(label) {\n        var nowTime = platform.now();\n        var markLabels = this.markLabels;\n        if (markLabels.has(label)) {\n          console.log(\"\".concat(label, \": \").concat(nowTime - markLabels.get(label), \" ms\"));\n        }\n        markLabels.set(label, nowTime);\n      }\n    }, {\n      key: \"reset\",\n      value: function reset(label) {\n        this.markLabels.delete(label);\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.timeLabels.clear();\n        this.markLabels.clear();\n      }\n    }]);\n  }();\n  var stopwatch = new Stopwatch();\n  var benchmark = Object.create(stopwatch);\n  benchmark.now = function () {\n    return platform.now();\n  };\n  benchmark.time = function (label, callback) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n      var result;\n      return _regenerator().w(function (_context) {\n        while (1) switch (_context.n) {\n          case 0:\n            stopwatch.start(label);\n            _context.n = 1;\n            return callback();\n          case 1:\n            result = _context.v;\n            stopwatch.stop(label);\n            return _context.a(2, result);\n        }\n      }, _callee);\n    }));\n  };\n  benchmark.line = function () {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;\n    console.log(\"-\".repeat(size));\n  };\n  benchmark.log = function () {\n    var _console;\n    for (var _len = arguments.length, message = new Array(_len), _key = 0; _key < _len; _key++) {\n      message[_key] = arguments[_key];\n    }\n    (_console = console).log.apply(_console, logBadge.concat(message));\n  };\n  benchmark.info = function () {\n    var _console2;\n    for (var _len2 = arguments.length, message = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      message[_key2] = arguments[_key2];\n    }\n    (_console2 = console).info.apply(_console2, infoBadge.concat(message));\n  };\n  exports.benchmark = benchmark;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9mdWNrLWJlbmNobWFyay5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcHJvZ3JhbS13ZWFwcC8uL3V0aWxzL2Z1Y2stYmVuY2htYXJrLmpzPzFkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoZywgZikge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmKGV4cG9ydHMpIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmKSA6IChnID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGcgfHwgc2VsZiwgZihnLmJlbmNobWFyayA9IHt9KSk7XG59KSh2b2lkIDAsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gICAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaSA9IG5bYV0oYyksXG4gICAgICAgIHUgPSBpLnZhbHVlO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHJldHVybiB2b2lkIGUobik7XG4gICAgfVxuICAgIGkuZG9uZSA/IHQodSkgOiBQcm9taXNlLnJlc29sdmUodSkudGhlbihyLCBvKTtcbiAgfVxuICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgZSA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAociwgbykge1xuICAgICAgICB2YXIgYSA9IG4uYXBwbHkodCwgZSk7XG4gICAgICAgIGZ1bmN0aW9uIF9uZXh0KG4pIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF90aHJvdyhuKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgX25leHQodm9pZCAwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gICAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbiAgfVxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICB2YXIgbyA9IHJbdF07XG4gICAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgZmFsc2UsIG8uY29uZmlndXJhYmxlID0gdHJ1ZSwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSB0cnVlKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gICAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSksIGU7XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociwgZSkge1xuICAgIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlKSB7XG4gICAgICAgIHQgJiYgKHIgPSB0KTtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzOiBGLFxuICAgICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuID49IHIubGVuZ3RoID8ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHJbbisrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGU6IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB0aHJvdyByO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZjogRlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgIH1cbiAgICB2YXIgbyxcbiAgICAgIGEgPSB0cnVlLFxuICAgICAgdSA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQgPSB0LmNhbGwocik7XG4gICAgICB9LFxuICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IHQubmV4dCgpO1xuICAgICAgICByZXR1cm4gYSA9IHIuZG9uZSwgcjtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbiAocikge1xuICAgICAgICB1ID0gdHJ1ZSwgbyA9IHI7XG4gICAgICB9LFxuICAgICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGEgfHwgbnVsbCA9PSB0LnJldHVybiB8fCB0LnJldHVybigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh1KSB0aHJvdyBvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICAgIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSkgOiBlW3JdID0gdCwgZTtcbiAgfVxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gICAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiB0LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG4gIH1cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdDtcbiAgICB9KSgpO1xuICB9XG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgICBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG4gIH1cbiAgZnVuY3Rpb24gX3JlZ2VuZXJhdG9yKCkge1xuICAgIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvYmxvYi9tYWluL3BhY2thZ2VzL2JhYmVsLWhlbHBlcnMvTElDRU5TRSAqL1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIHIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LFxuICAgICAgbiA9IHIuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgICBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgICBmdW5jdGlvbiBpKHIsIG4sIG8sIGkpIHtcbiAgICAgIHZhciBjID0gbiAmJiBuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG4gOiBHZW5lcmF0b3IsXG4gICAgICAgIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJfaW52b2tlXCIsIGZ1bmN0aW9uIChyLCBuLCBvKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBmID0gMCxcbiAgICAgICAgICBwID0gbyB8fCBbXSxcbiAgICAgICAgICB5ID0gZmFsc2UsXG4gICAgICAgICAgRyA9IHtcbiAgICAgICAgICAgIHA6IDAsXG4gICAgICAgICAgICBuOiAwLFxuICAgICAgICAgICAgdjogZSxcbiAgICAgICAgICAgIGE6IGQsXG4gICAgICAgICAgICBmOiBkLmJpbmQoZSwgNCksXG4gICAgICAgICAgICBkOiBmdW5jdGlvbiAodCwgcikge1xuICAgICAgICAgICAgICByZXR1cm4gaSA9IHQsIGMgPSAwLCB1ID0gZSwgRy5uID0gciwgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBkKHIsIG4pIHtcbiAgICAgICAgICBmb3IgKGMgPSByLCB1ID0gbiwgdCA9IDA7ICF5ICYmIGYgJiYgIW8gJiYgdCA8IHAubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBvLFxuICAgICAgICAgICAgICBpID0gcFt0XSxcbiAgICAgICAgICAgICAgZCA9IEcucCxcbiAgICAgICAgICAgICAgbCA9IGlbMl07XG4gICAgICAgICAgICByID4gMyA/IChvID0gbCA9PT0gbikgJiYgKHUgPSBpWyhjID0gaVs0XSkgPyA1IDogKGMgPSAzLCAzKV0sIGlbNF0gPSBpWzVdID0gZSkgOiBpWzBdIDw9IGQgJiYgKChvID0gciA8IDIgJiYgZCA8IGlbMV0pID8gKGMgPSAwLCBHLnYgPSBuLCBHLm4gPSBpWzFdKSA6IGQgPCBsICYmIChvID0gciA8IDMgfHwgaVswXSA+IG4gfHwgbiA+IGwpICYmIChpWzRdID0gciwgaVs1XSA9IG4sIEcubiA9IGwsIGMgPSAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvIHx8IHIgPiAxKSByZXR1cm4gYTtcbiAgICAgICAgICB0aHJvdyB5ID0gdHJ1ZSwgbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHAsIGwpIHtcbiAgICAgICAgICBpZiAoZiA+IDEpIHRocm93IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgICAgZm9yICh5ICYmIDEgPT09IHAgJiYgZChwLCBsKSwgYyA9IHAsIHUgPSBsOyAodCA9IGMgPCAyID8gZSA6IHUpIHx8ICF5Oykge1xuICAgICAgICAgICAgaSB8fCAoYyA/IGMgPCAzID8gKGMgPiAxICYmIChHLm4gPSAtMSksIGQoYywgdSkpIDogRy5uID0gdSA6IEcudiA9IHUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGYgPSAyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgfHwgKG8gPSBcIm5leHRcIiksIHQgPSBpW29dKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gdC5jYWxsKGksIHUpKSkgdGhyb3cgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgICBpZiAoIXQuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICB1ID0gdC52YWx1ZSwgYyA8IDIgJiYgKGMgPSAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgMSA9PT0gYyAmJiAodCA9IGkucmV0dXJuKSAmJiB0LmNhbGwoaSksIGMgPCAyICYmICh1ID0gVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBvICsgXCInIG1ldGhvZFwiKSwgYyA9IDEpO1xuICAgICAgICAgICAgICAgIGkgPSBlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0ID0gKHkgPSBHLm4gPCAwKSA/IHUgOiByLmNhbGwobiwgRykpICE9PSBhKSBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgaSA9IGUsIGMgPSAxLCB1ID0gdDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGYgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgICAgICBkb25lOiB5XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0ociwgbywgaSksIHRydWUpLCB1O1xuICAgIH1cbiAgICB2YXIgYSA9IHt9O1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgICB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIHZhciBjID0gW11bbl0gPyB0KHQoW11bbl0oKSkpIDogKF9yZWdlbmVyYXRvckRlZmluZSh0ID0ge30sIG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KSwgdCksXG4gICAgICB1ID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYyk7XG4gICAgZnVuY3Rpb24gZihlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChlLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1KSwgZTtcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBfcmVnZW5lcmF0b3JEZWZpbmUodSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSksIF9yZWdlbmVyYXRvckRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbiksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiLCBfcmVnZW5lcmF0b3JEZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIF9yZWdlbmVyYXRvckRlZmluZSh1KSwgX3JlZ2VuZXJhdG9yRGVmaW5lKHUsIG8sIFwiR2VuZXJhdG9yXCIpLCBfcmVnZW5lcmF0b3JEZWZpbmUodSwgbiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIF9yZWdlbmVyYXRvckRlZmluZSh1LCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH0pLCAoX3JlZ2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogaSxcbiAgICAgICAgbTogZlxuICAgICAgfTtcbiAgICB9KSgpO1xuICB9XG4gIGZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KSB7XG4gICAgdmFyIGkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdHJ5IHtcbiAgICAgIGkoe30sIFwiXCIsIHt9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpID0gMDtcbiAgICB9XG4gICAgX3JlZ2VuZXJhdG9yRGVmaW5lID0gZnVuY3Rpb24gKGUsIHIsIG4sIHQpIHtcbiAgICAgIGlmIChyKSBpID8gaShlLCByLCB7XG4gICAgICAgIHZhbHVlOiBuLFxuICAgICAgICBlbnVtZXJhYmxlOiAhdCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhdCxcbiAgICAgICAgd3JpdGFibGU6ICF0XG4gICAgICB9KSA6IGVbcl0gPSBuO2Vsc2Uge1xuICAgICAgICBmdW5jdGlvbiBvKHIsIG4pIHtcbiAgICAgICAgICBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UociwgbiwgZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbyhcIm5leHRcIiwgMCksIG8oXCJ0aHJvd1wiLCAxKSwgbyhcInJldHVyblwiLCAyKTtcbiAgICAgIH1cbiAgICB9LCBfcmVnZW5lcmF0b3JEZWZpbmUoZSwgciwgbiwgdCk7XG4gIH1cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICAgIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbiAgfVxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh0KTtcbiAgfVxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gICAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gICAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgICBpZiAocikge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0gLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbiAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG4gIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgIH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbiAgfVxuICB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xuICB9O1xuICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIGludGVydmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGNhbGxiYWNrKCkpO1xuICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJldHJ5KF94KSB7XG4gICAgcmV0dXJuIF9yZXRyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IC8vIOS9v+eUqOmdmeaAgee8k+WGsuWMuu+8jOmBv+WFjemHjeWkjeWIm+W7ulxuICBmdW5jdGlvbiBfcmV0cnkoKSB7XG4gICAgX3JldHJ5ID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTQoZm4pIHtcbiAgICAgIHZhciBpbnRlcnZhbHMsXG4gICAgICAgIHRpbWVzLFxuICAgICAgICBfYXJnczQgPSBhcmd1bWVudHMsXG4gICAgICAgIF90NTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0LnAgPSBfY29udGV4dDQubikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGludGVydmFscyA9IF9hcmdzNC5sZW5ndGggPiAxICYmIF9hcmdzNFsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M0WzFdIDogW107XG4gICAgICAgICAgICB0aW1lcyA9IF9hcmdzNC5sZW5ndGggPiAyICYmIF9hcmdzNFsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M0WzJdIDogMDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5wID0gMTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYSgyLCBmbigpKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfY29udGV4dDQucCA9IDI7XG4gICAgICAgICAgICBfdDUgPSBfY29udGV4dDQudjtcbiAgICAgICAgICAgIGlmICghKHRpbWVzID49IGludGVydmFscy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBfdDU7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hKDIsIGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5KGZuLCBpbnRlcnZhbHMsICsrdGltZXMpO1xuICAgICAgICAgICAgfSwgaW50ZXJ2YWxzW3RpbWVzXSkpO1xuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCwgbnVsbCwgW1sxLCAyXV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3JldHJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgdmFyIE9jdG9wdXNQbGF0Zm9ybSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2N0b3B1c1BsYXRmb3JtKHBsdWdpbnMsIHZlcnNpb24pIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPY3RvcHVzUGxhdGZvcm0pO1xuICAgICAgLyoqXG4gICAgICAgKiDmj5Lku7bliJfooahcbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGx1Z2luc1wiLCBbXSk7XG4gICAgICAvKipcbiAgICAgICAqIOW5s+WPsOeJiOacrFxuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbGF0Zm9ybVZlcnNpb25cIiwgXCIwLjEuM1wiKTtcbiAgICAgIC8qKlxuICAgICAgICog5bqU55So54mI5pysXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgXCJcIik7XG4gICAgICAvKipcbiAgICAgICAqIOWFqOWxgOWPmOmHj1xuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnbG9iYWxzXCIsIHtcbiAgICAgICAgZW52OiBcInVua25vd25cIixcbiAgICAgICAgYnI6IG51bGwsXG4gICAgICAgIGRwcjogMSxcbiAgICAgICAgc3lzdGVtOiBcIlwiXG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vb3BcIiwgbm9vcCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXRyeVwiLCByZXRyeSk7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uIHx8IFwiXCI7XG4gICAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgdGhpcy5nbG9iYWxzLmVudiA9IHRoaXMuYXV0b0VudigpO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9jdG9wdXNQbGF0Zm9ybSwgW3tcbiAgICAgIGtleTogXCJpbml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgICAgcGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZ2xvYmFscy5iciA9IHRoaXMudXNlQnJpZGdlKCk7XG4gICAgICAgIGdsb2JhbHMuZHByID0gdGhpcy51c2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIGdsb2JhbHMuc3lzdGVtID0gdGhpcy51c2VTeXN0ZW0oKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBsdWdpbnMpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlUGx1Z2lucyhjb2xsZWN0aW9uLCBuYW1lcywgaW5zdGFsbGVkUGx1Z2lucyk7XG4gICAgICAgIGluc3RhbGxlZFBsdWdpbnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXV0b0VudlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9FbnYoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaDVcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRe+8mueUseS6juaKlumfs+WcuuaZr+aUr+aMgXd45a+56LGh77yM5omA5Lul6ZyA6KaB5pS+5Zyod3jlr7nosaHkuYvliY3mo4Dmn6VcbiAgICAgICAgaWYgKHR5cGVvZiB0dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBcInR0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBteSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBcImFsaXBheVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd3ggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJ3ZWFwcFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaGFybW9ueVwiO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBsYXRmb3Jt77yBXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1c2VCcmlkZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1c2VCcmlkZ2UoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5nbG9iYWxzLmVudikge1xuICAgICAgICAgIGNhc2UgXCJhbGlwYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBteTtcbiAgICAgICAgICBjYXNlIFwidHRcIjpcbiAgICAgICAgICAgIHJldHVybiB0dDtcbiAgICAgICAgICBjYXNlIFwid2VhcHBcIjpcbiAgICAgICAgICAgIHJldHVybiB3eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXNlUGl4ZWxSYXRpb1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZVBpeGVsUmF0aW8oKSB7XG4gICAgICAgIHZhciBfdGhpcyRnbG9iYWxzID0gdGhpcy5nbG9iYWxzLFxuICAgICAgICAgIGVudiA9IF90aGlzJGdsb2JhbHMuZW52LFxuICAgICAgICAgIGJyID0gX3RoaXMkZ2xvYmFscy5icjtcbiAgICAgICAgaWYgKGVudiA9PT0gXCJoNVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZ2V0V2luZG93SW5mb1wiIGluIGJyKSB7XG4gICAgICAgICAgcmV0dXJuIGJyLmdldFdpbmRvd0luZm8oKS5waXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImdldFN5c3RlbUluZm9TeW5jXCIgaW4gYnIpIHtcbiAgICAgICAgICByZXR1cm4gYnIuZ2V0U3lzdGVtSW5mb1N5bmMoKS5waXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1c2VTeXN0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1c2VTeXN0ZW0oKSB7XG4gICAgICAgIHZhciBlbnYgPSB0aGlzLmdsb2JhbHMuZW52O1xuICAgICAgICB2YXIgc3lzdGVtO1xuICAgICAgICBzd2l0Y2ggKGVudikge1xuICAgICAgICAgIGNhc2UgXCJ3ZWFwcFwiOlxuICAgICAgICAgICAgc3lzdGVtID0gd3guZ2V0RGV2aWNlSW5mbygpLnBsYXRmb3JtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImFsaXBheVwiOlxuICAgICAgICAgICAgc3lzdGVtID0gbXkuZ2V0RGV2aWNlQmFzZUluZm8oKS5wbGF0Zm9ybTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgICAgICAgc3lzdGVtID0gaGFzLmdldERldmljZUluZm9TeW5jKCkucGxhdGZvcm07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaGFybW9ueVwiOlxuICAgICAgICAgICAgc3lzdGVtID0gaGFzLmdldFN5c3RlbUluZm9TeW5jKCkucGxhdGZvcm07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaDVcIjpcbiAgICAgICAgICAgIGlmIChcInVzZXJBZ2VudERhdGFcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBzeXN0ZW0gPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5wbGF0Zm9ybTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBVQSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICAgIGlmICgvKEFuZHJvaWR8QWRyKS9pLnRlc3QoVUEpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJhbmRyb2lkXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcKGlbXjtdKzsoIFU7KT8gQ1BVLitNYWMgT1MgWC9pLnRlc3QoVUEpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJpb3NcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvSGFybW9ueU9TL2kudGVzdChVQSkpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImhhcm1vbnlcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInVua25vd25cIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN5c3RlbSA9IFwidW5rbm93blwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeXN0ZW0udG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXNlUGx1Z2luc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZVBsdWdpbnMocGx1Z2lucywgcGx1Z2luTmFtZXMsIGluc3RhbGxlZFBsdWdpbnMpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwbHVnaW5OYW1lcyksXG4gICAgICAgICAgX3N0ZXAyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIGlmICghcGx1Z2lucy5oYXMocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChwbHVnaW5OYW1lLCBcIiBub3QgZm91bmRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgICAgICAgIC8vIOmAkuW9kuiwg+eUqOS+nei1llxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luLmRlcGVuZGVuY2llcykpIHtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwbHVnaW4uZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAgICAgICBfc3RlcDM7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcGx1Z2lucyRnZXQ7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKChfcGx1Z2lucyRnZXQgPSBwbHVnaW5zLmdldChkZXBlbmRlbmN5KSkgPT09IG51bGwgfHwgX3BsdWdpbnMkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGx1Z2lucyRnZXQuaW5zdGFsbCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gXCIuY29uY2F0KHBsdWdpbk5hbWUsIFwiIGRlcGVuZHMgb24gcGx1Z2luIFwiKS5jb25jYXQoZGVwZW5kZW5jeSwgXCIsIGJ1dCBcIikuY29uY2F0KGRlcGVuZGVuY3ksIFwiIGlzIG5vdCBmb3VuZFwiKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOmAkuW9kuWKoOi9veS+nei1llxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnVzZVBsdWdpbnMocGx1Z2lucywgcGx1Z2luLmRlcGVuZGVuY2llcywgaW5zdGFsbGVkUGx1Z2lucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluc3RhbGxQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbk5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3dpdGNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3aXRjaChlbnYpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxzLmVudiA9IGVudjtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIC8qKlxuICAgKiDlrprkuYnlubPlj7Dmj5Lku7ZcbiAgICovXG4gIHZhciBkZWZpbmVQbHVnaW4gPSBmdW5jdGlvbiBkZWZpbmVQbHVnaW4ocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfTtcbiAgZnVuY3Rpb24gaW5zdGFsbFBsdWdpbihwbGF0Zm9ybSwgcGx1Z2luKSB7XG4gICAgdmFyIHZhbHVlID0gcGx1Z2luLmluc3RhbGwuY2FsbChwbGF0Zm9ybSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXRmb3JtLCBwbHVnaW4ubmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdmFyIHBsdWdpbk5vdyA9IGRlZmluZVBsdWdpbih7XG4gICAgbmFtZTogXCJub3dcIixcbiAgICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIF90aGlzJGdsb2JhbHM3ID0gdGhpcy5nbG9iYWxzLFxuICAgICAgICBlbnYgPSBfdGhpcyRnbG9iYWxzNy5lbnYsXG4gICAgICAgIGJyID0gX3RoaXMkZ2xvYmFsczcuYnI7XG4gICAgICAvLyBwZXJmb3JtYW5jZeWPr+S7peaPkOS+m+abtOmrmOeyvuW6pueahOaXtumXtOa1i+mHj++8jOS4lOS4jeWPl+ezu+e7n+aXtumXtOeahOiwg+aVtO+8iOWmguabtOaUueezu+e7n+aXtumXtOaIluWQjOatpeaXtumXtO+8ieeahOW9seWTjVxuICAgICAgdmFyIHBlcmYgPSBlbnYgPT09IFwiaDVcIiB8fCBlbnYgPT09IFwidHRcIiA/IHBlcmZvcm1hbmNlIDogYnIuZ2V0UGVyZm9ybWFuY2UoKTtcbiAgICAgIGlmICh0eXBlb2YgKHBlcmYgPT09IG51bGwgfHwgcGVyZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyZi5ub3cpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8g5pSv5LuY5a6d5bCP56iL5bqP55qEcGVyZm9ybWFuY2Uubm93KCnojrflj5bnmoTmmK/lvZPliY3ml7bpl7TmiLPvvIzljZXkvY3mmK/lvq7np5LjgIJcbiAgICAgICAgaWYgKHBlcmYubm93KCkgLSBEYXRlLm5vdygpID4gMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyZi5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBINeeOr+Wig+S4i++8jHBlcmZvcm1hbmNlLm5vdygp6I635Y+W55qE5LiN5piv5b2T5YmN5pe26Ze05oiz77yM6ICM5piv5LuO6aG16Z2i5Yqg6L295byA5aeL55qE5pe26Ze05oiz77yM5Y2V5L2N5piv5q+r56eS44CCXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHBlcmYubm93KCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgdmFyIEVuaGFuY2VkUGxhdGZvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PY3RvcHVzUGxhdGZvcm0pIHtcbiAgICBmdW5jdGlvbiBFbmhhbmNlZFBsYXRmb3JtKCkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuaGFuY2VkUGxhdGZvcm0pO1xuICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEVuaGFuY2VkUGxhdGZvcm0sIFtbcGx1Z2luTm93XSwgXCIxLjEuMVwiXSk7XG4gICAgICBfdGhpcy5pbml0KCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0cyhFbmhhbmNlZFBsYXRmb3JtLCBfT2N0b3B1c1BsYXRmb3JtKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVuaGFuY2VkUGxhdGZvcm0sIFt7XG4gICAgICBrZXk6IFwiaW5zdGFsbFBsdWdpblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbGxQbHVnaW4kMShwbHVnaW4pIHtcbiAgICAgICAgaW5zdGFsbFBsdWdpbih0aGlzLCBwbHVnaW4pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShPY3RvcHVzUGxhdGZvcm0pO1xuICB2YXIgcGxhdGZvcm0gPSBuZXcgRW5oYW5jZWRQbGF0Zm9ybSgpO1xuICB2YXIgbG9nQmFkZ2UgPSBbXCIlY0JFTkNITUFSS1wiLCBcInBhZGRpbmc6IDJweCA0cHg7IGJhY2tncm91bmQ6ICM2OEI5ODQ7IGNvbG9yOiAjRkZGRkZGOyBib3JkZXItcmFkaXVzOiA0cHg7XCJdO1xuICB2YXIgaW5mb0JhZGdlID0gW1wiJWNCRU5DSE1BUktcIiwgXCJwYWRkaW5nOiAycHggNHB4OyBiYWNrZ3JvdW5kOiAjODlDRkYwOyBjb2xvcjogI0ZGRkZGRjsgYm9yZGVyLXJhZGl1czogNHB4O1wiXTtcbiAgdmFyIFN0b3B3YXRjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcHdhdGNoKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0b3B3YXRjaCk7XG4gICAgICB0aGlzLnRpbWVMYWJlbHMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm1hcmtMYWJlbHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoU3RvcHdhdGNoLCBbe1xuICAgICAga2V5OiBcInN0YXJ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQobGFiZWwpIHtcbiAgICAgICAgdGhpcy50aW1lTGFiZWxzLnNldChsYWJlbCwgcGxhdGZvcm0ubm93KCkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcChsYWJlbCkge1xuICAgICAgICB2YXIgbm93VGltZSA9IHBsYXRmb3JtLm5vdygpO1xuICAgICAgICB2YXIgdGltZUxhYmVscyA9IHRoaXMudGltZUxhYmVscztcbiAgICAgICAgaWYgKHRpbWVMYWJlbHMuaGFzKGxhYmVsKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiXCIuY29uY2F0KGxhYmVsLCBcIjogXCIpLmNvbmNhdChub3dUaW1lIC0gdGltZUxhYmVscy5nZXQobGFiZWwpLCBcIiBtc1wiKSk7XG4gICAgICAgICAgdGltZUxhYmVscy5kZWxldGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcmtcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrKGxhYmVsKSB7XG4gICAgICAgIHZhciBub3dUaW1lID0gcGxhdGZvcm0ubm93KCk7XG4gICAgICAgIHZhciBtYXJrTGFiZWxzID0gdGhpcy5tYXJrTGFiZWxzO1xuICAgICAgICBpZiAobWFya0xhYmVscy5oYXMobGFiZWwpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJcIi5jb25jYXQobGFiZWwsIFwiOiBcIikuY29uY2F0KG5vd1RpbWUgLSBtYXJrTGFiZWxzLmdldChsYWJlbCksIFwiIG1zXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrTGFiZWxzLnNldChsYWJlbCwgbm93VGltZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQobGFiZWwpIHtcbiAgICAgICAgdGhpcy5tYXJrTGFiZWxzLmRlbGV0ZShsYWJlbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudGltZUxhYmVscy5jbGVhcigpO1xuICAgICAgICB0aGlzLm1hcmtMYWJlbHMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIHN0b3B3YXRjaCA9IG5ldyBTdG9wd2F0Y2goKTtcbiAgdmFyIGJlbmNobWFyayA9IE9iamVjdC5jcmVhdGUoc3RvcHdhdGNoKTtcbiAgYmVuY2htYXJrLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGxhdGZvcm0ubm93KCk7XG4gIH07XG4gIGJlbmNobWFyay50aW1lID0gZnVuY3Rpb24gKGxhYmVsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQubikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHN0b3B3YXRjaC5zdGFydChsYWJlbCk7XG4gICAgICAgICAgICBfY29udGV4dC5uID0gMTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnY7XG4gICAgICAgICAgICBzdG9wd2F0Y2guc3RvcChsYWJlbCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG4gIH07XG4gIGJlbmNobWFyay5saW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiA0MDtcbiAgICBjb25zb2xlLmxvZyhcIi1cIi5yZXBlYXQoc2l6ZSkpO1xuICB9O1xuICBiZW5jaG1hcmsubG9nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY29uc29sZTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZSA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG1lc3NhZ2VbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgbG9nQmFkZ2UuY29uY2F0KG1lc3NhZ2UpKTtcbiAgfTtcbiAgYmVuY2htYXJrLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb25zb2xlMjtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2UgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIG1lc3NhZ2VbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmluZm8uYXBwbHkoX2NvbnNvbGUyLCBpbmZvQmFkZ2UuY29uY2F0KG1lc3NhZ2UpKTtcbiAgfTtcbiAgZXhwb3J0cy5iZW5jaG1hcmsgPSBiZW5jaG1hcms7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/fuck-benchmark.js\n");

/***/ }),

/***/ "./utils/fuck-svga.js":
/*!****************************!*\
  !*** ./utils/fuck-svga.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n(function (g, f) {\n   true ? f(exports) : 0;\n})(void 0, function (exports) {\n  'use strict';\n\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n  }\n  function _assertThisInitialized(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n  function asyncGeneratorStep(n, t, e, r, o, a, c) {\n    try {\n      var i = n[a](c),\n        u = i.value;\n    } catch (n) {\n      return void e(n);\n    }\n    i.done ? t(u) : Promise.resolve(u).then(r, o);\n  }\n  function _asyncToGenerator(n) {\n    return function () {\n      var t = this,\n        e = arguments;\n      return new Promise(function (r, o) {\n        var a = n.apply(t, e);\n        function _next(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n        }\n        function _throw(n) {\n          asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n        }\n        _next(void 0);\n      });\n    };\n  }\n  function _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n  }\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n      writable: false\n    }), e;\n  }\n  function _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n        t && (r = t);\n        var n = 0,\n          F = function () {};\n        return {\n          s: F,\n          n: function () {\n            return n >= r.length ? {\n              done: true\n            } : {\n              done: false,\n              value: r[n++]\n            };\n          },\n          e: function (r) {\n            throw r;\n          },\n          f: F\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o,\n      a = true,\n      u = false;\n    return {\n      s: function () {\n        t = t.call(r);\n      },\n      n: function () {\n        var r = t.next();\n        return a = r.done, r;\n      },\n      e: function (r) {\n        u = true, o = r;\n      },\n      f: function () {\n        try {\n          a || null == t.return || t.return();\n        } finally {\n          if (u) throw o;\n        }\n      }\n    };\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    }) : e[r] = t, e;\n  }\n  function _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n  }\n  function _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: true,\n        configurable: true\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: false\n    }), e && _setPrototypeOf(t, e);\n  }\n  function _isNativeReflectConstruct() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function () {\n      return !!t;\n    })();\n  }\n  function _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n      var e,\n        n,\n        i,\n        u,\n        a = [],\n        f = true,\n        o = false;\n      try {\n        if (i = (t = t.call(r)).next, 0 === l) {\n          if (Object(t) !== t) return;\n          f = !1;\n        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n      } catch (r) {\n        o = true, n = r;\n      } finally {\n        try {\n          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n        } finally {\n          if (o) throw n;\n        }\n      }\n      return a;\n    }\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n  }\n  function _regenerator() {\n    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\n    var e,\n      t,\n      r = \"function\" == typeof Symbol ? Symbol : {},\n      n = r.iterator || \"@@iterator\",\n      o = r.toStringTag || \"@@toStringTag\";\n    function i(r, n, o, i) {\n      var c = n && n.prototype instanceof Generator ? n : Generator,\n        u = Object.create(c.prototype);\n      return _regeneratorDefine(u, \"_invoke\", function (r, n, o) {\n        var i,\n          c,\n          u,\n          f = 0,\n          p = o || [],\n          y = false,\n          G = {\n            p: 0,\n            n: 0,\n            v: e,\n            a: d,\n            f: d.bind(e, 4),\n            d: function (t, r) {\n              return i = t, c = 0, u = e, G.n = r, a;\n            }\n          };\n        function d(r, n) {\n          for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {\n            var o,\n              i = p[t],\n              d = G.p,\n              l = i[2];\n            r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));\n          }\n          if (o || r > 1) return a;\n          throw y = true, n;\n        }\n        return function (o, p, l) {\n          if (f > 1) throw TypeError(\"Generator is already running\");\n          for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {\n            i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);\n            try {\n              if (f = 2, i) {\n                if (c || (o = \"next\"), t = i[o]) {\n                  if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\");\n                  if (!t.done) return t;\n                  u = t.value, c < 2 && (c = 0);\n                } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1);\n                i = e;\n              } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;\n            } catch (t) {\n              i = e, c = 1, u = t;\n            } finally {\n              f = 1;\n            }\n          }\n          return {\n            value: t,\n            done: y\n          };\n        };\n      }(r, o, i), true), u;\n    }\n    var a = {};\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    t = Object.getPrototypeOf;\n    var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {\n        return this;\n      }), t),\n      u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);\n    function f(e) {\n      return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e;\n    }\n    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine(u), _regeneratorDefine(u, o, \"Generator\"), _regeneratorDefine(u, n, function () {\n      return this;\n    }), _regeneratorDefine(u, \"toString\", function () {\n      return \"[object Generator]\";\n    }), (_regenerator = function () {\n      return {\n        w: i,\n        m: f\n      };\n    })();\n  }\n  function _regeneratorDefine(e, r, n, t) {\n    var i = Object.defineProperty;\n    try {\n      i({}, \"\", {});\n    } catch (e) {\n      i = 0;\n    }\n    _regeneratorDefine = function (e, r, n, t) {\n      if (r) i ? i(e, r, {\n        value: n,\n        enumerable: !t,\n        configurable: !t,\n        writable: !t\n      }) : e[r] = n;else {\n        function o(r, n) {\n          _regeneratorDefine(e, r, function (e) {\n            return this._invoke(r, n, e);\n          });\n        }\n        o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2);\n      }\n    }, _regeneratorDefine(e, r, n, t);\n  }\n  function _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n  }\n  function _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r);\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  } /******************************************************************************\n    Copyright (c) Microsoft Corporation.\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\n  function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n      return value instanceof P ? value : new P(function (resolve) {\n        resolve(value);\n      });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n  typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n  };\n  var noop$1 = function noop() {};\n  function delay(callback, interval) {\n    return new Promise(function (resolve) {\n      return setTimeout(function () {\n        return resolve(callback());\n      }, interval);\n    });\n  }\n  function retry(_x) {\n    return _retry.apply(this, arguments);\n  } // 使用静态缓冲区，避免重复创建\n  function _retry() {\n    _retry = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(fn) {\n      var intervals,\n        times,\n        _args4 = arguments,\n        _t5;\n      return _regenerator().w(function (_context4) {\n        while (1) switch (_context4.p = _context4.n) {\n          case 0:\n            intervals = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : [];\n            times = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : 0;\n            _context4.p = 1;\n            return _context4.a(2, fn());\n          case 2:\n            _context4.p = 2;\n            _t5 = _context4.v;\n            if (!(times >= intervals.length)) {\n              _context4.n = 3;\n              break;\n            }\n            throw _t5;\n          case 3:\n            return _context4.a(2, delay(function () {\n              return retry(fn, intervals, ++times);\n            }, intervals[times]));\n        }\n      }, _callee4, null, [[1, 2]]);\n    }));\n    return _retry.apply(this, arguments);\n  }\n  var BUFFER_SIZE = 4096; // 更大的缓冲区，减少字符串拼接次数\n  var STATIC_BUFFER = new Uint16Array(BUFFER_SIZE); // 预分配ASCII缓冲区\n  /**\n   * 优化的 UTF-8 解码函数\n   * 主要优化点：\n   * 1. 使用静态缓冲区减少内存分配\n   * 2. 批量处理 ASCII 字符\n   * 3. 优化循环结构和条件判断\n   * 4. 使用 Uint16Array 代替普通数组提高性能\n   */\n  function utf8(buffer, start, end) {\n    // 边界检查\n    if (start < 0 || end > buffer.length) throw new RangeError(\"Index out of range\");\n    if (end - start < 1) return \"\";\n    var resultParts = [];\n    var bufferPos = 0;\n    var appendBuffer = function appendBuffer(parts) {\n      resultParts.push(String.fromCharCode.apply(null, Array.from(parts)));\n    };\n    // 快速路径：检查是否全是 ASCII\n    var allAscii = true;\n    for (var i = start; i < end; i++) {\n      if (buffer[i] > 0x7F) {\n        allAscii = false;\n        break;\n      }\n    }\n    // 全 ASCII 优化路径\n    if (allAscii) {\n      for (var _i = start; _i < end; _i += BUFFER_SIZE) {\n        var chunkEnd = Math.min(_i + BUFFER_SIZE, end);\n        var len = chunkEnd - _i;\n        // 直接复制到 Uint16Array\n        for (var j = 0; j < len; j++) {\n          STATIC_BUFFER[j] = buffer[_i + j];\n        }\n        appendBuffer(STATIC_BUFFER.subarray(0, len));\n      }\n      return resultParts.join('');\n    }\n    // 混合内容处理\n    for (var _i2 = start; _i2 < end;) {\n      var byte = buffer[_i2++];\n      // ASCII 字符处理\n      if (byte < 0x80) {\n        STATIC_BUFFER[bufferPos++] = byte;\n        // 如果缓冲区满了，提交并清空\n        if (bufferPos === BUFFER_SIZE) {\n          appendBuffer(STATIC_BUFFER);\n          bufferPos = 0;\n        }\n        continue;\n      }\n      // 提交之前的 ASCII 字符\n      if (bufferPos > 0) {\n        appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n        bufferPos = 0;\n      }\n      // 变长编码处理 - 使用查表法代替多个条件判断\n      var codePoint = void 0;\n      // 2 字节序列: 110xxxxx 10xxxxxx\n      if ((byte & 0xE0) === 0xC0 && _i2 < end) {\n        codePoint = (byte & 0x1F) << 6 | buffer[_i2++] & 0x3F;\n      }\n      // 3 字节序列: 1110xxxx 10xxxxxx 10xxxxxx\n      else if ((byte & 0xF0) === 0xE0 && _i2 + 1 < end) {\n        codePoint = (byte & 0x0F) << 12 | (buffer[_i2++] & 0x3F) << 6 | buffer[_i2++] & 0x3F;\n      }\n      // 4 字节序列: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      else if ((byte & 0xF8) === 0xF0 && _i2 + 2 < end) {\n        codePoint = (byte & 0x07) << 18 | (buffer[_i2++] & 0x3F) << 12 | (buffer[_i2++] & 0x3F) << 6 | buffer[_i2++] & 0x3F;\n        // 处理 Unicode 代理对\n        if (codePoint > 0xFFFF) {\n          codePoint -= 0x10000;\n          STATIC_BUFFER[bufferPos++] = 0xD800 + (codePoint >> 10);\n          STATIC_BUFFER[bufferPos++] = 0xDC00 + (codePoint & 0x3FF);\n          // 检查缓冲区是否需要提交\n          if (bufferPos >= BUFFER_SIZE - 2) {\n            // 预留空间给下一个可能的代理对\n            appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n            bufferPos = 0;\n          }\n          continue;\n        }\n      }\n      // 无效的 UTF-8 序列\n      else {\n        codePoint = 0xFFFD; // Unicode 替换字符\n        // 跳过可能的后续字节\n        while (_i2 < end && (buffer[_i2] & 0xC0) === 0x80) _i2++;\n      }\n      STATIC_BUFFER[bufferPos++] = codePoint;\n      // 检查缓冲区是否需要提交\n      if (bufferPos >= BUFFER_SIZE - 3) {\n        // 预留空间给下一个可能的多字节字符\n        appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n        bufferPos = 0;\n      }\n    }\n    // 提交剩余字符\n    if (bufferPos > 0) {\n      appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n    }\n    return resultParts.join('');\n  }\n  var OctopusPlatform = /*#__PURE__*/function () {\n    function OctopusPlatform(plugins, version) {\n      _classCallCheck(this, OctopusPlatform);\n      /**\n       * 插件列表\n       */\n      _defineProperty(this, \"plugins\", []);\n      /**\n       * 平台版本\n       */\n      _defineProperty(this, \"platformVersion\", \"0.1.3\");\n      /**\n       * 应用版本\n       */\n      _defineProperty(this, \"version\", \"\");\n      /**\n       * 全局变量\n       */\n      _defineProperty(this, \"globals\", {\n        env: \"unknown\",\n        br: null,\n        dpr: 1,\n        system: \"\"\n      });\n      _defineProperty(this, \"noop\", noop$1);\n      _defineProperty(this, \"retry\", retry);\n      this.version = version || \"\";\n      this.plugins = plugins;\n      this.globals.env = this.autoEnv();\n    }\n    return _createClass(OctopusPlatform, [{\n      key: \"init\",\n      value: function init() {\n        var globals = this.globals,\n          plugins = this.plugins;\n        var collection = new Map();\n        var names = [];\n        var installedPlugins = new Set();\n        globals.br = this.useBridge();\n        globals.dpr = this.usePixelRatio();\n        globals.system = this.useSystem();\n        var _iterator = _createForOfIteratorHelper(plugins),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var plugin = _step.value;\n            names.push(plugin.name);\n            collection.set(plugin.name, plugin);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.usePlugins(collection, names, installedPlugins);\n        installedPlugins.clear();\n      }\n    }, {\n      key: \"autoEnv\",\n      value: function autoEnv() {\n        if (typeof window !== \"undefined\") {\n          return \"h5\";\n        }\n        // FIXME：由于抖音场景支持wx对象，所以需要放在wx对象之前检查\n        if (typeof tt !== \"undefined\") {\n          return \"tt\";\n        }\n        if (typeof my !== \"undefined\") {\n          return \"alipay\";\n        }\n        if (typeof wx !== \"undefined\") {\n          return \"weapp\";\n        }\n        if (typeof has !== \"undefined\") {\n          return \"harmony\";\n        }\n        throw new Error(\"Unsupported platform！\");\n      }\n    }, {\n      key: \"useBridge\",\n      value: function useBridge() {\n        switch (this.globals.env) {\n          case \"alipay\":\n            return my;\n          case \"tt\":\n            return tt;\n          case \"weapp\":\n            return wx;\n        }\n        return globalThis;\n      }\n    }, {\n      key: \"usePixelRatio\",\n      value: function usePixelRatio() {\n        var _this$globals = this.globals,\n          env = _this$globals.env,\n          br = _this$globals.br;\n        if (env === \"h5\") {\n          return devicePixelRatio;\n        }\n        if (\"getWindowInfo\" in br) {\n          return br.getWindowInfo().pixelRatio;\n        }\n        if (\"getSystemInfoSync\" in br) {\n          return br.getSystemInfoSync().pixelRatio;\n        }\n        return 1;\n      }\n    }, {\n      key: \"useSystem\",\n      value: function useSystem() {\n        var env = this.globals.env;\n        var system;\n        switch (env) {\n          case \"weapp\":\n            // 暂不支持api has.getDeviceInfo TODO\n            system = has.getDeviceInfo().platform;\n            break;\n          case \"alipay\":\n            system = my.getDeviceBaseInfo().platform;\n            break;\n          case \"tt\":\n            system = has.getDeviceInfoSync().platform;\n            break;\n          case \"harmony\":\n            system = has.getSystemInfoSync().platform;\n            break;\n          case \"h5\":\n            if (\"userAgentData\" in navigator) {\n              // @ts-ignore\n              system = navigator.userAgentData.platform;\n            } else {\n              var UA = navigator.userAgent;\n              if (/(Android|Adr)/i.test(UA)) {\n                system = \"android\";\n              } else if (/\\(i[^;]+;( U;)? CPU.+Mac OS X/i.test(UA)) {\n                system = \"ios\";\n              } else if (/HarmonyOS/i.test(UA)) {\n                system = \"harmony\";\n              } else {\n                system = \"unknown\";\n              }\n            }\n            break;\n          default:\n            system = \"unknown\";\n        }\n        return system.toLowerCase();\n      }\n    }, {\n      key: \"usePlugins\",\n      value: function usePlugins(plugins, pluginNames, installedPlugins) {\n        var _iterator2 = _createForOfIteratorHelper(pluginNames),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var pluginName = _step2.value;\n            if (!plugins.has(pluginName)) {\n              throw new Error(\"Plugin \".concat(pluginName, \" not found\"));\n            }\n            if (installedPlugins.has(pluginName)) {\n              return;\n            }\n            var plugin = plugins.get(pluginName);\n            // 递归调用依赖\n            if (Array.isArray(plugin.dependencies)) {\n              var _iterator3 = _createForOfIteratorHelper(plugin.dependencies),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _plugins$get;\n                  var dependency = _step3.value;\n                  if (typeof ((_plugins$get = plugins.get(dependency)) === null || _plugins$get === void 0 ? void 0 : _plugins$get.install) !== \"function\") {\n                    throw new Error(\"Plugin \".concat(pluginName, \" depends on plugin \").concat(dependency, \", but \").concat(dependency, \" is not found\"));\n                  }\n                }\n                // 递归加载依赖\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              this.usePlugins(plugins, plugin.dependencies, installedPlugins);\n            }\n            this.installPlugin(plugin);\n            installedPlugins.add(pluginName);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }, {\n      key: \"switch\",\n      value: function _switch(env) {\n        this.globals.env = env;\n        this.init();\n      }\n    }]);\n  }();\n  /**\n   * 定义平台插件\n   */\n  var definePlugin = function definePlugin(plugin) {\n    return plugin;\n  };\n  function installPlugin(platform, plugin) {\n    var value = plugin.install.call(platform);\n    Object.defineProperty(platform, plugin.name, {\n      get: function get() {\n        return value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n  }\n  var pluginSelector = definePlugin({\n    name: \"getSelector\",\n    install: function install() {\n      var _this$globals2 = this.globals,\n        env = _this$globals2.env,\n        br = _this$globals2.br;\n      if (env === \"h5\") {\n        return function (selector) {\n          return document.querySelector(selector);\n        };\n      }\n      return function (selector, component) {\n        return (component || br).createSelectorQuery().select(selector).fields({\n          node: true,\n          size: true\n        });\n      };\n    }\n  });\n\n  /**\n   * 通过选择器匹配获取canvas实例\n   * @returns\n   */\n  var pluginCanvas = definePlugin({\n    name: \"getCanvas\",\n    dependencies: [\"getSelector\"],\n    install: function install() {\n      var retry = this.retry,\n        getSelector = this.getSelector;\n      var _this$globals3 = this.globals,\n        env = _this$globals3.env;\n      _this$globals3.br;\n      var dpr = _this$globals3.dpr;\n      var intervals = [50, 100, 100];\n      function initCanvas(canvas, width, height) {\n        if (!canvas) {\n          throw new Error(\"canvas not found.\");\n        }\n        // const MAX_SIZE = 1365;\n        var context = canvas.getContext(\"2d\");\n        // let virtualWidth = width * dpr;\n        // let virtualHeight = height * dpr;\n        // // 微信小程序限制canvas最大尺寸为 1365 * 1365\n        // if (\n        //   env === \"weapp\" &&\n        //   (virtualWidth > MAX_SIZE || virtualHeight > MAX_SIZE)\n        // ) {\n        //   if (virtualWidth > virtualHeight) {\n        //     virtualHeight = (virtualHeight / virtualWidth) * MAX_SIZE;\n        //     virtualWidth = MAX_SIZE;\n        //   } else {\n        //     virtualWidth = (virtualWidth / virtualHeight) * MAX_SIZE;\n        //     virtualHeight = MAX_SIZE;\n        //   }\n        // }\n        // canvas!.width = virtualWidth;\n        // canvas!.height = virtualHeight;\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n        return {\n          canvas: canvas,\n          context: context\n        };\n      }\n      if (env === \"h5\") {\n        return function (selector) {\n          return retry(function () {\n            // FIXME: Taro 对 canvas 做了特殊处理，canvas 元素的 id 会被加上 canvas-id 的前缀\n            var canvas = getSelector(\"canvas[canvas-id=\".concat(selector.slice(1), \"]\")) || getSelector(selector);\n            return initCanvas(canvas, canvas === null || canvas === void 0 ? void 0 : canvas.clientWidth, canvas === null || canvas === void 0 ? void 0 : canvas.clientHeight);\n          }, intervals);\n        };\n      }\n      return function (selector, component) {\n        return retry(function () {\n          return new Promise(function (resolve, reject) {\n            var query = getSelector(selector, component);\n            query.exec(function (res) {\n              var _ref = res[0] || {},\n                node = _ref.node,\n                width = _ref.width,\n                height = _ref.height;\n              try {\n                resolve(initCanvas(node, width, height));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          });\n        }, intervals);\n      };\n    }\n  });\n\n  /**\n   * 用于处理数据解码\n   * @returns\n   */\n  var pluginDecode = definePlugin({\n    name: \"decode\",\n    install: function install() {\n      var _this$globals4 = this.globals,\n        env = _this$globals4.env,\n        br = _this$globals4.br;\n      var b64Wrap = function b64Wrap(b64) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"image/png\";\n        return \"data:\".concat(type, \";base64,\").concat(b64);\n      };\n      var decode = {\n        toBuffer: function toBuffer(data) {\n          var buffer = data.buffer,\n            byteOffset = data.byteOffset,\n            byteLength = data.byteLength;\n          if (buffer instanceof ArrayBuffer) {\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n          }\n          var view = new Uint8Array(byteLength);\n          view.set(data);\n          return view.buffer;\n        },\n        bytesToString: function bytesToString(data) {\n          var chunkSize = 8192; // 安全的块大小\n          var result = \"\";\n          for (var i = 0; i < data.length; i += chunkSize) {\n            var chunk = data.slice(i, i + chunkSize);\n            // 在安全的块上使用 String.fromCharCode\n            result += String.fromCharCode.apply(null, Array.from(chunk));\n          }\n          return result;\n        }\n      };\n      if (env === \"h5\") {\n        var textDecoder = new TextDecoder(\"utf-8\", {\n          fatal: true\n        });\n        return _objectSpread2(_objectSpread2({}, decode), {}, {\n          toDataURL: function toDataURL(data) {\n            return b64Wrap(btoa(decode.bytesToString(data)));\n          },\n          utf8: function utf8(data, start, end) {\n            return textDecoder.decode(data.subarray(start, end));\n          }\n        });\n      }\n      return _objectSpread2(_objectSpread2({}, decode), {}, {\n        toDataURL: function toDataURL(data) {\n          return b64Wrap(br.arrayBufferToBase64(decode.toBuffer(data)));\n        },\n        utf8: utf8\n      });\n    }\n  });\n\n  /**\n   * 用于处理远程文件读取\n   * @returns\n   */\n  var pluginDownload = definePlugin({\n    name: \"remote\",\n    install: function install() {\n      var _this$globals5 = this.globals,\n        env = _this$globals5.env,\n        br = _this$globals5.br;\n      var isRemote = function isRemote(url) {\n        return /^(blob:)?http(s)?:\\/\\//.test(url);\n      };\n      if (env === \"h5\") {\n        return {\n          is: isRemote,\n          fetch: function (_fetch) {\n            function fetch(_x2) {\n              return _fetch.apply(this, arguments);\n            }\n            fetch.toString = function () {\n              return _fetch.toString();\n            };\n            return fetch;\n          }(function (url) {\n            return fetch(url).then(function (response) {\n              if (response.ok) {\n                return response.arrayBuffer();\n              }\n              throw new Error(\"HTTP error, status=\".concat(response.status, \", statusText=\").concat(response.statusText));\n            });\n          })\n        };\n      }\n      function download(url, enableCache) {\n        return new Promise(function (resolve, reject) {\n          br.request({\n            url: url,\n            // @ts-ignore 支付宝小程序必须有该字段\n            dataType: \"arraybuffer\",\n            responseType: \"arraybuffer\",\n            enableCache: enableCache,\n            success: function success(res) {\n              return resolve(res.data);\n            },\n            fail: reject\n          });\n        }).catch(function (err) {\n          var errorMessage = err.errMsg || err.errorMessage || err.message;\n          // FIXME: 可能存在写入网络缓存空间失败的情况，此时重新下载\n          if (errorMessage.includes(\"ERR_CACHE_WRITE_FAILURE\") || errorMessage.includes(\"ERR_CACHE_WRITE_FAILED\")) {\n            return download(url, false);\n          }\n          throw err;\n        });\n      }\n      return {\n        is: isRemote,\n        fetch: function fetch(url) {\n          return download(url, true);\n        }\n      };\n    }\n  });\n\n  /**\n   * 用于处理本地文件存储\n   * @returns\n   */\n  var pluginFsm = definePlugin({\n    name: \"local\",\n    install: function install() {\n      var _this$globals6 = this.globals,\n        env = _this$globals6.env,\n        br = _this$globals6.br;\n      if (env === \"h5\" || env === \"tt\") {\n        return null;\n      }\n      var fsm = br.getFileSystemManager();\n      return {\n        exists: function exists(filepath) {\n          return new Promise(function (resolve) {\n            fsm.access({\n              path: filepath,\n              success: function success() {\n                return resolve(true);\n              },\n              fail: function fail() {\n                return resolve(false);\n              }\n            });\n          });\n        },\n        write: function write(data, filePath) {\n          return new Promise(function (resolve, reject) {\n            fsm.writeFile({\n              filePath: filePath,\n              data: data,\n              success: function success() {\n                return resolve(filePath);\n              },\n              fail: reject\n            });\n          });\n        },\n        read: function read(filePath) {\n          return new Promise(function (resolve, reject) {\n            fsm.readFile({\n              filePath: filePath,\n              success: function success(res) {\n                return resolve(res.data);\n              },\n              fail: reject\n            });\n          });\n        },\n        remove: function remove(filePath) {\n          return new Promise(function (resolve, reject) {\n            fsm.unlink({\n              filePath: filePath,\n              success: function success() {\n                return resolve(filePath);\n              },\n              fail: reject\n            });\n          });\n        }\n      };\n    }\n  });\n\n  /**\n   * 图片加载插件\n   * @package plugin-fsm 本地文件存储能力\n   * @package plugin-path 路径处理能力\n   * @package plugin-decode 解码能力\n   */\n  var pluginImage = definePlugin({\n    name: \"image\",\n    dependencies: [\"local\", \"decode\"],\n    install: function install() {\n      var local = this.local,\n        decode = this.decode;\n      var env = this.globals.env;\n      var printError = function printError(msg) {\n        return console.error(\"image error: \".concat(msg));\n      };\n      var genImageSource = function genImageSource(data, _filepath) {\n        return typeof data === \"string\" ? data : decode.toDataURL(data);\n      };\n      /**\n       * 加载图片\n       * @param img\n       * @param url\n       * @returns\n       */\n      function loadImage(img, url) {\n        return new Promise(function (resolve, reject) {\n          img.onload = function () {\n            return resolve(img);\n          };\n          img.onerror = function () {\n            return reject(new Error(\"SVGA LOADING FAILURE: \".concat(url)));\n          };\n          img.crossOrigin = \"anonymous\";\n          img.src = url;\n        });\n      }\n      function releaseImage(img) {\n        img.onload = null;\n        img.onerror = null;\n        img.src = \"\";\n      }\n      if (env === \"h5\") {\n        return {\n          create: function create(_) {\n            return new Image();\n          },\n          load: function () {\n            var _load = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(createImage, data, filepath) {\n              var _t;\n              return _regenerator().w(function (_context) {\n                while (1) switch (_context.p = _context.n) {\n                  case 0:\n                    if (!(data instanceof Uint8Array && \"createImageBitmap\" in globalThis)) {\n                      _context.n = 4;\n                      break;\n                    }\n                    _context.p = 1;\n                    _context.n = 2;\n                    return createImageBitmap(new Blob([decode.toBuffer(data)]));\n                  case 2:\n                    data = _context.v;\n                    _context.n = 4;\n                    break;\n                  case 3:\n                    _context.p = 3;\n                    _t = _context.v;\n                    printError(_t.message);\n                  case 4:\n                    if (!(data instanceof ImageBitmap)) {\n                      _context.n = 5;\n                      break;\n                    }\n                    return _context.a(2, data);\n                  case 5:\n                    return _context.a(2, loadImage(createImage(), genImageSource(data, filepath)));\n                }\n              }, _callee, null, [[1, 3]]);\n            }));\n            function load(_x3, _x4, _x5) {\n              return _load.apply(this, arguments);\n            }\n            return load;\n          }(),\n          release: releaseImage\n        };\n      }\n      // FIXME: 支付宝小程序IDE保存临时文件会失败;抖音最大用户文件大小为10M\n      if (env === \"weapp\") {\n        genImageSource = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(data, filepath) {\n            return _regenerator().w(function (_context2) {\n              while (1) switch (_context2.n) {\n                case 0:\n                  if (!(typeof data === \"string\")) {\n                    _context2.n = 1;\n                    break;\n                  }\n                  return _context2.a(2, data);\n                case 1:\n                  return _context2.a(2, local.write(decode.toBuffer(data), filepath).catch(function (ex) {\n                    printError(ex.errorMessage || ex.errMsg || ex.message);\n                    return decode.toDataURL(data);\n                  }));\n              }\n            }, _callee2);\n          }));\n          return function genImageSource(_x6, _x7) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      }\n      return {\n        create: function create(canvas) {\n          return canvas.createImage();\n        },\n        load: function () {\n          var _load2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(createImage, data, filepath) {\n            var _t2, _t3, _t4;\n            return _regenerator().w(function (_context3) {\n              while (1) switch (_context3.n) {\n                case 0:\n                  _t2 = loadImage;\n                  _t3 = createImage();\n                  _context3.n = 1;\n                  return genImageSource(data, filepath);\n                case 1:\n                  _t4 = _context3.v;\n                  return _context3.a(2, _t2(_t3, _t4));\n              }\n            }, _callee3);\n          }));\n          function load(_x8, _x9, _x0) {\n            return _load2.apply(this, arguments);\n          }\n          return load;\n        }(),\n        release: releaseImage\n      };\n    }\n  });\n  var pluginNow = definePlugin({\n    name: \"now\",\n    install: function install() {\n      var _this$globals7 = this.globals,\n        env = _this$globals7.env,\n        br = _this$globals7.br;\n      // performance可以提供更高精度的时间测量，且不受系统时间的调整（如更改系统时间或同步时间）的影响\n      var perf = env === \"h5\" || env === \"tt\" ? performance : br.getPerformance();\n      if (typeof (perf === null || perf === void 0 ? void 0 : perf.now) === \"function\") {\n        // 支付宝小程序的performance.now()获取的是当前时间戳，单位是微秒。\n        if (perf.now() - Date.now() > 1) {\n          return function () {\n            return perf.now() / 1000;\n          };\n        }\n        // H5环境下，performance.now()获取的不是当前时间戳，而是从页面加载开始的时间戳，单位是毫秒。\n        return function () {\n          return perf.now();\n        };\n      }\n      return function () {\n        return Date.now();\n      };\n    }\n  });\n\n  /**\n   * 用于创建离屏canvas\n   * @returns\n   */\n  var pluginOfsCanvas = definePlugin({\n    name: \"getOfsCanvas\",\n    install: function install() {\n      var env = this.globals.env;\n      var createOffscreenCanvas;\n      if (env === \"h5\") {\n        createOffscreenCanvas = function createOffscreenCanvas(options) {\n          return new OffscreenCanvas(options.width, options.height);\n        };\n      } else if (env === \"alipay\") {\n        createOffscreenCanvas = function createOffscreenCanvas(options) {\n          return my.createOffscreenCanvas(options);\n        };\n      } else if (env === \"tt\") {\n        createOffscreenCanvas = function createOffscreenCanvas(options) {\n          // 暂不支持api has.createOffscreenCanvas TODO\n          var canvas = has.createOffscreenCanvas();\n          canvas.width = options.width;\n          canvas.height = options.height;\n          return canvas;\n        };\n      } else {\n        createOffscreenCanvas = function createOffscreenCanvas(options) {\n          return wx.createOffscreenCanvas(options);\n        };\n      }\n      return function (options) {\n        var type = options.type || \"2d\";\n        var canvas = createOffscreenCanvas(_objectSpread2(_objectSpread2({}, options), {}, {\n          type: type\n        }));\n        var context = canvas.getContext(type);\n        return {\n          canvas: canvas,\n          context: context\n        };\n      };\n    }\n  });\n\n  /**\n   * 用于处理文件路径\n   * @returns\n   */\n  var pluginPath = definePlugin({\n    name: \"path\",\n    install: function install() {\n      var _this$globals8 = this.globals,\n        env = _this$globals8.env,\n        br = _this$globals8.br;\n      var filename = function filename(path) {\n        var filepath = path.split(/\\?#/g)[0];\n        return filepath.substring(filepath.lastIndexOf(\"/\") + 1);\n      };\n      if (env === \"h5\" || env === \"tt\") {\n        return {\n          USER_DATA_PATH: \"\",\n          is: function is(_) {\n            return false;\n          },\n          filename: filename,\n          resolve: function resolve(filename, prefix) {\n            return \"\";\n          }\n        };\n      }\n      var USER_DATA_PATH = br.env.USER_DATA_PATH;\n      return {\n        USER_DATA_PATH: USER_DATA_PATH,\n        is: function is(filepath) {\n          return filepath === null || filepath === void 0 ? void 0 : filepath.startsWith(USER_DATA_PATH);\n        },\n        filename: filename,\n        resolve: function resolve(filename, prefix) {\n          return \"\".concat(USER_DATA_PATH, \"/\").concat(prefix ? \"\".concat(prefix, \"__\") : \"\").concat(filename);\n        }\n      };\n    }\n  });\n\n  /**\n   * 用于处理requestAnimationFrame\n   * @returns\n   */\n  var pluginRaf = definePlugin({\n    name: \"rAF\",\n    install: function install() {\n      var env = this.globals.env;\n      function requestAnimationFrameImpl() {\n        return function (callback) {\n          return setTimeout(callback, Math.max(0, 16 - Date.now() % 16));\n        };\n      }\n      if (env === \"h5\") {\n        var rAF = \"requestAnimationFrame\" in globalThis ? requestAnimationFrame : requestAnimationFrameImpl();\n        return function (_, callback) {\n          return rAF(callback);\n        };\n      }\n      return function (canvas, callback) {\n        // 检查canvas是否存在\n        try {\n          return canvas.requestAnimationFrame(callback);\n        } catch (error) {\n          console.warn(error.message);\n          return requestAnimationFrameImpl()(callback);\n        }\n      };\n    }\n  });\n  var EnhancedPlatform = /*#__PURE__*/function (_OctopusPlatform) {\n    function EnhancedPlatform() {\n      var _this;\n      _classCallCheck(this, EnhancedPlatform);\n      _this = _callSuper(this, EnhancedPlatform, [[pluginSelector, pluginCanvas, pluginOfsCanvas, pluginDecode, pluginDownload, pluginFsm, pluginImage, pluginNow, pluginPath, pluginRaf], \"1.3.0\"]);\n      _this.init();\n      return _this;\n    }\n    _inherits(EnhancedPlatform, _OctopusPlatform);\n    return _createClass(EnhancedPlatform, [{\n      key: \"installPlugin\",\n      value: function installPlugin$1(plugin) {\n        installPlugin(this, plugin);\n      }\n    }]);\n  }(OctopusPlatform);\n  var platform = new EnhancedPlatform();\n  var ResourceManager = /*#__PURE__*/function () {\n    function ResourceManager(painter) {\n      _classCallCheck(this, ResourceManager);\n      this.painter = painter;\n      // FIXME: 微信小程序创建调用太多createImage会导致微信/微信小程序崩溃\n      this.caches = [];\n      /**\n       * 动态素材\n       */\n      this.dynamicMaterials = new Map();\n      /**\n       * 素材\n       */\n      this.materials = new Map();\n      /**\n       * 已清理Image对象的坐标\n       */\n      this.point = 0;\n    }\n    /**\n     * 创建图片标签\n     * @returns\n     */\n    return _createClass(ResourceManager, [{\n      key: \"createImage\",\n      value: function createImage() {\n        var img = null;\n        if (this.point > 0) {\n          this.point--;\n          img = this.caches.shift();\n        }\n        if (!img) {\n          img = platform.image.create(this.painter.F);\n        }\n        this.caches.push(img);\n        return img;\n      }\n      /**\n       * 将 ImageBitmap 插入到 caches\n       * @param img\n       */\n    }, {\n      key: \"inertBitmapIntoCaches\",\n      value: function inertBitmapIntoCaches(img) {\n        if (ResourceManager.isBitmap(img)) {\n          this.caches.push(img);\n        }\n      }\n      /**\n       * 加载额外的图片资源\n       * @param source 资源内容/地址\n       * @param filename 文件名称\n       * @returns\n       */\n    }, {\n      key: \"loadExtImage\",\n      value: function loadExtImage(source, filename) {\n        var _this = this;\n        return platform.image.load(function () {\n          return _this.createImage();\n        }, source, platform.path.resolve(filename, \"ext\")).then(function (img) {\n          _this.inertBitmapIntoCaches(img);\n          return img;\n        });\n      }\n      /**\n       * 加载图片集\n       * @param images 图片数据\n       * @param filename 文件名称\n       * @returns\n       */\n    }, {\n      key: \"loadImagesWithRecord\",\n      value: function loadImagesWithRecord(images_1, filename_1) {\n        return __awaiter(this, arguments, void 0, function (images, filename) {\n          var _this2 = this;\n          var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"normal\";\n          return /*#__PURE__*/_regenerator().m(function _callee() {\n            var imageAwaits, imageFilename;\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.n) {\n                case 0:\n                  imageAwaits = [];\n                  imageFilename = \"\".concat(filename.replace(/\\.svga$/g, \"\"), \".png\");\n                  Object.entries(images).forEach(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                      name = _ref2[0],\n                      image = _ref2[1];\n                    // 过滤 1px 透明图\n                    if (image instanceof Uint8Array && image.byteLength < 70) {\n                      return;\n                    }\n                    var p = platform.image.load(function () {\n                      return _this2.createImage();\n                    }, image, platform.path.resolve(imageFilename, type === \"dynamic\" ? \"dyn_\".concat(name) : name)).then(function (img) {\n                      _this2.inertBitmapIntoCaches(img);\n                      if (type === \"dynamic\") {\n                        _this2.dynamicMaterials.set(name, img);\n                      } else {\n                        _this2.materials.set(name, img);\n                      }\n                    });\n                    imageAwaits.push(p);\n                  });\n                  _context.n = 1;\n                  return Promise.all(imageAwaits);\n                case 1:\n                  return _context.a(2);\n              }\n            }, _callee);\n          })();\n        });\n      }\n      /**\n       * 释放图片资源\n       */\n    }, {\n      key: \"release\",\n      value: function release() {\n        // FIXME: 小程序 image 对象需要手动释放内存，否则可能导致小程序崩溃\n        var _iterator = _createForOfIteratorHelper(this.caches),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var img = _step.value;\n            ResourceManager.releaseOne(img);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this.materials.clear();\n        this.dynamicMaterials.clear();\n        // FIXME: 支付宝小程序 image 修改 src 无法触发 onload 事件\n        platform.globals.env === \"alipay\" ? this.cleanup() : this.tidyUp();\n      }\n      /**\n       * 整理图片资源，将重复的图片资源移除\n       */\n    }, {\n      key: \"tidyUp\",\n      value: function tidyUp() {\n        // 通过 Set 的去重特性，保持 caches 元素的唯一性\n        this.caches = Array.from(new Set(this.caches));\n        this.point = this.caches.length;\n      }\n      /**\n       * 清理图片资源\n       */\n    }, {\n      key: \"cleanup\",\n      value: function cleanup() {\n        this.caches.length = 0;\n        this.point = 0;\n      }\n    }], [{\n      key: \"isBitmap\",\n      value:\n      /**\n       * 判断是否是 ImageBitmap\n       * @param img\n       * @returns\n       */\n      function isBitmap(img) {\n        return platform.globals.env === \"h5\" && img instanceof ImageBitmap;\n      }\n      /**\n       * 释放内存资源（图片）\n       * @param img\n       */\n    }, {\n      key: \"releaseOne\",\n      value: function releaseOne(img) {\n        if (ResourceManager.isBitmap(img)) {\n          img.close();\n        } else if (img.src !== \"\") {\n          // 将存在本地的文件删除，防止用户空间被占满\n          if (platform.path.is(img.src)) {\n            platform.local.remove(img.src);\n          }\n          platform.image.release(img);\n        }\n      }\n    }]);\n  }();\n  function readFloatLEImpl() {\n    // 使用静态DataView池\n    var DATA_VIEW_POOL_SIZE = 4;\n    var dataViewPool = Array(DATA_VIEW_POOL_SIZE).fill(0).map(function () {\n      return new DataView(new ArrayBuffer(8));\n    }); // 使用8字节支持double\n    var currentViewIndex = 0;\n    return function readFloatLE(buf, pos) {\n      if (pos < 0 || pos + 4 > buf.length) throw new RangeError(\"Index out of range\");\n      // 轮换使用DataView池中的实例\n      var view = dataViewPool[currentViewIndex];\n      currentViewIndex = (currentViewIndex + 1) % DATA_VIEW_POOL_SIZE;\n      // 直接设置字节，避免创建subarray\n      var u8 = new Uint8Array(view.buffer);\n      u8[0] = buf[pos];\n      u8[1] = buf[pos + 1];\n      u8[2] = buf[pos + 2];\n      u8[3] = buf[pos + 3];\n      return view.getFloat32(0, true);\n    };\n  }\n  var readFloatLE = readFloatLEImpl(); /**\n                                       * 简易的hash算法\n                                       * @param buff\n                                       * @param start\n                                       * @param end\n                                       * @param step\n                                       * @returns\n                                       */\n  function calculateHash(buff, start, end, step) {\n    // 使用简单的哈希算法\n    var hash = 0;\n    for (var i = start; i < end; i += step) {\n      // 简单的哈希算法，类似于字符串哈希\n      hash = (hash << 5) - hash + buff[i];\n      hash = hash & hash; // 转换为32位整数\n    }\n    // 添加数据长度作为哈希的一部分，增加唯一性\n    hash = (hash << 5) - hash + end - start;\n    hash = hash & hash;\n    // 转换为字符串\n    return hash.toString(36);\n  }\n  var Preflight = /*#__PURE__*/function () {\n    function Preflight() {\n      _classCallCheck(this, Preflight);\n      this.caches = new Map();\n      this.count = 0;\n    }\n    return _createClass(Preflight, [{\n      key: \"size\",\n      get: function get() {\n        return this.caches.size;\n      }\n    }, {\n      key: \"hitCount\",\n      get: function get() {\n        return this.count;\n      }\n      // get cache() {\n      //   return Object.fromEntries(this.caches);\n      // }\n      /**\n       * 计算二进制数据的哈希值\n       * @param reader Reader对象\n       * @param end 结束位置\n       * @returns 哈希值\n       */\n    }, {\n      key: \"calculate\",\n      value: function calculate(reader, end) {\n        // 保存原始位置\n        var startPos = reader.pos,\n          buf = reader.buf;\n        var endPos = Math.min(end, reader.len);\n        // 采样数据以加快计算速度，同时保持足够的唯一性\n        // 对于大数据，每隔几个字节采样一次\n        var step = Math.max(1, Math.floor((endPos - startPos) / 100));\n        return calculateHash(buf, startPos, endPos, step);\n      }\n      /**\n       * 检查是否存在缓存数据\n       * @param key 键\n       * @returns 是否存在\n       */\n    }, {\n      key: \"has\",\n      value: function has(key) {\n        var hit = this.caches.has(key);\n        if (hit) {\n          this.count++;\n        }\n        return hit;\n        // return this.caches.has(key);\n      }\n      /**\n       * 获取缓存数据\n       * @param key 键\n       * @returns 缓存数据\n       */\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        return this.caches.get(key);\n      }\n      /**\n       * 设置缓存数据\n       * @param key 键\n       * @param value 缓存数据\n       */\n    }, {\n      key: \"set\",\n      value: function set(key, value) {\n        this.caches.set(key, value);\n      }\n      /**\n       * 清空所有缓存数据\n       */\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.count = 0;\n        this.caches.clear();\n      }\n    }]);\n  }();\n  var Reader = /*#__PURE__*/function () {\n    /**\n     * Constructs a new reader instance using the specified buffer.\n     * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n     * @constructor\n     * @param {Uint8Array} buffer Buffer to read from\n     */\n    function Reader(buffer) {\n      _classCallCheck(this, Reader);\n      this.preflight = new Preflight();\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    return _createClass(Reader, [{\n      key: \"indexOutOfRange\",\n      value: function indexOutOfRange(reader, writeLength) {\n        return new RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n      }\n      /**\n       * 将复杂逻辑分离到单独方法\n       * @returns\n       */\n    }, {\n      key: \"readVarint32Slow\",\n      value: function readVarint32Slow() {\n        var byte = this.buf[this.pos++];\n        var value = byte & 0x7f;\n        var shift = 7;\n        // 使用do-while循环减少条件判断\n        do {\n          if (this.pos >= this.len) {\n            throw this.indexOutOfRange(this);\n          }\n          byte = this.buf[this.pos++];\n          value |= (byte & 0x7f) << shift;\n          shift += 7;\n        } while (byte >= 128 && shift < 32);\n        return value >>> 0; // 确保无符号\n      }\n      /**\n       * Reads a sequence of bytes preceded by its length as a varint.\n       * @param length\n       * @returns\n       */\n    }, {\n      key: \"end\",\n      value: function end(length) {\n        return length === undefined ? this.len : this.pos + length;\n      }\n      /**\n       * Reads a varint as an unsigned 32 bit value.\n       * @function\n       * @returns {number} Value read\n       */\n    }, {\n      key: \"uint32\",\n      value: function uint32() {\n        // 快速路径：大多数情况下是单字节\n        var byte = this.buf[this.pos];\n        if (byte < 128) {\n          this.pos++;\n          return byte;\n        }\n        // 慢速路径：多字节处理\n        return this.readVarint32Slow();\n      }\n      /**\n       * Reads a varint as a signed 32 bit value.\n       * @returns {number} Value read\n       */\n    }, {\n      key: \"int32\",\n      value: function int32() {\n        return this.uint32() | 0;\n      }\n      /**\n       * Reads a float (32 bit) as a number.\n       * @function\n       * @returns {number} Value read\n       */\n    }, {\n      key: \"float\",\n      value: function float() {\n        var pos = this.pos + 4;\n        if (pos > this.len) {\n          throw this.indexOutOfRange(this, 4);\n        }\n        var value = readFloatLE(this.buf, this.pos);\n        this.pos = pos;\n        return value;\n      }\n      /**\n       * read bytes range\n       * @returns\n       */\n    }, {\n      key: \"getBytesRange\",\n      value: function getBytesRange() {\n        var length = this.uint32();\n        var start = this.pos;\n        var end = start + length;\n        if (end > this.len) {\n          throw this.indexOutOfRange(this, length);\n        }\n        return [start, end, length];\n      }\n      /**\n       * Reads a sequence of bytes preceded by its length as a varint.\n       * @returns {Uint8Array} Value read\n       */\n    }, {\n      key: \"bytes\",\n      value: function bytes() {\n        var _this$getBytesRange = this.getBytesRange(),\n          _this$getBytesRange2 = _slicedToArray(_this$getBytesRange, 3),\n          start = _this$getBytesRange2[0],\n          end = _this$getBytesRange2[1],\n          length = _this$getBytesRange2[2];\n        this.pos += length;\n        if (length === 0) {\n          return Reader.EMPTY_UINT8ARRAY;\n        }\n        return this.buf.subarray(start, end);\n      }\n      /**\n       * Reads a string preceeded by its byte length as a varint.\n       * @returns {string} Value read\n       */\n    }, {\n      key: \"string\",\n      value: function string() {\n        var _this$getBytesRange3 = this.getBytesRange(),\n          _this$getBytesRange4 = _slicedToArray(_this$getBytesRange3, 2),\n          start = _this$getBytesRange4[0],\n          end = _this$getBytesRange4[1];\n        // 直接在原始buffer上解码，避免创建中间bytes对象\n        var result = platform.decode.utf8(this.buf, start, end);\n        this.pos = end;\n        return result;\n      }\n      /**\n       * Skips the specified number of bytes if specified, otherwise skips a varint.\n       * @param {number} [length] Length if known, otherwise a varint is assumed\n       * @returns {Reader} `this`\n       */\n    }, {\n      key: \"skip\",\n      value: function skip(length) {\n        if (typeof length === \"number\") {\n          if (this.pos + length > this.len) {\n            throw this.indexOutOfRange(this, length);\n          }\n          this.pos += length;\n          return this;\n        }\n        // 变长整数跳过优化 - 使用位运算\n        var buf = this.buf,\n          len = this.len;\n        var pos = this.pos;\n        // 一次检查多个字节，减少循环次数\n        while (pos < len) {\n          var byte = buf[pos++];\n          if ((byte & 0x80) === 0) {\n            this.pos = pos;\n            return this;\n          }\n          // 快速检查连续的高位字节\n          if (pos < len && (buf[pos] & 0x80) !== 0) {\n            pos++;\n            if (pos < len && (buf[pos] & 0x80) !== 0) {\n              pos++;\n              if (pos < len && (buf[pos] & 0x80) !== 0) {\n                pos++;\n                // 继续检查剩余字节\n                while (pos < len && (buf[pos] & 0x80) !== 0) {\n                  pos++;\n                  if (pos - this.pos >= 10) {\n                    throw Error(\"invalid varint encoding\");\n                  }\n                }\n                if (pos < len) {\n                  this.pos = pos + 1;\n                  return this;\n                }\n              }\n            }\n          }\n        }\n        throw this.indexOutOfRange(this);\n      }\n      /**\n       * Skips the next element of the specified wire type.\n       * @param {number} wireType Wire type received\n       * @returns {Reader} `this`\n       */\n    }, {\n      key: \"skipType\",\n      value: function skipType(wireType) {\n        switch (wireType) {\n          case 0:\n            this.skip();\n            break;\n          case 1:\n            this.skip(8);\n            break;\n          case 2:\n            this.skip(this.uint32());\n            break;\n          case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n              this.skipType(wireType);\n            }\n            break;\n          case 5:\n            this.skip(4);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n        }\n        return this;\n      }\n    }]);\n  }(); // 添加静态缓存，用于常用的空数组\n  Reader.EMPTY_UINT8ARRAY = new Uint8Array(0);\n  var Layout = /*#__PURE__*/function () {\n    function Layout() {\n      _classCallCheck(this, Layout);\n      /**\n       * Layout x.\n       * @member {number} x\n       * @memberof com.opensource.svga.Layout\n       * @instance\n       */\n      this.x = 0;\n      /**\n       * Layout y.\n       * @member {number} y\n       * @memberof com.opensource.svga.Layout\n       * @instance\n       */\n      this.y = 0;\n      /**\n       * Layout width.\n       * @member {number} width\n       * @memberof com.opensource.svga.Layout\n       * @instance\n       */\n      this.width = 0;\n      /**\n       * Layout height.\n       * @member {number} height\n       * @memberof com.opensource.svga.Layout\n       * @instance\n       */\n      this.height = 0;\n    }\n    /**\n     * Decodes a Layout message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.Layout\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.Layout} Layout\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(Layout, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new Layout();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.x = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.y = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.width = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.height = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, Layout.format(message));\n        return preflight.get(hash);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        var _message$x = message.x,\n          x = _message$x === void 0 ? 0 : _message$x,\n          _message$y = message.y,\n          y = _message$y === void 0 ? 0 : _message$y,\n          _message$width = message.width,\n          width = _message$width === void 0 ? 0 : _message$width,\n          _message$height = message.height,\n          height = _message$height === void 0 ? 0 : _message$height;\n        return {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      }\n    }]);\n  }();\n  var Transform = /*#__PURE__*/function () {\n    function Transform() {\n      _classCallCheck(this, Transform);\n      /**\n       * Transform a.\n       * @member {number} a\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.a = 0;\n      /**\n       * Transform b.\n       * @member {number} b\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.b = 0;\n      /**\n       * Transform c.\n       * @member {number} c\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.c = 0;\n      /**\n       * Transform d.\n       * @member {number} d\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.d = 0;\n      /**\n       * Transform tx.\n       * @member {number} tx\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.tx = 0;\n      /**\n       * Transform ty.\n       * @member {number} ty\n       * @memberof com.opensource.svga.Transform\n       * @instance\n       */\n      this.ty = 0;\n    }\n    /**\n     * Decodes a Transform message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.Transform\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.Transform} Transform\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(Transform, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new Transform();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.a = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.b = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.c = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.d = reader.float();\n                break;\n              }\n            case 5:\n              {\n                message.tx = reader.float();\n                break;\n              }\n            case 6:\n              {\n                message.ty = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      }\n    }]);\n  }();\n  var ShapeArgs = /*#__PURE__*/function () {\n    function ShapeArgs() {\n      _classCallCheck(this, ShapeArgs);\n      /**\n       * ShapeArgs d.\n       * @member {string} d\n       * @memberof com.opensource.svga.ShapeEntity.ShapeArgs\n       * @instance\n       */\n      this.d = \"\";\n    }\n    /**\n     * Decodes a ShapeArgs message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity.ShapeArgs\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity.ShapeArgs} ShapeArgs\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(ShapeArgs, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new ShapeArgs();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.d = reader.string();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, message);\n        return preflight.get(hash);\n      }\n    }]);\n  }();\n  var RectArgs = /*#__PURE__*/function () {\n    function RectArgs() {\n      _classCallCheck(this, RectArgs);\n      /**\n       * RectArgs x.\n       * @member {number} x\n       * @memberof com.opensource.svga.ShapeEntity.RectArgs\n       * @instance\n       */\n      this.x = 0;\n      /**\n       * RectArgs y.\n       * @member {number} y\n       * @memberof com.opensource.svga.ShapeEntity.RectArgs\n       * @instance\n       */\n      this.y = 0;\n      /**\n       * RectArgs width.\n       * @member {number} width\n       * @memberof com.opensource.svga.ShapeEntity.RectArgs\n       * @instance\n       */\n      this.width = 0;\n      /**\n       * RectArgs height.\n       * @member {number} height\n       * @memberof com.opensource.svga.ShapeEntity.RectArgs\n       * @instance\n       */\n      this.height = 0;\n      /**\n       * RectArgs cornerRadius.\n       * @member {number} cornerRadius\n       * @memberof com.opensource.svga.ShapeEntity.RectArgs\n       * @instance\n       */\n      this.cornerRadius = 0;\n    }\n    /**\n     * Decodes a RectArgs message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity.RectArgs\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity.RectArgs} RectArgs\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(RectArgs, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new RectArgs();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.x = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.y = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.width = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.height = reader.float();\n                break;\n              }\n            case 5:\n              {\n                message.cornerRadius = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, message);\n        return preflight.get(hash);\n      }\n    }]);\n  }();\n  var EllipseArgs = /*#__PURE__*/function () {\n    function EllipseArgs() {\n      _classCallCheck(this, EllipseArgs);\n      /**\n       * EllipseArgs x.\n       * @member {number} x\n       * @memberof com.opensource.svga.ShapeEntity.EllipseArgs\n       * @instance\n       */\n      this.x = 0;\n      /**\n       * EllipseArgs y.\n       * @member {number} y\n       * @memberof com.opensource.svga.ShapeEntity.EllipseArgs\n       * @instance\n       */\n      this.y = 0;\n      /**\n       * EllipseArgs radiusX.\n       * @member {number} radiusX\n       * @memberof com.opensource.svga.ShapeEntity.EllipseArgs\n       * @instance\n       */\n      this.radiusX = 0;\n      /**\n       * EllipseArgs radiusY.\n       * @member {number} radiusY\n       * @memberof com.opensource.svga.ShapeEntity.EllipseArgs\n       * @instance\n       */\n      this.radiusY = 0;\n    }\n    /**\n     * Decodes an EllipseArgs message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity.EllipseArgs\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity.EllipseArgs} EllipseArgs\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(EllipseArgs, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new EllipseArgs();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.x = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.y = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.radiusX = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.radiusY = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, message);\n        return preflight.get(hash);\n      }\n    }]);\n  }();\n  var RGBAColor = /*#__PURE__*/function () {\n    function RGBAColor() {\n      _classCallCheck(this, RGBAColor);\n      /**\n       * RGBAColor r.\n       * @member {number} r\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor\n       * @instance\n       */\n      this.r = 0;\n      /**\n       * RGBAColor g.\n       * @member {number} g\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor\n       * @instance\n       */\n      this.g = 0;\n      /**\n       * RGBAColor b.\n       * @member {number} b\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor\n       * @instance\n       */\n      this.b = 0;\n      /**\n       * RGBAColor a.\n       * @member {number} a\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor\n       * @instance\n       */\n      this.a = 0;\n    }\n    /**\n     * Decodes a RGBAColor message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor} RGBAColor\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(RGBAColor, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new RGBAColor();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.r = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.g = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.b = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.a = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, RGBAColor.format(message));\n        return preflight.get(hash);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        var r = message.r,\n          g = message.g,\n          b = message.b,\n          a = message.a;\n        return \"rgba(\".concat(r * 255 | 0, \", \").concat(g * 255 | 0, \", \").concat(b * 255 | 0, \", \").concat(a * 1 | 0, \")\");\n      }\n    }]);\n  }();\n  var ShapeStyle = /*#__PURE__*/function () {\n    function ShapeStyle() {\n      _classCallCheck(this, ShapeStyle);\n      /**\n       * ShapeStyle fill.\n       * @member {com.opensource.svga.ShapeEntity.ShapeStyle.IRGBAColor|null|undefined} fill\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.fill = null;\n      /**\n       * ShapeStyle stroke.\n       * @member {com.opensource.svga.ShapeEntity.ShapeStyle.IRGBAColor|null|undefined} stroke\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.stroke = null;\n      /**\n       * ShapeStyle strokeWidth.\n       * @member {number} strokeWidth\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.strokeWidth = 0;\n      /**\n       * ShapeStyle lineCap.\n       * @member {com.opensource.svga.ShapeEntity.ShapeStyle.LineCap} lineCap\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.lineCap = 0;\n      /**\n       * ShapeStyle lineJoin.\n       * @member {com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin} lineJoin\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.lineJoin = 0;\n      /**\n       * ShapeStyle miterLimit.\n       * @member {number} miterLimit\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.miterLimit = 0;\n      /**\n       * ShapeStyle lineDashI.\n       * @member {number} lineDashI\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.lineDashI = 0;\n      /**\n       * ShapeStyle lineDashII.\n       * @member {number} lineDashII\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.lineDashII = 0;\n      /**\n       * ShapeStyle lineDashIII.\n       * @member {number} lineDashIII\n       * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n       * @instance\n       */\n      this.lineDashIII = 0;\n    }\n    /**\n     * Decodes a ShapeStyle message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity.ShapeStyle\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity.ShapeStyle} ShapeStyle\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(ShapeStyle, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var preflight = reader.preflight;\n        var end = reader.end(length);\n        var hash = preflight.calculate(reader, end);\n        if (preflight.has(hash)) {\n          reader.pos = end;\n          return preflight.get(hash);\n        }\n        var message = new ShapeStyle();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.fill = RGBAColor.decode(reader, reader.uint32());\n                break;\n              }\n            case 2:\n              {\n                message.stroke = RGBAColor.decode(reader, reader.uint32());\n                break;\n              }\n            case 3:\n              {\n                message.strokeWidth = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.lineCap = reader.int32();\n                break;\n              }\n            case 5:\n              {\n                message.lineJoin = reader.int32();\n                break;\n              }\n            case 6:\n              {\n                message.miterLimit = reader.float();\n                break;\n              }\n            case 7:\n              {\n                message.lineDashI = reader.float();\n                break;\n              }\n            case 8:\n              {\n                message.lineDashII = reader.float();\n                break;\n              }\n            case 9:\n              {\n                message.lineDashIII = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        preflight.set(hash, ShapeStyle.format(message));\n        return preflight.get(hash);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        var fill = message.fill,\n          stroke = message.stroke,\n          strokeWidth = message.strokeWidth,\n          miterLimit = message.miterLimit,\n          lineDashI = message.lineDashI,\n          lineDashII = message.lineDashII,\n          lineDashIII = message.lineDashIII;\n        var lineDash = [];\n        var lineCap;\n        var lineJoin;\n        if (lineDashI > 0) {\n          lineDash.push(lineDashI);\n        }\n        if (lineDashII > 0) {\n          if (lineDash.length < 1) {\n            lineDash.push(0);\n          }\n          lineDash.push(lineDashII);\n        }\n        if (lineDashIII > 0) {\n          if (lineDash.length < 2) {\n            lineDash.push(0, 0);\n          }\n          lineDash.push(lineDashIII);\n        }\n        switch (message.lineCap) {\n          case 0 /* PlatformVideo.LINE_CAP_CODE.BUTT */:\n            lineCap = \"butt\" /* PlatformVideo.LINE_CAP.BUTT */;\n            break;\n          case 1 /* PlatformVideo.LINE_CAP_CODE.ROUND */:\n            lineCap = \"round\" /* PlatformVideo.LINE_CAP.ROUND */;\n            break;\n          case 2 /* PlatformVideo.LINE_CAP_CODE.SQUARE */:\n            lineCap = \"square\" /* PlatformVideo.LINE_CAP.SQUARE */;\n            break;\n        }\n        switch (message.lineJoin) {\n          case 0 /* PlatformVideo.LINE_JOIN_CODE.MITER */:\n            lineJoin = \"miter\" /* PlatformVideo.LINE_JOIN.MITER */;\n            break;\n          case 1 /* PlatformVideo.LINE_JOIN_CODE.ROUND */:\n            lineJoin = \"round\" /* PlatformVideo.LINE_JOIN.ROUND */;\n            break;\n          case 2 /* PlatformVideo.LINE_JOIN_CODE.BEVEL */:\n            lineJoin = \"bevel\" /* PlatformVideo.LINE_JOIN.BEVEL */;\n            break;\n        }\n        return {\n          lineDash: lineDash,\n          fill: fill ? fill : null,\n          stroke: stroke ? stroke : null,\n          lineCap: lineCap,\n          lineJoin: lineJoin,\n          strokeWidth: strokeWidth,\n          miterLimit: miterLimit\n        };\n      }\n    }]);\n  }();\n  var ShapeEntity = /*#__PURE__*/function () {\n    function ShapeEntity() {\n      _classCallCheck(this, ShapeEntity);\n      /**\n       * ShapeEntity type.\n       * @member {com.opensource.svga.ShapeEntity.ShapeType} type\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.type = 0;\n      /**\n       * ShapeEntity shape.\n       * @member {com.opensource.svga.ShapeEntity.IShapeArgs|null|undefined} shape\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.shape = null;\n      /**\n       * ShapeEntity rect.\n       * @member {com.opensource.svga.ShapeEntity.IRectArgs|null|undefined} rect\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.rect = null;\n      /**\n       * ShapeEntity ellipse.\n       * @member {com.opensource.svga.ShapeEntity.IEllipseArgs|null|undefined} ellipse\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.ellipse = null;\n      /**\n       * ShapeEntity styles.\n       * @member {com.opensource.svga.ShapeEntity.IShapeStyle|null|undefined} styles\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.styles = null;\n      /**\n       * ShapeEntity transform.\n       * @member {com.opensource.svga.ITransform|null|undefined} transform\n       * @memberof com.opensource.svga.ShapeEntity\n       * @instance\n       */\n      this.transform = null;\n    }\n    /**\n     * Decodes a ShapeEntity message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.ShapeEntity\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.ShapeEntity} ShapeEntity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(ShapeEntity, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new ShapeEntity();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.type = reader.int32();\n                break;\n              }\n            case 2:\n              {\n                message.shape = ShapeArgs.decode(reader, reader.uint32());\n                break;\n              }\n            case 3:\n              {\n                message.rect = RectArgs.decode(reader, reader.uint32());\n                break;\n              }\n            case 4:\n              {\n                message.ellipse = EllipseArgs.decode(reader, reader.uint32());\n                break;\n              }\n            case 10:\n              {\n                message.styles = ShapeStyle.decode(reader, reader.uint32());\n                break;\n              }\n            case 11:\n              {\n                message.transform = Transform.decode(reader, reader.uint32());\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return ShapeEntity.format(message);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        var type = message.type,\n          shape = message.shape,\n          rect = message.rect,\n          ellipse = message.ellipse,\n          styles = message.styles,\n          transform = message.transform;\n        switch (type) {\n          case 0 /* PlatformVideo.SHAPE_TYPE_CODE.SHAPE */:\n            return {\n              type: \"shape\" /* PlatformVideo.SHAPE_TYPE.SHAPE */,\n              path: shape,\n              styles: styles,\n              transform: transform\n            };\n          case 1 /* PlatformVideo.SHAPE_TYPE_CODE.RECT */:\n            return {\n              type: \"rect\" /* PlatformVideo.SHAPE_TYPE.RECT */,\n              path: rect,\n              styles: styles,\n              transform: transform\n            };\n          case 2 /* PlatformVideo.SHAPE_TYPE_CODE.ELLIPSE */:\n            return {\n              type: \"ellipse\" /* PlatformVideo.SHAPE_TYPE.ELLIPSE */,\n              path: ellipse,\n              styles: styles,\n              transform: transform\n            };\n        }\n        return null;\n      }\n    }]);\n  }();\n  var FrameEntity = /*#__PURE__*/function () {\n    function FrameEntity() {\n      _classCallCheck(this, FrameEntity);\n      /**\n       * FrameEntity shapes.\n       * @member {Array.<com.opensource.svga.IShapeEntity>} shapes\n       * @memberof com.opensource.svga.FrameEntity\n       * @instance\n       */\n      this.shapes = [];\n      /**\n       * FrameEntity alpha.\n       * @member {number} alpha\n       * @memberof com.opensource.svga.FrameEntity\n       * @instance\n       */\n      this.alpha = 0;\n      /**\n       * FrameEntity layout.\n       * @member {com.opensource.svga.ILayout|null|undefined} layout\n       * @memberof com.opensource.svga.FrameEntity\n       * @instance\n       */\n      this.layout = null;\n      /**\n       * FrameEntity transform.\n       * @member {com.opensource.svga.ITransform|null|undefined} transform\n       * @memberof com.opensource.svga.FrameEntity\n       * @instance\n       */\n      this.transform = null;\n      /**\n       * FrameEntity clipPath.\n       * @member {string} clipPath\n       * @memberof com.opensource.svga.FrameEntity\n       * @instance\n       */\n      this.clipPath = \"\";\n    }\n    /**\n     * Decodes a FrameEntity message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.FrameEntity\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.FrameEntity} FrameEntity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(FrameEntity, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new FrameEntity();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.alpha = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.layout = Layout.decode(reader, reader.uint32());\n                break;\n              }\n            case 3:\n              {\n                message.transform = Transform.decode(reader, reader.uint32());\n                break;\n              }\n            case 4:\n              {\n                message.clipPath = reader.string();\n                break;\n              }\n            case 5:\n              {\n                var shape = ShapeEntity.decode(reader, reader.uint32());\n                if (shape !== null) {\n                  message.shapes.push(shape);\n                }\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        if (message.shapes.length === 0) {\n          message.shapes = reader.preflight.get(\"latest_shapes\");\n        } else {\n          reader.preflight.set(\"latest_shapes\", message.shapes);\n        }\n        return FrameEntity.format(message);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        // alpha值小于 0.05 将不展示，所以不做解析处理\n        if (message.alpha < 0.05) {\n          return FrameEntity.HIDDEN_FRAME;\n        }\n        var alpha = message.alpha,\n          layout = message.layout,\n          transform = message.transform,\n          shapes = message.shapes;\n        return {\n          alpha: alpha,\n          layout: layout,\n          transform: transform,\n          shapes: shapes\n        };\n      }\n    }]);\n  }();\n  FrameEntity.HIDDEN_FRAME = {\n    alpha: 0\n  };\n  var SpriteEntity = /*#__PURE__*/function () {\n    function SpriteEntity() {\n      _classCallCheck(this, SpriteEntity);\n      /**\n       * SpriteEntity frames.\n       * @member {Array.<com.opensource.svga.IFrameEntity>} frames\n       * @memberof com.opensource.svga.SpriteEntity\n       * @instance\n       */\n      this.frames = [];\n      /**\n       * SpriteEntity imageKey.\n       * @member {string} imageKey\n       * @memberof com.opensource.svga.SpriteEntity\n       * @instance\n       */\n      this.imageKey = \"\";\n      /**\n       * SpriteEntity matteKey.\n       * @member {string} matteKey\n       * @memberof com.opensource.svga.SpriteEntity\n       * @instance\n       */\n      this.matteKey = \"\";\n    }\n    /**\n     * Decodes a SpriteEntity message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.SpriteEntity\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.SpriteEntity} SpriteEntity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(SpriteEntity, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new SpriteEntity();\n        var tag;\n        reader.preflight.set(\"latest_shapes\", []);\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.imageKey = reader.string();\n                break;\n              }\n            case 2:\n              {\n                if (!(message.frames && message.frames.length)) {\n                  message.frames = [];\n                }\n                message.frames.push(FrameEntity.decode(reader, reader.uint32()));\n                break;\n              }\n            case 3:\n              {\n                message.matteKey = reader.string();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return SpriteEntity.format(message);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        return {\n          imageKey: message.imageKey,\n          frames: message.frames\n        };\n      }\n    }]);\n  }();\n  var MovieParams = /*#__PURE__*/function () {\n    function MovieParams() {\n      _classCallCheck(this, MovieParams);\n      /**\n       * MovieParams viewBoxWidth.\n       * @member {number} viewBoxWidth\n       * @memberof com.opensource.svga.MovieParams\n       * @instance\n       */\n      this.viewBoxWidth = 0;\n      /**\n       * MovieParams viewBoxHeight.\n       * @member {number} viewBoxHeight\n       * @memberof com.opensource.svga.MovieParams\n       * @instance\n       */\n      this.viewBoxHeight = 0;\n      /**\n       * MovieParams fps.\n       * @member {number} fps\n       * @memberof com.opensource.svga.MovieParams\n       * @instance\n       */\n      this.fps = 0;\n      /**\n       * MovieParams frames.\n       * @member {number} frames\n       * @memberof com.opensource.svga.MovieParams\n       * @instance\n       */\n      this.frames = 0;\n    }\n    /**\n     * Decodes a MovieParams message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.MovieParams\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.MovieParams} MovieParams\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(MovieParams, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new MovieParams();\n        var tag;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.viewBoxWidth = reader.float();\n                break;\n              }\n            case 2:\n              {\n                message.viewBoxHeight = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.fps = reader.int32();\n                break;\n              }\n            case 4:\n              {\n                message.frames = reader.int32();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      }\n    }]);\n  }();\n  var MovieEntity = /*#__PURE__*/function () {\n    function MovieEntity() {\n      _classCallCheck(this, MovieEntity);\n      /**\n       * MovieEntity version.\n       * @member {string} version\n       * @memberof com.opensource.svga.MovieEntity\n       * @instance\n       */\n      this.version = \"\";\n      /**\n       * MovieEntity params.\n       * @member {com.opensource.svga.IMovieParams|null|undefined} params\n       * @memberof com.opensource.svga.MovieEntity\n       * @instance\n       */\n      this.params = null;\n      /**\n       * MovieEntity images.\n       * @member {Object.<string,Uint8Array>} images\n       * @memberof com.opensource.svga.MovieEntity\n       * @instance\n       */\n      this.images = {};\n      /**\n       * MovieEntity sprites.\n       * @member {Array.<com.opensource.svga.ISpriteEntity>} sprites\n       * @memberof com.opensource.svga.MovieEntity\n       * @instance\n       */\n      this.sprites = [];\n    }\n    /**\n     * Decodes a MovieEntity message from the specified reader.\n     * @function decode\n     * @memberof com.opensource.svga.MovieEntity\n     * @static\n     * @param {$protobuf.Reader} reader Reader to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {com.opensource.svga.MovieEntity} MovieEntity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    return _createClass(MovieEntity, null, [{\n      key: \"decode\",\n      value: function decode(reader, length) {\n        var end = reader.end(length);\n        var message = new MovieEntity();\n        var key;\n        var value;\n        var end2;\n        var tag;\n        var tag2;\n        while (reader.pos < end) {\n          tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.version = reader.string();\n                break;\n              }\n            case 2:\n              {\n                message.params = MovieParams.decode(reader, reader.uint32());\n                break;\n              }\n            case 3:\n              {\n                end2 = reader.uint32() + reader.pos;\n                key = \"\";\n                value = MovieEntity.EMPTY_U8;\n                while (reader.pos < end2) {\n                  tag2 = reader.uint32();\n                  switch (tag2 >>> 3) {\n                    case 1:\n                      key = reader.string();\n                      break;\n                    case 2:\n                      value = reader.bytes();\n                      break;\n                    default:\n                      reader.skipType(tag2 & 7);\n                      break;\n                  }\n                }\n                message.images[key] = value;\n                break;\n              }\n            case 4:\n              {\n                message.sprites.push(SpriteEntity.decode(reader, reader.uint32()));\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return MovieEntity.format(message);\n      }\n    }, {\n      key: \"format\",\n      value: function format(message) {\n        var version = message.version,\n          images = message.images,\n          sprites = message.sprites;\n        var _message$params = message.params,\n          fps = _message$params.fps,\n          frames = _message$params.frames,\n          viewBoxWidth = _message$params.viewBoxWidth,\n          viewBoxHeight = _message$params.viewBoxHeight;\n        return {\n          version: version,\n          filename: \"\",\n          locked: false,\n          dynamicElements: {},\n          size: {\n            width: viewBoxWidth,\n            height: viewBoxHeight\n          },\n          fps: fps,\n          frames: frames,\n          images: images,\n          sprites: sprites\n        };\n      }\n    }]);\n  }();\n  MovieEntity.EMPTY_U8 = new Uint8Array(0); // import benchmark from \"octopus-benchmark\";\n  function createVideoEntity(data, filename) {\n    if (data instanceof Uint8Array) {\n      var reader = new Reader(data);\n      var video = MovieEntity.decode(reader);\n      // benchmark.log('preflight cache size', reader.preflight.size);\n      // benchmark.log('preflight hit count', reader.preflight.hitCount);\n      video.filename = filename;\n      reader.preflight.clear();\n      return video;\n    }\n    throw new Error(\"Invalid data type\");\n  } /**\n    * CurrentPoint对象池，用于减少对象创建和GC压力\n    */\n  var PointPool = /*#__PURE__*/function () {\n    function PointPool() {\n      _classCallCheck(this, PointPool);\n      this.pool = [];\n    }\n    return _createClass(PointPool, [{\n      key: \"acquire\",\n      value: function acquire() {\n        var pool = this.pool;\n        return pool.length > 0 ? pool.pop() : {\n          x: 0,\n          y: 0,\n          x1: 0,\n          y1: 0,\n          x2: 0,\n          y2: 0\n        };\n      }\n    }, {\n      key: \"release\",\n      value: function release(point) {\n        // 重置点的属性\n        point.x = point.y = point.x1 = point.y1 = point.x2 = point.y2 = 0;\n        this.pool.push(point);\n      }\n    }]);\n  }();\n  var Renderer2D = /*#__PURE__*/function () {\n    function Renderer2D(context) {\n      _classCallCheck(this, Renderer2D);\n      this.context = context;\n      this.pointPool = new PointPool();\n      this.lastResizeKey = \"\";\n      this.globalTransform = undefined;\n      this.currentPoint = this.pointPool.acquire();\n    }\n    return _createClass(Renderer2D, [{\n      key: \"setTransform\",\n      value: function setTransform(transform) {\n        if (transform && this.context) {\n          this.context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        }\n      }\n    }, {\n      key: \"drawBezier\",\n      value: function drawBezier(d, transform, styles) {\n        var context = this.context,\n          pointPool = this.pointPool;\n        this.currentPoint = pointPool.acquire();\n        context.save();\n        Renderer2D.resetShapeStyles(context, styles);\n        this.setTransform(transform);\n        context.beginPath();\n        if (d) {\n          // 使用状态机解析器替代正则表达式\n          var commands = Renderer2D.parseSVGPath(d);\n          var _iterator = _createForOfIteratorHelper(commands),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _step.value,\n                command = _step$value.command,\n                args = _step$value.args;\n              if (Renderer2D.SVG_PATH.has(command)) {\n                this.drawBezierElement(this.currentPoint, command, args.split(/[\\s,]+/).filter(Boolean));\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        Renderer2D.fillOrStroke(context, styles);\n        pointPool.release(this.currentPoint);\n        context.restore();\n      }\n    }, {\n      key: \"drawBezierElement\",\n      value: function drawBezierElement(currentPoint, method, args) {\n        var context = this.context;\n        switch (method) {\n          case \"M\":\n            currentPoint.x = +args[0];\n            currentPoint.y = +args[1];\n            context.moveTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"m\":\n            currentPoint.x += +args[0];\n            currentPoint.y += +args[1];\n            context.moveTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"L\":\n            currentPoint.x = +args[0];\n            currentPoint.y = +args[1];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"l\":\n            currentPoint.x += +args[0];\n            currentPoint.y += +args[1];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"H\":\n            currentPoint.x = +args[0];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"h\":\n            currentPoint.x += +args[0];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"V\":\n            currentPoint.y = +args[0];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"v\":\n            currentPoint.y += +args[0];\n            context.lineTo(currentPoint.x, currentPoint.y);\n            break;\n          case \"C\":\n            currentPoint.x1 = +args[0];\n            currentPoint.y1 = +args[1];\n            currentPoint.x2 = +args[2];\n            currentPoint.y2 = +args[3];\n            currentPoint.x = +args[4];\n            currentPoint.y = +args[5];\n            context.bezierCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x2, currentPoint.y2, currentPoint.x, currentPoint.y);\n            break;\n          case \"c\":\n            currentPoint.x1 = currentPoint.x + +args[0];\n            currentPoint.y1 = currentPoint.y + +args[1];\n            currentPoint.x2 = currentPoint.x + +args[2];\n            currentPoint.y2 = currentPoint.y + +args[3];\n            currentPoint.x += +args[4];\n            currentPoint.y += +args[5];\n            context.bezierCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x2, currentPoint.y2, currentPoint.x, currentPoint.y);\n            break;\n          case \"S\":\n            if (currentPoint.x1 !== undefined && currentPoint.y1 !== undefined && currentPoint.x2 !== undefined && currentPoint.y2 !== undefined) {\n              currentPoint.x1 = currentPoint.x - currentPoint.x2 + currentPoint.x;\n              currentPoint.y1 = currentPoint.y - currentPoint.y2 + currentPoint.y;\n              currentPoint.x2 = +args[0];\n              currentPoint.y2 = +args[1];\n              currentPoint.x = +args[2];\n              currentPoint.y = +args[3];\n              context.bezierCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x2, currentPoint.y2, currentPoint.x, currentPoint.y);\n            } else {\n              currentPoint.x1 = +args[0];\n              currentPoint.y1 = +args[1];\n              currentPoint.x = +args[2];\n              currentPoint.y = +args[3];\n              context.quadraticCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x, currentPoint.y);\n            }\n            break;\n          case \"s\":\n            if (currentPoint.x1 !== undefined && currentPoint.y1 !== undefined && currentPoint.x2 !== undefined && currentPoint.y2 !== undefined) {\n              currentPoint.x1 = currentPoint.x - currentPoint.x2 + currentPoint.x;\n              currentPoint.y1 = currentPoint.y - currentPoint.y2 + currentPoint.y;\n              currentPoint.x2 = currentPoint.x + +args[0];\n              currentPoint.y2 = currentPoint.y + +args[1];\n              currentPoint.x += +args[2];\n              currentPoint.y += +args[3];\n              context.bezierCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x2, currentPoint.y2, currentPoint.x, currentPoint.y);\n            } else {\n              currentPoint.x1 = currentPoint.x + +args[0];\n              currentPoint.y1 = currentPoint.y + +args[1];\n              currentPoint.x += +args[2];\n              currentPoint.y += +args[3];\n              context.quadraticCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x, currentPoint.y);\n            }\n            break;\n          case \"Q\":\n            currentPoint.x1 = +args[0];\n            currentPoint.y1 = +args[1];\n            currentPoint.x = +args[2];\n            currentPoint.y = +args[3];\n            context.quadraticCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x, currentPoint.y);\n            break;\n          case \"q\":\n            currentPoint.x1 = currentPoint.x + +args[0];\n            currentPoint.y1 = currentPoint.y + +args[1];\n            currentPoint.x += +args[2];\n            currentPoint.y += +args[3];\n            context.quadraticCurveTo(currentPoint.x1, currentPoint.y1, currentPoint.x, currentPoint.y);\n            break;\n          case \"Z\":\n          case \"z\":\n            context.closePath();\n            break;\n        }\n      }\n    }, {\n      key: \"drawEllipse\",\n      value: function drawEllipse(x, y, radiusX, radiusY, transform, styles) {\n        var context = this.context;\n        context.save();\n        Renderer2D.resetShapeStyles(context, styles);\n        this.setTransform(transform);\n        x -= radiusX;\n        y -= radiusY;\n        var w = radiusX * 2;\n        var h = radiusY * 2;\n        var kappa = 0.5522848;\n        var ox = w / 2 * kappa;\n        var oy = h / 2 * kappa;\n        var xe = x + w;\n        var ye = y + h;\n        var xm = x + w / 2;\n        var ym = y + h / 2;\n        context.beginPath();\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        Renderer2D.fillOrStroke(context, styles);\n        context.restore();\n      }\n    }, {\n      key: \"drawRect\",\n      value: function drawRect(x, y, width, height, cornerRadius, transform, styles) {\n        var context = this.context;\n        context.save();\n        Renderer2D.resetShapeStyles(context, styles);\n        this.setTransform(transform);\n        var radius = cornerRadius;\n        if (width < 2 * radius) {\n          radius = width / 2;\n        }\n        if (height < 2 * radius) {\n          radius = height / 2;\n        }\n        context.beginPath();\n        context.moveTo(x + radius, y);\n        context.arcTo(x + width, y, x + width, y + height, radius);\n        context.arcTo(x + width, y + height, x, y + height, radius);\n        context.arcTo(x, y + height, x, y, radius);\n        context.arcTo(x, y, x + width, y, radius);\n        context.closePath();\n        Renderer2D.fillOrStroke(context, styles);\n        context.restore();\n      }\n    }, {\n      key: \"drawShape\",\n      value: function drawShape(shape) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        var type = shape.type,\n          path = shape.path,\n          transform = shape.transform,\n          styles = shape.styles;\n        switch (type) {\n          case \"shape\" /* PlatformVideo.SHAPE_TYPE.SHAPE */:\n            this.drawBezier(path.d, transform, styles);\n            break;\n          case \"ellipse\" /* PlatformVideo.SHAPE_TYPE.ELLIPSE */:\n            this.drawEllipse((_a = path.x) !== null && _a !== void 0 ? _a : 0, (_b = path.y) !== null && _b !== void 0 ? _b : 0, (_c = path.radiusX) !== null && _c !== void 0 ? _c : 0, (_d = path.radiusY) !== null && _d !== void 0 ? _d : 0, transform, styles);\n            break;\n          case \"rect\" /* PlatformVideo.SHAPE_TYPE.RECT */:\n            this.drawRect((_e = path.x) !== null && _e !== void 0 ? _e : 0, (_f = path.y) !== null && _f !== void 0 ? _f : 0, (_g = path.width) !== null && _g !== void 0 ? _g : 0, (_h = path.height) !== null && _h !== void 0 ? _h : 0, (_j = path.cornerRadius) !== null && _j !== void 0 ? _j : 0, transform, styles);\n            break;\n        }\n      }\n    }, {\n      key: \"drawSprite\",\n      value: function drawSprite(frame, bitmap, dynamicElement) {\n        if (frame.alpha === 0) return;\n        var context = this.context;\n        var alpha = frame.alpha,\n          transform = frame.transform,\n          layout = frame.layout,\n          shapes = frame.shapes;\n        var _ref = transform !== null && transform !== void 0 ? transform : {},\n          _ref$a = _ref.a,\n          a = _ref$a === void 0 ? 1 : _ref$a,\n          _ref$b = _ref.b,\n          b = _ref$b === void 0 ? 0 : _ref$b,\n          _ref$c = _ref.c,\n          c = _ref$c === void 0 ? 0 : _ref$c,\n          _ref$d = _ref.d,\n          d = _ref$d === void 0 ? 1 : _ref$d,\n          _ref$tx = _ref.tx,\n          tx = _ref$tx === void 0 ? 0 : _ref$tx,\n          _ref$ty = _ref.ty,\n          ty = _ref$ty === void 0 ? 0 : _ref$ty;\n        context.save();\n        this.setTransform(this.globalTransform);\n        context.globalAlpha = alpha;\n        context.transform(a, b, c, d, tx, ty);\n        if (bitmap) {\n          context.drawImage(bitmap, 0, 0, layout.width, layout.height);\n        }\n        if (dynamicElement) {\n          context.drawImage(dynamicElement, (layout.width - dynamicElement.width) / 2, (layout.height - dynamicElement.height) / 2);\n        }\n        for (var i = 0; i < shapes.length; i++) {\n          this.drawShape(shapes[i]);\n        }\n        context.restore();\n      }\n      /**\n       * 调整画布尺寸\n       * @param contentMode\n       * @param videoSize\n       * @param canvasSize\n       * @returns\n       */\n    }, {\n      key: \"resize\",\n      value: function resize(contentMode, videoSize, canvasSize) {\n        var canvasWidth = canvasSize.width,\n          canvasHeight = canvasSize.height;\n        var videoWidth = videoSize.width,\n          videoHeight = videoSize.height;\n        var resizeKey = \"\".concat(contentMode, \"-\").concat(videoWidth, \"-\").concat(videoHeight, \"-\").concat(canvasWidth, \"-\").concat(canvasHeight);\n        var lastTransform = this.globalTransform;\n        if (this.lastResizeKey === resizeKey && lastTransform) {\n          return;\n        }\n        var scale = {\n          scaleX: 1,\n          scaleY: 1,\n          translateX: 0,\n          translateY: 0\n        };\n        if (contentMode === \"fill\" /* PLAYER_CONTENT_MODE.FILL */) {\n          scale.scaleX = canvasWidth / videoWidth;\n          scale.scaleY = canvasHeight / videoHeight;\n        } else {\n          scale = Renderer2D.calculateScale(contentMode, videoSize, canvasSize);\n        }\n        this.lastResizeKey = resizeKey;\n        this.globalTransform = {\n          a: scale.scaleX,\n          b: 0.0,\n          c: 0.0,\n          d: scale.scaleY,\n          tx: scale.translateX,\n          ty: scale.translateY\n        };\n      }\n    }, {\n      key: \"render\",\n      value: function render(videoEntity, materials, dynamicMaterials, currentFrame, head, tail) {\n        var sprite;\n        var imageKey;\n        var bitmap;\n        var dynamicElement;\n        for (var i = head; i < tail; i++) {\n          sprite = videoEntity.sprites[i];\n          imageKey = sprite.imageKey;\n          bitmap = materials.get(imageKey);\n          dynamicElement = dynamicMaterials.get(imageKey);\n          this.drawSprite(sprite.frames[currentFrame], bitmap, dynamicElement);\n        }\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.globalTransform = undefined;\n        this.lastResizeKey = \"\";\n        this.context = null;\n      }\n    }], [{\n      key: \"parseSVGPath\",\n      value:\n      // 在Renderer2D类中添加新的解析方法\n      function parseSVGPath(d) {\n        var SVG_LETTER_REGEXP = Renderer2D.SVG_LETTER_REGEXP;\n        var result = [];\n        var currentIndex = 0;\n        // 状态：0 - 等待命令，1 - 读取参数\n        var state = 0;\n        var currentCommand = \"\";\n        var currentArgs = \"\";\n        while (currentIndex < d.length) {\n          var char = d[currentIndex];\n          switch (state) {\n            case 0:\n              // 等待命令\n              if (SVG_LETTER_REGEXP.test(char)) {\n                currentCommand = char;\n                state = 1;\n              }\n              break;\n            case 1:\n              // 读取参数\n              if (SVG_LETTER_REGEXP.test(char)) {\n                // 遇到新命令，保存当前命令和参数\n                result.push({\n                  command: currentCommand,\n                  args: currentArgs.trim()\n                });\n                currentCommand = char;\n                currentArgs = \"\";\n              } else {\n                currentArgs += char;\n              }\n              break;\n          }\n          currentIndex++;\n        }\n        // 处理最后一个命令\n        if (currentCommand && state === 1) {\n          result.push({\n            command: currentCommand,\n            args: currentArgs.trim()\n          });\n        }\n        return result;\n      }\n    }, {\n      key: \"fillOrStroke\",\n      value: function fillOrStroke(context, styles) {\n        if (styles) {\n          if (styles.fill) {\n            context.fill();\n          }\n          if (styles.stroke) {\n            context.stroke();\n          }\n        }\n      }\n    }, {\n      key: \"resetShapeStyles\",\n      value: function resetShapeStyles(context, styles) {\n        if (styles) {\n          context.strokeStyle = styles.stroke || \"transparent\";\n          if (styles.strokeWidth > 0) {\n            context.lineWidth = styles.strokeWidth;\n          }\n          if (styles.miterLimit > 0) {\n            context.miterLimit = styles.miterLimit;\n          }\n          if (styles.lineCap) {\n            context.lineCap = styles.lineCap;\n          }\n          if (styles.lineJoin) {\n            context.lineJoin = styles.lineJoin;\n          }\n          context.fillStyle = styles.fill || \"transparent\";\n          if (styles.lineDash) {\n            context.setLineDash(styles.lineDash);\n          }\n        }\n      }\n      /**\n       * 计算缩放比例\n       * @param contentMode\n       * @param videoSize\n       * @param canvasSize\n       * @returns\n       */\n    }, {\n      key: \"calculateScale\",\n      value: function calculateScale(contentMode, videoSize, canvasSize) {\n        var imageRatio = videoSize.width / videoSize.height;\n        var viewRatio = canvasSize.width / canvasSize.height;\n        var isAspectFit = contentMode === \"aspect-fit\" /* PLAYER_CONTENT_MODE.ASPECT_FIT */;\n        var shouldUseWidth = imageRatio >= viewRatio && isAspectFit || imageRatio <= viewRatio && !isAspectFit;\n        var createTransform = function createTransform(scale, translateX, translateY) {\n          return {\n            scaleX: scale,\n            scaleY: scale,\n            translateX: translateX,\n            translateY: translateY\n          };\n        };\n        if (shouldUseWidth) {\n          var _scale = canvasSize.width / videoSize.width;\n          return createTransform(_scale, 0, (canvasSize.height - videoSize.height * _scale) / 2);\n        }\n        var scale = canvasSize.height / videoSize.height;\n        return createTransform(scale, (canvasSize.width - videoSize.width * scale) / 2, 0);\n      }\n    }]);\n  }();\n  /**\n   * https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths\n   * 绘制路径的不同指令：\n   * * 直线命令\n   * - M: moveTo，移动到指定点，不绘制直线。\n   * - L: lineTo，从起始点绘制一条直线到指定点。\n   * - H: horizontal lineTo，从起始点绘制一条水平线到指定点。\n   * - V: vertical lineTo，从起始点绘制一条垂直线到指定点。\n   * - Z: closePath，从起始点绘制一条直线到路径起点，形成一个闭合路径。\n   * * 曲线命令\n   * - C: bezierCurveTo，绘制三次贝塞尔曲线。\n   * - S: smooth curveTo，绘制平滑三次贝塞尔曲线。\n   * - Q: quadraticCurveTo，绘制两次贝塞尔曲线。\n   * - T: smooth quadraticCurveTo，绘制平滑两次贝塞尔曲线。\n   * * 弧线命令\n   * - A: arcTo，从起始点绘制一条弧线到指定点。\n   */\n  Renderer2D.SVG_PATH = new Set([\"M\", \"L\", \"H\", \"V\", \"Z\", \"C\", \"S\", \"Q\", \"m\", \"l\", \"h\", \"v\", \"z\", \"c\", \"s\", \"q\"]);\n  Renderer2D.SVG_LETTER_REGEXP = /[a-zA-Z]/;\n  var Renderer2DExtension = {\n    stick: function stick(context, bitmap) {\n      return function () {\n        return context.drawImage(bitmap, 0, 0);\n      };\n    },\n    clear: function clear(type, context, canvas, width, height) {\n      if (type === \"CL\") {\n        return function () {\n          // FIXME:【支付宝小程序】无法通过改变尺寸来清理画布，无论是Canvas还是OffscreenCanvas\n          context.clearRect(0, 0, width, height);\n        };\n      }\n      return function () {\n        canvas.width = width;\n        canvas.height = height;\n      };\n    }\n  }; /**\n     * 动画控制器\n     */\n  var Animator = /*#__PURE__*/function () {\n    function Animator() {\n      _classCallCheck(this, Animator);\n      /**\n       * 动画是否执行\n       */\n      this.isRunning = false;\n      /**\n       * 动画开始时间\n       */\n      this.startTime = 0;\n      /**\n       * 动画持续时间\n       */\n      this.duration = 0;\n      /**\n       * 循环播放开始帧与动画开始帧之间的时间偏差\n       */\n      this.loopStart = 0;\n      /**\n       * 动画暂停时的时间偏差\n       */\n      this.pauseTime = 0;\n      /**\n       * 循环持续时间\n       */\n      this.loopDuration = 0;\n      this.onAnimate = platform.noop;\n      /* ---- 事件钩子 ---- */\n      this.onStart = platform.noop;\n      this.onUpdate = platform.noop;\n      this.onEnd = platform.noop;\n    }\n    /**\n     * 设置动画的必要参数\n     * @param duration\n     * @param loopStart\n     * @param loop\n     * @param fillValue\n     */\n    return _createClass(Animator, [{\n      key: \"setConfig\",\n      value: function setConfig(duration, loopStart, loop, fillValue) {\n        this.duration = duration;\n        this.loopStart = loopStart;\n        this.loopDuration = duration * loop + fillValue - loopStart;\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.isRunning = true;\n        this.startTime = platform.now();\n        this.pauseTime = 0;\n        this.onStart();\n        this.doFrame();\n      }\n    }, {\n      key: \"resume\",\n      value: function resume() {\n        if (this.startTime === 0) {\n          return false;\n        }\n        this.isRunning = true;\n        this.doFrame();\n        return true;\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        if (this.startTime === 0) {\n          return false;\n        }\n        this.isRunning = false;\n        // 设置暂停的位置\n        this.pauseTime = (platform.now() - this.startTime) % this.duration;\n        return true;\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        this.isRunning = false;\n        this.startTime = 0;\n      }\n    }, {\n      key: \"doFrame\",\n      value: function doFrame() {\n        var _this = this;\n        if (this.isRunning) {\n          this.doDeltaTime(platform.now() - this.startTime);\n          if (this.isRunning) {\n            this.onAnimate(function () {\n              return _this.doFrame();\n            });\n          }\n        }\n      }\n    }, {\n      key: \"doDeltaTime\",\n      value: function doDeltaTime(deltaTime) {\n        var duration = this.duration,\n          loopStart = this.loopStart,\n          pauseTime = this.pauseTime,\n          loopDuration = this.loopDuration;\n        // 本轮动画已消耗的时间比例（Percentage of speed time）\n        var percent;\n        var ended = false;\n        // 运行时间 大于等于 循环持续时间\n        if (deltaTime >= loopDuration) {\n          // 动画已结束\n          percent = 1.0;\n          ended = true;\n          this.stop();\n        } else {\n          // 本轮动画已消耗的时间比例 = 本轮动画已消耗的时间 / 动画持续时间\n          percent = (deltaTime + loopStart + pauseTime) % duration / duration;\n        }\n        this.onUpdate(percent);\n        if (!this.isRunning && ended) {\n          this.onEnd();\n        }\n      }\n    }]);\n  }(); // DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n  // https://tools.ietf.org/html/rfc1951\n  // You may also wish to take a look at the guide I made about this program:\n  // https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n  // Some of the following code is similar to that of UZIP.js:\n  // https://github.com/photopea/UZIP.js\n  // However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n  // Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n  // is better for memory in most engines (I *think*).\n  // aliases for shorter compressed code (most minifers don't do this)\n  var u8 = Uint8Array,\n    u16 = Uint16Array,\n    i32 = Int32Array;\n  // fixed length extra bits\n  var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */0, 0, /* impossible */0]);\n  // fixed distance extra bits\n  var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */0, 0]);\n  // code length index map\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  // get base, reverse index map from extra bits\n  var freb = function freb(eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n      b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var _i = 1; _i < 30; ++_i) {\n      for (var j = b[_i]; j < b[_i + 1]; ++j) {\n        r[j] = j - b[_i] << 5 | _i;\n      }\n    }\n    return {\n      b: b,\n      r: r\n    };\n  };\n  var _freb = freb(fleb, 2),\n    fl = _freb.b,\n    revfl = _freb.r;\n  // we can ignore the fact that the other numbers are wrong; they never happen anyway\n  fl[28] = 258, revfl[258] = 28;\n  var _freb2 = freb(fdeb, 0),\n    fd = _freb2.b,\n    revfd = _freb2.r;\n  // map of value to reverse (assuming 16 bits)\n  var rev = new u16(32768);\n  for (var i$1 = 0; i$1 < 32768; ++i$1) {\n    // reverse table algorithm from SO\n    var x = (i$1 & 0xAAAA) >> 1 | (i$1 & 0x5555) << 1;\n    x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;\n    rev[i$1] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;\n  }\n  // create huffman tree from u8 \"map\": index -> code length for code index\n  // mb (max bits) must be at most 15\n  // TODO: optimize/split up?\n  var hMap = function hMap(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n      if (cd[i]) ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n      le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n      // u16 \"map\": index -> number of actual bits, symbol for code\n      co = new u16(1 << mb);\n      // bits to remove for reverser\n      var rvb = 15 - mb;\n      for (i = 0; i < s; ++i) {\n        // ignore 0 lengths\n        if (cd[i]) {\n          // num encoding both symbol and bits read\n          var sv = i << 4 | cd[i];\n          // free bits\n          var _r = mb - cd[i];\n          // start value\n          var v = le[cd[i] - 1]++ << _r;\n          // m is end value\n          for (var m = v | (1 << _r) - 1; v <= m; ++v) {\n            // every 16 bit value starting with the code yields the same result\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i = 0; i < s; ++i) {\n        if (cd[i]) {\n          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n        }\n      }\n    }\n    return co;\n  };\n  // fixed length tree\n  var flt = new u8(288);\n  for (var _i2$1 = 0; _i2$1 < 144; ++_i2$1) flt[_i2$1] = 8;\n  for (var _i3 = 144; _i3 < 256; ++_i3) flt[_i3] = 9;\n  for (var _i4 = 256; _i4 < 280; ++_i4) flt[_i4] = 7;\n  for (var _i5 = 280; _i5 < 288; ++_i5) flt[_i5] = 8;\n  // fixed distance tree\n  var fdt = new u8(32);\n  for (var _i6 = 0; _i6 < 32; ++_i6) fdt[_i6] = 5;\n  // fixed length map\n  var flm = /*#__PURE__*/hMap(flt, 9, 0),\n    flrm = /*#__PURE__*/hMap(flt, 9, 1);\n  // fixed distance map\n  var fdm = /*#__PURE__*/hMap(fdt, 5, 0),\n    fdrm = /*#__PURE__*/hMap(fdt, 5, 1);\n  // find max of array\n  var max = function max(a) {\n    var m = a[0];\n    for (var _i7 = 1; _i7 < a.length; ++_i7) {\n      if (a[_i7] > m) m = a[_i7];\n    }\n    return m;\n  };\n  // read d, starting at bit p and mask with m\n  var bits = function bits(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  // read d, starting at bit p continuing for at least 16 bits\n  var bits16 = function bits16(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  // get end of byte\n  var shft = function shft(p) {\n    return (p + 7) / 8 | 0;\n  };\n  // typed array slice - allows garbage collector to free original reference,\n  // while being more compatible than .slice\n  var slc = function slc(v, s, e) {\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n  };\n  // error codes\n  var ec = ['unexpected EOF', 'invalid block type', 'invalid length/literal', 'invalid distance', 'stream finished', 'no stream handler',,\n  // determined by compression function\n  'no callback', 'invalid UTF-8 data', 'extra field too long', 'date not in range 1980-2099', 'filename too long', 'stream finishing', 'invalid zip data'\n  // determined by unknown compression method\n  ];\n  var _err = function err(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace) Error.captureStackTrace(e, _err);\n    if (!nt) throw e;\n    return e;\n  };\n  // expands raw DEFLATE data\n  var inflt = function inflt(dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length,\n      dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l) return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function cbuf(l) {\n      var bl = buf.length;\n      // need to increase size to fit\n      if (l > bl) {\n        // Double or set to necessary, whichever is greater\n        var nbuf = new u8(Math.max(bl * 2, l));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        // BFINAL - this is only 1 when last chunk is next\n        final = bits(dat, pos, 1);\n        // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          // go to end of byte boundary\n          var s = shft(pos) + 4,\n            l = dat[s - 4] | dat[s - 3] << 8,\n            t = s + l;\n          if (t > sl) {\n            if (noSt) _err(0);\n            break;\n          }\n          // ensure size\n          if (resize) cbuf(bt + l);\n          // Copy over uncompressed data\n          buf.set(dat.subarray(s, t), bt);\n          // Get new bitpos, update byte count\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n          //  literal                            lengths\n          var hLit = bits(dat, pos, 31) + 257,\n            hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          // length+distance tree\n          var ldt = new u8(tl);\n          // code length tree\n          var clt = new u8(19);\n          for (var _i8 = 0; _i8 < hcLen; ++_i8) {\n            // use index map to get real code\n            clt[clim[_i8]] = bits(dat, pos + _i8 * 3, 7);\n          }\n          pos += hcLen * 3;\n          // code lengths bits\n          var clb = max(clt),\n            clbmsk = (1 << clb) - 1;\n          // code lengths map\n          var clm = hMap(clt, clb, 1);\n          for (var _i9 = 0; _i9 < tl;) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            // bits read\n            pos += r & 15;\n            // symbol\n            var _s = r >> 4;\n            // code length to copy\n            if (_s < 16) {\n              ldt[_i9++] = _s;\n            } else {\n              //  copy   count\n              var c = 0,\n                n = 0;\n              if (_s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[_i9 - 1];else if (_s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (_s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--) ldt[_i9++] = c;\n            }\n          }\n          //    length tree                 distance tree\n          var lt = ldt.subarray(0, hLit),\n            dt = ldt.subarray(hLit);\n          // max length bits\n          lbt = max(lt);\n          // max dist bits\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else _err(1);\n        if (pos > tbts) {\n          if (noSt) _err(0);\n          break;\n        }\n      }\n      // Make sure the buffer can hold this + the largest possible addition\n      // Maximum chunk size (practically, theoretically infinite) is 2^17\n      if (resize) cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1,\n        dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (;; lpos = pos) {\n        // bits read, code\n        var _c = lm[bits16(dat, pos) & lms],\n          sym = _c >> 4;\n        pos += _c & 15;\n        if (pos > tbts) {\n          if (noSt) _err(0);\n          break;\n        }\n        if (!_c) _err(2);\n        if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n          lpos = pos, lm = undefined;\n          break;\n        } else {\n          var add = sym - 254;\n          // no extra bits needed if less\n          if (sym > 264) {\n            // index\n            var _i0 = sym - 257,\n              b = fleb[_i0];\n            add = bits(dat, pos, (1 << b) - 1) + fl[_i0];\n            pos += b;\n          }\n          // dist\n          var d = dm[bits16(dat, pos) & dms],\n            dsym = d >> 4;\n          if (!d) _err(3);\n          pos += d & 15;\n          var _dt = fd[dsym];\n          if (dsym > 3) {\n            var _b2 = fdeb[dsym];\n            _dt += bits16(dat, pos) & (1 << _b2) - 1, pos += _b2;\n          }\n          if (pos > tbts) {\n            if (noSt) _err(0);\n            break;\n          }\n          if (resize) cbuf(bt + 131072);\n          var end = bt + add;\n          if (bt < _dt) {\n            var shift = dl - _dt,\n              dend = Math.min(_dt, end);\n            if (shift + bt < 0) _err(3);\n            for (; bt < dend; ++bt) buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt) buf[bt] = buf[bt - _dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  // starting at p, write the minimum number of bits that can hold v to d\n  var wbits = function wbits(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n  };\n  // starting at p, write the minimum number of bits (>8) that can hold v to d\n  var wbits16 = function wbits16(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n  };\n  // creates code lengths from a frequency table\n  var hTree = function hTree(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var _i1 = 0; _i1 < d.length; ++_i1) {\n      if (d[_i1]) t.push({\n        s: _i1,\n        f: d[_i1]\n      });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return {\n      t: et,\n      l: 0\n    };\n    if (s == 1) {\n      var v = new u8(t[0].s + 1);\n      v[t[0].s] = 1;\n      return {\n        t: v,\n        l: 1\n      };\n    }\n    t.sort(function (a, b) {\n      return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n      s: -1,\n      f: 25001\n    });\n    var l = t[0],\n      r = t[1],\n      i0 = 0,\n      i1 = 1,\n      i2 = 2;\n    t[0] = {\n      s: -1,\n      f: l.f + r.f,\n      l: l,\n      r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n      l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n      r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n      t[i1++] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n      };\n    }\n    var maxSym = t2[0].s;\n    for (var _i10 = 1; _i10 < s; ++_i10) {\n      if (t2[_i10].s > maxSym) maxSym = t2[_i10].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = _ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n      // more algorithms from UZIP.js\n      // TODO: find out how this code works (debt)\n      //  ind    debt\n      var _i11 = 0,\n        dt = 0;\n      //    left            cost\n      var lft = mbt - mb,\n        cst = 1 << lft;\n      t2.sort(function (a, b) {\n        return tr[b.s] - tr[a.s] || a.f - b.f;\n      });\n      for (; _i11 < s; ++_i11) {\n        var _i12 = t2[_i11].s;\n        if (tr[_i12] > mb) {\n          dt += cst - (1 << mbt - tr[_i12]);\n          tr[_i12] = mb;\n        } else break;\n      }\n      dt >>= lft;\n      while (dt > 0) {\n        var _i13 = t2[_i11].s;\n        if (tr[_i13] < mb) dt -= 1 << mb - tr[_i13]++ - 1;else ++_i11;\n      }\n      for (; _i11 >= 0 && dt; --_i11) {\n        var _i14 = t2[_i11].s;\n        if (tr[_i14] == mb) {\n          --tr[_i14];\n          ++dt;\n        }\n      }\n      mbt = mb;\n    }\n    return {\n      t: new u8(tr),\n      l: mbt\n    };\n  };\n  // get the max length and assign length codes\n  var _ln = function ln(n, l, d) {\n    return n.s == -1 ? Math.max(_ln(n.l, l, d + 1), _ln(n.r, l, d + 1)) : l[n.s] = d;\n  };\n  // length codes generation\n  var lc = function lc(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0,\n      cln = c[0],\n      cls = 1;\n    var w = function w(v) {\n      cl[cli++] = v;\n    };\n    for (var _i15 = 1; _i15 <= s; ++_i15) {\n      if (c[_i15] == cln && _i15 != s) ++cls;else {\n        if (!cln && cls > 2) {\n          for (; cls > 138; cls -= 138) w(32754);\n          if (cls > 2) {\n            w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n            cls = 0;\n          }\n        } else if (cls > 3) {\n          w(cln), --cls;\n          for (; cls > 6; cls -= 6) w(8304);\n          if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n        }\n        while (cls--) w(cln);\n        cls = 1;\n        cln = c[_i15];\n      }\n    }\n    return {\n      c: cl.subarray(0, cli),\n      n: s\n    };\n  };\n  // calculate the length of output from tree, code lengths\n  var clen = function clen(cf, cl) {\n    var l = 0;\n    for (var _i16 = 0; _i16 < cl.length; ++_i16) l += cf[_i16] * cl[_i16];\n    return l;\n  };\n  // writes a fixed block\n  // returns the new bit pos\n  var wfblk = function wfblk(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var _i17 = 0; _i17 < s; ++_i17) out[o + _i17 + 4] = dat[_i17];\n    return (o + 4 + s) * 8;\n  };\n  // writes a block\n  var wblk = function wblk(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _hTree = hTree(lf, 15),\n      dlt = _hTree.t,\n      mlb = _hTree.l;\n    var _hTree2 = hTree(df, 15),\n      ddt = _hTree2.t,\n      mdb = _hTree2.l;\n    var _lc = lc(dlt),\n      lclt = _lc.c,\n      nlc = _lc.n;\n    var _lc2 = lc(ddt),\n      lcdt = _lc2.c,\n      ndc = _lc2.n;\n    var lcfreq = new u16(19);\n    for (var _i18 = 0; _i18 < lclt.length; ++_i18) ++lcfreq[lclt[_i18] & 31];\n    for (var _i19 = 0; _i19 < lcdt.length; ++_i19) ++lcfreq[lcdt[_i19] & 31];\n    var _hTree3 = hTree(lcfreq, 7),\n      lct = _hTree3.t,\n      mlcb = _hTree3.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n      var llm = hMap(lct, mlcb, 0);\n      wbits(out, p, nlc - 257);\n      wbits(out, p + 5, ndc - 1);\n      wbits(out, p + 10, nlcc - 4);\n      p += 14;\n      for (var _i20 = 0; _i20 < nlcc; ++_i20) wbits(out, p + 3 * _i20, lct[clim[_i20]]);\n      p += 3 * nlcc;\n      var lcts = [lclt, lcdt];\n      for (var it = 0; it < 2; ++it) {\n        var clct = lcts[it];\n        for (var _i21 = 0; _i21 < clct.length; ++_i21) {\n          var len = clct[_i21] & 31;\n          wbits(out, p, llm[len]), p += lct[len];\n          if (len > 15) wbits(out, p, clct[_i21] >> 5 & 127), p += clct[_i21] >> 12;\n        }\n      }\n    } else {\n      lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var _i22 = 0; _i22 < li; ++_i22) {\n      var sym = syms[_i22];\n      if (sym > 255) {\n        var _len = sym >> 18 & 31;\n        wbits16(out, p, lm[_len + 257]), p += ll[_len + 257];\n        if (_len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[_len];\n        var dst = sym & 31;\n        wbits16(out, p, dm[dst]), p += dl[dst];\n        if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];\n      } else {\n        wbits16(out, p, lm[sym]), p += ll[sym];\n      }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n  };\n  // deflate options (nice << 13) | chain\n  var deo = /*#__PURE__*/new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n  // empty\n  var et = /*#__PURE__*/new u8(0);\n  // compresses data into a raw DEFLATE buffer\n  var dflt = function dflt(dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n      if (pos) w[0] = st.r >> 3;\n      var opt = deo[lvl - 1];\n      var n = opt >> 13,\n        c = opt & 8191;\n      var msk = (1 << plvl) - 1;\n      //    prev 2-byte val map    curr 2-byte val map\n      var prev = st.p || new u16(32768),\n        head = st.h || new u16(msk + 1);\n      var bs1 = Math.ceil(plvl / 3),\n        bs2 = 2 * bs1;\n      var hsh = function hsh(i) {\n        return (dat[i] ^ dat[i + 1] << bs1 ^ dat[i + 2] << bs2) & msk;\n      };\n      // 24576 is an arbitrary number of maximum symbols per block\n      // 424 buffer for last block\n      var syms = new i32(25000);\n      // length/literal freq   distance freq\n      var lf = new u16(288),\n        df = new u16(32);\n      //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n      var _lc3 = 0,\n        eb = 0,\n        _i23 = st.i || 0,\n        li = 0,\n        wi = st.w || 0,\n        bs = 0;\n      for (; _i23 + 2 < s; ++_i23) {\n        // hash value\n        var hv = hsh(_i23);\n        // index mod 32768    previous index mod\n        var imod = _i23 & 32767,\n          pimod = head[hv];\n        prev[imod] = pimod;\n        head[hv] = imod;\n        // We always should modify head and prev, but only add symbols if\n        // this data is not yet processed (\"wait\" for wait index)\n        if (wi <= _i23) {\n          // bytes remaining\n          var rem = s - _i23;\n          if ((_lc3 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n            pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, _i23 - bs, pos);\n            li = _lc3 = eb = 0, bs = _i23;\n            for (var j = 0; j < 286; ++j) lf[j] = 0;\n            for (var _j = 0; _j < 30; ++_j) df[_j] = 0;\n          }\n          //  len    dist   chain\n          var l = 2,\n            d = 0,\n            ch = c,\n            dif = imod - pimod & 32767;\n          if (rem > 2 && hv == hsh(_i23 - dif)) {\n            var maxn = Math.min(n, rem) - 1;\n            var maxd = Math.min(32767, _i23);\n            // max possible length\n            // not capped at dif because decompressors implement \"rolling\" index population\n            var ml = Math.min(258, rem);\n            while (dif <= maxd && --ch && imod != pimod) {\n              if (dat[_i23 + l] == dat[_i23 + l - dif]) {\n                var nl = 0;\n                for (; nl < ml && dat[_i23 + nl] == dat[_i23 + nl - dif]; ++nl);\n                if (nl > l) {\n                  l = nl, d = dif;\n                  // break out early when we reach \"nice\" (we are satisfied enough)\n                  if (nl > maxn) break;\n                  // now, find the rarest 2-byte sequence within this\n                  // length of literals and search for that instead.\n                  // Much faster than just using the start\n                  var mmd = Math.min(dif, nl - 2);\n                  var md = 0;\n                  for (var _j2 = 0; _j2 < mmd; ++_j2) {\n                    var ti = _i23 - dif + _j2 & 32767;\n                    var pti = prev[ti];\n                    var cd = ti - pti & 32767;\n                    if (cd > md) md = cd, pimod = ti;\n                  }\n                }\n              }\n              // check the previous match\n              imod = pimod, pimod = prev[imod];\n              dif += imod - pimod & 32767;\n            }\n          }\n          // d will be nonzero only when a match was found\n          if (d) {\n            // store both dist and len data in one int32\n            // Make sure this is recognized as a len/dist with 28th bit (2^28)\n            syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n            var lin = revfl[l] & 31,\n              din = revfd[d] & 31;\n            eb += fleb[lin] + fdeb[din];\n            ++lf[257 + lin];\n            ++df[din];\n            wi = _i23 + l;\n            ++_lc3;\n          } else {\n            syms[li++] = dat[_i23];\n            ++lf[dat[_i23]];\n          }\n        }\n      }\n      for (_i23 = Math.max(_i23, wi); _i23 < s; ++_i23) {\n        syms[li++] = dat[_i23];\n        ++lf[dat[_i23]];\n      }\n      pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, _i23 - bs, pos);\n      if (!lst) {\n        st.r = pos & 7 | w[pos / 8 | 0] << 3;\n        // shft(pos) now 1 less if pos & 7 != 0\n        pos -= 7;\n        st.h = head, st.p = prev, st.i = _i23, st.w = wi;\n      }\n    } else {\n      for (var _i24 = st.w || 0; _i24 < s + lst; _i24 += 65535) {\n        // end\n        var e = _i24 + 65535;\n        if (e >= s) {\n          // write final block\n          w[pos / 8 | 0] = lst;\n          e = s;\n        }\n        pos = wfblk(w, pos + 1, dat.subarray(_i24, e));\n      }\n      st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n  };\n  // Adler32\n  var adler = function adler() {\n    var a = 1,\n      b = 0;\n    return {\n      p: function p(d) {\n        // closures have awful performance\n        var n = a,\n          m = b;\n        var l = d.length | 0;\n        for (var _i25 = 0; _i25 != l;) {\n          var e = Math.min(_i25 + 2655, l);\n          for (; _i25 < e; ++_i25) m += n += d[_i25];\n          n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n        }\n        a = n, b = m;\n      },\n      d: function d() {\n        a %= 65521, b %= 65521;\n        return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | b >> 8;\n      }\n    };\n  };\n  // deflate with opts\n  var dopt = function dopt(dat, opt, pre, post, st) {\n    if (!st) {\n      st = {\n        l: 1\n      };\n      if (opt.dictionary) {\n        var dict = opt.dictionary.subarray(-32768);\n        var newDat = new u8(dict.length + dat.length);\n        newDat.set(dict);\n        newDat.set(dat, dict.length);\n        dat = newDat;\n        st.w = dict.length;\n      }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);\n  };\n  // write bytes\n  var wbytes = function wbytes(d, b, v) {\n    for (; v; ++b) d[b] = v, v >>>= 8;\n  };\n  // zlib header\n  var zlh = function zlh(c, o) {\n    var _a, _b;\n    var lv = (_a = o.level) !== null && _a !== void 0 ? _a : 0,\n      fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (((_b = o.dictionary) !== null && _b !== void 0 ? _b : 0) && 32);\n    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;\n    if (o.dictionary) {\n      var h = adler();\n      h.p(o.dictionary);\n      wbytes(c, 2, h.d());\n    }\n  };\n  // zlib start\n  var zls = function zls(d, dict) {\n    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) _err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict) _err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n  };\n  // before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n  /**\n   * Compress data with Zlib\n   * @param data The data to compress\n   * @param opts The compression options\n   * @returns The zlib-compressed version of the data\n   */\n  function zlibSync(data) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n  }\n  /**\n   * Expands Zlib data\n   * @param data The data to decompress\n   * @param opts The decompression options\n   * @returns The decompressed version of the data\n   */\n  function unzlibSync(data) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return inflt(data.subarray(zls(data, opts.dictionary), -4), {\n      i: 2\n    }, opts && opts.out, opts && opts.dictionary);\n  }\n  var CRC32 = /*#__PURE__*/function () {\n    function CRC32() {\n      _classCallCheck(this, CRC32);\n      this.caches = new Map();\n    }\n    return _createClass(CRC32, [{\n      key: \"calculate\",\n      value: function calculate(buff) {\n        if (!(buff instanceof Uint8Array)) {\n          throw new TypeError('Input must be a Uint8Array');\n        }\n        var caches = this.caches;\n        var key = platform.decode.bytesToString(buff);\n        if (caches.has(key)) {\n          return caches.get(key);\n        }\n        var crc = CRC32.WHITE_COLOR;\n        // 使用位运算优化\n        for (var i = 0; i < buff.length; i++) {\n          crc = crc >>> 8 ^ CRC32.table[(crc ^ buff[i]) & 0xff];\n        }\n        caches.set(key, (crc ^ CRC32.WHITE_COLOR) >>> 0);\n        return caches.get(key);\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.caches.clear();\n      }\n    }]);\n  }();\n  // CRC32 Table 初始化\n  CRC32.table = Uint32Array.from(Array(256), function (_, i) {\n    var c = i;\n    for (var j = 0; j < 8; j++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    return c >>> 0;\n  });\n  CRC32.WHITE_COLOR = 0xffffffff;\n  var PNGEncoder = /*#__PURE__*/function () {\n    function PNGEncoder(width, height) {\n      _classCallCheck(this, PNGEncoder);\n      this.width = width;\n      this.height = height;\n      this.crc32 = new CRC32();\n      this.view = new DataView(new ArrayBuffer(4 * width * height));\n    }\n    return _createClass(PNGEncoder, [{\n      key: \"createChunk\",\n      value: function createChunk(type, data) {\n        // 长度（4字节，大端序）\n        var length = new Uint8Array(4);\n        new DataView(length.buffer).setUint32(0, data.length, false);\n        // 块类型（4字节， ASCII）\n        var chunkType = Uint8Array.from(type, function (c) {\n          return c.charCodeAt(0);\n        });\n        // 计算 CRC32 校验（类型 + 数据）\n        var partialChunk = new Uint8Array(chunkType.length + data.length);\n        partialChunk.set(chunkType);\n        partialChunk.set(data, chunkType.length);\n        var crc = new Uint8Array(4);\n        new DataView(crc.buffer).setUint32(0, this.crc32.calculate(partialChunk) >>> 0, false);\n        // 汇总成完整的chunk数据\n        var result = new Uint8Array(length.length + partialChunk.length + crc.length);\n        result.set(length);\n        result.set(partialChunk, length.length);\n        result.set(crc, length.length + partialChunk.length);\n        return result;\n      }\n    }, {\n      key: \"createIHDRChunk\",\n      value: function createIHDRChunk() {\n        var ihdrData = new Uint8Array(13);\n        var view = new DataView(ihdrData.buffer);\n        // 宽度\n        view.setUint32(0, this.width, false);\n        // 高度\n        view.setUint32(4, this.height, false);\n        // 位深度\n        view.setUint8(8, 8);\n        // 颜色类型\n        view.setUint8(9, 6);\n        // 压缩方法\n        view.setUint8(10, 0);\n        // 过滤器方法\n        view.setUint8(11, 0);\n        // 交错方法\n        view.setUint8(12, 0);\n        return this.createChunk(\"IHDR\", ihdrData);\n      }\n    }, {\n      key: \"createIDATChunk\",\n      value: function createIDATChunk() {\n        var width = this.width,\n          height = this.height;\n        var validRowSize = width * 4;\n        // 每行开头添加一位过滤头数据\n        var rowSize = validRowSize + 1;\n        var data = new Uint8Array(rowSize * height);\n        // 将Uint32数据转换为Uint8数据\n        var pixelsData = new Uint8Array(this.view.buffer);\n        var startIdx;\n        var srcStart;\n        for (var y = 0; y < height; y++) {\n          startIdx = y * rowSize;\n          data[startIdx] = 0x00; // 过滤头\n          // ✅ 复制预先转换好的 RGBA 数据\n          srcStart = y * validRowSize; // Uint32 => 每个元素占 4 字节\n          data.set(pixelsData.subarray(srcStart, srcStart + validRowSize), startIdx + 1);\n        }\n        // 使用 zlib 进行压缩, 平衡压缩率有利于提升文件生成速度\n        return this.createChunk(\"IDAT\", zlibSync(data));\n      }\n    }, {\n      key: \"setPixel\",\n      value: function setPixel(x, y, pixel) {\n        this.view.setUint32((y * this.width + x) * 4, pixel, false);\n      }\n    }, {\n      key: \"write\",\n      value: function write(pixels) {\n        var width = this.width,\n          height = this.height;\n        var pos;\n        var r;\n        var g;\n        var b;\n        var a;\n        var pixel;\n        for (var y = 0; y < height; y++) {\n          for (var x = 0; x < width; x++) {\n            pos = (y * width + x) * 4;\n            r = pixels[pos];\n            g = pixels[pos + 1];\n            b = pixels[pos + 2];\n            a = pixels[pos + 3];\n            pixel = (r << 24 | g << 16 | b << 8 | a) >>> 0;\n            this.setPixel(x, y, pixel);\n          }\n        }\n        return this;\n      }\n    }, {\n      key: \"flush\",\n      value: function flush() {\n        // 预先创建所有块\n        var iHDRChunk = this.createIHDRChunk();\n        var iDATChunk = this.createIDATChunk();\n        var iENDChunk = this.createChunk(\"IEND\", new Uint8Array(0));\n        // 一次性分配内存（直接计算总大小）\n        var pngData = new Uint8Array(8 + iHDRChunk.length + iDATChunk.length + iENDChunk.length);\n        /* ------ 按顺序写入数据 ------ */\n        // 1. 写入文件头（固定 8 字节）\n        var offset = 0;\n        pngData.set(new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), offset);\n        // 2. 写入IHDR块\n        offset += 8;\n        pngData.set(iHDRChunk, offset);\n        // 3. 写入IDAT块\n        offset += iHDRChunk.length;\n        pngData.set(iDATChunk, offset);\n        // 4. 写入IEND块\n        offset += iDATChunk.length;\n        pngData.set(iENDChunk, offset);\n        /* ------ 清空 CRC32 缓存 ------ */\n        this.crc32.clear();\n        return pngData;\n      }\n    }]);\n  }(); // ---------------------------------------------------------------------\n  // qrBitBuffer\n  // ---------------------------------------------------------------------\n  var BitBuffer = /*#__PURE__*/function () {\n    function BitBuffer() {\n      _classCallCheck(this, BitBuffer);\n      this.buffer = [];\n      this.lengthInBits = 0;\n    }\n    return _createClass(BitBuffer, [{\n      key: \"getAt\",\n      value: function getAt(i) {\n        var bufIndex = ~~(i / 8);\n        return (this.buffer[bufIndex] >>> 7 - i % 8 & 1) === 1;\n      }\n    }, {\n      key: \"put\",\n      value: function put(num, length) {\n        for (var i = 0; i < length; i++) {\n          this.putBit((num >>> length - i - 1 & 1) === 1);\n        }\n      }\n    }, {\n      key: \"putBit\",\n      value: function putBit(bit) {\n        var len = this.lengthInBits,\n          buffer = this.buffer;\n        var bufIndex = ~~(len / 8);\n        if (buffer.length <= bufIndex) {\n          buffer.push(0);\n        }\n        if (bit) {\n          buffer[bufIndex] |= 0x80 >>> len % 8;\n        }\n        this.lengthInBits += 1;\n      }\n    }]);\n  }(); // ---------------------------------------------------------------------\n  // QRMode\n  // ---------------------------------------------------------------------\n  var QRMode = {\n    MODE_NUMBER: 1 << 0,\n    MODE_ALPHA_NUM: 1 << 1,\n    MODE_8BIT_BYTE: 1 << 2,\n    MODE_KANJI: 1 << 3\n  };\n  // ---------------------------------------------------------------------\n  // QRErrorCorrectLevel\n  // ---------------------------------------------------------------------\n  var QRErrorCorrectLevel = {\n    L: 1,\n    M: 0,\n    Q: 3,\n    H: 2\n  };\n  // ---------------------------------------------------------------------\n  // QRMaskPattern\n  // ---------------------------------------------------------------------\n  var QRMaskPattern = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7\n  };\n  var BitByte = /*#__PURE__*/function () {\n    function BitByte(data) {\n      _classCallCheck(this, BitByte);\n      var parsedData = [];\n      // Added to support UTF-8 Characters\n      for (var i = 0; i < data.length; i++) {\n        var byteArray = [];\n        var code = data.charCodeAt(i);\n        if (code > 0x10000) {\n          byteArray[0] = 0xf0 | (code & 0x1c0000) >>> 18;\n          byteArray[1] = 0x80 | (code & 0x3f000) >>> 12;\n          byteArray[2] = 0x80 | (code & 0xfc0) >>> 6;\n          byteArray[3] = 0x80 | code & 0x3f;\n        } else if (code > 0x800) {\n          byteArray[0] = 0xe0 | (code & 0xf000) >>> 12;\n          byteArray[1] = 0x80 | (code & 0xfc0) >>> 6;\n          byteArray[2] = 0x80 | code & 0x3f;\n        } else if (code > 0x80) {\n          byteArray[0] = 0xc0 | (code & 0x7c0) >>> 6;\n          byteArray[1] = 0x80 | code & 0x3f;\n        } else {\n          byteArray[0] = code;\n        }\n        // Fix Unicode corruption bug\n        parsedData.push(byteArray);\n      }\n      this.bytes = parsedData.flat(1);\n      var bytes = this.bytes;\n      if (bytes.length !== data.length) {\n        bytes.unshift(191);\n        bytes.unshift(187);\n        bytes.unshift(239);\n      }\n    }\n    return _createClass(BitByte, [{\n      key: \"mode\",\n      get: function get() {\n        return QRMode.MODE_8BIT_BYTE;\n      }\n    }, {\n      key: \"length\",\n      get: function get() {\n        return this.bytes.length;\n      }\n    }, {\n      key: \"write\",\n      value: function write(buff) {\n        var bytes = this.bytes;\n        for (var i = 0; i < bytes.length; i++) {\n          buff.put(bytes[i], 8);\n        }\n      }\n    }]);\n  }();\n  var RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];\n  var RSBlock = /*#__PURE__*/function () {\n    function RSBlock() {\n      _classCallCheck(this, RSBlock);\n    }\n    return _createClass(RSBlock, [{\n      key: \"getRSBlockTable\",\n      value: function getRSBlockTable(typeNumber, errorCorrectLevel) {\n        var L = QRErrorCorrectLevel.L,\n          M = QRErrorCorrectLevel.M,\n          Q = QRErrorCorrectLevel.Q,\n          H = QRErrorCorrectLevel.H;\n        var pos = (typeNumber - 1) * 4;\n        switch (errorCorrectLevel) {\n          case L:\n            return RS_BLOCK_TABLE[pos + 0];\n          case M:\n            return RS_BLOCK_TABLE[pos + 1];\n          case Q:\n            return RS_BLOCK_TABLE[pos + 2];\n          case H:\n            return RS_BLOCK_TABLE[pos + 3];\n          default:\n            throw new Error(\"bad rs block @ typeNumber:\".concat(typeNumber, \"/errorCorrectLevel: \").concat(errorCorrectLevel));\n        }\n      }\n    }, {\n      key: \"getRSBlocks\",\n      value: function getRSBlocks(typeNumber, errorCorrectLevel) {\n        var rsBlock = this.getRSBlockTable(typeNumber, errorCorrectLevel);\n        var length = rsBlock.length / 3;\n        var list = [];\n        for (var i = 0; i < length; i++) {\n          var count = rsBlock[i * 3];\n          var totalCount = rsBlock[i * 3 + 1];\n          var dataCount = rsBlock[i * 3 + 2];\n          for (var j = 0; j < count; j++) {\n            list.push({\n              totalCount: totalCount,\n              dataCount: dataCount\n            });\n          }\n        }\n        return list;\n      }\n    }]);\n  }(); // ---------------------------------------------------------------------\n  // QRMath\n  // ---------------------------------------------------------------------\n  var EXP_TABLE = new Array(256);\n  var LOG_TABLE = new Array(256);\n  // initialize tables\n  for (var i = 0; i < 8; i++) {\n    EXP_TABLE[i] = 1 << i;\n  }\n  for (var _i = 8; _i < 256; _i++) {\n    EXP_TABLE[_i] = EXP_TABLE[_i - 4] ^ EXP_TABLE[_i - 5] ^ EXP_TABLE[_i - 6] ^ EXP_TABLE[_i - 8];\n  }\n  for (var _i2 = 0; _i2 < 255; _i2++) {\n    LOG_TABLE[EXP_TABLE[_i2]] = _i2;\n  }\n  var QRMath = {\n    glog: function glog(n) {\n      if (n < 1) {\n        throw new Error(\"glog(\".concat(n, \")\"));\n      }\n      return LOG_TABLE[n];\n    },\n    gexp: function gexp(n) {\n      if (n < 0) {\n        n = 255 + n % 255;\n      } else if (n > 255) {\n        n %= 255;\n      }\n      return EXP_TABLE[n];\n    }\n  };\n  var Polynomial = /*#__PURE__*/function () {\n    function Polynomial(num, shift) {\n      _classCallCheck(this, Polynomial);\n      var length = num.length;\n      if (length === undefined) {\n        throw new Error(\"\".concat(length, \"/\").concat(shift));\n      }\n      var offset = 0;\n      while (offset < length && num[offset] === 0) {\n        offset++;\n      }\n      var len = length - offset;\n      this.num = new Array(len + shift);\n      for (var i = 0; i < len; i++) {\n        this.num[i] = num[i + offset];\n      }\n    }\n    return _createClass(Polynomial, [{\n      key: \"length\",\n      get: function get() {\n        return this.num.length;\n      }\n    }, {\n      key: \"getAt\",\n      value: function getAt(i) {\n        return this.num[i];\n      }\n    }, {\n      key: \"multiply\",\n      value: function multiply(e) {\n        var glog = QRMath.glog,\n          gexp = QRMath.gexp;\n        var num = [];\n        for (var i = 0; i < this.length; i++) {\n          for (var j = 0; j < e.length; j++) {\n            num[i + j] ^= gexp(glog(this.getAt(i)) + glog(e.getAt(j)));\n          }\n        }\n        return new Polynomial(num, 0);\n      }\n    }, {\n      key: \"mod\",\n      value: function mod(e) {\n        if (this.length - e.length < 0) {\n          return this;\n        }\n        var glog = QRMath.glog,\n          gexp = QRMath.gexp;\n        var ratio = glog(this.getAt(0)) - glog(e.getAt(0));\n        var num = [];\n        for (var i = 0; i < this.length; i++) {\n          var n = this.getAt(i);\n          num[i] = i < e.length ? n ^ gexp(glog(e.getAt(i)) + ratio) : n;\n        }\n        // recursive call\n        return new Polynomial(num, 0).mod(e);\n      }\n    }]);\n  }();\n  var PATTERN_POSITION_TABLE = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]];\n  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n  var genBCHDigit = function genBCHDigit(data) {\n    return data === 0 ? 0 : Math.log2(data);\n  };\n  var BCH_G15 = genBCHDigit(G15);\n  var BCH_G18 = genBCHDigit(G18);\n  // ---------------------------------------------------------------------\n  // QRUtil\n  // ---------------------------------------------------------------------\n  var Util = {\n    getBCHTypeInfo: function getBCHTypeInfo(data) {\n      var d = data << 10;\n      while (genBCHDigit(d) - BCH_G15 >= 0) {\n        d ^= G15 << genBCHDigit(d) - BCH_G15;\n      }\n      return (data << 10 | d) ^ G15_MASK;\n    },\n    getBCHTypeNumber: function getBCHTypeNumber(data) {\n      var d = data << 12;\n      while (genBCHDigit(d) - BCH_G18 >= 0) {\n        d ^= G18 << genBCHDigit(d) - BCH_G18;\n      }\n      return data << 12 | d;\n    },\n    getPatternPosition: function getPatternPosition(typeNumber) {\n      return PATTERN_POSITION_TABLE[typeNumber - 1];\n    },\n    getMaskFunction: function getMaskFunction(maskPattern) {\n      var PATTERN000 = QRMaskPattern.PATTERN000,\n        PATTERN001 = QRMaskPattern.PATTERN001,\n        PATTERN010 = QRMaskPattern.PATTERN010,\n        PATTERN011 = QRMaskPattern.PATTERN011,\n        PATTERN100 = QRMaskPattern.PATTERN100,\n        PATTERN101 = QRMaskPattern.PATTERN101,\n        PATTERN110 = QRMaskPattern.PATTERN110,\n        PATTERN111 = QRMaskPattern.PATTERN111;\n      switch (maskPattern) {\n        case PATTERN000:\n          return function (i, j) {\n            return (i + j) % 2 === 0;\n          };\n        case PATTERN001:\n          return function (i) {\n            return i % 2 === 0;\n          };\n        case PATTERN010:\n          return function (_i, j) {\n            return j % 3 === 0;\n          };\n        case PATTERN011:\n          return function (i, j) {\n            return (i + j) % 3 === 0;\n          };\n        case PATTERN100:\n          return function (i, j) {\n            return (~~(i / 2) + ~~(j / 3)) % 2 === 0;\n          };\n        case PATTERN101:\n          return function (i, j) {\n            return i * j % 2 + i * j % 3 === 0;\n          };\n        case PATTERN110:\n          return function (i, j) {\n            return (i * j % 2 + i * j % 3) % 2 === 0;\n          };\n        case PATTERN111:\n          return function (i, j) {\n            return (i * j % 3 + (i + j) % 2) % 2 === 0;\n          };\n        default:\n          throw new Error(\"bad maskPattern: \".concat(maskPattern));\n      }\n    },\n    getErrorCorrectPolynomial: function getErrorCorrectPolynomial(errorCorrectLength) {\n      var a = new Polynomial([1], 0);\n      for (var i = 0; i < errorCorrectLength; i++) {\n        a = a.multiply(new Polynomial([1, QRMath.gexp(i)], 0));\n      }\n      return a;\n    },\n    getLengthInBits: function getLengthInBits(mode, type) {\n      var MODE_NUMBER = QRMode.MODE_NUMBER,\n        MODE_ALPHA_NUM = QRMode.MODE_ALPHA_NUM,\n        MODE_8BIT_BYTE = QRMode.MODE_8BIT_BYTE,\n        MODE_KANJI = QRMode.MODE_KANJI;\n      if (type < 1 || type > 40) {\n        throw new Error(\"type: \".concat(type));\n      }\n      if (type >= 1 && type < 10) {\n        // 1 - 9\n        switch (mode) {\n          case MODE_NUMBER:\n            return 10;\n          case MODE_ALPHA_NUM:\n            return 9;\n          case MODE_8BIT_BYTE:\n            return 8;\n          case MODE_KANJI:\n            return 8;\n        }\n      }\n      if (type < 27) {\n        // 10 - 26\n        switch (mode) {\n          case MODE_NUMBER:\n            return 12;\n          case MODE_ALPHA_NUM:\n            return 11;\n          case MODE_8BIT_BYTE:\n            return 16;\n          case MODE_KANJI:\n            return 10;\n        }\n      }\n      if (type <= 40) {\n        // 27 - 40\n        switch (mode) {\n          case MODE_NUMBER:\n            return 14;\n          case MODE_ALPHA_NUM:\n            return 13;\n          case MODE_8BIT_BYTE:\n            return 16;\n          case MODE_KANJI:\n            return 12;\n        }\n      }\n      throw new Error(\"mode: \".concat(mode));\n    },\n    getLostPoint: function getLostPoint(qr) {\n      var moduleCount = qr.getModuleCount();\n      var lostPoint = 0;\n      // LEVEL1\n      for (var row = 0; row < moduleCount; row++) {\n        for (var col = 0; col < moduleCount; col++) {\n          var dark = qr.isDark(row, col);\n          var sameCount = 0;\n          for (var r = -1; r <= 1; r++) {\n            var nRow = row + r;\n            if (nRow < 0 || moduleCount <= nRow) continue;\n            for (var c = -1; c <= 1; c++) {\n              var nCol = col + c;\n              if (nCol < 0 || moduleCount <= nCol) continue;\n              if (r === 0 && c === 0) continue;\n              if (dark === qr.isDark(nRow, nCol)) {\n                sameCount++;\n              }\n            }\n          }\n          if (sameCount > 5) {\n            lostPoint += sameCount + 3 - 5;\n          }\n        }\n      }\n      // LEVEL2\n      for (var _row = 0; _row < moduleCount - 1; _row++) {\n        for (var _col = 0; _col < moduleCount - 1; _col++) {\n          var count = 0;\n          if (qr.isDark(_row, _col)) count++;\n          if (qr.isDark(_row + 1, _col)) count++;\n          if (qr.isDark(_row, _col + 1)) count++;\n          if (qr.isDark(_row + 1, _col + 1)) count++;\n          if (count === 0 || count === 4) {\n            lostPoint += 3;\n          }\n        }\n      }\n      // LEVEL3\n      for (var _row2 = 0; _row2 < moduleCount; _row2++) {\n        for (var _col2 = 0; _col2 < moduleCount - 6; _col2++) {\n          if (qr.isDark(_row2, _col2) && !qr.isDark(_row2, _col2 + 1) && qr.isDark(_row2, _col2 + 2) && qr.isDark(_row2, _col2 + 3) && qr.isDark(_row2, _col2 + 4) && !qr.isDark(_row2, _col2 + 5) && qr.isDark(_row2, _col2 + 6)) {\n            lostPoint += 40;\n          }\n        }\n      }\n      for (var _col3 = 0; _col3 < moduleCount; _col3++) {\n        for (var _row3 = 0; _row3 < moduleCount - 6; _row3++) {\n          if (qr.isDark(_row3, _col3) && !qr.isDark(_row3 + 1, _col3) && qr.isDark(_row3 + 2, _col3) && qr.isDark(_row3 + 3, _col3) && qr.isDark(_row3 + 4, _col3) && !qr.isDark(_row3 + 5, _col3) && qr.isDark(_row3 + 6, _col3)) {\n            lostPoint += 40;\n          }\n        }\n      }\n      // LEVEL4\n      var darkCount = 0;\n      for (var _col4 = 0; _col4 < moduleCount; _col4++) {\n        for (var _row4 = 0; _row4 < moduleCount; _row4++) {\n          if (qr.isDark(_row4, _col4)) {\n            darkCount++;\n          }\n        }\n      }\n      var ratio = Math.abs(100 * darkCount / Math.pow(moduleCount, 2) - 50) / 5;\n      return lostPoint + ratio * 10;\n    }\n  };\n  var PAD0 = 0xec;\n  var PAD1 = 0x11;\n  /**\n   * QRCode实现\n   * https://www.cnblogs.com/leestar54/p/15782929.html\n   * @param typeNumber 1 to 40\n   * @param errorCorrectLevel 'L','M','Q','H'\n   */\n  var QRCode = /*#__PURE__*/function () {\n    function QRCode(typeNumber, errorCorrectLevel) {\n      _classCallCheck(this, QRCode);\n      this.typeNumber = typeNumber;\n      this.modules = [];\n      this.moduleCount = 0;\n      this.dataCache = null;\n      this.dataList = [];\n      this.errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];\n    }\n    return _createClass(QRCode, [{\n      key: \"makeImpl\",\n      value: function makeImpl(test, maskPattern) {\n        this.moduleCount = this.typeNumber * 4 + 17;\n        this.modules = function (moduleCount) {\n          var modules = [];\n          // 预设一个 moduleCount * moduleCount 的空白矩阵\n          for (var row = 0; row < moduleCount; row++) {\n            modules[row] = [];\n            for (var col = 0; col < moduleCount; col++) {\n              modules[row][col] = null;\n            }\n          }\n          return modules;\n        }(this.moduleCount);\n        var count = this.moduleCount - 7;\n        this.setupPositionProbePattern(0, 0);\n        this.setupPositionProbePattern(count, 0);\n        this.setupPositionProbePattern(0, count);\n        this.setupPositionAdjustPattern();\n        this.setupTimingPattern();\n        this.setupTypeInfo(test, maskPattern);\n        if (this.typeNumber >= 7) {\n          this.setupTypeNumber(test);\n        }\n        if (this.dataCache === null) {\n          this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);\n        }\n        this.mapData(this.dataCache, maskPattern);\n      }\n    }, {\n      key: \"setupPositionProbePattern\",\n      value: function setupPositionProbePattern(row, col) {\n        var modules = this.modules,\n          moduleCount = this.moduleCount;\n        for (var r = -1; r <= 7; r++) {\n          var nr = row + r;\n          if (nr <= -1 || moduleCount <= nr) continue;\n          for (var c = -1; c <= 7; c++) {\n            var nc = col + c;\n            if (nc <= -1 || moduleCount <= nc) continue;\n            modules[nr][nc] = r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4;\n          }\n        }\n      }\n    }, {\n      key: \"setupPositionAdjustPattern\",\n      value: function setupPositionAdjustPattern() {\n        var typeNumber = this.typeNumber,\n          modules = this.modules;\n        var pos = Util.getPatternPosition(typeNumber);\n        var length = pos.length;\n        for (var i = 0; i < length; i++) {\n          for (var j = 0; j < length; j++) {\n            var row = pos[i];\n            var col = pos[j];\n            if (modules[row][col] != null) continue;\n            for (var r = -2; r <= 2; r++) {\n              for (var c = -2; c <= 2; c++) {\n                modules[row + r][col + c] = r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0;\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"setupTimingPattern\",\n      value: function setupTimingPattern() {\n        var moduleCount = this.moduleCount,\n          modules = this.modules;\n        var count = moduleCount - 8;\n        for (var r = 8; r < count; r++) {\n          if (modules[r][6] != null) continue;\n          modules[r][6] = r % 2 === 0;\n        }\n        for (var c = 8; c < count; c++) {\n          if (modules[6][c] != null) continue;\n          modules[6][c] = c % 2 === 0;\n        }\n      }\n    }, {\n      key: \"setupTypeInfo\",\n      value: function setupTypeInfo(test, maskPattern) {\n        var errorCorrectLevel = this.errorCorrectLevel,\n          modules = this.modules,\n          moduleCount = this.moduleCount;\n        var data = errorCorrectLevel << 3 | maskPattern;\n        var bits = Util.getBCHTypeInfo(data);\n        // vertical\n        for (var i = 0; i < 15; i++) {\n          var mod = !test && (bits >> i & 1) === 1;\n          if (i < 6) {\n            modules[i][8] = mod;\n          } else if (i < 8) {\n            modules[i + 1][8] = mod;\n          } else {\n            modules[moduleCount - 15 + i][8] = mod;\n          }\n        }\n        // horizontal\n        for (var _i = 0; _i < 15; _i++) {\n          var _mod = !test && (bits >> _i & 1) === 1;\n          if (_i < 8) {\n            modules[8][moduleCount - _i - 1] = _mod;\n          } else if (_i < 9) {\n            modules[8][15 - _i] = _mod;\n          } else {\n            modules[8][15 - _i - 1] = _mod;\n          }\n        }\n        // fixed module\n        modules[moduleCount - 8][8] = !test;\n      }\n    }, {\n      key: \"getBestMaskPattern\",\n      value: function getBestMaskPattern() {\n        var minLostPoint = 0;\n        var pattern = 0;\n        for (var i = 0; i < 8; i++) {\n          this.makeImpl(true, i);\n          var lostPoint = Util.getLostPoint(this);\n          if (i === 0 || minLostPoint > lostPoint) {\n            minLostPoint = lostPoint;\n            pattern = i;\n          }\n        }\n        return pattern;\n      }\n    }, {\n      key: \"setupTypeNumber\",\n      value: function setupTypeNumber(test) {\n        var typeNumber = this.typeNumber,\n          modules = this.modules,\n          moduleCount = this.moduleCount;\n        var bits = Util.getBCHTypeNumber(typeNumber);\n        for (var i = 0; i < 18; i++) {\n          var mod = !test && (bits >> i & 1) === 1;\n          modules[~~(i / 3)][i % 3 + moduleCount - 8 - 3] = mod;\n          modules[i % 3 + moduleCount - 8 - 3][~~(i / 3)] = mod;\n        }\n      }\n    }, {\n      key: \"createData\",\n      value: function createData(typeNumber, errorCorrectLevel, dataList) {\n        var rsBlocks = new RSBlock().getRSBlocks(typeNumber, errorCorrectLevel);\n        var buffer = new BitBuffer();\n        for (var i = 0; i < dataList.length; i++) {\n          var data = dataList[i];\n          buffer.put(data.mode, 4);\n          buffer.put(data.length, Util.getLengthInBits(data.mode, typeNumber));\n          data.write(buffer);\n        }\n        // calc num max data.\n        var totalDataCount = 0;\n        for (var _i2 = 0; _i2 < rsBlocks.length; _i2++) {\n          totalDataCount += rsBlocks[_i2].dataCount;\n        }\n        var totalCount = totalDataCount * 8;\n        if (buffer.lengthInBits > totalCount) {\n          throw new Error(\"code length overflow. (\".concat(buffer.lengthInBits, \" > \").concat(totalCount, \")\"));\n        }\n        // end code\n        if (buffer.lengthInBits + 4 <= totalCount) {\n          buffer.put(0, 4);\n        }\n        // padding\n        while (buffer.lengthInBits % 8 !== 0) {\n          buffer.putBit(false);\n        }\n        // padding\n        while (true) {\n          if (buffer.lengthInBits >= totalCount) {\n            break;\n          }\n          buffer.put(PAD0, 8);\n          if (buffer.lengthInBits >= totalCount) {\n            break;\n          }\n          buffer.put(PAD1, 8);\n        }\n        return this.createBytes(buffer, rsBlocks);\n      }\n    }, {\n      key: \"mapData\",\n      value: function mapData(data, maskPattern) {\n        var modules = this.modules,\n          moduleCount = this.moduleCount;\n        var maskFunc = Util.getMaskFunction(maskPattern);\n        var inc = -1;\n        var row = moduleCount - 1;\n        var bitIndex = 7;\n        var byteIndex = 0;\n        for (var col = row; col > 0; col -= 2) {\n          if (col === 6) col -= 1;\n          while (true) {\n            for (var c = 0; c < 2; c++) {\n              if (modules[row][col - c] == null) {\n                var dark = false;\n                if (byteIndex < data.length) {\n                  dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n                }\n                if (maskFunc(row, col - c)) {\n                  dark = !dark;\n                }\n                modules[row][col - c] = dark;\n                bitIndex--;\n                if (bitIndex === -1) {\n                  byteIndex++;\n                  bitIndex = 7;\n                }\n              }\n            }\n            row += inc;\n            if (row < 0 || moduleCount <= row) {\n              row -= inc;\n              inc = -inc;\n              break;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"createBytes\",\n      value: function createBytes(bitBuffer, rsBlocks) {\n        var dcdata = [];\n        var ecdata = [];\n        var offset = 0;\n        var maxDcCount = 0;\n        var maxEcCount = 0;\n        for (var r = 0; r < rsBlocks.length; r++) {\n          var dcCount = rsBlocks[r].dataCount;\n          var ecCount = rsBlocks[r].totalCount - dcCount;\n          maxDcCount = Math.max(maxDcCount, dcCount);\n          maxEcCount = Math.max(maxEcCount, ecCount);\n          dcdata[r] = [];\n          for (var i = 0; i < dcCount; i++) {\n            dcdata[r][i] = 0xff & bitBuffer.buffer[i + offset];\n          }\n          offset += dcCount;\n          var rsPoly = Util.getErrorCorrectPolynomial(ecCount);\n          var rawPoly = new Polynomial(dcdata[r], rsPoly.length - 1);\n          var modPoly = rawPoly.mod(rsPoly);\n          ecdata[r] = new Array(rsPoly.length - 1);\n          for (var _i3 = 0; _i3 < ecdata[r].length; _i3++) {\n            var modIndex = _i3 + modPoly.length - ecdata[r].length;\n            ecdata[r][_i3] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n          }\n        }\n        var totalCodeCount = 0;\n        for (var _i4 = 0; _i4 < rsBlocks.length; _i4++) {\n          totalCodeCount += rsBlocks[_i4].totalCount;\n        }\n        var data = new Array(totalCodeCount);\n        var index = 0;\n        for (var _i5 = 0; _i5 < maxDcCount; _i5++) {\n          for (var _r = 0; _r < rsBlocks.length; _r++) {\n            if (_i5 < dcdata[_r].length) {\n              data[index++] = dcdata[_r][_i5];\n            }\n          }\n        }\n        for (var _i6 = 0; _i6 < maxEcCount; _i6++) {\n          for (var _r2 = 0; _r2 < rsBlocks.length; _r2++) {\n            if (_i6 < ecdata[_r2].length) {\n              data[index++] = ecdata[_r2][_i6];\n            }\n          }\n        }\n        return data;\n      }\n    }, {\n      key: \"isDark\",\n      value: function isDark(row, col) {\n        var moduleCount = this.moduleCount;\n        if (row < 0 || moduleCount <= row || col < 0 || moduleCount <= col) {\n          throw new Error(\"\".concat(row, \", \").concat(col));\n        }\n        return this.modules[row][col];\n      }\n    }, {\n      key: \"addData\",\n      value: function addData(data) {\n        this.dataList.push(new BitByte(data));\n        this.dataCache = null;\n      }\n    }, {\n      key: \"getModuleCount\",\n      value: function getModuleCount() {\n        return this.moduleCount;\n      }\n    }, {\n      key: \"make\",\n      value: function make() {\n        this.makeImpl(false, this.getBestMaskPattern());\n      }\n    }]);\n  }(); /**\n       * SVGA 下载解析器\n       */\n  var Parser = /*#__PURE__*/function () {\n    function Parser() {\n      _classCallCheck(this, Parser);\n    }\n    return _createClass(Parser, null, [{\n      key: \"decompress\",\n      value:\n      /**\n       * 解压视频源文件\n       * @param data\n       * @returns\n       */\n      function decompress(data) {\n        return unzlibSync(new Uint8Array(data)).buffer;\n      }\n      /**\n       * 解析视频实体\n       * @param data 视频二进制数据\n       * @param url 视频地址\n       * @param needDecompress 是否解压\n       * @returns\n       */\n    }, {\n      key: \"parseVideo\",\n      value: function parseVideo(data, url) {\n        var needDecompress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        return createVideoEntity(new Uint8Array(needDecompress ? this.decompress(data) : data), platform.path.filename(url));\n      }\n      /**\n       * 读取文件资源\n       * @param url 文件资源地址\n       * @returns\n       */\n    }, {\n      key: \"download\",\n      value: function download(url) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n          var globals, remote, path, local, env, supportLocal, filepath, buff, _t;\n          return _regenerator().w(function (_context) {\n            while (1) switch (_context.p = _context.n) {\n              case 0:\n                globals = platform.globals, remote = platform.remote, path = platform.path, local = platform.local;\n                env = globals.env;\n                supportLocal = env !== \"h5\" && env !== \"tt\";\n                filepath = path.is(url) ? url : path.resolve(path.filename(url)); // 本地读取\n                if (!supportLocal) {\n                  _context.n = 2;\n                  break;\n                }\n                _context.n = 1;\n                return local.exists(filepath);\n              case 1:\n                if (!_context.v) {\n                  _context.n = 2;\n                  break;\n                }\n                return _context.a(2, local.read(filepath));\n              case 2:\n                _context.n = 3;\n                return remote.fetch(url);\n              case 3:\n                buff = _context.v;\n                if (!supportLocal) {\n                  _context.n = 7;\n                  break;\n                }\n                _context.p = 4;\n                _context.n = 5;\n                return local.write(buff, filepath);\n              case 5:\n                _context.n = 7;\n                break;\n              case 6:\n                _context.p = 6;\n                _t = _context.v;\n                // eslint-disable-next-line no-console\n                console.error(_t);\n              case 7:\n                return _context.a(2, buff);\n            }\n          }, _callee, null, [[4, 6]]);\n        }));\n      }\n      /**\n       * 通过 url 下载并解析 SVGA 文件\n       * @param url SVGA 文件的下载链接\n       * @returns Promise<SVGA 数据源\n       */\n    }, {\n      key: \"load\",\n      value: function load(url) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee2() {\n          var _t2, _t3, _t4;\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                _t2 = Parser;\n                _context2.n = 1;\n                return Parser.download(url);\n              case 1:\n                _t3 = _context2.v;\n                _t4 = url;\n                return _context2.a(2, _t2.parseVideo.call(_t2, _t3, _t4));\n            }\n          }, _callee2);\n        }));\n      }\n    }]);\n  }();\n  var noop = platform.noop;\n  var Painter = /*#__PURE__*/function () {\n    /**\n     *\n     * @param mode\n     * @param W 海报模式必须传入\n     * @param H 海报模式必须传入\n     */\n    function Painter() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"dual\";\n      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      _classCallCheck(this, Painter);\n      this.mode = mode;\n      /**\n       * 主屏的 Canvas 元素\n       * Front Screen\n       */\n      this.F = null;\n      /**\n       * 主屏的 Context 对象\n       * Front Context\n       */\n      this.FC = null;\n      /**\n       * 副屏的 Canvas 元素\n       * Background Screen\n       */\n      this.B = null;\n      /**\n       * 副屏的 Context 对象\n       * Background Context\n       */\n      this.BC = null;\n      /**\n       * 粉刷模式\n       */\n      this.model = {};\n      /**\n       * 渲染器实例\n       */\n      this.renderer = null;\n      this.clearContainer = noop;\n      this.clearSecondary = noop;\n      this.resize = noop;\n      this.draw = noop;\n      this.stick = noop;\n      var dpr = platform.globals.dpr;\n      this.W = width * dpr;\n      this.H = height * dpr;\n    }\n    /**\n     * 设置 Canvas 的处理模式\n     * - C：代表 Canvas\n     * - O：代表 OffscreenCanvas\n     */\n    return _createClass(Painter, [{\n      key: \"setActionModel\",\n      value: function setActionModel(type) {\n        var model = this.model;\n        var env = platform.globals.env;\n        // set type\n        model.type = type;\n        // set clear\n        if (type === \"O\" && env === \"tt\" || env === \"alipay\") {\n          model.clear = \"CL\";\n        } else {\n          model.clear = \"RE\";\n        }\n      }\n      /**\n       * 注册画笔，根据环境判断生成最优的绘制方式\n       * @param selector\n       * @param ofsSelector\n       * @param component\n       */\n    }, {\n      key: \"register\",\n      value: function register(selector, ofsSelector, component) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n          var model, mode, getCanvas, getOfsCanvas, env, _W, _H, _getOfsCanvas, canvas, context, _yield$getCanvas, _canvas, _context, FC, F, W, H, clearType, ofsResult, _BC, _B, B, BC, renderer;\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                model = this.model, mode = this.mode;\n                getCanvas = platform.getCanvas, getOfsCanvas = platform.getOfsCanvas;\n                env = platform.globals.env; // #region set main screen implement\n                // -------- 创建主屏 ---------\n                if (!(mode === \"single\" && (env !== \"h5\" || \"OffscreenCanvas\" in globalThis))) {\n                  _context2.n = 1;\n                  break;\n                }\n                _W = this.W, _H = this.H;\n                _getOfsCanvas = getOfsCanvas({\n                  width: _W,\n                  height: _H\n                }), canvas = _getOfsCanvas.canvas, context = _getOfsCanvas.context; // 添加主屏\n                this.F = canvas;\n                this.FC = context;\n                this.setActionModel(\"O\");\n                _context2.n = 3;\n                break;\n              case 1:\n                _context2.n = 2;\n                return getCanvas(selector, component);\n              case 2:\n                _yield$getCanvas = _context2.v;\n                _canvas = _yield$getCanvas.canvas;\n                _context = _yield$getCanvas.context;\n                // 添加主屏\n                this.F = _canvas;\n                this.FC = _context;\n                this.setActionModel(\"C\");\n                if (mode === \"single\") {\n                  _canvas.width = this.W;\n                  _canvas.height = this.H;\n                } else {\n                  this.W = _canvas.width;\n                  this.H = _canvas.height;\n                }\n              case 3:\n                // #endregion set main screen implement\n                FC = this.FC, F = this.F, W = this.W, H = this.H;\n                clearType = model.clear;\n                this.clearContainer = Renderer2DExtension.clear(clearType, FC, F, W, H);\n                if (!(mode === \"single\")) {\n                  _context2.n = 4;\n                  break;\n                }\n                this.B = F;\n                this.BC = FC;\n                this.clearSecondary = this.clearContainer;\n                this.stick = noop;\n                _context2.n = 8;\n                break;\n              case 4:\n                if (!(typeof ofsSelector === \"string\" && ofsSelector !== \"\")) {\n                  _context2.n = 6;\n                  break;\n                }\n                _context2.n = 5;\n                return getCanvas(ofsSelector, component);\n              case 5:\n                ofsResult = _context2.v;\n                ofsResult.canvas.width = W;\n                ofsResult.canvas.height = H;\n                this.setActionModel(\"C\");\n                _context2.n = 7;\n                break;\n              case 6:\n                ofsResult = getOfsCanvas({\n                  width: W,\n                  height: H\n                });\n                this.setActionModel(\"O\");\n              case 7:\n                this.B = ofsResult.canvas;\n                this.BC = ofsResult.context;\n                // #endregion set secondary screen implement\n                _BC = this.BC, _B = this.B;\n                this.clearSecondary = Renderer2DExtension.clear(clearType, _BC, _B, W, H);\n                this.stick = Renderer2DExtension.stick(FC, _B);\n              case 8:\n                // #region other methods implement\n                // ------- 生成其他方法 --------\n                B = this.B, BC = this.BC;\n                renderer = this.renderer = new Renderer2D(BC);\n                this.resize = function (contentMode, videoSize) {\n                  return renderer.resize(contentMode, videoSize, B);\n                };\n                this.draw = function (videoEntity, materials, dynamicMaterials, currentFrame, head, tail) {\n                  return renderer.render(videoEntity, materials, dynamicMaterials, currentFrame, head, tail);\n                };\n              // #endregion other methods implement\n              case 9:\n                return _context2.a(2);\n            }\n          }, _callee, this);\n        }));\n      }\n      /**\n       * 销毁画笔\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var _a;\n        this.clearContainer();\n        this.clearSecondary();\n        this.F = this.FC = this.B = this.BC = null;\n        this.clearContainer = this.clearSecondary = this.stick = noop;\n        (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.destroy();\n      }\n    }]);\n  }();\n  var Config = /*#__PURE__*/function () {\n    function Config() {\n      _classCallCheck(this, Config);\n      /**\n       * 最后停留的目标模式，类似于 animation-fill-mode，默认值 forwards。\n       */\n      this.fillMode = \"backwards\" /* PLAYER_FILL_MODE.BACKWARDS */;\n      /**\n       * 播放模式，默认值 forwards\n       */\n      this.playMode = \"forwards\" /* PLAYER_PLAY_MODE.FORWARDS */;\n      /**\n       * 填充模式，类似于 content-mode。\n       */\n      this.contentMode = \"fill\" /* PLAYER_CONTENT_MODE.FILL */;\n      /**\n       * 开始播放的帧，默认值 0\n       */\n      this.startFrame = 0;\n      /**\n       * 结束播放的帧，默认值 0\n       */\n      this.endFrame = 0;\n      /**\n       * 循环播放的开始帧，默认值 0\n       */\n      this.loopStartFrame = 0;\n      /**\n       * 循环次数，默认值 0（无限循环）\n       */\n      this.loop = 0;\n    }\n    return _createClass(Config, [{\n      key: \"register\",\n      value: function register(config) {\n        if (typeof config.loop === \"number\" && config.loop >= 0) {\n          this.loop = config.loop;\n        }\n        if (config.fillMode && [\"forwards\" /* PLAYER_FILL_MODE.FORWARDS */, \"backwards\" /* PLAYER_FILL_MODE.BACKWARDS */, \"none\" /* PLAYER_FILL_MODE.NONE */].includes(config.fillMode)) {\n          this.fillMode = config.fillMode;\n        }\n        if (config.playMode && [\"forwards\" /* PLAYER_PLAY_MODE.FORWARDS */, \"fallbacks\" /* PLAYER_PLAY_MODE.FALLBACKS */].includes(config.playMode)) {\n          this.playMode = config.playMode;\n        }\n        if (typeof config.startFrame === \"number\" && config.startFrame >= 0) {\n          this.startFrame = config.startFrame;\n        }\n        if (typeof config.endFrame === \"number\" && config.endFrame >= 0) {\n          this.endFrame = config.endFrame;\n        }\n        if (typeof config.loopStartFrame === \"number\" && config.loopStartFrame >= 0) {\n          this.loopStartFrame = config.loopStartFrame;\n        }\n        if (typeof config.contentMode === \"string\") {\n          this.contentMode = config.contentMode;\n        }\n      }\n    }, {\n      key: \"setItem\",\n      value: function setItem(key, value) {\n        this.register(_defineProperty({}, key, value));\n      }\n    }, {\n      key: \"getConfig\",\n      value: function getConfig(entity) {\n        var playMode = this.playMode,\n          loopStartFrame = this.loopStartFrame,\n          startFrame = this.startFrame,\n          endFrame = this.endFrame,\n          fillMode = this.fillMode,\n          loop = this.loop;\n        var fps = entity.fps,\n          sprites = entity.sprites;\n        var frames = entity.frames;\n        var spriteCount = sprites.length;\n        var start = startFrame > 0 ? startFrame : 0;\n        var end = endFrame > 0 && endFrame < frames ? endFrame : frames;\n        // 每帧持续的时间\n        var frameDuration = 1000 / fps;\n        if (start > end) {\n          throw new Error(\"StartFrame should greater than EndFrame\");\n        }\n        // 更新活动帧总数\n        if (end < frames) {\n          frames = end - start;\n        } else if (start > 0) {\n          frames -= start;\n        }\n        var duration = Math.floor(frames * frameDuration * Math.pow(10, 6)) / Math.pow(10, 6);\n        var currFrame = 0;\n        var extFrame = 0;\n        var loopStart;\n        // 顺序播放/倒叙播放\n        if (playMode === \"forwards\" /* PLAYER_PLAY_MODE.FORWARDS */) {\n          // 重置为开始帧\n          currFrame = Math.max(loopStartFrame, startFrame);\n          if (fillMode === \"forwards\" /* PLAYER_FILL_MODE.FORWARDS */) {\n            extFrame = 1;\n          }\n          loopStart = loopStartFrame > start ? (loopStartFrame - start) * frameDuration : 0;\n        } else {\n          // 重置为开始帧\n          currFrame = Math.min(loopStartFrame, end - 1);\n          if (fillMode === \"backwards\" /* PLAYER_FILL_MODE.BACKWARDS */) {\n            extFrame = 1;\n          }\n          loopStart = loopStartFrame < end ? (end - loopStartFrame) * frameDuration : 0;\n        }\n        return {\n          currFrame: currFrame,\n          startFrame: start,\n          endFrame: end,\n          totalFrame: frames,\n          spriteCount: spriteCount,\n          aniConfig: {\n            // 单个周期的运行时长\n            duration: duration,\n            // 第一个周期开始时间偏移量\n            loopStart: loopStart,\n            // 循环次数\n            loop: loop === 0 ? Infinity : loop,\n            // 最后一帧不在周期内，需要单独计算\n            fillValue: extFrame * frameDuration\n          }\n        };\n      }\n    }]);\n  }(); /**\n       * SVGA 播放器\n       */\n  var Player = /*#__PURE__*/function () {\n    function Player() {\n      _classCallCheck(this, Player);\n      /**\n       * 当前配置项\n       */\n      this.config = new Config();\n      /**\n       * 资源管理器\n       */\n      this.resource = null;\n      /**\n       * 刷头实例\n       */\n      this.painter = new Painter();\n      /**\n       * 动画实例\n       */\n      this.animator = new Animator();\n    }\n    /**\n     * 设置配置项\n     * @param options 可配置项\n     * @property container 主屏，播放动画的 Canvas 元素\n     * @property secondary 副屏，播放动画的 Canvas 元素\n     * @property loop 循环次数，默认值 0（无限循环）\n     * @property fillMode 最后停留的目标模式，类似于 animation-fill-mode，接受值 forwards 和 fallbacks，默认值 forwards。\n     * @property playMode 播放模式，接受值 forwards 和 fallbacks ，默认值 forwards。\n     * @property startFrame 单个循环周期内开始播放的帧数，默认值 0\n     * @property endFrame 单个循环周期内结束播放的帧数，默认值 0\n     * @property loopStartFrame 循环播放的开始帧，仅影响第一个周期的开始帧，默认值 0\n     * @property enableInObserver 是否启用 IntersectionObserver 监听容器是否处于浏览器视窗内，默认值 false\n     */\n    return _createClass(Player, [{\n      key: \"setConfig\",\n      value: function setConfig(options, component) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n          var config, container, secondary;\n          return _regenerator().w(function (_context) {\n            while (1) switch (_context.n) {\n              case 0:\n                config = typeof options === \"string\" ? {\n                  container: options\n                } : options;\n                container = config.container, secondary = config.secondary;\n                this.config.register(config);\n                // 监听容器是否处于浏览器视窗内\n                // this.setIntersectionObserver()\n                _context.n = 1;\n                return this.painter.register(container, secondary, component);\n              case 1:\n                this.resource = new ResourceManager(this.painter);\n                this.animator.onAnimate = platform.rAF.bind(null, this.painter.F);\n              case 2:\n                return _context.a(2);\n            }\n          }, _callee, this);\n        }));\n      }\n      /**\n       * 更新配置\n       * @param key\n       * @param value\n       */\n    }, {\n      key: \"setItem\",\n      value: function setItem(key, value) {\n        this.config.setItem(key, value);\n      }\n      /**\n       * 装载 SVGA 数据元\n       * @param videoEntity SVGA 数据源\n       * @returns Promise<void>\n       */\n    }, {\n      key: \"mount\",\n      value: function mount(videoEntity) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee2() {\n          var images, filename;\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                if (videoEntity) {\n                  _context2.n = 1;\n                  break;\n                }\n                throw new Error(\"videoEntity undefined\");\n              case 1:\n                images = videoEntity.images, filename = videoEntity.filename;\n                this.animator.stop();\n                this.painter.clearSecondary();\n                this.resource.release();\n                this.entity = videoEntity;\n                _context2.n = 2;\n                return this.resource.loadImagesWithRecord(images, filename);\n              case 2:\n                return _context2.a(2);\n            }\n          }, _callee2, this);\n        }));\n      }\n      /**\n       * 开始播放\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _a;\n        this.startAnimation();\n        (_a = this.onStart) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n      /**\n       * 重新播放\n       */\n    }, {\n      key: \"resume\",\n      value: function resume() {\n        var _a;\n        if (this.animator.resume()) {\n          (_a = this.onResume) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n      }\n      /**\n       * 暂停播放\n       */\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        var _a;\n        if (this.animator.pause()) {\n          (_a = this.onPause) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n      }\n      /**\n       * 停止播放\n       */\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var _a;\n        this.animator.stop();\n        this.painter.clearContainer();\n        this.painter.clearSecondary();\n        (_a = this.onStop) === null || _a === void 0 ? void 0 : _a.call(this);\n      }\n      /**\n       * 销毁实例\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var _a, _b;\n        this.animator.stop();\n        this.painter.destroy();\n        (_a = this.resource) === null || _a === void 0 ? void 0 : _a.release();\n        (_b = this.resource) === null || _b === void 0 ? void 0 : _b.cleanup();\n        this.entity = undefined;\n      }\n      /**\n       * 跳转到指定帧\n       * @param frame 目标帧\n       * @param andPlay 是否立即播放\n       */\n    }, {\n      key: \"stepToFrame\",\n      value: function stepToFrame(frame) {\n        var andPlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.entity || frame < 0 || frame >= this.entity.frames) return;\n        this.pause();\n        this.config.loopStartFrame = frame;\n        if (andPlay) {\n          this.start();\n        }\n      }\n      /**\n       * 跳转到指定百分比\n       * @param percent 目标百分比\n       * @param andPlay 是否立即播放\n       */\n    }, {\n      key: \"stepToPercentage\",\n      value: function stepToPercentage(percent) {\n        var andPlay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.entity) return;\n        var frames = this.entity.frames;\n        var frame = percent < 0 ? 0 : Math.round(percent * frames);\n        if (frame >= frames) {\n          frame = frames - 1;\n        }\n        debugger;\n        this.stepToFrame(frame, andPlay);\n      }\n      /**\n       * 开始绘制动画\n       */\n    }, {\n      key: \"startAnimation\",\n      value: function startAnimation() {\n        var _this = this;\n        var entity = this.entity,\n          config = this.config,\n          animator = this.animator,\n          painter = this.painter,\n          resource = this.resource;\n        painter.W;\n        painter.H;\n        var materials = resource.materials,\n          dynamicMaterials = resource.dynamicMaterials;\n        var fillMode = config.fillMode,\n          playMode = config.playMode,\n          contentMode = config.contentMode;\n        var _config$getConfig = config.getConfig(entity),\n          currFrame = _config$getConfig.currFrame,\n          startFrame = _config$getConfig.startFrame,\n          endFrame = _config$getConfig.endFrame,\n          totalFrame = _config$getConfig.totalFrame,\n          spriteCount = _config$getConfig.spriteCount,\n          aniConfig = _config$getConfig.aniConfig;\n        var duration = aniConfig.duration,\n          loopStart = aniConfig.loopStart,\n          loop = aniConfig.loop,\n          fillValue = aniConfig.fillValue;\n        var isReverseMode = playMode === \"fallbacks\" /* PLAYER_PLAY_MODE.FALLBACKS */;\n        // 当前帧\n        var currentFrame = currFrame;\n        // 片段绘制结束位置\n        var tail = 0;\n        var nextTail;\n        // 上一帧\n        var latestFrame;\n        // 下一帧\n        var nextFrame;\n        // 精确帧\n        var exactFrame;\n        // 当前已完成的百分比\n        var percent;\n        // 是否还有剩余时间\n        var hasRemained;\n        // 更新动画基础信息\n        animator.setConfig(duration, loopStart, loop, fillValue);\n        painter.resize(contentMode, entity.size);\n        // 分段渲染函数\n        var MAX_DRAW_TIME_PER_FRAME = 8;\n        var MAX_ACCELERATE_DRAW_TIME_PER_FRAME = 3;\n        var MAX_DYNAMIC_CHUNK_SIZE = 34;\n        var MIN_DYNAMIC_CHUNK_SIZE = 1;\n        var render = function render(head, tail) {\n          return painter.draw(entity, materials, dynamicMaterials, currentFrame, head, tail);\n        };\n        // 动态调整每次绘制的块大小\n        var dynamicChunkSize = 4; // 初始块大小\n        var startTime;\n        var chunk;\n        var elapsed;\n        // 使用`指数退避算法`平衡渲染速度和流畅度\n        var patchDraw = function patchDraw(before) {\n          startTime = platform.now();\n          before();\n          while (tail < spriteCount) {\n            // 根据当前块大小计算nextTail\n            chunk = Math.min(dynamicChunkSize, spriteCount - tail);\n            nextTail = tail + chunk | 0;\n            render(tail, nextTail);\n            tail = nextTail;\n            // 动态调整块大小\n            elapsed = platform.now() - startTime;\n            if (elapsed < MAX_ACCELERATE_DRAW_TIME_PER_FRAME) {\n              dynamicChunkSize = Math.min(dynamicChunkSize * 2, MAX_DYNAMIC_CHUNK_SIZE); // 加快绘制\n            } else if (elapsed > MAX_DRAW_TIME_PER_FRAME) {\n              dynamicChunkSize = Math.max(dynamicChunkSize / 2, MIN_DYNAMIC_CHUNK_SIZE); // 减慢绘制\n              break;\n            }\n          }\n        };\n        // 动画绘制过程\n        animator.onUpdate = function (timePercent) {\n          var _a;\n          patchDraw(function () {\n            percent = isReverseMode ? 1 - timePercent : timePercent;\n            exactFrame = percent * totalFrame;\n            if (isReverseMode) {\n              nextFrame = (timePercent === 0 ? endFrame : Math.ceil(exactFrame)) - 1;\n              // FIXME: 倒序会有一帧的偏差，需要校准当前帧\n              percent = currentFrame / totalFrame;\n            } else {\n              nextFrame = timePercent === 1 ? startFrame : Math.floor(exactFrame);\n            }\n            hasRemained = currentFrame === nextFrame;\n          });\n          if (hasRemained) return;\n          if (tail < spriteCount) {\n            render(tail, spriteCount);\n          }\n          painter.clearContainer();\n          painter.stick();\n          painter.clearSecondary();\n          latestFrame = currentFrame;\n          currentFrame = nextFrame;\n          tail = 0;\n          (_a = _this.onProcess) === null || _a === void 0 ? void 0 : _a.call(_this, ~~(percent * 100) / 100, latestFrame);\n        };\n        animator.onStart = function () {\n          entity.locked = true;\n        };\n        animator.onEnd = function () {\n          var _a;\n          entity.locked = false;\n          // 如果不保留最后一帧渲染，则清空画布\n          if (fillMode === \"none\" /* PLAYER_FILL_MODE.NONE */) {\n            painter.clearContainer();\n          }\n          (_a = _this.onEnd) === null || _a === void 0 ? void 0 : _a.call(_this);\n        };\n        animator.start();\n      }\n    }]);\n  }();\n  var Poster = /*#__PURE__*/function () {\n    function Poster(width, height) {\n      _classCallCheck(this, Poster);\n      /**\n       * 海报配置项\n       */\n      this.config = {\n        /**\n         * 主屏，绘制海报的 Canvas 元素\n         */\n        container: \"\",\n        /**\n         * 填充模式，类似于 content-mode。\n         */\n        contentMode: \"fill\" /* PLAYER_CONTENT_MODE.FILL */,\n\n        /**\n         * 绘制成海报的帧，默认是0。\n         */\n        frame: 0\n      };\n      /**\n       * 是否配置完成\n       */\n      this.isConfigured = false;\n      /**\n       * 资源管理器\n       */\n      this.resource = null;\n      this.painter = new Painter(\"single\", width, height);\n    }\n    /**\n     * 注册 SVGA 海报\n     * @param selector 容器选择器\n     * @param component 组件\n     */\n    return _createClass(Poster, [{\n      key: \"register\",\n      value: function register() {\n        return __awaiter(this, arguments, void 0, function () {\n          var _this = this;\n          var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n          var component = arguments.length > 1 ? arguments[1] : undefined;\n          return /*#__PURE__*/_regenerator().m(function _callee() {\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.n) {\n                case 0:\n                  _context.n = 1;\n                  return _this.painter.register(selector, \"\", component);\n                case 1:\n                  _this.resource = new ResourceManager(_this.painter);\n                case 2:\n                  return _context.a(2);\n              }\n            }, _callee);\n          })();\n        });\n      }\n      /**\n       * 设置配置项\n       * @param options 可配置项\n       */\n    }, {\n      key: \"setConfig\",\n      value: function setConfig() {\n        return __awaiter(this, arguments, void 0, function () {\n          var _this2 = this;\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var component = arguments.length > 1 ? arguments[1] : undefined;\n          return /*#__PURE__*/_regenerator().m(function _callee2() {\n            return _regenerator().w(function (_context2) {\n              while (1) switch (_context2.n) {\n                case 0:\n                  if (typeof options === \"string\") {\n                    _this2.config.container = options;\n                  } else {\n                    Object.assign(_this2.config, options);\n                  }\n                  _this2.isConfigured = true;\n                  _context2.n = 1;\n                  return _this2.register(_this2.config.container, component);\n                case 1:\n                  return _context2.a(2);\n              }\n            }, _callee2);\n          })();\n        });\n      }\n      /**\n       * 修改内容模式\n       * @param contentMode\n       */\n    }, {\n      key: \"setContentMode\",\n      value: function setContentMode(contentMode) {\n        this.config.contentMode = contentMode;\n      }\n      /**\n       * 设置当前帧\n       * @param frame\n       */\n    }, {\n      key: \"setFrame\",\n      value: function setFrame(frame) {\n        this.config.frame = frame;\n      }\n      /**\n       * 装载 SVGA 数据元\n       * @param videoEntity SVGA 数据源\n       * @param currFrame\n       * @returns\n       */\n    }, {\n      key: \"mount\",\n      value: function mount(videoEntity) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee3() {\n          var images, filename;\n          return _regenerator().w(function (_context3) {\n            while (1) switch (_context3.n) {\n              case 0:\n                if (videoEntity) {\n                  _context3.n = 1;\n                  break;\n                }\n                throw new Error(\"videoEntity undefined\");\n              case 1:\n                if (this.isConfigured) {\n                  _context3.n = 3;\n                  break;\n                }\n                _context3.n = 2;\n                return this.register();\n              case 2:\n                this.isConfigured = true;\n              case 3:\n                images = videoEntity.images, filename = videoEntity.filename;\n                this.painter.clearContainer();\n                this.resource.release();\n                this.entity = videoEntity;\n                _context3.n = 4;\n                return this.resource.loadImagesWithRecord(images, filename);\n              case 4:\n                return _context3.a(2);\n            }\n          }, _callee3, this);\n        }));\n      }\n      /**\n       * 绘制海报\n       */\n    }, {\n      key: \"draw\",\n      value: function draw() {\n        if (!this.entity) return;\n        var painter = this.painter,\n          resource = this.resource,\n          entity = this.entity,\n          config = this.config;\n        painter.resize(config.contentMode, entity.size);\n        painter.draw(entity, resource.materials, resource.dynamicMaterials, config.frame, 0, entity.sprites.length);\n      }\n      /**\n       * 获取海报的 ImageData 数据\n       */\n    }, {\n      key: \"toImageData\",\n      value: function toImageData() {\n        var _this$painter = this.painter,\n          FC = _this$painter.FC,\n          width = _this$painter.W,\n          height = _this$painter.H;\n        return FC.getImageData(0, 0, width, height);\n      }\n      /**\n       * 销毁海报\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var _a, _b;\n        this.painter.destroy();\n        (_a = this.resource) === null || _a === void 0 ? void 0 : _a.release();\n        (_b = this.resource) === null || _b === void 0 ? void 0 : _b.cleanup();\n        this.entity = undefined;\n      }\n    }]);\n  }();\n  function parseOptions(options) {\n    var _a, _b, _c, _d;\n    var typeNumber = (_a = options.typeNumber) !== null && _a !== void 0 ? _a : 4;\n    var correctLevel = (_b = options.correctLevel) !== null && _b !== void 0 ? _b : \"H\";\n    var codeColor = (_c = options.codeColor) !== null && _c !== void 0 ? _c : \"#000000\";\n    var backgroundColor = (_d = options.backgroundColor) !== null && _d !== void 0 ? _d : \"#FFFFFF\";\n    return {\n      code: options.code,\n      size: options.size,\n      typeNumber: typeNumber,\n      correctLevel: correctLevel,\n      codeColor: codeColor,\n      backgroundColor: backgroundColor\n    };\n  }\n  var calcCellSizeAndPadding = function calcCellSizeAndPadding(moduleCount, size) {\n    var cellSize = ~~(size / moduleCount);\n    return {\n      padding: ~~((size - moduleCount * cellSize) / 2),\n      cellSize: cellSize || 2\n    };\n  };\n  function generateImageBufferFromCode(options) {\n    var _parseOptions = parseOptions(options),\n      code = _parseOptions.code,\n      typeNumber = _parseOptions.typeNumber,\n      correctLevel = _parseOptions.correctLevel,\n      size = _parseOptions.size,\n      codeColor = _parseOptions.codeColor,\n      backgroundColor = _parseOptions.backgroundColor;\n    var qr;\n    try {\n      qr = new QRCode(typeNumber, correctLevel);\n      qr.addData(code);\n      qr.make();\n    } catch (e) {\n      if (typeNumber >= 40) {\n        throw new Error(\"Text too long to encode\");\n      }\n      return arguments.callee({\n        code: code,\n        size: size,\n        correctLevel: correctLevel,\n        typeNumber: typeNumber + 1,\n        codeColor: codeColor,\n        backgroundColor: backgroundColor\n      });\n    }\n    // calc cellsize and margin\n    var moduleCount = qr.getModuleCount();\n    var _calcCellSizeAndPaddi = calcCellSizeAndPadding(moduleCount, size),\n      padding = _calcCellSizeAndPaddi.padding,\n      cellSize = _calcCellSizeAndPaddi.cellSize;\n    var max = moduleCount * cellSize + padding;\n    var CODE_COLOR = +\"\".concat(codeColor.replace(\"#\", \"0x\"), \"FF\");\n    var BACKGROUND_COLOR = +\"\".concat(backgroundColor.replace(\"#\", \"0x\"), \"FF\");\n    var png = new PNGEncoder(size, size);\n    for (var y = 0; y < size; y++) {\n      for (var x = 0; x < size; x++) {\n        if (padding <= x && x < max && padding <= y && y < max) {\n          var c = ~~((x - padding) / cellSize);\n          var r = ~~((y - padding) / cellSize);\n          png.setPixel(x, y, qr.isDark(r, c) ? CODE_COLOR : BACKGROUND_COLOR);\n        } else {\n          png.setPixel(x, y, BACKGROUND_COLOR);\n        }\n      }\n    }\n    return png.flush();\n  }\n  function generateImageFromCode(options) {\n    var buff = generateImageBufferFromCode(options);\n    return platform.decode.toDataURL(buff);\n  } /**\n    * 将 ImageData 转换为 PNG 格式的 Buffer\n    * @param imageData\n    * @returns PNG 格式的 Buffer\n    */\n  function createBufferOfImageData(imageData) {\n    var width = imageData.width,\n      height = imageData.height,\n      data = imageData.data;\n    return new PNGEncoder(width, height).write(data).flush();\n  }\n  /**\n   * @deprecated 请使用 createBufferOfImageData 代替，此方法可能在后续版本中移除\n   */\n  var getBufferFromImageData = createBufferOfImageData;\n  /**\n   * 将 ImageData 转换为 PNG 格式的 Base64 字符串\n   * @param imageData\n   * @returns PNG 格式的 Base64 字符串\n   */\n  function createImageDataUrl(imageData) {\n    return platform.decode.toDataURL(createBufferOfImageData(imageData));\n  }\n  /**\n   * @deprecated 请使用 createImageDataUrl 代替，此方法可能在后续版本中移除\n   */\n  var getDataURLFromImageData = createImageDataUrl; /**\n                                                    * 检查数据是否为zlib压缩格式\n                                                    * @param data 待检查的二进制数据\n                                                    * @returns 是否为zlib压缩格式\n                                                    */\n  function isZlibCompressed(data) {\n    // 检查数据长度是否足够（至少需要2字节头部和4字节ADLER-32校验和）\n    if (data.length < 6) {\n      return false;\n    }\n    // 获取CMF和FLG字节\n    var cmf = data[0];\n    var flg = data[1];\n    // 检查CMF的压缩方法（低4位为8表示DEFLATE）\n    if ((cmf & 0x0f) !== 8) {\n      return false;\n    }\n    // 检查窗口大小（高4位通常为7，但不是严格要求）\n    // - 这里不强制检查，因为理论上可以是其他值\n    // 验证头部校验（CMF * 256 + FLG必须是31的倍数）\n    if ((cmf * 256 + flg) % 31 !== 0) {\n      return false;\n    }\n    // 检查字典标志位（如果设置了字典，需要额外验证，但这种情况很少见）\n    var fdict = (flg & 0x20) !== 0;\n    if (fdict) {\n      // 标准zlib压缩通常不使用预定义字典\n      // 这里假设不使用字典，若检测到字典标志则认为不是标准zlib格式\n      return false;\n    }\n    // 尝试提取ADLER-32校验和并验证其格式\n    // 虽然无法验证校验和值（需要解压后计算），但可以检查其是否为合理的数值\n    var adler32Bytes = data.slice(-4);\n    if (adler32Bytes.length !== 4) {\n      return false;\n    }\n    var adler32 = adler32Bytes[0] << 24 | adler32Bytes[1] << 16 | adler32Bytes[2] << 8 | adler32Bytes[3];\n    // 有效的ADLER-32值应大于0（除非是空数据）\n    if (data.length > 2 && adler32 === 0) {\n      return false;\n    }\n    // 所有检查都通过，数据可能是zlib压缩格式\n    return true;\n  }\n  var VideoManager = /*#__PURE__*/function () {\n    function VideoManager(loadMode, options) {\n      _classCallCheck(this, VideoManager);\n      /**\n       * 视频池的当前指针位置\n       */\n      this.point = 0;\n      /**\n       * 视频的最大留存数量，其他视频将放在磁盘上缓存\n       */\n      this.maxRemain = 3;\n      /**\n       * 留存视频的开始指针位置\n       */\n      this.remainStart = 0;\n      /**\n       * 留存视频的结束指针位置\n       */\n      this.remainEnd = 0;\n      /**\n       * 视频加载模式\n       * - 快速加载模式：可保证当前视频加载完成后，尽快播放；其他请求将使用Promise的方式保存在bucket中，以供后续使用\n       * - 完整加载模式：可保证所有视频加载完成，确保播放切换的流畅性\n       */\n      this.loadMode = \"fast\";\n      /**\n       * 视频池的所有数据\n       */\n      this.buckets = [];\n      this.options = {\n        /**\n         * 预处理动效数据\n         * @param url\n         * @returns\n         */\n        preprocess: function preprocess(bucket) {\n          return Parser.download(bucket.origin);\n        },\n        /**\n         * 后处理动效数据\n         * @param bucket\n         * @param data\n         * @returns\n         */\n        postprocess: function postprocess(bucket, data) {\n          return Parser.parseVideo(data, bucket.origin, true);\n        },\n        /**\n         * 清理数据\n         * @param buckets\n         * @returns\n         */\n        cleanup: function cleanup(buckets) {\n          platform.globals;\n          var local = platform.local,\n            path = platform.path;\n          buckets.forEach(function (bucket) {\n            if (path.is(bucket.local)) {\n              local.remove(bucket.local);\n            }\n          });\n        }\n      };\n      if (typeof loadMode === \"string\") {\n        this.loadMode = loadMode;\n      }\n      Object.assign(this.options, options);\n    }\n    /**\n     * 更新留存指针位置\n     */\n    return _createClass(VideoManager, [{\n      key: \"size\",\n      get:\n      /**\n       * 获取视频池大小\n       */\n      function get() {\n        return this.buckets.length;\n      }\n    }, {\n      key: \"updateRemainRange\",\n      value: function updateRemainRange(point, maxRemain, totalCount) {\n        if (point < 0) {\n          this.point = 0;\n        } else if (point >= totalCount) {\n          this.point = totalCount - 1;\n        } else {\n          this.point = point;\n        }\n        if (this.loadMode === \"whole\") {\n          this.remainStart = 0;\n          this.remainEnd = totalCount;\n        } else {\n          if (maxRemain < 1) {\n            this.maxRemain = 1;\n          } else if (maxRemain > totalCount) {\n            this.maxRemain = totalCount;\n          } else {\n            this.maxRemain = maxRemain;\n          }\n          this.remainStart = this.point - Math.floor(this.maxRemain / 2);\n          if (this.remainStart < 0) {\n            this.remainStart = totalCount + this.remainStart;\n          }\n          this.remainEnd = this.remainStart + this.maxRemain;\n          if (this.remainEnd > totalCount) {\n            this.remainEnd = this.remainEnd % totalCount;\n          }\n        }\n      }\n      /**\n       * 指针是否在留存空间内\n       * @param point\n       * @returns\n       */\n    }, {\n      key: \"includeRemainRange\",\n      value: function includeRemainRange(point) {\n        if (this.remainStart < this.remainEnd) {\n          return point >= this.remainStart && point < this.remainEnd;\n        }\n        if (this.remainStart > this.remainEnd) {\n          return point >= this.remainStart || point < this.remainEnd;\n        }\n        return true;\n      }\n    }, {\n      key: \"downloadAndParseVideo\",\n      value: function downloadAndParseVideo(bucket_1) {\n        return __awaiter(this, arguments, void 0, function (bucket) {\n          var _this = this;\n          var needParse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          return /*#__PURE__*/_regenerator().m(function _callee() {\n            var options, data;\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.n) {\n                case 0:\n                  options = _this.options;\n                  _context.n = 1;\n                  return options.preprocess(bucket);\n                case 1:\n                  data = _context.v;\n                  if (!needParse) {\n                    _context.n = 2;\n                    break;\n                  }\n                  return _context.a(2, options.postprocess(bucket, data));\n                case 2:\n                  return _context.a(2, data);\n              }\n            }, _callee);\n          })();\n        });\n      }\n      /**\n       * 创建bucket\n       * @param url 远程地址\n       * @param point 指针位置\n       * @param needDownloadAndParse 是否需要下载并解析\n       * @returns\n       */\n    }, {\n      key: \"createBucket\",\n      value: function createBucket(url, point, needDownloadAndParse) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee2() {\n          var path, bucket;\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                path = platform.path;\n                bucket = {\n                  origin: url,\n                  local: path.resolve(path.filename(url)),\n                  entity: null,\n                  promise: null\n                };\n                this.buckets[point] = bucket;\n                if (!needDownloadAndParse) {\n                  _context2.n = 2;\n                  break;\n                }\n                _context2.n = 1;\n                return this.downloadAndParseVideo(bucket, true);\n              case 1:\n                bucket.entity = _context2.v;\n                _context2.n = 3;\n                break;\n              case 2:\n                if (this.includeRemainRange(point)) {\n                  bucket.promise = this.downloadAndParseVideo(bucket);\n                }\n              case 3:\n                return _context2.a(2, bucket);\n            }\n          }, _callee2, this);\n        }));\n      }\n      /**\n       * 预加载视频到本地磁盘中\n       * @param urls 视频远程地址\n       * @param point 当前指针位置\n       * @param maxRemain 最大留存数量\n       */\n    }, {\n      key: \"prepare\",\n      value: function prepare(urls_1) {\n        return __awaiter(this, arguments, void 0, function (urls) {\n          var _this2 = this;\n          var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var maxRemain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n          return /*#__PURE__*/_regenerator().m(function _callee3() {\n            var loadMode, currentPoint, needDownloadAndParse, preloadBucket;\n            return _regenerator().w(function (_context3) {\n              while (1) switch (_context3.n) {\n                case 0:\n                  _this2.updateRemainRange(point, maxRemain, urls.length);\n                  loadMode = _this2.loadMode, currentPoint = _this2.point;\n                  needDownloadAndParse = loadMode === \"whole\"; // 优先加载当前动效\n                  _context3.n = 1;\n                  return _this2.createBucket(urls[currentPoint], currentPoint, needDownloadAndParse);\n                case 1:\n                  preloadBucket = _context3.v;\n                  _context3.n = 2;\n                  return Promise.all(urls.map(function (url, index) {\n                    return index === currentPoint ? preloadBucket : _this2.createBucket(url, index, needDownloadAndParse);\n                  }));\n                case 2:\n                  return _context3.a(2);\n              }\n            }, _callee3);\n          })();\n        });\n      }\n      /**\n       * 获取当前帧的bucket\n       * @returns\n       */\n    }, {\n      key: \"get\",\n      value: function get() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee4() {\n          var _this3 = this;\n          var bucket;\n          return _regenerator().w(function (_context4) {\n            while (1) switch (_context4.n) {\n              case 0:\n                bucket = this.buckets[this.point];\n                if (bucket.entity) {\n                  _context4.n = 2;\n                  break;\n                }\n                if (!bucket.promise) {\n                  bucket.promise = this.downloadAndParseVideo(bucket);\n                }\n                _context4.n = 1;\n                return bucket.promise.then(function (data) {\n                  return _this3.options.postprocess(bucket, data);\n                });\n              case 1:\n                bucket.entity = _context4.v;\n                bucket.promise = null;\n              case 2:\n                return _context4.a(2, bucket);\n            }\n          }, _callee4, this);\n        }));\n      }\n      /**\n       * 获取当前的指针位置\n       * @returns\n       */\n    }, {\n      key: \"getPoint\",\n      value: function getPoint() {\n        return this.point;\n      }\n      /**\n       * 获取指定位置的bucket\n       * @param pos\n       * @returns\n       */\n    }, {\n      key: \"go\",\n      value: function go(point) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee5() {\n          var _this4 = this;\n          var size, buckets, loadMode;\n          return _regenerator().w(function (_context5) {\n            while (1) switch (_context5.n) {\n              case 0:\n                size = this.size, buckets = this.buckets, loadMode = this.loadMode;\n                if (!(point < 0 || point >= size)) {\n                  _context5.n = 1;\n                  break;\n                }\n                return _context5.a(2, buckets[this.point]);\n              case 1:\n                this.updateRemainRange(point, this.maxRemain, buckets.length);\n                if (loadMode === \"fast\" && this.maxRemain !== buckets.length) {\n                  buckets.forEach(function (bucket, index) {\n                    if (_this4.includeRemainRange(index)) {\n                      if (bucket.entity === null && bucket.promise === null) {\n                        bucket.promise = _this4.downloadAndParseVideo(bucket);\n                      }\n                    } else {\n                      bucket.entity = null;\n                      bucket.promise = null;\n                    }\n                  });\n                }\n                return _context5.a(2, this.get());\n            }\n          }, _callee5, this);\n        }));\n      }\n      /**\n       * 清理所有的bucket\n       * @returns\n       */\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        return __awaiter(this, arguments, void 0, function () {\n          var _this5 = this;\n          var needRemoveFiles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n          return /*#__PURE__*/_regenerator().m(function _callee6() {\n            var buckets;\n            return _regenerator().w(function (_context6) {\n              while (1) switch (_context6.n) {\n                case 0:\n                  buckets = _this5.buckets;\n                  _this5.point = 0;\n                  _this5.remainStart = 0;\n                  _this5.remainEnd = 0;\n                  _this5.maxRemain = 3;\n                  _this5.buckets = [];\n                  if (!needRemoveFiles) {\n                    _context6.n = 1;\n                    break;\n                  }\n                  _context6.n = 1;\n                  return _this5.options.cleanup(buckets);\n                case 1:\n                  return _context6.a(2);\n              }\n            }, _callee6);\n          })();\n        });\n      }\n    }]);\n  }();\n  var VideoEditor = /*#__PURE__*/function () {\n    function VideoEditor(painter, resource, entity) {\n      _classCallCheck(this, VideoEditor);\n      this.painter = painter;\n      this.resource = resource;\n      this.entity = entity;\n    }\n    return _createClass(VideoEditor, [{\n      key: \"set\",\n      value: function set(key_1, value_1) {\n        return __awaiter(this, arguments, void 0, function (key, value) {\n          var _this = this;\n          var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"R\";\n          return /*#__PURE__*/_regenerator().m(function _callee() {\n            var entity, resource;\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.n) {\n                case 0:\n                  entity = _this.entity, resource = _this.resource;\n                  if (!(mode === \"A\")) {\n                    _context.n = 2;\n                    break;\n                  }\n                  _context.n = 1;\n                  return resource.loadImagesWithRecord(_defineProperty({}, key, value), entity.filename, \"dynamic\");\n                case 1:\n                  _context.n = 3;\n                  break;\n                case 2:\n                  entity.images[key] = value;\n                case 3:\n                  return _context.a(2);\n              }\n            }, _callee);\n          })();\n        });\n      }\n      /**\n       * 获取自定义编辑器\n       * @returns\n       */\n    }, {\n      key: \"getContext\",\n      value: function getContext() {\n        return this.painter.BC;\n      }\n      /**\n       * 是否是有效的Key\n       * @param key\n       * @returns\n       */\n    }, {\n      key: \"hasValidKey\",\n      value: function hasValidKey(key) {\n        var images = this.entity.images;\n        if (typeof Object.hasOwn === \"function\") {\n          return Object.hasOwn(images, key);\n        }\n        return Object.prototype.hasOwnProperty.call(images, key);\n      }\n      /**\n       * 加载并缓存图片\n       * @param source\n       * @param url\n       * @returns\n       */\n    }, {\n      key: \"loadImage\",\n      value: function loadImage(source, url) {\n        return this.resource.loadExtImage(source, platform.path.filename(url));\n      }\n      /**\n       * 创建画布图片\n       * @param key\n       * @param context\n       * @param options\n       * @returns\n       */\n    }, {\n      key: \"setCanvas\",\n      value: function setCanvas(key, context, options) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee2() {\n          var _a, _b, canvas, width, height, imageData;\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                if (!this.entity.locked) {\n                  _context2.n = 1;\n                  break;\n                }\n                return _context2.a(2);\n              case 1:\n                canvas = context.canvas;\n                width = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : canvas.width;\n                height = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : canvas.height;\n                imageData = context.getImageData(0, 0, width, height);\n                this.painter.clearSecondary();\n                _context2.n = 2;\n                return this.set(key, new Uint8Array(createBufferOfImageData(imageData)), options === null || options === void 0 ? void 0 : options.mode);\n              case 2:\n                return _context2.a(2);\n            }\n          }, _callee2, this);\n        }));\n      }\n      /**\n       * 创建二进制图片\n       * @param key\n       * @param buff\n       * @param options\n       * @returns\n       */\n    }, {\n      key: \"setImage\",\n      value: function setImage(key, url, options) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee3() {\n          var _t, _t2, _t3, _t4, _t5, _t6;\n          return _regenerator().w(function (_context3) {\n            while (1) switch (_context3.n) {\n              case 0:\n                if (!this.entity.locked) {\n                  _context3.n = 1;\n                  break;\n                }\n                return _context3.a(2);\n              case 1:\n                if (!url.startsWith(\"data:image\")) {\n                  _context3.n = 3;\n                  break;\n                }\n                _context3.n = 2;\n                return this.set(key, url, options === null || options === void 0 ? void 0 : options.mode);\n              case 2:\n                _context3.n = 5;\n                break;\n              case 3:\n                _t = this;\n                _t2 = key;\n                _t3 = Uint8Array;\n                _context3.n = 4;\n                return Parser.download(url);\n              case 4:\n                _t4 = _context3.v;\n                _t5 = new _t3(_t4);\n                _t6 = options === null || options === void 0 ? void 0 : options.mode;\n                _context3.n = 5;\n                return _t.set.call(_t, _t2, _t5, _t6);\n              case 5:\n                return _context3.a(2);\n            }\n          }, _callee3, this);\n        }));\n      }\n      /**\n       * 创建二维码图片\n       * @param key\n       * @param code\n       * @param options\n       * @returns\n       */\n    }, {\n      key: \"setQRCode\",\n      value: function setQRCode(key, code, options) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee4() {\n          return _regenerator().w(function (_context4) {\n            while (1) switch (_context4.n) {\n              case 0:\n                if (!this.entity.locked) {\n                  _context4.n = 1;\n                  break;\n                }\n                return _context4.a(2);\n              case 1:\n                _context4.n = 2;\n                return this.set(key, new Uint8Array(generateImageBufferFromCode(Object.assign(Object.assign({}, options), {\n                  code: code\n                }))), options === null || options === void 0 ? void 0 : options.mode);\n              case 2:\n                return _context4.a(2);\n            }\n          }, _callee4, this);\n        }));\n      }\n    }]);\n  }();\n  exports.EnhancedPlatform = EnhancedPlatform;\n  exports.Painter = Painter;\n  exports.Parser = Parser;\n  exports.Player = Player;\n  exports.Poster = Poster;\n  exports.VideoEditor = VideoEditor;\n  exports.VideoManager = VideoManager;\n  exports.createBufferOfImageData = createBufferOfImageData;\n  exports.createImageDataUrl = createImageDataUrl;\n  exports.generateImageBufferFromCode = generateImageBufferFromCode;\n  exports.generateImageFromCode = generateImageFromCode;\n  exports.getBufferFromImageData = getBufferFromImageData;\n  exports.getDataURLFromImageData = getDataURLFromImageData;\n  exports.isZlibCompressed = isZlibCompressed;\n  exports.platform = platform;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9mdWNrLXN2Z2EuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi91dGlscy9mdWNrLXN2Z2EuanM/NDViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIChnLCBmKSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGYoZXhwb3J0cykgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGYpIDogKGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZyB8fCBzZWxmLCBmKGcuT2N0b3B1c1N2Z2EgPSB7fSkpO1xufSkodm9pZCAwLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAgIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKG4sIHQsIGUsIHIsIG8sIGEsIGMpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGkgPSBuW2FdKGMpLFxuICAgICAgICB1ID0gaS52YWx1ZTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICByZXR1cm4gdm9pZCBlKG4pO1xuICAgIH1cbiAgICBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7XG4gIH1cbiAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3Iobikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgIGUgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHtcbiAgICAgICAgdmFyIGEgPSBuLmFwcGx5KHQsIGUpO1xuICAgICAgICBmdW5jdGlvbiBfbmV4dChuKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCBuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfdGhyb3cobikge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIF9uZXh0KHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICAgIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG4gIH1cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgICAgdmFyIG8gPSByW3RdO1xuICAgICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8IGZhbHNlLCBvLmNvbmZpZ3VyYWJsZSA9IHRydWUsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gdHJ1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICAgIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pLCBlO1xuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHIsIGUpIHtcbiAgICB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKCF0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyKSB8fCAodCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSkgfHwgZSkge1xuICAgICAgICB0ICYmIChyID0gdCk7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgczogRixcbiAgICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbiA+PSByLmxlbmd0aCA/IHtcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiByW24rK11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlOiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGY6IEZcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgdmFyIG8sXG4gICAgICBhID0gdHJ1ZSxcbiAgICAgIHUgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0ID0gdC5jYWxsKHIpO1xuICAgICAgfSxcbiAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSB0Lm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGEgPSByLmRvbmUsIHI7XG4gICAgICB9LFxuICAgICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdSA9IHRydWUsIG8gPSByO1xuICAgICAgfSxcbiAgICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhIHx8IG51bGwgPT0gdC5yZXR1cm4gfHwgdC5yZXR1cm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodSkgdGhyb3cgbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pIDogZVtyXSA9IHQsIGU7XG4gIH1cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICAgIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbiAgfVxuICBmdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICB9IGNhdGNoICh0KSB7fVxuICAgIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXQ7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICAgIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKG51bGwgIT0gdCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgIG4sXG4gICAgICAgIGksXG4gICAgICAgIHUsXG4gICAgICAgIGEgPSBbXSxcbiAgICAgICAgZiA9IHRydWUsXG4gICAgICAgIG8gPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgICAgZiA9ICExO1xuICAgICAgICB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIG8gPSB0cnVlLCBuID0gcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gICAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICAgIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICAgIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbiAgfVxuICBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7XG4gICAgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iL21haW4vcGFja2FnZXMvYmFiZWwtaGVscGVycy9MSUNFTlNFICovXG4gICAgdmFyIGUsXG4gICAgICB0LFxuICAgICAgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sXG4gICAgICBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICAgIG8gPSByLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgIGZ1bmN0aW9uIGkociwgbiwgbywgaSkge1xuICAgICAgdmFyIGMgPSBuICYmIG4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gbiA6IEdlbmVyYXRvcixcbiAgICAgICAgdSA9IE9iamVjdC5jcmVhdGUoYy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvckRlZmluZSh1LCBcIl9pbnZva2VcIiwgZnVuY3Rpb24gKHIsIG4sIG8pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgYyxcbiAgICAgICAgICB1LFxuICAgICAgICAgIGYgPSAwLFxuICAgICAgICAgIHAgPSBvIHx8IFtdLFxuICAgICAgICAgIHkgPSBmYWxzZSxcbiAgICAgICAgICBHID0ge1xuICAgICAgICAgICAgcDogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICB2OiBlLFxuICAgICAgICAgICAgYTogZCxcbiAgICAgICAgICAgIGY6IGQuYmluZChlLCA0KSxcbiAgICAgICAgICAgIGQ6IGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpID0gdCwgYyA9IDAsIHUgPSBlLCBHLm4gPSByLCBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGQociwgbikge1xuICAgICAgICAgIGZvciAoYyA9IHIsIHUgPSBuLCB0ID0gMDsgIXkgJiYgZiAmJiAhbyAmJiB0IDwgcC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdmFyIG8sXG4gICAgICAgICAgICAgIGkgPSBwW3RdLFxuICAgICAgICAgICAgICBkID0gRy5wLFxuICAgICAgICAgICAgICBsID0gaVsyXTtcbiAgICAgICAgICAgIHIgPiAzID8gKG8gPSBsID09PSBuKSAmJiAodSA9IGlbKGMgPSBpWzRdKSA/IDUgOiAoYyA9IDMsIDMpXSwgaVs0XSA9IGlbNV0gPSBlKSA6IGlbMF0gPD0gZCAmJiAoKG8gPSByIDwgMiAmJiBkIDwgaVsxXSkgPyAoYyA9IDAsIEcudiA9IG4sIEcubiA9IGlbMV0pIDogZCA8IGwgJiYgKG8gPSByIDwgMyB8fCBpWzBdID4gbiB8fCBuID4gbCkgJiYgKGlbNF0gPSByLCBpWzVdID0gbiwgRy5uID0gbCwgYyA9IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG8gfHwgciA+IDEpIHJldHVybiBhO1xuICAgICAgICAgIHRocm93IHkgPSB0cnVlLCBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobywgcCwgbCkge1xuICAgICAgICAgIGlmIChmID4gMSkgdGhyb3cgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICBmb3IgKHkgJiYgMSA9PT0gcCAmJiBkKHAsIGwpLCBjID0gcCwgdSA9IGw7ICh0ID0gYyA8IDIgPyBlIDogdSkgfHwgIXk7KSB7XG4gICAgICAgICAgICBpIHx8IChjID8gYyA8IDMgPyAoYyA+IDEgJiYgKEcubiA9IC0xKSwgZChjLCB1KSkgOiBHLm4gPSB1IDogRy52ID0gdSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoZiA9IDIsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyB8fCAobyA9IFwibmV4dFwiKSwgdCA9IGlbb10pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSB0LmNhbGwoaSwgdSkpKSB0aHJvdyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICAgIGlmICghdC5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgIHUgPSB0LnZhbHVlLCBjIDwgMiAmJiAoYyA9IDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSAxID09PSBjICYmICh0ID0gaS5yZXR1cm4pICYmIHQuY2FsbChpKSwgYyA8IDIgJiYgKHUgPSBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG8gKyBcIicgbWV0aG9kXCIpLCBjID0gMSk7XG4gICAgICAgICAgICAgICAgaSA9IGU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHQgPSAoeSA9IEcubiA8IDApID8gdSA6IHIuY2FsbChuLCBHKSkgIT09IGEpIGJyZWFrO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICBpID0gZSwgYyA9IDEsIHUgPSB0O1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgICAgIGRvbmU6IHlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfShyLCBvLCBpKSwgdHJ1ZSksIHU7XG4gICAgfVxuICAgIHZhciBhID0ge307XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICAgIHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIGMgPSBbXVtuXSA/IHQodChbXVtuXSgpKSkgOiAoX3JlZ2VuZXJhdG9yRGVmaW5lKHQgPSB7fSwgbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pLCB0KSxcbiAgICAgIHUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjKTtcbiAgICBmdW5jdGlvbiBmKGUpIHtcbiAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGUuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZShlLCBvLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHUpLCBlO1xuICAgIH1cbiAgICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIF9yZWdlbmVyYXRvckRlZmluZSh1LCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSwgX3JlZ2VuZXJhdG9yRGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIsIF9yZWdlbmVyYXRvckRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgbywgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgX3JlZ2VuZXJhdG9yRGVmaW5lKHUpLCBfcmVnZW5lcmF0b3JEZWZpbmUodSwgbywgXCJHZW5lcmF0b3JcIiksIF9yZWdlbmVyYXRvckRlZmluZSh1LCBuLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgX3JlZ2VuZXJhdG9yRGVmaW5lKHUsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgfSksIChfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3OiBpLFxuICAgICAgICBtOiBmXG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cbiAgZnVuY3Rpb24gX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpIHtcbiAgICB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB0cnkge1xuICAgICAgaSh7fSwgXCJcIiwge30pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGkgPSAwO1xuICAgIH1cbiAgICBfcmVnZW5lcmF0b3JEZWZpbmUgPSBmdW5jdGlvbiAoZSwgciwgbiwgdCkge1xuICAgICAgaWYgKHIpIGkgPyBpKGUsIHIsIHtcbiAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgIGVudW1lcmFibGU6ICF0LFxuICAgICAgICBjb25maWd1cmFibGU6ICF0LFxuICAgICAgICB3cml0YWJsZTogIXRcbiAgICAgIH0pIDogZVtyXSA9IG47ZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIG8ociwgbikge1xuICAgICAgICAgIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShyLCBuLCBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvKFwibmV4dFwiLCAwKSwgbyhcInRocm93XCIsIDEpLCBvKFwicmV0dXJuXCIsIDIpO1xuICAgICAgfVxuICAgIH0sIF9yZWdlbmVyYXRvckRlZmluZShlLCByLCBuLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gICAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICAgIH1cbiAgfSAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbiAgICBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcbiAgICBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXG5cbiAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xuICB9XG4gIHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG4gIH07XG4gIHZhciBub29wJDEgPSBmdW5jdGlvbiBub29wKCkge307XG4gIGZ1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCBpbnRlcnZhbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShjYWxsYmFjaygpKTtcbiAgICAgIH0sIGludGVydmFsKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXRyeShfeCkge1xuICAgIHJldHVybiBfcmV0cnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSAvLyDkvb/nlKjpnZnmgIHnvJPlhrLljLrvvIzpgb/lhY3ph43lpI3liJvlu7pcbiAgZnVuY3Rpb24gX3JldHJ5KCkge1xuICAgIF9yZXRyeSA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWU0KGZuKSB7XG4gICAgICB2YXIgaW50ZXJ2YWxzLFxuICAgICAgICB0aW1lcyxcbiAgICAgICAgX2FyZ3M0ID0gYXJndW1lbnRzLFxuICAgICAgICBfdDU7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQ0KSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5wID0gX2NvbnRleHQ0Lm4pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpbnRlcnZhbHMgPSBfYXJnczQubGVuZ3RoID4gMSAmJiBfYXJnczRbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNFsxXSA6IFtdO1xuICAgICAgICAgICAgdGltZXMgPSBfYXJnczQubGVuZ3RoID4gMiAmJiBfYXJnczRbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNFsyXSA6IDA7XG4gICAgICAgICAgICBfY29udGV4dDQucCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmEoMiwgZm4oKSk7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnAgPSAyO1xuICAgICAgICAgICAgX3Q1ID0gX2NvbnRleHQ0LnY7XG4gICAgICAgICAgICBpZiAoISh0aW1lcyA+PSBpbnRlcnZhbHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubiA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgX3Q1O1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYSgyLCBkZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXRyeShmbiwgaW50ZXJ2YWxzLCArK3RpbWVzKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsc1t0aW1lc10pKTtcbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTQsIG51bGwsIFtbMSwgMl1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9yZXRyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHZhciBCVUZGRVJfU0laRSA9IDQwOTY7IC8vIOabtOWkp+eahOe8k+WGsuWMuu+8jOWHj+WwkeWtl+espuS4suaLvOaOpeasoeaVsFxuICB2YXIgU1RBVElDX0JVRkZFUiA9IG5ldyBVaW50MTZBcnJheShCVUZGRVJfU0laRSk7IC8vIOmihOWIhumFjUFTQ0lJ57yT5Yay5Yy6XG4gIC8qKlxuICAgKiDkvJjljJbnmoQgVVRGLTgg6Kej56CB5Ye95pWwXG4gICAqIOS4u+imgeS8mOWMlueCue+8mlxuICAgKiAxLiDkvb/nlKjpnZnmgIHnvJPlhrLljLrlh4/lsJHlhoXlrZjliIbphY1cbiAgICogMi4g5om56YeP5aSE55CGIEFTQ0lJIOWtl+esplxuICAgKiAzLiDkvJjljJblvqrnjq/nu5PmnoTlkozmnaHku7bliKTmlq1cbiAgICogNC4g5L2/55SoIFVpbnQxNkFycmF5IOS7o+abv+aZrumAmuaVsOe7hOaPkOmrmOaAp+iDvVxuICAgKi9cbiAgZnVuY3Rpb24gdXRmOChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAvLyDovrnnlYzmo4Dmn6VcbiAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIGlmIChlbmQgLSBzdGFydCA8IDEpIHJldHVybiBcIlwiO1xuICAgIHZhciByZXN1bHRQYXJ0cyA9IFtdO1xuICAgIHZhciBidWZmZXJQb3MgPSAwO1xuICAgIHZhciBhcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIocGFydHMpIHtcbiAgICAgIHJlc3VsdFBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKHBhcnRzKSkpO1xuICAgIH07XG4gICAgLy8g5b+r6YCf6Lev5b6E77ya5qOA5p+l5piv5ZCm5YWo5pivIEFTQ0lJXG4gICAgdmFyIGFsbEFzY2lpID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgaWYgKGJ1ZmZlcltpXSA+IDB4N0YpIHtcbiAgICAgICAgYWxsQXNjaWkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIOWFqCBBU0NJSSDkvJjljJbot6/lvoRcbiAgICBpZiAoYWxsQXNjaWkpIHtcbiAgICAgIGZvciAodmFyIF9pID0gc3RhcnQ7IF9pIDwgZW5kOyBfaSArPSBCVUZGRVJfU0laRSkge1xuICAgICAgICB2YXIgY2h1bmtFbmQgPSBNYXRoLm1pbihfaSArIEJVRkZFUl9TSVpFLCBlbmQpO1xuICAgICAgICB2YXIgbGVuID0gY2h1bmtFbmQgLSBfaTtcbiAgICAgICAgLy8g55u05o6l5aSN5Yi25YiwIFVpbnQxNkFycmF5XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBTVEFUSUNfQlVGRkVSW2pdID0gYnVmZmVyW19pICsgal07XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQnVmZmVyKFNUQVRJQ19CVUZGRVIuc3ViYXJyYXkoMCwgbGVuKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0UGFydHMuam9pbignJyk7XG4gICAgfVxuICAgIC8vIOa3t+WQiOWGheWuueWkhOeQhlxuICAgIGZvciAodmFyIF9pMiA9IHN0YXJ0OyBfaTIgPCBlbmQ7KSB7XG4gICAgICB2YXIgYnl0ZSA9IGJ1ZmZlcltfaTIrK107XG4gICAgICAvLyBBU0NJSSDlrZfnrKblpITnkIZcbiAgICAgIGlmIChieXRlIDwgMHg4MCkge1xuICAgICAgICBTVEFUSUNfQlVGRkVSW2J1ZmZlclBvcysrXSA9IGJ5dGU7XG4gICAgICAgIC8vIOWmguaenOe8k+WGsuWMuua7oeS6hu+8jOaPkOS6pOW5tua4heepulxuICAgICAgICBpZiAoYnVmZmVyUG9zID09PSBCVUZGRVJfU0laRSkge1xuICAgICAgICAgIGFwcGVuZEJ1ZmZlcihTVEFUSUNfQlVGRkVSKTtcbiAgICAgICAgICBidWZmZXJQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8g5o+Q5Lqk5LmL5YmN55qEIEFTQ0lJIOWtl+esplxuICAgICAgaWYgKGJ1ZmZlclBvcyA+IDApIHtcbiAgICAgICAgYXBwZW5kQnVmZmVyKFNUQVRJQ19CVUZGRVIuc3ViYXJyYXkoMCwgYnVmZmVyUG9zKSk7XG4gICAgICAgIGJ1ZmZlclBvcyA9IDA7XG4gICAgICB9XG4gICAgICAvLyDlj5jplb/nvJbnoIHlpITnkIYgLSDkvb/nlKjmn6Xooajms5Xku6Pmm7/lpJrkuKrmnaHku7bliKTmlq1cbiAgICAgIHZhciBjb2RlUG9pbnQgPSB2b2lkIDA7XG4gICAgICAvLyAyIOWtl+iKguW6j+WIlzogMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmICgoYnl0ZSAmIDB4RTApID09PSAweEMwICYmIF9pMiA8IGVuZCkge1xuICAgICAgICBjb2RlUG9pbnQgPSAoYnl0ZSAmIDB4MUYpIDw8IDYgfCBidWZmZXJbX2kyKytdICYgMHgzRjtcbiAgICAgIH1cbiAgICAgIC8vIDMg5a2X6IqC5bqP5YiXOiAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgZWxzZSBpZiAoKGJ5dGUgJiAweEYwKSA9PT0gMHhFMCAmJiBfaTIgKyAxIDwgZW5kKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IChieXRlICYgMHgwRikgPDwgMTIgfCAoYnVmZmVyW19pMisrXSAmIDB4M0YpIDw8IDYgfCBidWZmZXJbX2kyKytdICYgMHgzRjtcbiAgICAgIH1cbiAgICAgIC8vIDQg5a2X6IqC5bqP5YiXOiAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgZWxzZSBpZiAoKGJ5dGUgJiAweEY4KSA9PT0gMHhGMCAmJiBfaTIgKyAyIDwgZW5kKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IChieXRlICYgMHgwNykgPDwgMTggfCAoYnVmZmVyW19pMisrXSAmIDB4M0YpIDw8IDEyIHwgKGJ1ZmZlcltfaTIrK10gJiAweDNGKSA8PCA2IHwgYnVmZmVyW19pMisrXSAmIDB4M0Y7XG4gICAgICAgIC8vIOWkhOeQhiBVbmljb2RlIOS7o+eQhuWvuVxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgU1RBVElDX0JVRkZFUltidWZmZXJQb3MrK10gPSAweEQ4MDAgKyAoY29kZVBvaW50ID4+IDEwKTtcbiAgICAgICAgICBTVEFUSUNfQlVGRkVSW2J1ZmZlclBvcysrXSA9IDB4REMwMCArIChjb2RlUG9pbnQgJiAweDNGRik7XG4gICAgICAgICAgLy8g5qOA5p+l57yT5Yay5Yy65piv5ZCm6ZyA6KaB5o+Q5LqkXG4gICAgICAgICAgaWYgKGJ1ZmZlclBvcyA+PSBCVUZGRVJfU0laRSAtIDIpIHtcbiAgICAgICAgICAgIC8vIOmihOeVmeepuumXtOe7meS4i+S4gOS4quWPr+iDveeahOS7o+eQhuWvuVxuICAgICAgICAgICAgYXBwZW5kQnVmZmVyKFNUQVRJQ19CVUZGRVIuc3ViYXJyYXkoMCwgYnVmZmVyUG9zKSk7XG4gICAgICAgICAgICBidWZmZXJQb3MgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8g5peg5pWI55qEIFVURi04IOW6j+WIl1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDsgLy8gVW5pY29kZSDmm7/mjaLlrZfnrKZcbiAgICAgICAgLy8g6Lez6L+H5Y+v6IO955qE5ZCO57ut5a2X6IqCXG4gICAgICAgIHdoaWxlIChfaTIgPCBlbmQgJiYgKGJ1ZmZlcltfaTJdICYgMHhDMCkgPT09IDB4ODApIF9pMisrO1xuICAgICAgfVxuICAgICAgU1RBVElDX0JVRkZFUltidWZmZXJQb3MrK10gPSBjb2RlUG9pbnQ7XG4gICAgICAvLyDmo4Dmn6XnvJPlhrLljLrmmK/lkKbpnIDopoHmj5DkuqRcbiAgICAgIGlmIChidWZmZXJQb3MgPj0gQlVGRkVSX1NJWkUgLSAzKSB7XG4gICAgICAgIC8vIOmihOeVmeepuumXtOe7meS4i+S4gOS4quWPr+iDveeahOWkmuWtl+iKguWtl+esplxuICAgICAgICBhcHBlbmRCdWZmZXIoU1RBVElDX0JVRkZFUi5zdWJhcnJheSgwLCBidWZmZXJQb3MpKTtcbiAgICAgICAgYnVmZmVyUG9zID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8g5o+Q5Lqk5Ymp5L2Z5a2X56ymXG4gICAgaWYgKGJ1ZmZlclBvcyA+IDApIHtcbiAgICAgIGFwcGVuZEJ1ZmZlcihTVEFUSUNfQlVGRkVSLnN1YmFycmF5KDAsIGJ1ZmZlclBvcykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0UGFydHMuam9pbignJyk7XG4gIH1cbiAgdmFyIE9jdG9wdXNQbGF0Zm9ybSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2N0b3B1c1BsYXRmb3JtKHBsdWdpbnMsIHZlcnNpb24pIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPY3RvcHVzUGxhdGZvcm0pO1xuICAgICAgLyoqXG4gICAgICAgKiDmj5Lku7bliJfooahcbiAgICAgICAqL1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGx1Z2luc1wiLCBbXSk7XG4gICAgICAvKipcbiAgICAgICAqIOW5s+WPsOeJiOacrFxuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbGF0Zm9ybVZlcnNpb25cIiwgXCIwLjEuM1wiKTtcbiAgICAgIC8qKlxuICAgICAgICog5bqU55So54mI5pysXG4gICAgICAgKi9cbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgXCJcIik7XG4gICAgICAvKipcbiAgICAgICAqIOWFqOWxgOWPmOmHj1xuICAgICAgICovXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnbG9iYWxzXCIsIHtcbiAgICAgICAgZW52OiBcInVua25vd25cIixcbiAgICAgICAgYnI6IG51bGwsXG4gICAgICAgIGRwcjogMSxcbiAgICAgICAgc3lzdGVtOiBcIlwiXG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vb3BcIiwgbm9vcCQxKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJldHJ5XCIsIHJldHJ5KTtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb24gfHwgXCJcIjtcbiAgICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICB0aGlzLmdsb2JhbHMuZW52ID0gdGhpcy5hdXRvRW52KCk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoT2N0b3B1c1BsYXRmb3JtLCBbe1xuICAgICAga2V5OiBcImluaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFscyxcbiAgICAgICAgICBwbHVnaW5zID0gdGhpcy5wbHVnaW5zO1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xuICAgICAgICBnbG9iYWxzLmJyID0gdGhpcy51c2VCcmlkZ2UoKTtcbiAgICAgICAgZ2xvYmFscy5kcHIgPSB0aGlzLnVzZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgZ2xvYmFscy5zeXN0ZW0gPSB0aGlzLnVzZVN5c3RlbSgpO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGx1Z2lucyksXG4gICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2gocGx1Z2luLm5hbWUpO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VQbHVnaW5zKGNvbGxlY3Rpb24sIG5hbWVzLCBpbnN0YWxsZWRQbHVnaW5zKTtcbiAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5jbGVhcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdXRvRW52XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b0VudigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJoNVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1F77ya55Sx5LqO5oqW6Z+z5Zy65pmv5pSv5oyBd3jlr7nosaHvvIzmiYDku6XpnIDopoHmlL7lnKh3eOWvueixoeS5i+WJjeajgOafpVxuICAgICAgICBpZiAodHlwZW9mIHR0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwidHRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG15ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYWxpcGF5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBcIndlYXBwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoYXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJoYXJtb255XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGxhdGZvcm3vvIFcIik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVzZUJyaWRnZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZUJyaWRnZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmdsb2JhbHMuZW52KSB7XG4gICAgICAgICAgY2FzZSBcImFsaXBheVwiOlxuICAgICAgICAgICAgcmV0dXJuIG15O1xuICAgICAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgICAgICAgcmV0dXJuIHR0O1xuICAgICAgICAgIGNhc2UgXCJ3ZWFwcFwiOlxuICAgICAgICAgICAgcmV0dXJuIHd4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1c2VQaXhlbFJhdGlvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXNlUGl4ZWxSYXRpbygpIHtcbiAgICAgICAgdmFyIF90aGlzJGdsb2JhbHMgPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgICAgZW52ID0gX3RoaXMkZ2xvYmFscy5lbnYsXG4gICAgICAgICAgYnIgPSBfdGhpcyRnbG9iYWxzLmJyO1xuICAgICAgICBpZiAoZW52ID09PSBcImg1XCIpIHtcbiAgICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJnZXRXaW5kb3dJbmZvXCIgaW4gYnIpIHtcbiAgICAgICAgICByZXR1cm4gYnIuZ2V0V2luZG93SW5mbygpLnBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZ2V0U3lzdGVtSW5mb1N5bmNcIiBpbiBicikge1xuICAgICAgICAgIHJldHVybiBici5nZXRTeXN0ZW1JbmZvU3luYygpLnBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVzZVN5c3RlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVzZVN5c3RlbSgpIHtcbiAgICAgICAgdmFyIGVudiA9IHRoaXMuZ2xvYmFscy5lbnY7XG4gICAgICAgIHZhciBzeXN0ZW07XG4gICAgICAgIHN3aXRjaCAoZW52KSB7XG4gICAgICAgICAgY2FzZSBcIndlYXBwXCI6XG4gICAgICAgICAgICAvLyDmmoLkuI3mlK/mjIFhcGkgaGFzLmdldERldmljZUluZm8gVE9ET1xuICAgICAgICAgICAgc3lzdGVtID0gaGFzLmdldERldmljZUluZm8oKS5wbGF0Zm9ybTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhbGlwYXlcIjpcbiAgICAgICAgICAgIHN5c3RlbSA9IG15LmdldERldmljZUJhc2VJbmZvKCkucGxhdGZvcm07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHRcIjpcbiAgICAgICAgICAgIHN5c3RlbSA9IGhhcy5nZXREZXZpY2VJbmZvU3luYygpLnBsYXRmb3JtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhhcm1vbnlcIjpcbiAgICAgICAgICAgIHN5c3RlbSA9IGhhcy5nZXRTeXN0ZW1JbmZvU3luYygpLnBsYXRmb3JtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImg1XCI6XG4gICAgICAgICAgICBpZiAoXCJ1c2VyQWdlbnREYXRhXCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgc3lzdGVtID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEucGxhdGZvcm07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgVUEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICAgICAgICBpZiAoLyhBbmRyb2lkfEFkcikvaS50ZXN0KFVBKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYW5kcm9pZFwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9cXChpW147XSs7KCBVOyk/IENQVS4rTWFjIE9TIFgvaS50ZXN0KFVBKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiaW9zXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoL0hhcm1vbnlPUy9pLnRlc3QoVUEpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJoYXJtb255XCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzeXN0ZW0gPSBcInVua25vd25cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3lzdGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVzZVBsdWdpbnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1c2VQbHVnaW5zKHBsdWdpbnMsIHBsdWdpbk5hbWVzLCBpbnN0YWxsZWRQbHVnaW5zKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGx1Z2luTmFtZXMpLFxuICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICBpZiAoIXBsdWdpbnMuaGFzKHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiBcIi5jb25jYXQocGx1Z2luTmFtZSwgXCIgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW5OYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICAgICAgICAvLyDpgJLlvZLosIPnlKjkvp3otZZcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbi5kZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGx1Z2luLmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgICAgICAgX3N0ZXAzO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3BsdWdpbnMkZ2V0O1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICgoX3BsdWdpbnMkZ2V0ID0gcGx1Z2lucy5nZXQoZGVwZW5kZW5jeSkpID09PSBudWxsIHx8IF9wbHVnaW5zJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BsdWdpbnMkZ2V0Lmluc3RhbGwpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIFwiLmNvbmNhdChwbHVnaW5OYW1lLCBcIiBkZXBlbmRzIG9uIHBsdWdpbiBcIikuY29uY2F0KGRlcGVuZGVuY3ksIFwiLCBidXQgXCIpLmNvbmNhdChkZXBlbmRlbmN5LCBcIiBpcyBub3QgZm91bmRcIikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDpgJLlvZLliqDovb3kvp3otZZcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy51c2VQbHVnaW5zKHBsdWdpbnMsIHBsdWdpbi5kZXBlbmRlbmNpZXMsIGluc3RhbGxlZFBsdWdpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnN0YWxsUGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW5OYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN3aXRjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zd2l0Y2goZW52KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscy5lbnYgPSBlbnY7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuICAvKipcbiAgICog5a6a5LmJ5bmz5Y+w5o+S5Lu2XG4gICAqL1xuICB2YXIgZGVmaW5lUGx1Z2luID0gZnVuY3Rpb24gZGVmaW5lUGx1Z2luKHBsdWdpbikge1xuICAgIHJldHVybiBwbHVnaW47XG4gIH07XG4gIGZ1bmN0aW9uIGluc3RhbGxQbHVnaW4ocGxhdGZvcm0sIHBsdWdpbikge1xuICAgIHZhciB2YWx1ZSA9IHBsdWdpbi5pbnN0YWxsLmNhbGwocGxhdGZvcm0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbGF0Zm9ybSwgcGx1Z2luLm5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHZhciBwbHVnaW5TZWxlY3RvciA9IGRlZmluZVBsdWdpbih7XG4gICAgbmFtZTogXCJnZXRTZWxlY3RvclwiLFxuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2xvYmFsczIgPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgIGVudiA9IF90aGlzJGdsb2JhbHMyLmVudixcbiAgICAgICAgYnIgPSBfdGhpcyRnbG9iYWxzMi5icjtcbiAgICAgIGlmIChlbnYgPT09IFwiaDVcIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvciwgY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IGJyKS5jcmVhdGVTZWxlY3RvclF1ZXJ5KCkuc2VsZWN0KHNlbGVjdG9yKS5maWVsZHMoe1xuICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgc2l6ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICog6YCa6L+H6YCJ5oup5Zmo5Yy56YWN6I635Y+WY2FudmFz5a6e5L6LXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB2YXIgcGx1Z2luQ2FudmFzID0gZGVmaW5lUGx1Z2luKHtcbiAgICBuYW1lOiBcImdldENhbnZhc1wiLFxuICAgIGRlcGVuZGVuY2llczogW1wiZ2V0U2VsZWN0b3JcIl0sXG4gICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciByZXRyeSA9IHRoaXMucmV0cnksXG4gICAgICAgIGdldFNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvcjtcbiAgICAgIHZhciBfdGhpcyRnbG9iYWxzMyA9IHRoaXMuZ2xvYmFscyxcbiAgICAgICAgZW52ID0gX3RoaXMkZ2xvYmFsczMuZW52O1xuICAgICAgX3RoaXMkZ2xvYmFsczMuYnI7XG4gICAgICB2YXIgZHByID0gX3RoaXMkZ2xvYmFsczMuZHByO1xuICAgICAgdmFyIGludGVydmFscyA9IFs1MCwgMTAwLCAxMDBdO1xuICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW52YXMgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zdCBNQVhfU0laRSA9IDEzNjU7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgLy8gbGV0IHZpcnR1YWxXaWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAvLyBsZXQgdmlydHVhbEhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICAgICAgLy8gLy8g5b6u5L+h5bCP56iL5bqP6ZmQ5Yi2Y2FudmFz5pyA5aSn5bC65a+45Li6IDEzNjUgKiAxMzY1XG4gICAgICAgIC8vIGlmIChcbiAgICAgICAgLy8gICBlbnYgPT09IFwid2VhcHBcIiAmJlxuICAgICAgICAvLyAgICh2aXJ0dWFsV2lkdGggPiBNQVhfU0laRSB8fCB2aXJ0dWFsSGVpZ2h0ID4gTUFYX1NJWkUpXG4gICAgICAgIC8vICkge1xuICAgICAgICAvLyAgIGlmICh2aXJ0dWFsV2lkdGggPiB2aXJ0dWFsSGVpZ2h0KSB7XG4gICAgICAgIC8vICAgICB2aXJ0dWFsSGVpZ2h0ID0gKHZpcnR1YWxIZWlnaHQgLyB2aXJ0dWFsV2lkdGgpICogTUFYX1NJWkU7XG4gICAgICAgIC8vICAgICB2aXJ0dWFsV2lkdGggPSBNQVhfU0laRTtcbiAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgdmlydHVhbFdpZHRoID0gKHZpcnR1YWxXaWR0aCAvIHZpcnR1YWxIZWlnaHQpICogTUFYX1NJWkU7XG4gICAgICAgIC8vICAgICB2aXJ0dWFsSGVpZ2h0ID0gTUFYX1NJWkU7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGNhbnZhcyEud2lkdGggPSB2aXJ0dWFsV2lkdGg7XG4gICAgICAgIC8vIGNhbnZhcyEuaGVpZ2h0ID0gdmlydHVhbEhlaWdodDtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVudiA9PT0gXCJoNVwiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gcmV0cnkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRhcm8g5a+5IGNhbnZhcyDlgZrkuobnibnmrorlpITnkIbvvIxjYW52YXMg5YWD57Sg55qEIGlkIOS8muiiq+WKoOS4iiBjYW52YXMtaWQg55qE5YmN57yAXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZ2V0U2VsZWN0b3IoXCJjYW52YXNbY2FudmFzLWlkPVwiLmNvbmNhdChzZWxlY3Rvci5zbGljZSgxKSwgXCJdXCIpKSB8fCBnZXRTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gaW5pdENhbnZhcyhjYW52YXMsIGNhbnZhcyA9PT0gbnVsbCB8fCBjYW52YXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzID09PSBudWxsIHx8IGNhbnZhcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgfSwgaW50ZXJ2YWxzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcmV0cnkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBnZXRTZWxlY3RvcihzZWxlY3RvciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIHF1ZXJ5LmV4ZWMoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICB2YXIgX3JlZiA9IHJlc1swXSB8fCB7fSxcbiAgICAgICAgICAgICAgICBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGluaXRDYW52YXMobm9kZSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaW50ZXJ2YWxzKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICog55So5LqO5aSE55CG5pWw5o2u6Kej56CBXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB2YXIgcGx1Z2luRGVjb2RlID0gZGVmaW5lUGx1Z2luKHtcbiAgICBuYW1lOiBcImRlY29kZVwiLFxuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2xvYmFsczQgPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgIGVudiA9IF90aGlzJGdsb2JhbHM0LmVudixcbiAgICAgICAgYnIgPSBfdGhpcyRnbG9iYWxzNC5icjtcbiAgICAgIHZhciBiNjRXcmFwID0gZnVuY3Rpb24gYjY0V3JhcChiNjQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgIHJldHVybiBcImRhdGE6XCIuY29uY2F0KHR5cGUsIFwiO2Jhc2U2NCxcIikuY29uY2F0KGI2NCk7XG4gICAgICB9O1xuICAgICAgdmFyIGRlY29kZSA9IHtcbiAgICAgICAgdG9CdWZmZXI6IGZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gZGF0YS5idWZmZXIsXG4gICAgICAgICAgICBieXRlT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHZpZXcuc2V0KGRhdGEpO1xuICAgICAgICAgIHJldHVybiB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhkYXRhKSB7XG4gICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IDgxOTI7IC8vIOWuieWFqOeahOWdl+Wkp+Wwj1xuICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBkYXRhLnNsaWNlKGksIGkgKyBjaHVua1NpemUpO1xuICAgICAgICAgICAgLy8g5Zyo5a6J5YWo55qE5Z2X5LiK5L2/55SoIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20oY2h1bmspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChlbnYgPT09IFwiaDVcIikge1xuICAgICAgICB2YXIgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVjb2RlKSwge30sIHtcbiAgICAgICAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIHRvRGF0YVVSTChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gYjY0V3JhcChidG9hKGRlY29kZS5ieXRlc1RvU3RyaW5nKGRhdGEpKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1dGY4OiBmdW5jdGlvbiB1dGY4KGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YS5zdWJhcnJheShzdGFydCwgZW5kKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVjb2RlKSwge30sIHtcbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbiB0b0RhdGFVUkwoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBiNjRXcmFwKGJyLmFycmF5QnVmZmVyVG9CYXNlNjQoZGVjb2RlLnRvQnVmZmVyKGRhdGEpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHV0Zjg6IHV0ZjhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIOeUqOS6juWkhOeQhui/nOeoi+aWh+S7tuivu+WPllxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgdmFyIHBsdWdpbkRvd25sb2FkID0gZGVmaW5lUGx1Z2luKHtcbiAgICBuYW1lOiBcInJlbW90ZVwiLFxuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2xvYmFsczUgPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgIGVudiA9IF90aGlzJGdsb2JhbHM1LmVudixcbiAgICAgICAgYnIgPSBfdGhpcyRnbG9iYWxzNS5icjtcbiAgICAgIHZhciBpc1JlbW90ZSA9IGZ1bmN0aW9uIGlzUmVtb3RlKHVybCkge1xuICAgICAgICByZXR1cm4gL14oYmxvYjopP2h0dHAocyk/OlxcL1xcLy8udGVzdCh1cmwpO1xuICAgICAgfTtcbiAgICAgIGlmIChlbnYgPT09IFwiaDVcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzOiBpc1JlbW90ZSxcbiAgICAgICAgICBmZXRjaDogZnVuY3Rpb24gKF9mZXRjaCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZmV0Y2goX3gyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZldGNoLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX2ZldGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoO1xuICAgICAgICAgIH0oZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBlcnJvciwgc3RhdHVzPVwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsIFwiLCBzdGF0dXNUZXh0PVwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRvd25sb2FkKHVybCwgZW5hYmxlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBici5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSDmlK/ku5jlrp3lsI/nqIvluo/lv4XpobvmnInor6XlrZfmrrVcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgICAgIGVuYWJsZUNhY2hlOiBlbmFibGVDYWNoZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlcy5kYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsOiByZWplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBlcnIuZXJyTXNnIHx8IGVyci5lcnJvck1lc3NhZ2UgfHwgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgLy8gRklYTUU6IOWPr+iDveWtmOWcqOWGmeWFpee9kee7nOe8k+WtmOepuumXtOWksei0peeahOaDheWGte+8jOatpOaXtumHjeaWsOS4i+i9vVxuICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJFUlJfQ0FDSEVfV1JJVEVfRkFJTFVSRVwiKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJFUlJfQ0FDSEVfV1JJVEVfRkFJTEVEXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG93bmxvYWQodXJsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpczogaXNSZW1vdGUsXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaCh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gZG93bmxvYWQodXJsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiDnlKjkuo7lpITnkIbmnKzlnLDmlofku7blrZjlgqhcbiAgICogQHJldHVybnNcbiAgICovXG4gIHZhciBwbHVnaW5Gc20gPSBkZWZpbmVQbHVnaW4oe1xuICAgIG5hbWU6IFwibG9jYWxcIixcbiAgICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIF90aGlzJGdsb2JhbHM2ID0gdGhpcy5nbG9iYWxzLFxuICAgICAgICBlbnYgPSBfdGhpcyRnbG9iYWxzNi5lbnYsXG4gICAgICAgIGJyID0gX3RoaXMkZ2xvYmFsczYuYnI7XG4gICAgICBpZiAoZW52ID09PSBcImg1XCIgfHwgZW52ID09PSBcInR0XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZnNtID0gYnIuZ2V0RmlsZVN5c3RlbU1hbmFnZXIoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4aXN0czogZnVuY3Rpb24gZXhpc3RzKGZpbGVwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBmc20uYWNjZXNzKHtcbiAgICAgICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIGZhaWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGRhdGEsIGZpbGVQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZzbS53cml0ZUZpbGUoe1xuICAgICAgICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmYWlsOiByZWplY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKGZpbGVQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZzbS5yZWFkRmlsZSh7XG4gICAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMuZGF0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhaWw6IHJlamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGZpbGVQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZzbS51bmxpbmsoe1xuICAgICAgICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmYWlsOiByZWplY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIOWbvueJh+WKoOi9veaPkuS7tlxuICAgKiBAcGFja2FnZSBwbHVnaW4tZnNtIOacrOWcsOaWh+S7tuWtmOWCqOiDveWKm1xuICAgKiBAcGFja2FnZSBwbHVnaW4tcGF0aCDot6/lvoTlpITnkIbog73liptcbiAgICogQHBhY2thZ2UgcGx1Z2luLWRlY29kZSDop6PnoIHog73liptcbiAgICovXG4gIHZhciBwbHVnaW5JbWFnZSA9IGRlZmluZVBsdWdpbih7XG4gICAgbmFtZTogXCJpbWFnZVwiLFxuICAgIGRlcGVuZGVuY2llczogW1wibG9jYWxcIiwgXCJkZWNvZGVcIl0sXG4gICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBsb2NhbCA9IHRoaXMubG9jYWwsXG4gICAgICAgIGRlY29kZSA9IHRoaXMuZGVjb2RlO1xuICAgICAgdmFyIGVudiA9IHRoaXMuZ2xvYmFscy5lbnY7XG4gICAgICB2YXIgcHJpbnRFcnJvciA9IGZ1bmN0aW9uIHByaW50RXJyb3IobXNnKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiaW1hZ2UgZXJyb3I6IFwiLmNvbmNhdChtc2cpKTtcbiAgICAgIH07XG4gICAgICB2YXIgZ2VuSW1hZ2VTb3VyY2UgPSBmdW5jdGlvbiBnZW5JbWFnZVNvdXJjZShkYXRhLCBfZmlsZXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IGRlY29kZS50b0RhdGFVUkwoZGF0YSk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiDliqDovb3lm77niYdcbiAgICAgICAqIEBwYXJhbSBpbWdcbiAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZShpbWcsIHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShpbWcpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIlNWR0EgTE9BRElORyBGQUlMVVJFOiBcIi5jb25jYXQodXJsKSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlbGVhc2VJbWFnZShpbWcpIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgaW1nLnNyYyA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW52ID09PSBcImg1XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2xvYWQgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlKGNyZWF0ZUltYWdlLCBkYXRhLCBmaWxlcGF0aCkge1xuICAgICAgICAgICAgICB2YXIgX3Q7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnAgPSBfY29udGV4dC5uKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIFwiY3JlYXRlSW1hZ2VCaXRtYXBcIiBpbiBnbG9iYWxUaGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnAgPSAxO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKG5ldyBCbG9iKFtkZWNvZGUudG9CdWZmZXIoZGF0YSldKSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC52O1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnAgPSAzO1xuICAgICAgICAgICAgICAgICAgICBfdCA9IF9jb250ZXh0LnY7XG4gICAgICAgICAgICAgICAgICAgIHByaW50RXJyb3IoX3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMiwgbG9hZEltYWdlKGNyZWF0ZUltYWdlKCksIGdlbkltYWdlU291cmNlKGRhdGEsIGZpbGVwYXRoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAzXV0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZChfeDMsIF94NCwgX3g1KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgICAgICAgfSgpLFxuICAgICAgICAgIHJlbGVhc2U6IHJlbGVhc2VJbWFnZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IOaUr+S7mOWuneWwj+eoi+W6j0lEReS/neWtmOS4tOaXtuaWh+S7tuS8muWksei0pTvmipbpn7PmnIDlpKfnlKjmiLfmlofku7blpKflsI/kuLoxME1cbiAgICAgIGlmIChlbnYgPT09IFwid2VhcHBcIikge1xuICAgICAgICBnZW5JbWFnZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTIoZGF0YSwgZmlsZXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYSgyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMiwgbG9jYWwud3JpdGUoZGVjb2RlLnRvQnVmZmVyKGRhdGEpLCBmaWxlcGF0aCkuY2F0Y2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50RXJyb3IoZXguZXJyb3JNZXNzYWdlIHx8IGV4LmVyck1zZyB8fCBleC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZS50b0RhdGFVUkwoZGF0YSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdlbkltYWdlU291cmNlKF94NiwgX3g3KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShjYW52YXMpIHtcbiAgICAgICAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2xvYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTMoY3JlYXRlSW1hZ2UsIGRhdGEsIGZpbGVwYXRoKSB7XG4gICAgICAgICAgICB2YXIgX3QyLCBfdDMsIF90NDtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLm4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBfdDIgPSBsb2FkSW1hZ2U7XG4gICAgICAgICAgICAgICAgICBfdDMgPSBjcmVhdGVJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbkltYWdlU291cmNlKGRhdGEsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBfdDQgPSBfY29udGV4dDMudjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYSgyLCBfdDIoX3QzLCBfdDQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBmdW5jdGlvbiBsb2FkKF94OCwgX3g5LCBfeDApIHtcbiAgICAgICAgICAgIHJldHVybiBfbG9hZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgICAgIH0oKSxcbiAgICAgICAgcmVsZWFzZTogcmVsZWFzZUltYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHZhciBwbHVnaW5Ob3cgPSBkZWZpbmVQbHVnaW4oe1xuICAgIG5hbWU6IFwibm93XCIsXG4gICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBfdGhpcyRnbG9iYWxzNyA9IHRoaXMuZ2xvYmFscyxcbiAgICAgICAgZW52ID0gX3RoaXMkZ2xvYmFsczcuZW52LFxuICAgICAgICBiciA9IF90aGlzJGdsb2JhbHM3LmJyO1xuICAgICAgLy8gcGVyZm9ybWFuY2Xlj6/ku6Xmj5Dkvpvmm7Tpq5jnsr7luqbnmoTml7bpl7TmtYvph4/vvIzkuJTkuI3lj5fns7vnu5/ml7bpl7TnmoTosIPmlbTvvIjlpoLmm7TmlLnns7vnu5/ml7bpl7TmiJblkIzmraXml7bpl7TvvInnmoTlvbHlk41cbiAgICAgIHZhciBwZXJmID0gZW52ID09PSBcImg1XCIgfHwgZW52ID09PSBcInR0XCIgPyBwZXJmb3JtYW5jZSA6IGJyLmdldFBlcmZvcm1hbmNlKCk7XG4gICAgICBpZiAodHlwZW9mIChwZXJmID09PSBudWxsIHx8IHBlcmYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcmYubm93KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIOaUr+S7mOWuneWwj+eoi+W6j+eahHBlcmZvcm1hbmNlLm5vdygp6I635Y+W55qE5piv5b2T5YmN5pe26Ze05oiz77yM5Y2V5L2N5piv5b6u56eS44CCXG4gICAgICAgIGlmIChwZXJmLm5vdygpIC0gRGF0ZS5ub3coKSA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmYubm93KCkgLyAxMDAwO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSDXnjq/looPkuIvvvIxwZXJmb3JtYW5jZS5ub3coKeiOt+WPlueahOS4jeaYr+W9k+WJjeaXtumXtOaIs++8jOiAjOaYr+S7jumhtemdouWKoOi9veW8gOWni+eahOaXtumXtOaIs++8jOWNleS9jeaYr+avq+enkuOAglxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwZXJmLm5vdygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIOeUqOS6juWIm+W7uuemu+Wxj2NhbnZhc1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgdmFyIHBsdWdpbk9mc0NhbnZhcyA9IGRlZmluZVBsdWdpbih7XG4gICAgbmFtZTogXCJnZXRPZnNDYW52YXNcIixcbiAgICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGVudiA9IHRoaXMuZ2xvYmFscy5lbnY7XG4gICAgICB2YXIgY3JlYXRlT2Zmc2NyZWVuQ2FudmFzO1xuICAgICAgaWYgKGVudiA9PT0gXCJoNVwiKSB7XG4gICAgICAgIGNyZWF0ZU9mZnNjcmVlbkNhbnZhcyA9IGZ1bmN0aW9uIGNyZWF0ZU9mZnNjcmVlbkNhbnZhcyhvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMob3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChlbnYgPT09IFwiYWxpcGF5XCIpIHtcbiAgICAgICAgY3JlYXRlT2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKG9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gbXkuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChlbnYgPT09IFwidHRcIikge1xuICAgICAgICBjcmVhdGVPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMob3B0aW9ucykge1xuICAgICAgICAgIC8vIOaaguS4jeaUr+aMgWFwaSBoYXMuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzIFRPRE9cbiAgICAgICAgICB2YXIgY2FudmFzID0gaGFzLmNyZWF0ZU9mZnNjcmVlbkNhbnZhcygpO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMob3B0aW9ucykge1xuICAgICAgICAgIHJldHVybiB3eC5jcmVhdGVPZmZzY3JlZW5DYW52YXMob3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgXCIyZFwiO1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIOeUqOS6juWkhOeQhuaWh+S7tui3r+W+hFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgdmFyIHBsdWdpblBhdGggPSBkZWZpbmVQbHVnaW4oe1xuICAgIG5hbWU6IFwicGF0aFwiLFxuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2xvYmFsczggPSB0aGlzLmdsb2JhbHMsXG4gICAgICAgIGVudiA9IF90aGlzJGdsb2JhbHM4LmVudixcbiAgICAgICAgYnIgPSBfdGhpcyRnbG9iYWxzOC5icjtcbiAgICAgIHZhciBmaWxlbmFtZSA9IGZ1bmN0aW9uIGZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgdmFyIGZpbGVwYXRoID0gcGF0aC5zcGxpdCgvXFw/Iy9nKVswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVwYXRoLnN1YnN0cmluZyhmaWxlcGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgIH07XG4gICAgICBpZiAoZW52ID09PSBcImg1XCIgfHwgZW52ID09PSBcInR0XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBVU0VSX0RBVEFfUEFUSDogXCJcIixcbiAgICAgICAgICBpczogZnVuY3Rpb24gaXMoXykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZmlsZW5hbWUsIHByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIFVTRVJfREFUQV9QQVRIID0gYnIuZW52LlVTRVJfREFUQV9QQVRIO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVVNFUl9EQVRBX1BBVEg6IFVTRVJfREFUQV9QQVRILFxuICAgICAgICBpczogZnVuY3Rpb24gaXMoZmlsZXBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZmlsZXBhdGggPT09IG51bGwgfHwgZmlsZXBhdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVwYXRoLnN0YXJ0c1dpdGgoVVNFUl9EQVRBX1BBVEgpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoZmlsZW5hbWUsIHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChVU0VSX0RBVEFfUEFUSCwgXCIvXCIpLmNvbmNhdChwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiX19cIikgOiBcIlwiKS5jb25jYXQoZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIOeUqOS6juWkhOeQhnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgdmFyIHBsdWdpblJhZiA9IGRlZmluZVBsdWdpbih7XG4gICAgbmFtZTogXCJyQUZcIixcbiAgICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGVudiA9IHRoaXMuZ2xvYmFscy5lbnY7XG4gICAgICBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVJbXBsKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIE1hdGgubWF4KDAsIDE2IC0gRGF0ZS5ub3coKSAlIDE2KSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZW52ID09PSBcImg1XCIpIHtcbiAgICAgICAgdmFyIHJBRiA9IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgaW4gZ2xvYmFsVGhpcyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHJlcXVlc3RBbmltYXRpb25GcmFtZUltcGwoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfLCBjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiByQUYoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYW52YXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIOajgOafpWNhbnZhc+aYr+WQpuWtmOWcqFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYW52YXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZUltcGwoKShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgdmFyIEVuaGFuY2VkUGxhdGZvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PY3RvcHVzUGxhdGZvcm0pIHtcbiAgICBmdW5jdGlvbiBFbmhhbmNlZFBsYXRmb3JtKCkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuaGFuY2VkUGxhdGZvcm0pO1xuICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEVuaGFuY2VkUGxhdGZvcm0sIFtbcGx1Z2luU2VsZWN0b3IsIHBsdWdpbkNhbnZhcywgcGx1Z2luT2ZzQ2FudmFzLCBwbHVnaW5EZWNvZGUsIHBsdWdpbkRvd25sb2FkLCBwbHVnaW5Gc20sIHBsdWdpbkltYWdlLCBwbHVnaW5Ob3csIHBsdWdpblBhdGgsIHBsdWdpblJhZl0sIFwiMS4zLjBcIl0pO1xuICAgICAgX3RoaXMuaW5pdCgpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHMoRW5oYW5jZWRQbGF0Zm9ybSwgX09jdG9wdXNQbGF0Zm9ybSk7XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbmhhbmNlZFBsYXRmb3JtLCBbe1xuICAgICAga2V5OiBcImluc3RhbGxQbHVnaW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnN0YWxsUGx1Z2luJDEocGx1Z2luKSB7XG4gICAgICAgIGluc3RhbGxQbHVnaW4odGhpcywgcGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oT2N0b3B1c1BsYXRmb3JtKTtcbiAgdmFyIHBsYXRmb3JtID0gbmV3IEVuaGFuY2VkUGxhdGZvcm0oKTtcbiAgdmFyIFJlc291cmNlTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VNYW5hZ2VyKHBhaW50ZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNvdXJjZU1hbmFnZXIpO1xuICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgICAgIC8vIEZJWE1FOiDlvq7kv6HlsI/nqIvluo/liJvlu7rosIPnlKjlpKrlpJpjcmVhdGVJbWFnZeS8muWvvOiHtOW+ruS/oS/lvq7kv6HlsI/nqIvluo/ltKnmuoNcbiAgICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgICAvKipcbiAgICAgICAqIOWKqOaAgee0oOadkFxuICAgICAgICovXG4gICAgICB0aGlzLmR5bmFtaWNNYXRlcmlhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAvKipcbiAgICAgICAqIOe0oOadkFxuICAgICAgICovXG4gICAgICB0aGlzLm1hdGVyaWFscyA9IG5ldyBNYXAoKTtcbiAgICAgIC8qKlxuICAgICAgICog5bey5riF55CGSW1hZ2Xlr7nosaHnmoTlnZDmoIdcbiAgICAgICAqL1xuICAgICAgdGhpcy5wb2ludCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWIm+W7uuWbvueJh+agh+etvlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZXNvdXJjZU1hbmFnZXIsIFt7XG4gICAgICBrZXk6IFwiY3JlYXRlSW1hZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbWFnZSgpIHtcbiAgICAgICAgdmFyIGltZyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBvaW50ID4gMCkge1xuICAgICAgICAgIHRoaXMucG9pbnQtLTtcbiAgICAgICAgICBpbWcgPSB0aGlzLmNhY2hlcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW1nKSB7XG4gICAgICAgICAgaW1nID0gcGxhdGZvcm0uaW1hZ2UuY3JlYXRlKHRoaXMucGFpbnRlci5GKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlcy5wdXNoKGltZyk7XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOWwhiBJbWFnZUJpdG1hcCDmj5LlhaXliLAgY2FjaGVzXG4gICAgICAgKiBAcGFyYW0gaW1nXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5lcnRCaXRtYXBJbnRvQ2FjaGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5lcnRCaXRtYXBJbnRvQ2FjaGVzKGltZykge1xuICAgICAgICBpZiAoUmVzb3VyY2VNYW5hZ2VyLmlzQml0bWFwKGltZykpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlcy5wdXNoKGltZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog5Yqg6L296aKd5aSW55qE5Zu+54mH6LWE5rqQXG4gICAgICAgKiBAcGFyYW0gc291cmNlIOi1hOa6kOWGheWuuS/lnLDlnYBcbiAgICAgICAqIEBwYXJhbSBmaWxlbmFtZSDmlofku7blkI3np7BcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibG9hZEV4dEltYWdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEV4dEltYWdlKHNvdXJjZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtLmltYWdlLmxvYWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVJbWFnZSgpO1xuICAgICAgICB9LCBzb3VyY2UsIHBsYXRmb3JtLnBhdGgucmVzb2x2ZShmaWxlbmFtZSwgXCJleHRcIikpLnRoZW4oZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgIF90aGlzLmluZXJ0Qml0bWFwSW50b0NhY2hlcyhpbWcpO1xuICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDliqDovb3lm77niYfpm4ZcbiAgICAgICAqIEBwYXJhbSBpbWFnZXMg5Zu+54mH5pWw5o2uXG4gICAgICAgKiBAcGFyYW0gZmlsZW5hbWUg5paH5Lu25ZCN56ewXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRJbWFnZXNXaXRoUmVjb3JkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEltYWdlc1dpdGhSZWNvcmQoaW1hZ2VzXzEsIGZpbGVuYW1lXzEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGltYWdlcywgZmlsZW5hbWUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJub3JtYWxcIjtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZUF3YWl0cywgaW1hZ2VGaWxlbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaW1hZ2VBd2FpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGltYWdlRmlsZW5hbWUgPSBcIlwiLmNvbmNhdChmaWxlbmFtZS5yZXBsYWNlKC9cXC5zdmdhJC9nLCBcIlwiKSwgXCIucG5nXCIpO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW1hZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBfcmVmMlswXSxcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IF9yZWYyWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyDov4fmu6QgMXB4IOmAj+aYjuWbvlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGltYWdlLmJ5dGVMZW5ndGggPCA3MCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBsYXRmb3JtLmltYWdlLmxvYWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1hZ2UsIHBsYXRmb3JtLnBhdGgucmVzb2x2ZShpbWFnZUZpbGVuYW1lLCB0eXBlID09PSBcImR5bmFtaWNcIiA/IFwiZHluX1wiLmNvbmNhdChuYW1lKSA6IG5hbWUpKS50aGVuKGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuaW5lcnRCaXRtYXBJbnRvQ2FjaGVzKGltZyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuZHluYW1pY01hdGVyaWFscy5zZXQobmFtZSwgaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLm1hdGVyaWFscy5zZXQobmFtZSwgaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUF3YWl0cy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpbWFnZUF3YWl0cyk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDph4rmlL7lm77niYfotYTmupBcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZWxlYXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgICAgLy8gRklYTUU6IOWwj+eoi+W6jyBpbWFnZSDlr7nosaHpnIDopoHmiYvliqjph4rmlL7lhoXlrZjvvIzlkKbliJnlj6/og73lr7zoh7TlsI/nqIvluo/ltKnmuoNcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY2FjaGVzKSxcbiAgICAgICAgICBfc3RlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGltZyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgUmVzb3VyY2VNYW5hZ2VyLnJlbGVhc2VPbmUoaW1nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGVyaWFscy5jbGVhcigpO1xuICAgICAgICB0aGlzLmR5bmFtaWNNYXRlcmlhbHMuY2xlYXIoKTtcbiAgICAgICAgLy8gRklYTUU6IOaUr+S7mOWuneWwj+eoi+W6jyBpbWFnZSDkv67mlLkgc3JjIOaXoOazleinpuWPkSBvbmxvYWQg5LqL5Lu2XG4gICAgICAgIHBsYXRmb3JtLmdsb2JhbHMuZW52ID09PSBcImFsaXBheVwiID8gdGhpcy5jbGVhbnVwKCkgOiB0aGlzLnRpZHlVcCgpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmlbTnkIblm77niYfotYTmupDvvIzlsIbph43lpI3nmoTlm77niYfotYTmupDnp7vpmaRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0aWR5VXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aWR5VXAoKSB7XG4gICAgICAgIC8vIOmAmui/hyBTZXQg55qE5Y676YeN54m55oCn77yM5L+d5oyBIGNhY2hlcyDlhYPntKDnmoTllK/kuIDmgKdcbiAgICAgICAgdGhpcy5jYWNoZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5jYWNoZXMpKTtcbiAgICAgICAgdGhpcy5wb2ludCA9IHRoaXMuY2FjaGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog5riF55CG5Zu+54mH6LWE5rqQXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuY2FjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9pbnQgPSAwO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImlzQml0bWFwXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8qKlxuICAgICAgICog5Yik5pat5piv5ZCm5pivIEltYWdlQml0bWFwXG4gICAgICAgKiBAcGFyYW0gaW1nXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBpc0JpdG1hcChpbWcpIHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtLmdsb2JhbHMuZW52ID09PSBcImg1XCIgJiYgaW1nIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOmHiuaUvuWGheWtmOi1hOa6kO+8iOWbvueJh++8iVxuICAgICAgICogQHBhcmFtIGltZ1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbGVhc2VPbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlT25lKGltZykge1xuICAgICAgICBpZiAoUmVzb3VyY2VNYW5hZ2VyLmlzQml0bWFwKGltZykpIHtcbiAgICAgICAgICBpbWcuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuc3JjICE9PSBcIlwiKSB7XG4gICAgICAgICAgLy8g5bCG5a2Y5Zyo5pys5Zyw55qE5paH5Lu25Yig6Zmk77yM6Ziy5q2i55So5oi356m66Ze06KKr5Y2g5ruhXG4gICAgICAgICAgaWYgKHBsYXRmb3JtLnBhdGguaXMoaW1nLnNyYykpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtLmxvY2FsLnJlbW92ZShpbWcuc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGxhdGZvcm0uaW1hZ2UucmVsZWFzZShpbWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIHJlYWRGbG9hdExFSW1wbCgpIHtcbiAgICAvLyDkvb/nlKjpnZnmgIFEYXRhVmlld+axoFxuICAgIHZhciBEQVRBX1ZJRVdfUE9PTF9TSVpFID0gNDtcbiAgICB2YXIgZGF0YVZpZXdQb29sID0gQXJyYXkoREFUQV9WSUVXX1BPT0xfU0laRSkuZmlsbCgwKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIH0pOyAvLyDkvb/nlKg45a2X6IqC5pSv5oyBZG91YmxlXG4gICAgdmFyIGN1cnJlbnRWaWV3SW5kZXggPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiByZWFkRmxvYXRMRShidWYsIHBvcykge1xuICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zICsgNCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgLy8g6L2u5o2i5L2/55SoRGF0YVZpZXfmsaDkuK3nmoTlrp7kvotcbiAgICAgIHZhciB2aWV3ID0gZGF0YVZpZXdQb29sW2N1cnJlbnRWaWV3SW5kZXhdO1xuICAgICAgY3VycmVudFZpZXdJbmRleCA9IChjdXJyZW50Vmlld0luZGV4ICsgMSkgJSBEQVRBX1ZJRVdfUE9PTF9TSVpFO1xuICAgICAgLy8g55u05o6l6K6+572u5a2X6IqC77yM6YG/5YWN5Yib5bu6c3ViYXJyYXlcbiAgICAgIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKTtcbiAgICAgIHU4WzBdID0gYnVmW3Bvc107XG4gICAgICB1OFsxXSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgIHU4WzJdID0gYnVmW3BvcyArIDJdO1xuICAgICAgdThbM10gPSBidWZbcG9zICsgM107XG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xuICAgIH07XG4gIH1cbiAgdmFyIHJlYWRGbG9hdExFID0gcmVhZEZsb2F0TEVJbXBsKCk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiDnroDmmJPnmoRoYXNo566X5rOVXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBidWZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVIYXNoKGJ1ZmYsIHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAvLyDkvb/nlKjnroDljZXnmoTlk4jluIznrpfms5VcbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcbiAgICAgIC8vIOeugOWNleeahOWTiOW4jOeul+azle+8jOexu+S8vOS6juWtl+espuS4suWTiOW4jFxuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGJ1ZmZbaV07XG4gICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIOi9rOaNouS4ujMy5L2N5pW05pWwXG4gICAgfVxuICAgIC8vIOa3u+WKoOaVsOaNrumVv+W6puS9nOS4uuWTiOW4jOeahOS4gOmDqOWIhu+8jOWinuWKoOWUr+S4gOaAp1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBlbmQgLSBzdGFydDtcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7XG4gICAgLy8g6L2s5o2i5Li65a2X56ym5LiyXG4gICAgcmV0dXJuIGhhc2gudG9TdHJpbmcoMzYpO1xuICB9XG4gIHZhciBQcmVmbGlnaHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZWZsaWdodCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcmVmbGlnaHQpO1xuICAgICAgdGhpcy5jYWNoZXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQcmVmbGlnaHQsIFt7XG4gICAgICBrZXk6IFwic2l6ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlcy5zaXplO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoaXRDb3VudFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgfVxuICAgICAgLy8gZ2V0IGNhY2hlKCkge1xuICAgICAgLy8gICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuY2FjaGVzKTtcbiAgICAgIC8vIH1cbiAgICAgIC8qKlxuICAgICAgICog6K6h566X5LqM6L+b5Yi25pWw5o2u55qE5ZOI5biM5YC8XG4gICAgICAgKiBAcGFyYW0gcmVhZGVyIFJlYWRlcuWvueixoVxuICAgICAgICogQHBhcmFtIGVuZCDnu5PmnZ/kvY3nva5cbiAgICAgICAqIEByZXR1cm5zIOWTiOW4jOWAvFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbGN1bGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZShyZWFkZXIsIGVuZCkge1xuICAgICAgICAvLyDkv53lrZjljp/lp4vkvY3nva5cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gcmVhZGVyLnBvcyxcbiAgICAgICAgICBidWYgPSByZWFkZXIuYnVmO1xuICAgICAgICB2YXIgZW5kUG9zID0gTWF0aC5taW4oZW5kLCByZWFkZXIubGVuKTtcbiAgICAgICAgLy8g6YeH5qC35pWw5o2u5Lul5Yqg5b+r6K6h566X6YCf5bqm77yM5ZCM5pe25L+d5oyB6Laz5aSf55qE5ZSv5LiA5oCnXG4gICAgICAgIC8vIOWvueS6juWkp+aVsOaNru+8jOavj+malOWHoOS4quWtl+iKgumHh+agt+S4gOasoVxuICAgICAgICB2YXIgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKGVuZFBvcyAtIHN0YXJ0UG9zKSAvIDEwMCkpO1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlSGFzaChidWYsIHN0YXJ0UG9zLCBlbmRQb3MsIHN0ZXApO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmo4Dmn6XmmK/lkKblrZjlnKjnvJPlrZjmlbDmja5cbiAgICAgICAqIEBwYXJhbSBrZXkg6ZSuXG4gICAgICAgKiBAcmV0dXJucyDmmK/lkKblrZjlnKhcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHZhciBoaXQgPSB0aGlzLmNhY2hlcy5oYXMoa2V5KTtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5jYWNoZXMuaGFzKGtleSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOiOt+WPlue8k+WtmOaVsOaNrlxuICAgICAgICogQHBhcmFtIGtleSDplK5cbiAgICAgICAqIEByZXR1cm5zIOe8k+WtmOaVsOaNrlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVzLmdldChrZXkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDorr7nva7nvJPlrZjmlbDmja5cbiAgICAgICAqIEBwYXJhbSBrZXkg6ZSuXG4gICAgICAgKiBAcGFyYW0gdmFsdWUg57yT5a2Y5pWw5o2uXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmuIXnqbrmiYDmnInnvJPlrZjmlbDmja5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jYWNoZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gICAgICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFkZXIpO1xuICAgICAgdGhpcy5wcmVmbGlnaHQgPSBuZXcgUHJlZmxpZ2h0KCk7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZWFkZXIsIFt7XG4gICAgICBrZXk6IFwiaW5kZXhPdXRPZlJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDlsIblpI3mnYLpgLvovpHliIbnprvliLDljZXni6zmlrnms5VcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVhZFZhcmludDMyU2xvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRWYXJpbnQzMlNsb3coKSB7XG4gICAgICAgIHZhciBieXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgICAgIHZhciB2YWx1ZSA9IGJ5dGUgJiAweDdmO1xuICAgICAgICB2YXIgc2hpZnQgPSA3O1xuICAgICAgICAvLyDkvb/nlKhkby13aGlsZeW+queOr+WHj+WwkeadoeS7tuWIpOaWrVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnl0ZSA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgICAgICAgIHZhbHVlIHw9IChieXRlICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgICAgICAgc2hpZnQgKz0gNztcbiAgICAgICAgfSB3aGlsZSAoYnl0ZSA+PSAxMjggJiYgc2hpZnQgPCAzMik7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+Pj4gMDsgLy8g56Gu5L+d5peg56ym5Y+3XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAgICAgICAqIEBwYXJhbSBsZW5ndGhcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5kXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbiA6IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1aW50MzJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1aW50MzIoKSB7XG4gICAgICAgIC8vIOW/q+mAn+i3r+W+hO+8muWkp+WkmuaVsOaDheWGteS4i+aYr+WNleWtl+iKglxuICAgICAgICB2YXIgYnl0ZSA9IHRoaXMuYnVmW3RoaXMucG9zXTtcbiAgICAgICAgaWYgKGJ5dGUgPCAxMjgpIHtcbiAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgIHJldHVybiBieXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIOaFoumAn+i3r+W+hO+8muWkmuWtl+iKguWkhOeQhlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVmFyaW50MzJTbG93KCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbnQzMlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJmbG9hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsb2F0KCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MgKyA0O1xuICAgICAgICBpZiAocG9zID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSByZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiByZWFkIGJ5dGVzIHJhbmdlXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEJ5dGVzUmFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCeXRlc1JhbmdlKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5pbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmQsIGxlbmd0aF07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAgICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnl0ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBieXRlcygpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldEJ5dGVzUmFuZ2UgPSB0aGlzLmdldEJ5dGVzUmFuZ2UoKSxcbiAgICAgICAgICBfdGhpcyRnZXRCeXRlc1JhbmdlMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGdldEJ5dGVzUmFuZ2UsIDMpLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkZ2V0Qnl0ZXNSYW5nZTJbMF0sXG4gICAgICAgICAgZW5kID0gX3RoaXMkZ2V0Qnl0ZXNSYW5nZTJbMV0sXG4gICAgICAgICAgbGVuZ3RoID0gX3RoaXMkZ2V0Qnl0ZXNSYW5nZTJbMl07XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBSZWFkZXIuRU1QVFlfVUlOVDhBUlJBWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RyaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0Qnl0ZXNSYW5nZTMgPSB0aGlzLmdldEJ5dGVzUmFuZ2UoKSxcbiAgICAgICAgICBfdGhpcyRnZXRCeXRlc1JhbmdlNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJGdldEJ5dGVzUmFuZ2UzLCAyKSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJGdldEJ5dGVzUmFuZ2U0WzBdLFxuICAgICAgICAgIGVuZCA9IF90aGlzJGdldEJ5dGVzUmFuZ2U0WzFdO1xuICAgICAgICAvLyDnm7TmjqXlnKjljp/lp4tidWZmZXLkuIrop6PnoIHvvIzpgb/lhY3liJvlu7rkuK3pl7RieXRlc+WvueixoVxuICAgICAgICB2YXIgcmVzdWx0ID0gcGxhdGZvcm0uZGVjb2RlLnV0ZjgodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICAgICAgICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2tpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyDlj5jplb/mlbTmlbDot7Pov4fkvJjljJYgLSDkvb/nlKjkvY3ov5DnrpdcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuYnVmLFxuICAgICAgICAgIGxlbiA9IHRoaXMubGVuO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIOS4gOasoeajgOafpeWkmuS4quWtl+iKgu+8jOWHj+WwkeW+queOr+asoeaVsFxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgdmFyIGJ5dGUgPSBidWZbcG9zKytdO1xuICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyDlv6vpgJ/mo4Dmn6Xov57nu63nmoTpq5jkvY3lrZfoioJcbiAgICAgICAgICBpZiAocG9zIDwgbGVuICYmIChidWZbcG9zXSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gJiYgKGJ1Zltwb3NdICYgMHg4MCkgIT09IDApIHtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gJiYgKGJ1Zltwb3NdICYgMHg4MCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAvLyDnu6fnu63mo4Dmn6XliankvZnlrZfoioJcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuICYmIChidWZbcG9zXSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgIGlmIChwb3MgLSB0aGlzLnBvcyA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5pbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gICAgICAgKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJza2lwVHlwZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBUeXBlKHdpcmVUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7IC8vIOa3u+WKoOmdmeaAgee8k+WtmO+8jOeUqOS6juW4uOeUqOeahOepuuaVsOe7hFxuICBSZWFkZXIuRU1QVFlfVUlOVDhBUlJBWSA9IG5ldyBVaW50OEFycmF5KDApO1xuICB2YXIgTGF5b3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXlvdXQoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0KTtcbiAgICAgIC8qKlxuICAgICAgICogTGF5b3V0IHguXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHhcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLkxheW91dFxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIExheW91dCB5LlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB5XG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5MYXlvdXRcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBMYXlvdXQgd2lkdGguXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5MYXlvdXRcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogTGF5b3V0IGhlaWdodC5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaGVpZ2h0XG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5MYXlvdXRcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBMYXlvdXQgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5MYXlvdXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfSByZWFkZXIgUmVhZGVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5MYXlvdXR9IExheW91dFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMYXlvdXQsIG51bGwsIFt7XG4gICAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcmVmbGlnaHQgPSByZWFkZXIucHJlZmxpZ2h0O1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmVuZChsZW5ndGgpO1xuICAgICAgICB2YXIgaGFzaCA9IHByZWZsaWdodC5jYWxjdWxhdGUocmVhZGVyLCBlbmQpO1xuICAgICAgICBpZiAocHJlZmxpZ2h0LmhhcyhoYXNoKSkge1xuICAgICAgICAgIHJlYWRlci5wb3MgPSBlbmQ7XG4gICAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgTGF5b3V0KCk7XG4gICAgICAgIHZhciB0YWc7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnggPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlZmxpZ2h0LnNldChoYXNoLCBMYXlvdXQuZm9ybWF0KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfbWVzc2FnZSR4ID0gbWVzc2FnZS54LFxuICAgICAgICAgIHggPSBfbWVzc2FnZSR4ID09PSB2b2lkIDAgPyAwIDogX21lc3NhZ2UkeCxcbiAgICAgICAgICBfbWVzc2FnZSR5ID0gbWVzc2FnZS55LFxuICAgICAgICAgIHkgPSBfbWVzc2FnZSR5ID09PSB2b2lkIDAgPyAwIDogX21lc3NhZ2UkeSxcbiAgICAgICAgICBfbWVzc2FnZSR3aWR0aCA9IG1lc3NhZ2Uud2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBfbWVzc2FnZSR3aWR0aCA9PT0gdm9pZCAwID8gMCA6IF9tZXNzYWdlJHdpZHRoLFxuICAgICAgICAgIF9tZXNzYWdlJGhlaWdodCA9IG1lc3NhZ2UuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodCA9IF9tZXNzYWdlJGhlaWdodCA9PT0gdm9pZCAwID8gMCA6IF9tZXNzYWdlJGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIHZhciBUcmFuc2Zvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm0pO1xuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gYS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuVHJhbnNmb3JtXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5hID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIGIuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGJcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlRyYW5zZm9ybVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBjLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBjXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5UcmFuc2Zvcm1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmMgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gZC5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuVHJhbnNmb3JtXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5kID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtIHR4LlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB0eFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuVHJhbnNmb3JtXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy50eCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSB0eS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdHlcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlRyYW5zZm9ybVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHkgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgVHJhbnNmb3JtIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuVHJhbnNmb3JtXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcn0gcmVhZGVyIFJlYWRlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge2NvbS5vcGVuc291cmNlLnN2Z2EuVHJhbnNmb3JtfSBUcmFuc2Zvcm1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtLCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmVuZChsZW5ndGgpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmIgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR4ID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHkgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIHZhciBTaGFwZUFyZ3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNoYXBlQXJncygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZUFyZ3MpO1xuICAgICAgLyoqXG4gICAgICAgKiBTaGFwZUFyZ3MgZC5cbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVBcmdzXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5kID0gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFNoYXBlQXJncyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlQXJnc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ9IHJlYWRlciBSZWFkZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlQXJnc30gU2hhcGVBcmdzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNoYXBlQXJncywgbnVsbCwgW3tcbiAgICAgIGtleTogXCJkZWNvZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHByZWZsaWdodCA9IHJlYWRlci5wcmVmbGlnaHQ7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuZW5kKGxlbmd0aCk7XG4gICAgICAgIHZhciBoYXNoID0gcHJlZmxpZ2h0LmNhbGN1bGF0ZShyZWFkZXIsIGVuZCk7XG4gICAgICAgIGlmIChwcmVmbGlnaHQuaGFzKGhhc2gpKSB7XG4gICAgICAgICAgcmVhZGVyLnBvcyA9IGVuZDtcbiAgICAgICAgICByZXR1cm4gcHJlZmxpZ2h0LmdldChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBTaGFwZUFyZ3MoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlZmxpZ2h0LnNldChoYXNoLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIHZhciBSZWN0QXJncyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdEFyZ3MoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdEFyZ3MpO1xuICAgICAgLyoqXG4gICAgICAgKiBSZWN0QXJncyB4LlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB4XG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5SZWN0QXJnc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIFJlY3RBcmdzIHkuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHlcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlJlY3RBcmdzXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogUmVjdEFyZ3Mgd2lkdGguXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5SZWN0QXJnc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBSZWN0QXJncyBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGhlaWdodFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuUmVjdEFyZ3NcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIFJlY3RBcmdzIGNvcm5lclJhZGl1cy5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gY29ybmVyUmFkaXVzXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5SZWN0QXJnc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFJlY3RBcmdzIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuUmVjdEFyZ3NcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfSByZWFkZXIgUmVhZGVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5SZWN0QXJnc30gUmVjdEFyZ3NcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVjdEFyZ3MsIG51bGwsIFt7XG4gICAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwcmVmbGlnaHQgPSByZWFkZXIucHJlZmxpZ2h0O1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmVuZChsZW5ndGgpO1xuICAgICAgICB2YXIgaGFzaCA9IHByZWZsaWdodC5jYWxjdWxhdGUocmVhZGVyLCBlbmQpO1xuICAgICAgICBpZiAocHJlZmxpZ2h0LmhhcyhoYXNoKSkge1xuICAgICAgICAgIHJlYWRlci5wb3MgPSBlbmQ7XG4gICAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgUmVjdEFyZ3MoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnkgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNvcm5lclJhZGl1cyA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVmbGlnaHQuc2V0KGhhc2gsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gcHJlZmxpZ2h0LmdldChoYXNoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIEVsbGlwc2VBcmdzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGxpcHNlQXJncygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlQXJncyk7XG4gICAgICAvKipcbiAgICAgICAqIEVsbGlwc2VBcmdzIHguXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHhcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LkVsbGlwc2VBcmdzXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogRWxsaXBzZUFyZ3MgeS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0geVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuRWxsaXBzZUFyZ3NcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBFbGxpcHNlQXJncyByYWRpdXNYLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSByYWRpdXNYXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5FbGxpcHNlQXJnc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMucmFkaXVzWCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIEVsbGlwc2VBcmdzIHJhZGl1c1kuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHJhZGl1c1lcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LkVsbGlwc2VBcmdzXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5yYWRpdXNZID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBFbGxpcHNlQXJncyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LkVsbGlwc2VBcmdzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcn0gcmVhZGVyIFJlYWRlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuRWxsaXBzZUFyZ3N9IEVsbGlwc2VBcmdzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVsbGlwc2VBcmdzLCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlZmxpZ2h0ID0gcmVhZGVyLnByZWZsaWdodDtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5lbmQobGVuZ3RoKTtcbiAgICAgICAgdmFyIGhhc2ggPSBwcmVmbGlnaHQuY2FsY3VsYXRlKHJlYWRlciwgZW5kKTtcbiAgICAgICAgaWYgKHByZWZsaWdodC5oYXMoaGFzaCkpIHtcbiAgICAgICAgICByZWFkZXIucG9zID0gZW5kO1xuICAgICAgICAgIHJldHVybiBwcmVmbGlnaHQuZ2V0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IEVsbGlwc2VBcmdzKCk7XG4gICAgICAgIHZhciB0YWc7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnggPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmFkaXVzWCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJhZGl1c1kgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJlZmxpZ2h0LnNldChoYXNoLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIHZhciBSR0JBQ29sb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJHQkFDb2xvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSR0JBQ29sb3IpO1xuICAgICAgLyoqXG4gICAgICAgKiBSR0JBQ29sb3Igci5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gclxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5SR0JBQ29sb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnIgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBSR0JBQ29sb3IgZy5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZ1xuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5SR0JBQ29sb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmcgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBSR0JBQ29sb3IgYi5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYlxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5SR0JBQ29sb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmIgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBSR0JBQ29sb3IgYS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5SR0JBQ29sb3JcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmEgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgUkdCQUNvbG9yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5SR0JBQ29sb3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfSByZWFkZXIgUmVhZGVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlLlJHQkFDb2xvcn0gUkdCQUNvbG9yXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJHQkFDb2xvciwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJkZWNvZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHByZWZsaWdodCA9IHJlYWRlci5wcmVmbGlnaHQ7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuZW5kKGxlbmd0aCk7XG4gICAgICAgIHZhciBoYXNoID0gcHJlZmxpZ2h0LmNhbGN1bGF0ZShyZWFkZXIsIGVuZCk7XG4gICAgICAgIGlmIChwcmVmbGlnaHQuaGFzKGhhc2gpKSB7XG4gICAgICAgICAgcmVhZGVyLnBvcyA9IGVuZDtcbiAgICAgICAgICByZXR1cm4gcHJlZmxpZ2h0LmdldChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBSR0JBQ29sb3IoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuciA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmcgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5iID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVmbGlnaHQuc2V0KGhhc2gsIFJHQkFDb2xvci5mb3JtYXQobWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gcHJlZmxpZ2h0LmdldChoYXNoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHIgPSBtZXNzYWdlLnIsXG4gICAgICAgICAgZyA9IG1lc3NhZ2UuZyxcbiAgICAgICAgICBiID0gbWVzc2FnZS5iLFxuICAgICAgICAgIGEgPSBtZXNzYWdlLmE7XG4gICAgICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KHIgKiAyNTUgfCAwLCBcIiwgXCIpLmNvbmNhdChnICogMjU1IHwgMCwgXCIsIFwiKS5jb25jYXQoYiAqIDI1NSB8IDAsIFwiLCBcIikuY29uY2F0KGEgKiAxIHwgMCwgXCIpXCIpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuICB2YXIgU2hhcGVTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhcGVTdHlsZSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZVN0eWxlKTtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBmaWxsLlxuICAgICAgICogQG1lbWJlciB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlLklSR0JBQ29sb3J8bnVsbHx1bmRlZmluZWR9IGZpbGxcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlU3R5bGVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmZpbGwgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBTaGFwZVN0eWxlIHN0cm9rZS5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5JUkdCQUNvbG9yfG51bGx8dW5kZWZpbmVkfSBzdHJva2VcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlU3R5bGVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIFNoYXBlU3R5bGUgc3Ryb2tlV2lkdGguXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIFNoYXBlU3R5bGUgbGluZUNhcC5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5MaW5lQ2FwfSBsaW5lQ2FwXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5saW5lQ2FwID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBsaW5lSm9pbi5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZS5MaW5lSm9pbn0gbGluZUpvaW5cbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlU3R5bGVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmxpbmVKb2luID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBtaXRlckxpbWl0LlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtaXRlckxpbWl0XG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5taXRlckxpbWl0ID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBsaW5lRGFzaEkuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxpbmVEYXNoSVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMubGluZURhc2hJID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBsaW5lRGFzaElJLlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBsaW5lRGFzaElJXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlXG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5saW5lRGFzaElJID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVTdHlsZSBsaW5lRGFzaElJSS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbGluZURhc2hJSUlcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlU3R5bGVcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmxpbmVEYXNoSUlJID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIFNoYXBlU3R5bGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5TaGFwZVN0eWxlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcn0gcmVhZGVyIFJlYWRlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuU2hhcGVTdHlsZX0gU2hhcGVTdHlsZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTaGFwZVN0eWxlLCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgcHJlZmxpZ2h0ID0gcmVhZGVyLnByZWZsaWdodDtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5lbmQobGVuZ3RoKTtcbiAgICAgICAgdmFyIGhhc2ggPSBwcmVmbGlnaHQuY2FsY3VsYXRlKHJlYWRlciwgZW5kKTtcbiAgICAgICAgaWYgKHByZWZsaWdodC5oYXMoaGFzaCkpIHtcbiAgICAgICAgICByZWFkZXIucG9zID0gZW5kO1xuICAgICAgICAgIHJldHVybiBwcmVmbGlnaHQuZ2V0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IFNoYXBlU3R5bGUoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmlsbCA9IFJHQkFDb2xvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cm9rZSA9IFJHQkFDb2xvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cm9rZVdpZHRoID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGluZUNhcCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVKb2luID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWl0ZXJMaW1pdCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVEYXNoSSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVEYXNoSUkgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lRGFzaElJSSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVmbGlnaHQuc2V0KGhhc2gsIFNoYXBlU3R5bGUuZm9ybWF0KG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIHByZWZsaWdodC5nZXQoaGFzaCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBmaWxsID0gbWVzc2FnZS5maWxsLFxuICAgICAgICAgIHN0cm9rZSA9IG1lc3NhZ2Uuc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gbWVzc2FnZS5zdHJva2VXaWR0aCxcbiAgICAgICAgICBtaXRlckxpbWl0ID0gbWVzc2FnZS5taXRlckxpbWl0LFxuICAgICAgICAgIGxpbmVEYXNoSSA9IG1lc3NhZ2UubGluZURhc2hJLFxuICAgICAgICAgIGxpbmVEYXNoSUkgPSBtZXNzYWdlLmxpbmVEYXNoSUksXG4gICAgICAgICAgbGluZURhc2hJSUkgPSBtZXNzYWdlLmxpbmVEYXNoSUlJO1xuICAgICAgICB2YXIgbGluZURhc2ggPSBbXTtcbiAgICAgICAgdmFyIGxpbmVDYXA7XG4gICAgICAgIHZhciBsaW5lSm9pbjtcbiAgICAgICAgaWYgKGxpbmVEYXNoSSA+IDApIHtcbiAgICAgICAgICBsaW5lRGFzaC5wdXNoKGxpbmVEYXNoSSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVEYXNoSUkgPiAwKSB7XG4gICAgICAgICAgaWYgKGxpbmVEYXNoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIGxpbmVEYXNoLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVEYXNoLnB1c2gobGluZURhc2hJSSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVEYXNoSUlJID4gMCkge1xuICAgICAgICAgIGlmIChsaW5lRGFzaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBsaW5lRGFzaC5wdXNoKDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lRGFzaC5wdXNoKGxpbmVEYXNoSUlJKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubGluZUNhcCkge1xuICAgICAgICAgIGNhc2UgMCAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfQ0FQX0NPREUuQlVUVCAqLzpcbiAgICAgICAgICAgIGxpbmVDYXAgPSBcImJ1dHRcIiAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfQ0FQLkJVVFQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEgLyogUGxhdGZvcm1WaWRlby5MSU5FX0NBUF9DT0RFLlJPVU5EICovOlxuICAgICAgICAgICAgbGluZUNhcCA9IFwicm91bmRcIiAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfQ0FQLlJPVU5EICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyIC8qIFBsYXRmb3JtVmlkZW8uTElORV9DQVBfQ09ERS5TUVVBUkUgKi86XG4gICAgICAgICAgICBsaW5lQ2FwID0gXCJzcXVhcmVcIiAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfQ0FQLlNRVUFSRSAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5saW5lSm9pbikge1xuICAgICAgICAgIGNhc2UgMCAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfSk9JTl9DT0RFLk1JVEVSICovOlxuICAgICAgICAgICAgbGluZUpvaW4gPSBcIm1pdGVyXCIgLyogUGxhdGZvcm1WaWRlby5MSU5FX0pPSU4uTUlURVIgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEgLyogUGxhdGZvcm1WaWRlby5MSU5FX0pPSU5fQ09ERS5ST1VORCAqLzpcbiAgICAgICAgICAgIGxpbmVKb2luID0gXCJyb3VuZFwiIC8qIFBsYXRmb3JtVmlkZW8uTElORV9KT0lOLlJPVU5EICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyIC8qIFBsYXRmb3JtVmlkZW8uTElORV9KT0lOX0NPREUuQkVWRUwgKi86XG4gICAgICAgICAgICBsaW5lSm9pbiA9IFwiYmV2ZWxcIiAvKiBQbGF0Zm9ybVZpZGVvLkxJTkVfSk9JTi5CRVZFTCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgICAgIGZpbGw6IGZpbGwgPyBmaWxsIDogbnVsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/IHN0cm9rZSA6IG51bGwsXG4gICAgICAgICAgbGluZUNhcDogbGluZUNhcCxcbiAgICAgICAgICBsaW5lSm9pbjogbGluZUpvaW4sXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIG1pdGVyTGltaXQ6IG1pdGVyTGltaXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFNoYXBlRW50aXR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFwZUVudGl0eSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZUVudGl0eSk7XG4gICAgICAvKipcbiAgICAgICAqIFNoYXBlRW50aXR5IHR5cGUuXG4gICAgICAgKiBAbWVtYmVyIHtjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LlNoYXBlVHlwZX0gdHlwZVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHlcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnR5cGUgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBTaGFwZUVudGl0eSBzaGFwZS5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHkuSVNoYXBlQXJnc3xudWxsfHVuZGVmaW5lZH0gc2hhcGVcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIFNoYXBlRW50aXR5IHJlY3QuXG4gICAgICAgKiBAbWVtYmVyIHtjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5LklSZWN0QXJnc3xudWxsfHVuZGVmaW5lZH0gcmVjdFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU2hhcGVFbnRpdHlcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnJlY3QgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBTaGFwZUVudGl0eSBlbGxpcHNlLlxuICAgICAgICogQG1lbWJlciB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5JRWxsaXBzZUFyZ3N8bnVsbHx1bmRlZmluZWR9IGVsbGlwc2VcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbGxpcHNlID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVFbnRpdHkgc3R5bGVzLlxuICAgICAgICogQG1lbWJlciB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eS5JU2hhcGVTdHlsZXxudWxsfHVuZGVmaW5lZH0gc3R5bGVzXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogU2hhcGVFbnRpdHkgdHJhbnNmb3JtLlxuICAgICAgICogQG1lbWJlciB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5JVHJhbnNmb3JtfG51bGx8dW5kZWZpbmVkfSB0cmFuc2Zvcm1cbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgU2hhcGVFbnRpdHkgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyLlxuICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5TaGFwZUVudGl0eVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ9IHJlYWRlciBSZWFkZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAqIEByZXR1cm5zIHtjb20ub3BlbnNvdXJjZS5zdmdhLlNoYXBlRW50aXR5fSBTaGFwZUVudGl0eVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTaGFwZUVudGl0eSwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJkZWNvZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5lbmQobGVuZ3RoKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgU2hhcGVFbnRpdHkoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gU2hhcGVBcmdzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVjdCA9IFJlY3RBcmdzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxsaXBzZSA9IEVsbGlwc2VBcmdzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0eWxlcyA9IFNoYXBlU3R5bGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhbnNmb3JtID0gVHJhbnNmb3JtLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaGFwZUVudGl0eS5mb3JtYXQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWVzc2FnZS50eXBlLFxuICAgICAgICAgIHNoYXBlID0gbWVzc2FnZS5zaGFwZSxcbiAgICAgICAgICByZWN0ID0gbWVzc2FnZS5yZWN0LFxuICAgICAgICAgIGVsbGlwc2UgPSBtZXNzYWdlLmVsbGlwc2UsXG4gICAgICAgICAgc3R5bGVzID0gbWVzc2FnZS5zdHlsZXMsXG4gICAgICAgICAgdHJhbnNmb3JtID0gbWVzc2FnZS50cmFuc2Zvcm07XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMCAvKiBQbGF0Zm9ybVZpZGVvLlNIQVBFX1RZUEVfQ09ERS5TSEFQRSAqLzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2hhcGVcIiAvKiBQbGF0Zm9ybVZpZGVvLlNIQVBFX1RZUEUuU0hBUEUgKi8sXG4gICAgICAgICAgICAgIHBhdGg6IHNoYXBlLFxuICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAxIC8qIFBsYXRmb3JtVmlkZW8uU0hBUEVfVFlQRV9DT0RFLlJFQ1QgKi86XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlY3RcIiAvKiBQbGF0Zm9ybVZpZGVvLlNIQVBFX1RZUEUuUkVDVCAqLyxcbiAgICAgICAgICAgICAgcGF0aDogcmVjdCxcbiAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMiAvKiBQbGF0Zm9ybVZpZGVvLlNIQVBFX1RZUEVfQ09ERS5FTExJUFNFICovOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlbGxpcHNlXCIgLyogUGxhdGZvcm1WaWRlby5TSEFQRV9UWVBFLkVMTElQU0UgKi8sXG4gICAgICAgICAgICAgIHBhdGg6IGVsbGlwc2UsXG4gICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIEZyYW1lRW50aXR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmFtZUVudGl0eSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFtZUVudGl0eSk7XG4gICAgICAvKipcbiAgICAgICAqIEZyYW1lRW50aXR5IHNoYXBlcy5cbiAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxjb20ub3BlbnNvdXJjZS5zdmdhLklTaGFwZUVudGl0eT59IHNoYXBlc1xuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuRnJhbWVFbnRpdHlcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgICAgLyoqXG4gICAgICAgKiBGcmFtZUVudGl0eSBhbHBoYS5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYWxwaGFcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLkZyYW1lRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5hbHBoYSA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIEZyYW1lRW50aXR5IGxheW91dC5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuSUxheW91dHxudWxsfHVuZGVmaW5lZH0gbGF5b3V0XG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5GcmFtZUVudGl0eVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMubGF5b3V0ID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogRnJhbWVFbnRpdHkgdHJhbnNmb3JtLlxuICAgICAgICogQG1lbWJlciB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5JVHJhbnNmb3JtfG51bGx8dW5kZWZpbmVkfSB0cmFuc2Zvcm1cbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLkZyYW1lRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBGcmFtZUVudGl0eSBjbGlwUGF0aC5cbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gY2xpcFBhdGhcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLkZyYW1lRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5jbGlwUGF0aCA9IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBGcmFtZUVudGl0eSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIuXG4gICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLkZyYW1lRW50aXR5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcn0gcmVhZGVyIFJlYWRlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge2NvbS5vcGVuc291cmNlLnN2Z2EuRnJhbWVFbnRpdHl9IEZyYW1lRW50aXR5XG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgKi9cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZyYW1lRW50aXR5LCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmVuZChsZW5ndGgpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBGcmFtZUVudGl0eSgpO1xuICAgICAgICB2YXIgdGFnO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hbHBoYSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxheW91dCA9IExheW91dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYW5zZm9ybSA9IFRyYW5zZm9ybS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNsaXBQYXRoID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBTaGFwZUVudGl0eS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaGFwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbWVzc2FnZS5zaGFwZXMgPSByZWFkZXIucHJlZmxpZ2h0LmdldChcImxhdGVzdF9zaGFwZXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZGVyLnByZWZsaWdodC5zZXQoXCJsYXRlc3Rfc2hhcGVzXCIsIG1lc3NhZ2Uuc2hhcGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnJhbWVFbnRpdHkuZm9ybWF0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JtYXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobWVzc2FnZSkge1xuICAgICAgICAvLyBhbHBoYeWAvOWwj+S6jiAwLjA1IOWwhuS4jeWxleekuu+8jOaJgOS7peS4jeWBmuino+aekOWkhOeQhlxuICAgICAgICBpZiAobWVzc2FnZS5hbHBoYSA8IDAuMDUpIHtcbiAgICAgICAgICByZXR1cm4gRnJhbWVFbnRpdHkuSElEREVOX0ZSQU1FO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHBoYSA9IG1lc3NhZ2UuYWxwaGEsXG4gICAgICAgICAgbGF5b3V0ID0gbWVzc2FnZS5sYXlvdXQsXG4gICAgICAgICAgdHJhbnNmb3JtID0gbWVzc2FnZS50cmFuc2Zvcm0sXG4gICAgICAgICAgc2hhcGVzID0gbWVzc2FnZS5zaGFwZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgIHNoYXBlczogc2hhcGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIEZyYW1lRW50aXR5LkhJRERFTl9GUkFNRSA9IHtcbiAgICBhbHBoYTogMFxuICB9O1xuICB2YXIgU3ByaXRlRW50aXR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcHJpdGVFbnRpdHkoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaXRlRW50aXR5KTtcbiAgICAgIC8qKlxuICAgICAgICogU3ByaXRlRW50aXR5IGZyYW1lcy5cbiAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxjb20ub3BlbnNvdXJjZS5zdmdhLklGcmFtZUVudGl0eT59IGZyYW1lc1xuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU3ByaXRlRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgICAgIC8qKlxuICAgICAgICogU3ByaXRlRW50aXR5IGltYWdlS2V5LlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBpbWFnZUtleVxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU3ByaXRlRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5pbWFnZUtleSA9IFwiXCI7XG4gICAgICAvKipcbiAgICAgICAqIFNwcml0ZUVudGl0eSBtYXR0ZUtleS5cbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbWF0dGVLZXlcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLlNwcml0ZUVudGl0eVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF0dGVLZXkgPSBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgU3ByaXRlRW50aXR5IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuU3ByaXRlRW50aXR5XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcn0gcmVhZGVyIFJlYWRlciB0byBkZWNvZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICogQHJldHVybnMge2NvbS5vcGVuc291cmNlLnN2Z2EuU3ByaXRlRW50aXR5fSBTcHJpdGVFbnRpdHlcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoU3ByaXRlRW50aXR5LCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmVuZChsZW5ndGgpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBTcHJpdGVFbnRpdHkoKTtcbiAgICAgICAgdmFyIHRhZztcbiAgICAgICAgcmVhZGVyLnByZWZsaWdodC5zZXQoXCJsYXRlc3Rfc2hhcGVzXCIsIFtdKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW1hZ2VLZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZnJhbWVzICYmIG1lc3NhZ2UuZnJhbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnJhbWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnJhbWVzLnB1c2goRnJhbWVFbnRpdHkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF0dGVLZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTcHJpdGVFbnRpdHkuZm9ybWF0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JtYXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGltYWdlS2V5OiBtZXNzYWdlLmltYWdlS2V5LFxuICAgICAgICAgIGZyYW1lczogbWVzc2FnZS5mcmFtZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIE1vdmllUGFyYW1zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb3ZpZVBhcmFtcygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb3ZpZVBhcmFtcyk7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmllUGFyYW1zIHZpZXdCb3hXaWR0aC5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdmlld0JveFdpZHRoXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZVBhcmFtc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMudmlld0JveFdpZHRoID0gMDtcbiAgICAgIC8qKlxuICAgICAgICogTW92aWVQYXJhbXMgdmlld0JveEhlaWdodC5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdmlld0JveEhlaWdodFxuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVQYXJhbXNcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnZpZXdCb3hIZWlnaHQgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZpZVBhcmFtcyBmcHMuXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZwc1xuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVQYXJhbXNcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLmZwcyA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmllUGFyYW1zIGZyYW1lcy5cbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZnJhbWVzXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZVBhcmFtc1xuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vdmllUGFyYW1zIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVQYXJhbXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfSByZWFkZXIgUmVhZGVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZVBhcmFtc30gTW92aWVQYXJhbXNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTW92aWVQYXJhbXMsIG51bGwsIFt7XG4gICAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuZW5kKGxlbmd0aCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IE1vdmllUGFyYW1zKCk7XG4gICAgICAgIHZhciB0YWc7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZpZXdCb3hXaWR0aCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZpZXdCb3hIZWlnaHQgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mcHMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mcmFtZXMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIHZhciBNb3ZpZUVudGl0eSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW92aWVFbnRpdHkoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW92aWVFbnRpdHkpO1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZpZUVudGl0eSB2ZXJzaW9uLlxuICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB2ZXJzaW9uXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZUVudGl0eVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMudmVyc2lvbiA9IFwiXCI7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmllRW50aXR5IHBhcmFtcy5cbiAgICAgICAqIEBtZW1iZXIge2NvbS5vcGVuc291cmNlLnN2Z2EuSU1vdmllUGFyYW1zfG51bGx8dW5kZWZpbmVkfSBwYXJhbXNcbiAgICAgICAqIEBtZW1iZXJvZiBjb20ub3BlbnNvdXJjZS5zdmdhLk1vdmllRW50aXR5XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICAgICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZpZUVudGl0eSBpbWFnZXMuXG4gICAgICAgKiBAbWVtYmVyIHtPYmplY3QuPHN0cmluZyxVaW50OEFycmF5Pn0gaW1hZ2VzXG4gICAgICAgKiBAbWVtYmVyb2YgY29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZUVudGl0eVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAvKipcbiAgICAgICAqIE1vdmllRW50aXR5IHNwcml0ZXMuXG4gICAgICAgKiBAbWVtYmVyIHtBcnJheS48Y29tLm9wZW5zb3VyY2Uuc3ZnYS5JU3ByaXRlRW50aXR5Pn0gc3ByaXRlc1xuICAgICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVFbnRpdHlcbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIE1vdmllRW50aXR5IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlci5cbiAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICogQG1lbWJlcm9mIGNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVFbnRpdHlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfSByZWFkZXIgUmVhZGVyIHRvIGRlY29kZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgKiBAcmV0dXJucyB7Y29tLm9wZW5zb3VyY2Uuc3ZnYS5Nb3ZpZUVudGl0eX0gTW92aWVFbnRpdHlcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTW92aWVFbnRpdHksIG51bGwsIFt7XG4gICAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuZW5kKGxlbmd0aCk7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IE1vdmllRW50aXR5KCk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIGVuZDI7XG4gICAgICAgIHZhciB0YWc7XG4gICAgICAgIHZhciB0YWcyO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcmFtcyA9IE1vdmllUGFyYW1zLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgIGtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNb3ZpZUVudGl0eS5FTVBUWV9VODtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIHtcbiAgICAgICAgICAgICAgICAgIHRhZzIgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZzIgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZzIgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbWFnZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNwcml0ZXMucHVzaChTcHJpdGVFbnRpdHkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNb3ZpZUVudGl0eS5mb3JtYXQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcm1hdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gbWVzc2FnZS52ZXJzaW9uLFxuICAgICAgICAgIGltYWdlcyA9IG1lc3NhZ2UuaW1hZ2VzLFxuICAgICAgICAgIHNwcml0ZXMgPSBtZXNzYWdlLnNwcml0ZXM7XG4gICAgICAgIHZhciBfbWVzc2FnZSRwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyxcbiAgICAgICAgICBmcHMgPSBfbWVzc2FnZSRwYXJhbXMuZnBzLFxuICAgICAgICAgIGZyYW1lcyA9IF9tZXNzYWdlJHBhcmFtcy5mcmFtZXMsXG4gICAgICAgICAgdmlld0JveFdpZHRoID0gX21lc3NhZ2UkcGFyYW1zLnZpZXdCb3hXaWR0aCxcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gX21lc3NhZ2UkcGFyYW1zLnZpZXdCb3hIZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICBmaWxlbmFtZTogXCJcIixcbiAgICAgICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgICAgIGR5bmFtaWNFbGVtZW50czoge30sXG4gICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgd2lkdGg6IHZpZXdCb3hXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlld0JveEhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnBzOiBmcHMsXG4gICAgICAgICAgZnJhbWVzOiBmcmFtZXMsXG4gICAgICAgICAgaW1hZ2VzOiBpbWFnZXMsXG4gICAgICAgICAgc3ByaXRlczogc3ByaXRlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuICBNb3ZpZUVudGl0eS5FTVBUWV9VOCA9IG5ldyBVaW50OEFycmF5KDApOyAvLyBpbXBvcnQgYmVuY2htYXJrIGZyb20gXCJvY3RvcHVzLWJlbmNobWFya1wiO1xuICBmdW5jdGlvbiBjcmVhdGVWaWRlb0VudGl0eShkYXRhLCBmaWxlbmFtZSkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBSZWFkZXIoZGF0YSk7XG4gICAgICB2YXIgdmlkZW8gPSBNb3ZpZUVudGl0eS5kZWNvZGUocmVhZGVyKTtcbiAgICAgIC8vIGJlbmNobWFyay5sb2coJ3ByZWZsaWdodCBjYWNoZSBzaXplJywgcmVhZGVyLnByZWZsaWdodC5zaXplKTtcbiAgICAgIC8vIGJlbmNobWFyay5sb2coJ3ByZWZsaWdodCBoaXQgY291bnQnLCByZWFkZXIucHJlZmxpZ2h0LmhpdENvdW50KTtcbiAgICAgIHZpZGVvLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICByZWFkZXIucHJlZmxpZ2h0LmNsZWFyKCk7XG4gICAgICByZXR1cm4gdmlkZW87XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO1xuICB9IC8qKlxuICAgICogQ3VycmVudFBvaW505a+56LGh5rGg77yM55So5LqO5YeP5bCR5a+56LGh5Yib5bu65ZKMR0PljovliptcbiAgICAqL1xuICB2YXIgUG9pbnRQb29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2ludFBvb2woKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnRQb29sKTtcbiAgICAgIHRoaXMucG9vbCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBvaW50UG9vbCwgW3tcbiAgICAgIGtleTogXCJhY3F1aXJlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZSgpIHtcbiAgICAgICAgdmFyIHBvb2wgPSB0aGlzLnBvb2w7XG4gICAgICAgIHJldHVybiBwb29sLmxlbmd0aCA+IDAgPyBwb29sLnBvcCgpIDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB4MTogMCxcbiAgICAgICAgICB5MTogMCxcbiAgICAgICAgICB4MjogMCxcbiAgICAgICAgICB5MjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZWxlYXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZShwb2ludCkge1xuICAgICAgICAvLyDph43nva7ngrnnmoTlsZ7mgKdcbiAgICAgICAgcG9pbnQueCA9IHBvaW50LnkgPSBwb2ludC54MSA9IHBvaW50LnkxID0gcG9pbnQueDIgPSBwb2ludC55MiA9IDA7XG4gICAgICAgIHRoaXMucG9vbC5wdXNoKHBvaW50KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFJlbmRlcmVyMkQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyMkQoY29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcmVyMkQpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucG9pbnRQb29sID0gbmV3IFBvaW50UG9vbCgpO1xuICAgICAgdGhpcy5sYXN0UmVzaXplS2V5ID0gXCJcIjtcbiAgICAgIHRoaXMuZ2xvYmFsVHJhbnNmb3JtID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jdXJyZW50UG9pbnQgPSB0aGlzLnBvaW50UG9vbC5hY3F1aXJlKCk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVuZGVyZXIyRCwgW3tcbiAgICAgIGtleTogXCJzZXRUcmFuc2Zvcm1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LnRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyYXdCZXppZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmV6aWVyKGQsIHRyYW5zZm9ybSwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIHBvaW50UG9vbCA9IHRoaXMucG9pbnRQb29sO1xuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludCA9IHBvaW50UG9vbC5hY3F1aXJlKCk7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBSZW5kZXJlcjJELnJlc2V0U2hhcGVTdHlsZXMoY29udGV4dCwgc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAvLyDkvb/nlKjnirbmgIHmnLrop6PmnpDlmajmm7/ku6PmraPliJnooajovr7lvI9cbiAgICAgICAgICB2YXIgY29tbWFuZHMgPSBSZW5kZXJlcjJELnBhcnNlU1ZHUGF0aChkKTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29tbWFuZHMpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBfc3RlcCR2YWx1ZS5jb21tYW5kLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBfc3RlcCR2YWx1ZS5hcmdzO1xuICAgICAgICAgICAgICBpZiAoUmVuZGVyZXIyRC5TVkdfUEFUSC5oYXMoY29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCZXppZXJFbGVtZW50KHRoaXMuY3VycmVudFBvaW50LCBjb21tYW5kLCBhcmdzLnNwbGl0KC9bXFxzLF0rLykuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVuZGVyZXIyRC5maWxsT3JTdHJva2UoY29udGV4dCwgc3R5bGVzKTtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2UodGhpcy5jdXJyZW50UG9pbnQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0JlemllckVsZW1lbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmV6aWVyRWxlbWVudChjdXJyZW50UG9pbnQsIG1ldGhvZCwgYXJncykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgY3VycmVudFBvaW50LnggPSArYXJnc1swXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55ID0gK2FyZ3NbMV07XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ICs9ICthcmdzWzBdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkgKz0gK2FyZ3NbMV07XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ID0gK2FyZ3NbMF07XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueSA9ICthcmdzWzFdO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCArPSArYXJnc1swXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55ICs9ICthcmdzWzFdO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCA9ICthcmdzWzBdO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCArPSArYXJnc1swXTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgY3VycmVudFBvaW50LnkgPSArYXJnc1swXTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgY3VycmVudFBvaW50LnkgKz0gK2FyZ3NbMF07XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MSA9ICthcmdzWzBdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkxID0gK2FyZ3NbMV07XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueDIgPSArYXJnc1syXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MiA9ICthcmdzWzNdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnggPSArYXJnc1s0XTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55ID0gK2FyZ3NbNV07XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3VycmVudFBvaW50LngxLCBjdXJyZW50UG9pbnQueTEsIGN1cnJlbnRQb2ludC54MiwgY3VycmVudFBvaW50LnkyLCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MSA9IGN1cnJlbnRQb2ludC54ICsgK2FyZ3NbMF07XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueTEgPSBjdXJyZW50UG9pbnQueSArICthcmdzWzFdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LngyID0gY3VycmVudFBvaW50LnggKyArYXJnc1syXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MiA9IGN1cnJlbnRQb2ludC55ICsgK2FyZ3NbM107XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCArPSArYXJnc1s0XTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55ICs9ICthcmdzWzVdO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRQb2ludC54MSwgY3VycmVudFBvaW50LnkxLCBjdXJyZW50UG9pbnQueDIsIGN1cnJlbnRQb2ludC55MiwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICBpZiAoY3VycmVudFBvaW50LngxICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFBvaW50LnkxICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFBvaW50LngyICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFBvaW50LnkyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50LngxID0gY3VycmVudFBvaW50LnggLSBjdXJyZW50UG9pbnQueDIgKyBjdXJyZW50UG9pbnQueDtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50LnkxID0gY3VycmVudFBvaW50LnkgLSBjdXJyZW50UG9pbnQueTIgKyBjdXJyZW50UG9pbnQueTtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50LngyID0gK2FyZ3NbMF07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MiA9ICthcmdzWzFdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueCA9ICthcmdzWzJdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueSA9ICthcmdzWzNdO1xuICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3VycmVudFBvaW50LngxLCBjdXJyZW50UG9pbnQueTEsIGN1cnJlbnRQb2ludC54MiwgY3VycmVudFBvaW50LnkyLCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50LngxID0gK2FyZ3NbMF07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MSA9ICthcmdzWzFdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueCA9ICthcmdzWzJdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueSA9ICthcmdzWzNdO1xuICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFBvaW50LngxLCBjdXJyZW50UG9pbnQueTEsIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb2ludC54MSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRQb2ludC55MSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRQb2ludC54MiAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRQb2ludC55MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MSA9IGN1cnJlbnRQb2ludC54IC0gY3VycmVudFBvaW50LngyICsgY3VycmVudFBvaW50Lng7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MSA9IGN1cnJlbnRQb2ludC55IC0gY3VycmVudFBvaW50LnkyICsgY3VycmVudFBvaW50Lnk7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MiA9IGN1cnJlbnRQb2ludC54ICsgK2FyZ3NbMF07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MiA9IGN1cnJlbnRQb2ludC55ICsgK2FyZ3NbMV07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ICs9ICthcmdzWzJdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueSArPSArYXJnc1szXTtcbiAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRQb2ludC54MSwgY3VycmVudFBvaW50LnkxLCBjdXJyZW50UG9pbnQueDIsIGN1cnJlbnRQb2ludC55MiwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MSA9IGN1cnJlbnRQb2ludC54ICsgK2FyZ3NbMF07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC55MSA9IGN1cnJlbnRQb2ludC55ICsgK2FyZ3NbMV07XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ICs9ICthcmdzWzJdO1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnQueSArPSArYXJnc1szXTtcbiAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnRQb2ludC54MSwgY3VycmVudFBvaW50LnkxLCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54MSA9ICthcmdzWzBdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkxID0gK2FyZ3NbMV07XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCA9ICthcmdzWzJdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkgPSArYXJnc1szXTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50UG9pbnQueDEsIGN1cnJlbnRQb2ludC55MSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueDEgPSBjdXJyZW50UG9pbnQueCArICthcmdzWzBdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkxID0gY3VycmVudFBvaW50LnkgKyArYXJnc1sxXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ICs9ICthcmdzWzJdO1xuICAgICAgICAgICAgY3VycmVudFBvaW50LnkgKz0gK2FyZ3NbM107XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFBvaW50LngxLCBjdXJyZW50UG9pbnQueTEsIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd0VsbGlwc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZLCB0cmFuc2Zvcm0sIHN0eWxlcykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIFJlbmRlcmVyMkQucmVzZXRTaGFwZVN0eWxlcyhjb250ZXh0LCBzdHlsZXMpO1xuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICB4IC09IHJhZGl1c1g7XG4gICAgICAgIHkgLT0gcmFkaXVzWTtcbiAgICAgICAgdmFyIHcgPSByYWRpdXNYICogMjtcbiAgICAgICAgdmFyIGggPSByYWRpdXNZICogMjtcbiAgICAgICAgdmFyIGthcHBhID0gMC41NTIyODQ4O1xuICAgICAgICB2YXIgb3ggPSB3IC8gMiAqIGthcHBhO1xuICAgICAgICB2YXIgb3kgPSBoIC8gMiAqIGthcHBhO1xuICAgICAgICB2YXIgeGUgPSB4ICsgdztcbiAgICAgICAgdmFyIHllID0geSArIGg7XG4gICAgICAgIHZhciB4bSA9IHggKyB3IC8gMjtcbiAgICAgICAgdmFyIHltID0geSArIGggLyAyO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgICAgIFJlbmRlcmVyMkQuZmlsbE9yU3Ryb2tlKGNvbnRleHQsIHN0eWxlcyk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3UmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgdHJhbnNmb3JtLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBSZW5kZXJlcjJELnJlc2V0U2hhcGVTdHlsZXMoY29udGV4dCwgc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICAgICAgaWYgKHdpZHRoIDwgMiAqIHJhZGl1cykge1xuICAgICAgICAgIHJhZGl1cyA9IHdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMiAqIHJhZGl1cykge1xuICAgICAgICAgIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgIGNvbnRleHQuYXJjVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQuYXJjVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0LCByYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmFyY1RvKHgsIHkgKyBoZWlnaHQsIHgsIHksIHJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSwgeCArIHdpZHRoLCB5LCByYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBSZW5kZXJlcjJELmZpbGxPclN0cm9rZShjb250ZXh0LCBzdHlsZXMpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJhd1NoYXBlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1NoYXBlKHNoYXBlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICB2YXIgdHlwZSA9IHNoYXBlLnR5cGUsXG4gICAgICAgICAgcGF0aCA9IHNoYXBlLnBhdGgsXG4gICAgICAgICAgdHJhbnNmb3JtID0gc2hhcGUudHJhbnNmb3JtLFxuICAgICAgICAgIHN0eWxlcyA9IHNoYXBlLnN0eWxlcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInNoYXBlXCIgLyogUGxhdGZvcm1WaWRlby5TSEFQRV9UWVBFLlNIQVBFICovOlxuICAgICAgICAgICAgdGhpcy5kcmF3QmV6aWVyKHBhdGguZCwgdHJhbnNmb3JtLCBzdHlsZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVsbGlwc2VcIiAvKiBQbGF0Zm9ybVZpZGVvLlNIQVBFX1RZUEUuRUxMSVBTRSAqLzpcbiAgICAgICAgICAgIHRoaXMuZHJhd0VsbGlwc2UoKF9hID0gcGF0aC54KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCAoX2IgPSBwYXRoLnkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsIChfYyA9IHBhdGgucmFkaXVzWCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCwgKF9kID0gcGF0aC5yYWRpdXNZKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwLCB0cmFuc2Zvcm0sIHN0eWxlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVjdFwiIC8qIFBsYXRmb3JtVmlkZW8uU0hBUEVfVFlQRS5SRUNUICovOlxuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdCgoX2UgPSBwYXRoLngpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDAsIChfZiA9IHBhdGgueSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMCwgKF9nID0gcGF0aC53aWR0aCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMCwgKF9oID0gcGF0aC5oZWlnaHQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDAsIChfaiA9IHBhdGguY29ybmVyUmFkaXVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAwLCB0cmFuc2Zvcm0sIHN0eWxlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3U3ByaXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1Nwcml0ZShmcmFtZSwgYml0bWFwLCBkeW5hbWljRWxlbWVudCkge1xuICAgICAgICBpZiAoZnJhbWUuYWxwaGEgPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBhbHBoYSA9IGZyYW1lLmFscGhhLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IGZyYW1lLnRyYW5zZm9ybSxcbiAgICAgICAgICBsYXlvdXQgPSBmcmFtZS5sYXlvdXQsXG4gICAgICAgICAgc2hhcGVzID0gZnJhbWUuc2hhcGVzO1xuICAgICAgICB2YXIgX3JlZiA9IHRyYW5zZm9ybSAhPT0gbnVsbCAmJiB0cmFuc2Zvcm0gIT09IHZvaWQgMCA/IHRyYW5zZm9ybSA6IHt9LFxuICAgICAgICAgIF9yZWYkYSA9IF9yZWYuYSxcbiAgICAgICAgICBhID0gX3JlZiRhID09PSB2b2lkIDAgPyAxIDogX3JlZiRhLFxuICAgICAgICAgIF9yZWYkYiA9IF9yZWYuYixcbiAgICAgICAgICBiID0gX3JlZiRiID09PSB2b2lkIDAgPyAwIDogX3JlZiRiLFxuICAgICAgICAgIF9yZWYkYyA9IF9yZWYuYyxcbiAgICAgICAgICBjID0gX3JlZiRjID09PSB2b2lkIDAgPyAwIDogX3JlZiRjLFxuICAgICAgICAgIF9yZWYkZCA9IF9yZWYuZCxcbiAgICAgICAgICBkID0gX3JlZiRkID09PSB2b2lkIDAgPyAxIDogX3JlZiRkLFxuICAgICAgICAgIF9yZWYkdHggPSBfcmVmLnR4LFxuICAgICAgICAgIHR4ID0gX3JlZiR0eCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkdHgsXG4gICAgICAgICAgX3JlZiR0eSA9IF9yZWYudHksXG4gICAgICAgICAgdHkgPSBfcmVmJHR5ID09PSB2b2lkIDAgPyAwIDogX3JlZiR0eTtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRoaXMuZ2xvYmFsVHJhbnNmb3JtKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkeW5hbWljRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGR5bmFtaWNFbGVtZW50LCAobGF5b3V0LndpZHRoIC0gZHluYW1pY0VsZW1lbnQud2lkdGgpIC8gMiwgKGxheW91dC5oZWlnaHQgLSBkeW5hbWljRWxlbWVudC5oZWlnaHQpIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDosIPmlbTnlLvluIPlsLrlr7hcbiAgICAgICAqIEBwYXJhbSBjb250ZW50TW9kZVxuICAgICAgICogQHBhcmFtIHZpZGVvU2l6ZVxuICAgICAgICogQHBhcmFtIGNhbnZhc1NpemVcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGNvbnRlbnRNb2RlLCB2aWRlb1NpemUsIGNhbnZhc1NpemUpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgICBjYW52YXNIZWlnaHQgPSBjYW52YXNTaXplLmhlaWdodDtcbiAgICAgICAgdmFyIHZpZGVvV2lkdGggPSB2aWRlb1NpemUud2lkdGgsXG4gICAgICAgICAgdmlkZW9IZWlnaHQgPSB2aWRlb1NpemUuaGVpZ2h0O1xuICAgICAgICB2YXIgcmVzaXplS2V5ID0gXCJcIi5jb25jYXQoY29udGVudE1vZGUsIFwiLVwiKS5jb25jYXQodmlkZW9XaWR0aCwgXCItXCIpLmNvbmNhdCh2aWRlb0hlaWdodCwgXCItXCIpLmNvbmNhdChjYW52YXNXaWR0aCwgXCItXCIpLmNvbmNhdChjYW52YXNIZWlnaHQpO1xuICAgICAgICB2YXIgbGFzdFRyYW5zZm9ybSA9IHRoaXMuZ2xvYmFsVHJhbnNmb3JtO1xuICAgICAgICBpZiAodGhpcy5sYXN0UmVzaXplS2V5ID09PSByZXNpemVLZXkgJiYgbGFzdFRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGUgPSB7XG4gICAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRlbnRNb2RlID09PSBcImZpbGxcIiAvKiBQTEFZRVJfQ09OVEVOVF9NT0RFLkZJTEwgKi8pIHtcbiAgICAgICAgICBzY2FsZS5zY2FsZVggPSBjYW52YXNXaWR0aCAvIHZpZGVvV2lkdGg7XG4gICAgICAgICAgc2NhbGUuc2NhbGVZID0gY2FudmFzSGVpZ2h0IC8gdmlkZW9IZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGUgPSBSZW5kZXJlcjJELmNhbGN1bGF0ZVNjYWxlKGNvbnRlbnRNb2RlLCB2aWRlb1NpemUsIGNhbnZhc1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFJlc2l6ZUtleSA9IHJlc2l6ZUtleTtcbiAgICAgICAgdGhpcy5nbG9iYWxUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgYTogc2NhbGUuc2NhbGVYLFxuICAgICAgICAgIGI6IDAuMCxcbiAgICAgICAgICBjOiAwLjAsXG4gICAgICAgICAgZDogc2NhbGUuc2NhbGVZLFxuICAgICAgICAgIHR4OiBzY2FsZS50cmFuc2xhdGVYLFxuICAgICAgICAgIHR5OiBzY2FsZS50cmFuc2xhdGVZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih2aWRlb0VudGl0eSwgbWF0ZXJpYWxzLCBkeW5hbWljTWF0ZXJpYWxzLCBjdXJyZW50RnJhbWUsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgdmFyIHNwcml0ZTtcbiAgICAgICAgdmFyIGltYWdlS2V5O1xuICAgICAgICB2YXIgYml0bWFwO1xuICAgICAgICB2YXIgZHluYW1pY0VsZW1lbnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBoZWFkOyBpIDwgdGFpbDsgaSsrKSB7XG4gICAgICAgICAgc3ByaXRlID0gdmlkZW9FbnRpdHkuc3ByaXRlc1tpXTtcbiAgICAgICAgICBpbWFnZUtleSA9IHNwcml0ZS5pbWFnZUtleTtcbiAgICAgICAgICBiaXRtYXAgPSBtYXRlcmlhbHMuZ2V0KGltYWdlS2V5KTtcbiAgICAgICAgICBkeW5hbWljRWxlbWVudCA9IGR5bmFtaWNNYXRlcmlhbHMuZ2V0KGltYWdlS2V5KTtcbiAgICAgICAgICB0aGlzLmRyYXdTcHJpdGUoc3ByaXRlLmZyYW1lc1tjdXJyZW50RnJhbWVdLCBiaXRtYXAsIGR5bmFtaWNFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxUcmFuc2Zvcm0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdFJlc2l6ZUtleSA9IFwiXCI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwicGFyc2VTVkdQYXRoXCIsXG4gICAgICB2YWx1ZTpcbiAgICAgIC8vIOWcqFJlbmRlcmVyMkTnsbvkuK3mt7vliqDmlrDnmoTop6PmnpDmlrnms5VcbiAgICAgIGZ1bmN0aW9uIHBhcnNlU1ZHUGF0aChkKSB7XG4gICAgICAgIHZhciBTVkdfTEVUVEVSX1JFR0VYUCA9IFJlbmRlcmVyMkQuU1ZHX0xFVFRFUl9SRUdFWFA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgIC8vIOeKtuaAge+8mjAgLSDnrYnlvoXlkb3ku6TvvIwxIC0g6K+75Y+W5Y+C5pWwXG4gICAgICAgIHZhciBzdGF0ZSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50Q29tbWFuZCA9IFwiXCI7XG4gICAgICAgIHZhciBjdXJyZW50QXJncyA9IFwiXCI7XG4gICAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBkLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjaGFyID0gZFtjdXJyZW50SW5kZXhdO1xuICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLy8g562J5b6F5ZG95LukXG4gICAgICAgICAgICAgIGlmIChTVkdfTEVUVEVSX1JFR0VYUC50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1hbmQgPSBjaGFyO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgLy8g6K+75Y+W5Y+C5pWwXG4gICAgICAgICAgICAgIGlmIChTVkdfTEVUVEVSX1JFR0VYUC50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgLy8g6YGH5Yiw5paw5ZG95Luk77yM5L+d5a2Y5b2T5YmN5ZG95Luk5ZKM5Y+C5pWwXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogY3VycmVudENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBjdXJyZW50QXJncy50cmltKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29tbWFuZCA9IGNoYXI7XG4gICAgICAgICAgICAgICAgY3VycmVudEFyZ3MgPSBcIlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBcmdzICs9IGNoYXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIOWkhOeQhuacgOWQjuS4gOS4quWRveS7pFxuICAgICAgICBpZiAoY3VycmVudENvbW1hbmQgJiYgc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBjb21tYW5kOiBjdXJyZW50Q29tbWFuZCxcbiAgICAgICAgICAgIGFyZ3M6IGN1cnJlbnRBcmdzLnRyaW0oKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbGxPclN0cm9rZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxPclN0cm9rZShjb250ZXh0LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgIGlmIChzdHlsZXMuZmlsbCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHlsZXMuc3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNldFNoYXBlU3R5bGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTaGFwZVN0eWxlcyhjb250ZXh0LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZXMuc3Ryb2tlIHx8IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICBpZiAoc3R5bGVzLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHlsZXMubWl0ZXJMaW1pdCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0eWxlcy5taXRlckxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3R5bGVzLmxpbmVDYXApIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZUNhcCA9IHN0eWxlcy5saW5lQ2FwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3R5bGVzLmxpbmVKb2luKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gc3R5bGVzLmxpbmVKb2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlcy5maWxsIHx8IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICBpZiAoc3R5bGVzLmxpbmVEYXNoKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0eWxlcy5saW5lRGFzaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOiuoeeul+e8qeaUvuavlOS+i1xuICAgICAgICogQHBhcmFtIGNvbnRlbnRNb2RlXG4gICAgICAgKiBAcGFyYW0gdmlkZW9TaXplXG4gICAgICAgKiBAcGFyYW0gY2FudmFzU2l6ZVxuICAgICAgICogQHJldHVybnNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJjYWxjdWxhdGVTY2FsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVNjYWxlKGNvbnRlbnRNb2RlLCB2aWRlb1NpemUsIGNhbnZhc1NpemUpIHtcbiAgICAgICAgdmFyIGltYWdlUmF0aW8gPSB2aWRlb1NpemUud2lkdGggLyB2aWRlb1NpemUuaGVpZ2h0O1xuICAgICAgICB2YXIgdmlld1JhdGlvID0gY2FudmFzU2l6ZS53aWR0aCAvIGNhbnZhc1NpemUuaGVpZ2h0O1xuICAgICAgICB2YXIgaXNBc3BlY3RGaXQgPSBjb250ZW50TW9kZSA9PT0gXCJhc3BlY3QtZml0XCIgLyogUExBWUVSX0NPTlRFTlRfTU9ERS5BU1BFQ1RfRklUICovO1xuICAgICAgICB2YXIgc2hvdWxkVXNlV2lkdGggPSBpbWFnZVJhdGlvID49IHZpZXdSYXRpbyAmJiBpc0FzcGVjdEZpdCB8fCBpbWFnZVJhdGlvIDw9IHZpZXdSYXRpbyAmJiAhaXNBc3BlY3RGaXQ7XG4gICAgICAgIHZhciBjcmVhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm0oc2NhbGUsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NhbGVYOiBzY2FsZSxcbiAgICAgICAgICAgIHNjYWxlWTogc2NhbGUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaG91bGRVc2VXaWR0aCkge1xuICAgICAgICAgIHZhciBfc2NhbGUgPSBjYW52YXNTaXplLndpZHRoIC8gdmlkZW9TaXplLndpZHRoO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm0oX3NjYWxlLCAwLCAoY2FudmFzU2l6ZS5oZWlnaHQgLSB2aWRlb1NpemUuaGVpZ2h0ICogX3NjYWxlKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZSA9IGNhbnZhc1NpemUuaGVpZ2h0IC8gdmlkZW9TaXplLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybShzY2FsZSwgKGNhbnZhc1NpemUud2lkdGggLSB2aWRlb1NpemUud2lkdGggKiBzY2FsZSkgLyAyLCAwKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgLyoqXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL1NWRy9UdXRvcmlhbC9QYXRoc1xuICAgKiDnu5jliLbot6/lvoTnmoTkuI3lkIzmjIfku6TvvJpcbiAgICogKiDnm7Tnur/lkb3ku6RcbiAgICogLSBNOiBtb3ZlVG/vvIznp7vliqjliLDmjIflrprngrnvvIzkuI3nu5jliLbnm7Tnur/jgIJcbiAgICogLSBMOiBsaW5lVG/vvIzku47otbflp4vngrnnu5jliLbkuIDmnaHnm7Tnur/liLDmjIflrprngrnjgIJcbiAgICogLSBIOiBob3Jpem9udGFsIGxpbmVUb++8jOS7jui1t+Wni+eCuee7mOWItuS4gOadoeawtOW5s+e6v+WIsOaMh+WumueCueOAglxuICAgKiAtIFY6IHZlcnRpY2FsIGxpbmVUb++8jOS7jui1t+Wni+eCuee7mOWItuS4gOadoeWeguebtOe6v+WIsOaMh+WumueCueOAglxuICAgKiAtIFo6IGNsb3NlUGF0aO+8jOS7jui1t+Wni+eCuee7mOWItuS4gOadoeebtOe6v+WIsOi3r+W+hOi1t+eCue+8jOW9ouaIkOS4gOS4qumXreWQiOi3r+W+hOOAglxuICAgKiAqIOabsue6v+WRveS7pFxuICAgKiAtIEM6IGJlemllckN1cnZlVG/vvIznu5jliLbkuInmrKHotJ3loZ7lsJTmm7Lnur/jgIJcbiAgICogLSBTOiBzbW9vdGggY3VydmVUb++8jOe7mOWItuW5s+a7keS4ieasoei0neWhnuWwlOabsue6v+OAglxuICAgKiAtIFE6IHF1YWRyYXRpY0N1cnZlVG/vvIznu5jliLbkuKTmrKHotJ3loZ7lsJTmm7Lnur/jgIJcbiAgICogLSBUOiBzbW9vdGggcXVhZHJhdGljQ3VydmVUb++8jOe7mOWItuW5s+a7keS4pOasoei0neWhnuWwlOabsue6v+OAglxuICAgKiAqIOW8p+e6v+WRveS7pFxuICAgKiAtIEE6IGFyY1Rv77yM5LuO6LW35aeL54K557uY5Yi25LiA5p2h5byn57q/5Yiw5oyH5a6a54K544CCXG4gICAqL1xuICBSZW5kZXJlcjJELlNWR19QQVRIID0gbmV3IFNldChbXCJNXCIsIFwiTFwiLCBcIkhcIiwgXCJWXCIsIFwiWlwiLCBcIkNcIiwgXCJTXCIsIFwiUVwiLCBcIm1cIiwgXCJsXCIsIFwiaFwiLCBcInZcIiwgXCJ6XCIsIFwiY1wiLCBcInNcIiwgXCJxXCJdKTtcbiAgUmVuZGVyZXIyRC5TVkdfTEVUVEVSX1JFR0VYUCA9IC9bYS16QS1aXS87XG4gIHZhciBSZW5kZXJlcjJERXh0ZW5zaW9uID0ge1xuICAgIHN0aWNrOiBmdW5jdGlvbiBzdGljayhjb250ZXh0LCBiaXRtYXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcih0eXBlLCBjb250ZXh0LCBjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICh0eXBlID09PSBcIkNMXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBGSVhNRTrjgJDmlK/ku5jlrp3lsI/nqIvluo/jgJHml6Dms5XpgJrov4fmlLnlj5jlsLrlr7jmnaXmuIXnkIbnlLvluIPvvIzml6DorrrmmK9DYW52YXPov5jmmK9PZmZzY3JlZW5DYW52YXNcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfTtcbiAgICB9XG4gIH07IC8qKlxuICAgICAqIOWKqOeUu+aOp+WItuWZqFxuICAgICAqL1xuICB2YXIgQW5pbWF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdG9yKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdG9yKTtcbiAgICAgIC8qKlxuICAgICAgICog5Yqo55S75piv5ZCm5omn6KGMXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAvKipcbiAgICAgICAqIOWKqOeUu+W8gOWni+aXtumXtFxuICAgICAgICovXG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIOWKqOeUu+aMgee7reaXtumXtFxuICAgICAgICovXG4gICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgIC8qKlxuICAgICAgICog5b6q546v5pKt5pS+5byA5aeL5bin5LiO5Yqo55S75byA5aeL5bin5LmL6Ze055qE5pe26Ze05YGP5beuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubG9vcFN0YXJ0ID0gMDtcbiAgICAgIC8qKlxuICAgICAgICog5Yqo55S75pqC5YGc5pe255qE5pe26Ze05YGP5beuXG4gICAgICAgKi9cbiAgICAgIHRoaXMucGF1c2VUaW1lID0gMDtcbiAgICAgIC8qKlxuICAgICAgICog5b6q546v5oyB57ut5pe26Ze0XG4gICAgICAgKi9cbiAgICAgIHRoaXMubG9vcER1cmF0aW9uID0gMDtcbiAgICAgIHRoaXMub25BbmltYXRlID0gcGxhdGZvcm0ubm9vcDtcbiAgICAgIC8qIC0tLS0g5LqL5Lu26ZKp5a2QIC0tLS0gKi9cbiAgICAgIHRoaXMub25TdGFydCA9IHBsYXRmb3JtLm5vb3A7XG4gICAgICB0aGlzLm9uVXBkYXRlID0gcGxhdGZvcm0ubm9vcDtcbiAgICAgIHRoaXMub25FbmQgPSBwbGF0Zm9ybS5ub29wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorr7nva7liqjnlLvnmoTlv4XopoHlj4LmlbBcbiAgICAgKiBAcGFyYW0gZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gbG9vcFN0YXJ0XG4gICAgICogQHBhcmFtIGxvb3BcbiAgICAgKiBAcGFyYW0gZmlsbFZhbHVlXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBbmltYXRvciwgW3tcbiAgICAgIGtleTogXCJzZXRDb25maWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb25maWcoZHVyYXRpb24sIGxvb3BTdGFydCwgbG9vcCwgZmlsbFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBsb29wU3RhcnQ7XG4gICAgICAgIHRoaXMubG9vcER1cmF0aW9uID0gZHVyYXRpb24gKiBsb29wICsgZmlsbFZhbHVlIC0gbG9vcFN0YXJ0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGxhdGZvcm0ubm93KCk7XG4gICAgICAgIHRoaXMucGF1c2VUaW1lID0gMDtcbiAgICAgICAgdGhpcy5vblN0YXJ0KCk7XG4gICAgICAgIHRoaXMuZG9GcmFtZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXN1bWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9GcmFtZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGF1c2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIOiuvue9ruaaguWBnOeahOS9jee9rlxuICAgICAgICB0aGlzLnBhdXNlVGltZSA9IChwbGF0Zm9ybS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lKSAlIHRoaXMuZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb0ZyYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG9GcmFtZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgdGhpcy5kb0RlbHRhVGltZShwbGF0Zm9ybS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMub25BbmltYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRvRnJhbWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkb0RlbHRhVGltZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvRGVsdGFUaW1lKGRlbHRhVGltZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIGxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0LFxuICAgICAgICAgIHBhdXNlVGltZSA9IHRoaXMucGF1c2VUaW1lLFxuICAgICAgICAgIGxvb3BEdXJhdGlvbiA9IHRoaXMubG9vcER1cmF0aW9uO1xuICAgICAgICAvLyDmnKzova7liqjnlLvlt7LmtojogJfnmoTml7bpl7Tmr5TkvovvvIhQZXJjZW50YWdlIG9mIHNwZWVkIHRpbWXvvIlcbiAgICAgICAgdmFyIHBlcmNlbnQ7XG4gICAgICAgIHZhciBlbmRlZCA9IGZhbHNlO1xuICAgICAgICAvLyDov5DooYzml7bpl7Qg5aSn5LqO562J5LqOIOW+queOr+aMgee7reaXtumXtFxuICAgICAgICBpZiAoZGVsdGFUaW1lID49IGxvb3BEdXJhdGlvbikge1xuICAgICAgICAgIC8vIOWKqOeUu+W3sue7k+adn1xuICAgICAgICAgIHBlcmNlbnQgPSAxLjA7XG4gICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIOacrOi9ruWKqOeUu+W3sua2iOiAl+eahOaXtumXtOavlOS+iyA9IOacrOi9ruWKqOeUu+W3sua2iOiAl+eahOaXtumXtCAvIOWKqOeUu+aMgee7reaXtumXtFxuICAgICAgICAgIHBlcmNlbnQgPSAoZGVsdGFUaW1lICsgbG9vcFN0YXJ0ICsgcGF1c2VUaW1lKSAlIGR1cmF0aW9uIC8gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblVwZGF0ZShwZXJjZW50KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiBlbmRlZCkge1xuICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpOyAvLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTUxXG4gIC8vIFlvdSBtYXkgYWxzbyB3aXNoIHRvIHRha2UgYSBsb29rIGF0IHRoZSBndWlkZSBJIG1hZGUgYWJvdXQgdGhpcyBwcm9ncmFtOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovMjUzZjMxZWI1YWJjM2Q5Mjc1YWI5NDMwMDNmZmVjYWRcbiAgLy8gU29tZSBvZiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgc2ltaWxhciB0byB0aGF0IG9mIFVaSVAuanM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VWklQLmpzXG4gIC8vIEhvd2V2ZXIsIHRoZSB2YXN0IG1ham9yaXR5IG9mIHRoZSBjb2RlYmFzZSBoYXMgZGl2ZXJnZWQgZnJvbSBVWklQLmpzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlIGFuZCByZWR1Y2UgYnVuZGxlIHNpemUuXG4gIC8vIFNvbWV0aW1lcyAwIHdpbGwgYXBwZWFyIHdoZXJlIC0xIHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUuIFRoaXMgaXMgYmVjYXVzZSB1c2luZyBhIHVpbnRcbiAgLy8gaXMgYmV0dGVyIGZvciBtZW1vcnkgaW4gbW9zdCBlbmdpbmVzIChJICp0aGluayopLlxuICAvLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxuICB2YXIgdTggPSBVaW50OEFycmF5LFxuICAgIHUxNiA9IFVpbnQxNkFycmF5LFxuICAgIGkzMiA9IEludDMyQXJyYXk7XG4gIC8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG4gIHZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8wLCAwLCAvKiBpbXBvc3NpYmxlICovMF0pO1xuICAvLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4gIHZhciBmZGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIC8qIHVudXNlZCAqLzAsIDBdKTtcbiAgLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG4gIHZhciBjbGltID0gbmV3IHU4KFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSk7XG4gIC8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbiAgdmFyIGZyZWIgPSBmdW5jdGlvbiBmcmViKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICBiW2ldID0gc3RhcnQgKz0gMSA8PCBlYltpIC0gMV07XG4gICAgfVxuICAgIC8vIG51bWJlcnMgaGVyZSBhcmUgYXQgbWF4IDE4IGJpdHNcbiAgICB2YXIgciA9IG5ldyBpMzIoYlszMF0pO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCAzMDsgKytfaSkge1xuICAgICAgZm9yICh2YXIgaiA9IGJbX2ldOyBqIDwgYltfaSArIDFdOyArK2opIHtcbiAgICAgICAgcltqXSA9IGogLSBiW19pXSA8PCA1IHwgX2k7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiOiBiLFxuICAgICAgcjogclxuICAgIH07XG4gIH07XG4gIHZhciBfZnJlYiA9IGZyZWIoZmxlYiwgMiksXG4gICAgZmwgPSBfZnJlYi5iLFxuICAgIHJldmZsID0gX2ZyZWIucjtcbiAgLy8gd2UgY2FuIGlnbm9yZSB0aGUgZmFjdCB0aGF0IHRoZSBvdGhlciBudW1iZXJzIGFyZSB3cm9uZzsgdGhleSBuZXZlciBoYXBwZW4gYW55d2F5XG4gIGZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xuICB2YXIgX2ZyZWIyID0gZnJlYihmZGViLCAwKSxcbiAgICBmZCA9IF9mcmViMi5iLFxuICAgIHJldmZkID0gX2ZyZWIyLnI7XG4gIC8vIG1hcCBvZiB2YWx1ZSB0byByZXZlcnNlIChhc3N1bWluZyAxNiBiaXRzKVxuICB2YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDMyNzY4OyArK2kkMSkge1xuICAgIC8vIHJldmVyc2UgdGFibGUgYWxnb3JpdGhtIGZyb20gU09cbiAgICB2YXIgeCA9IChpJDEgJiAweEFBQUEpID4+IDEgfCAoaSQxICYgMHg1NTU1KSA8PCAxO1xuICAgIHggPSAoeCAmIDB4Q0NDQykgPj4gMiB8ICh4ICYgMHgzMzMzKSA8PCAyO1xuICAgIHggPSAoeCAmIDB4RjBGMCkgPj4gNCB8ICh4ICYgMHgwRjBGKSA8PCA0O1xuICAgIHJldltpJDFdID0gKCh4ICYgMHhGRjAwKSA+PiA4IHwgKHggJiAweDAwRkYpIDw8IDgpID4+IDE7XG4gIH1cbiAgLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4gIC8vIG1iIChtYXggYml0cykgbXVzdCBiZSBhdCBtb3N0IDE1XG4gIC8vIFRPRE86IG9wdGltaXplL3NwbGl0IHVwP1xuICB2YXIgaE1hcCA9IGZ1bmN0aW9uIGhNYXAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgaWYgKGNkW2ldKSArK2xbY2RbaV0gLSAxXTtcbiAgICB9XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMTsgaSA8IG1iOyArK2kpIHtcbiAgICAgIGxlW2ldID0gbGVbaSAtIDFdICsgbFtpIC0gMV0gPDwgMTtcbiAgICB9XG4gICAgdmFyIGNvO1xuICAgIGlmIChyKSB7XG4gICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgIGNvID0gbmV3IHUxNigxIDw8IG1iKTtcbiAgICAgIC8vIGJpdHMgdG8gcmVtb3ZlIGZvciByZXZlcnNlclxuICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgLy8gbnVtIGVuY29kaW5nIGJvdGggc3ltYm9sIGFuZCBiaXRzIHJlYWRcbiAgICAgICAgICB2YXIgc3YgPSBpIDw8IDQgfCBjZFtpXTtcbiAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICB2YXIgX3IgPSBtYiAtIGNkW2ldO1xuICAgICAgICAgIC8vIHN0YXJ0IHZhbHVlXG4gICAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgX3I7XG4gICAgICAgICAgLy8gbSBpcyBlbmQgdmFsdWVcbiAgICAgICAgICBmb3IgKHZhciBtID0gdiB8ICgxIDw8IF9yKSAtIDE7IHYgPD0gbTsgKyt2KSB7XG4gICAgICAgICAgICAvLyBldmVyeSAxNiBiaXQgdmFsdWUgc3RhcnRpbmcgd2l0aCB0aGUgY29kZSB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAgICBjb1tyZXZbdl0gPj4gcnZiXSA9IHN2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbyA9IG5ldyB1MTYocyk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgIGNvW2ldID0gcmV2W2xlW2NkW2ldIC0gMV0rK10gPj4gMTUgLSBjZFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG4gIH07XG4gIC8vIGZpeGVkIGxlbmd0aCB0cmVlXG4gIHZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbiAgZm9yICh2YXIgX2kyJDEgPSAwOyBfaTIkMSA8IDE0NDsgKytfaTIkMSkgZmx0W19pMiQxXSA9IDg7XG4gIGZvciAodmFyIF9pMyA9IDE0NDsgX2kzIDwgMjU2OyArK19pMykgZmx0W19pM10gPSA5O1xuICBmb3IgKHZhciBfaTQgPSAyNTY7IF9pNCA8IDI4MDsgKytfaTQpIGZsdFtfaTRdID0gNztcbiAgZm9yICh2YXIgX2k1ID0gMjgwOyBfaTUgPCAyODg7ICsrX2k1KSBmbHRbX2k1XSA9IDg7XG4gIC8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbiAgdmFyIGZkdCA9IG5ldyB1OCgzMik7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IDMyOyArK19pNikgZmR0W19pNl0gPSA1O1xuICAvLyBmaXhlZCBsZW5ndGggbWFwXG4gIHZhciBmbG0gPSAvKiNfX1BVUkVfXyovaE1hcChmbHQsIDksIDApLFxuICAgIGZscm0gPSAvKiNfX1BVUkVfXyovaE1hcChmbHQsIDksIDEpO1xuICAvLyBmaXhlZCBkaXN0YW5jZSBtYXBcbiAgdmFyIGZkbSA9IC8qI19fUFVSRV9fKi9oTWFwKGZkdCwgNSwgMCksXG4gICAgZmRybSA9IC8qI19fUFVSRV9fKi9oTWFwKGZkdCwgNSwgMSk7XG4gIC8vIGZpbmQgbWF4IG9mIGFycmF5XG4gIHZhciBtYXggPSBmdW5jdGlvbiBtYXgoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBfaTcgPSAxOyBfaTcgPCBhLmxlbmd0aDsgKytfaTcpIHtcbiAgICAgIGlmIChhW19pN10gPiBtKSBtID0gYVtfaTddO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfTtcbiAgLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbiAgdmFyIGJpdHMgPSBmdW5jdGlvbiBiaXRzKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IHAgLyA4IHwgMDtcbiAgICByZXR1cm4gKGRbb10gfCBkW28gKyAxXSA8PCA4KSA+PiAocCAmIDcpICYgbTtcbiAgfTtcbiAgLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG4gIHZhciBiaXRzMTYgPSBmdW5jdGlvbiBiaXRzMTYoZCwgcCkge1xuICAgIHZhciBvID0gcCAvIDggfCAwO1xuICAgIHJldHVybiAoZFtvXSB8IGRbbyArIDFdIDw8IDggfCBkW28gKyAyXSA8PCAxNikgPj4gKHAgJiA3KTtcbiAgfTtcbiAgLy8gZ2V0IGVuZCBvZiBieXRlXG4gIHZhciBzaGZ0ID0gZnVuY3Rpb24gc2hmdChwKSB7XG4gICAgcmV0dXJuIChwICsgNykgLyA4IHwgMDtcbiAgfTtcbiAgLy8gdHlwZWQgYXJyYXkgc2xpY2UgLSBhbGxvd3MgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gZnJlZSBvcmlnaW5hbCByZWZlcmVuY2UsXG4gIC8vIHdoaWxlIGJlaW5nIG1vcmUgY29tcGF0aWJsZSB0aGFuIC5zbGljZVxuICB2YXIgc2xjID0gZnVuY3Rpb24gc2xjKHYsIHMsIGUpIHtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aCkgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgcmV0dXJuIG5ldyB1OCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgfTtcbiAgLy8gZXJyb3IgY29kZXNcbiAgdmFyIGVjID0gWyd1bmV4cGVjdGVkIEVPRicsICdpbnZhbGlkIGJsb2NrIHR5cGUnLCAnaW52YWxpZCBsZW5ndGgvbGl0ZXJhbCcsICdpbnZhbGlkIGRpc3RhbmNlJywgJ3N0cmVhbSBmaW5pc2hlZCcsICdubyBzdHJlYW0gaGFuZGxlcicsLFxuICAvLyBkZXRlcm1pbmVkIGJ5IGNvbXByZXNzaW9uIGZ1bmN0aW9uXG4gICdubyBjYWxsYmFjaycsICdpbnZhbGlkIFVURi04IGRhdGEnLCAnZXh0cmEgZmllbGQgdG9vIGxvbmcnLCAnZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5JywgJ2ZpbGVuYW1lIHRvbyBsb25nJywgJ3N0cmVhbSBmaW5pc2hpbmcnLCAnaW52YWxpZCB6aXAgZGF0YSdcbiAgLy8gZGV0ZXJtaW5lZCBieSB1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxuICBdO1xuICB2YXIgX2VyciA9IGZ1bmN0aW9uIGVycihpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSwgX2Vycik7XG4gICAgaWYgKCFudCkgdGhyb3cgZTtcbiAgICByZXR1cm4gZTtcbiAgfTtcbiAgLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG4gIHZhciBpbmZsdCA9IGZ1bmN0aW9uIGluZmx0KGRhdCwgc3QsIGJ1ZiwgZGljdCkge1xuICAgIC8vIHNvdXJjZSBsZW5ndGggICAgICAgZGljdCBsZW5ndGhcbiAgICB2YXIgc2wgPSBkYXQubGVuZ3RoLFxuICAgICAgZGwgPSBkaWN0ID8gZGljdC5sZW5ndGggOiAwO1xuICAgIGlmICghc2wgfHwgc3QuZiAmJiAhc3QubCkgcmV0dXJuIGJ1ZiB8fCBuZXcgdTgoMCk7XG4gICAgdmFyIG5vQnVmID0gIWJ1ZjtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgcmVzaXplID0gbm9CdWYgfHwgc3QuaSAhPSAyO1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSBzdC5pO1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmIChub0J1ZikgYnVmID0gbmV3IHU4KHNsICogMyk7XG4gICAgLy8gZW5zdXJlIGJ1ZmZlciBjYW4gZml0IGF0IGxlYXN0IGwgZWxlbWVudHNcbiAgICB2YXIgY2J1ZiA9IGZ1bmN0aW9uIGNidWYobCkge1xuICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugc2l6ZSB0byBmaXRcbiAgICAgIGlmIChsID4gYmwpIHtcbiAgICAgICAgLy8gRG91YmxlIG9yIHNldCB0byBuZWNlc3NhcnksIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICBuYnVmLnNldChidWYpO1xuICAgICAgICBidWYgPSBuYnVmO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gIGxhc3QgY2h1bmsgICAgICAgICBiaXRwb3MgICAgICAgICAgIGJ5dGVzXG4gICAgdmFyIGZpbmFsID0gc3QuZiB8fCAwLFxuICAgICAgcG9zID0gc3QucCB8fCAwLFxuICAgICAgYnQgPSBzdC5iIHx8IDAsXG4gICAgICBsbSA9IHN0LmwsXG4gICAgICBkbSA9IHN0LmQsXG4gICAgICBsYnQgPSBzdC5tLFxuICAgICAgZGJ0ID0gc3QubjtcbiAgICAvLyB0b3RhbCBiaXRzXG4gICAgdmFyIHRidHMgPSBzbCAqIDg7XG4gICAgZG8ge1xuICAgICAgaWYgKCFsbSkge1xuICAgICAgICAvLyBCRklOQUwgLSB0aGlzIGlzIG9ubHkgMSB3aGVuIGxhc3QgY2h1bmsgaXMgbmV4dFxuICAgICAgICBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAvLyB0eXBlOiAwID0gbm8gY29tcHJlc3Npb24sIDEgPSBmaXhlZCBodWZmbWFuLCAyID0gZHluYW1pYyBodWZmbWFuXG4gICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgLy8gZ28gdG8gZW5kIG9mIGJ5dGUgYm91bmRhcnlcbiAgICAgICAgICB2YXIgcyA9IHNoZnQocG9zKSArIDQsXG4gICAgICAgICAgICBsID0gZGF0W3MgLSA0XSB8IGRhdFtzIC0gM10gPDwgOCxcbiAgICAgICAgICAgIHQgPSBzICsgbDtcbiAgICAgICAgICBpZiAodCA+IHNsKSB7XG4gICAgICAgICAgICBpZiAobm9TdCkgX2VycigwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgIGlmIChyZXNpemUpIGNidWYoYnQgKyBsKTtcbiAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDgsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IDEpIGxtID0gZmxybSwgZG0gPSBmZHJtLCBsYnQgPSA5LCBkYnQgPSA1O2Vsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NyxcbiAgICAgICAgICAgIGhjTGVuID0gYml0cyhkYXQsIHBvcyArIDEwLCAxNSkgKyA0O1xuICAgICAgICAgIHZhciB0bCA9IGhMaXQgKyBiaXRzKGRhdCwgcG9zICsgNSwgMzEpICsgMTtcbiAgICAgICAgICBwb3MgKz0gMTQ7XG4gICAgICAgICAgLy8gbGVuZ3RoK2Rpc3RhbmNlIHRyZWVcbiAgICAgICAgICB2YXIgbGR0ID0gbmV3IHU4KHRsKTtcbiAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0cmVlXG4gICAgICAgICAgdmFyIGNsdCA9IG5ldyB1OCgxOSk7XG4gICAgICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgaGNMZW47ICsrX2k4KSB7XG4gICAgICAgICAgICAvLyB1c2UgaW5kZXggbWFwIHRvIGdldCByZWFsIGNvZGVcbiAgICAgICAgICAgIGNsdFtjbGltW19pOF1dID0gYml0cyhkYXQsIHBvcyArIF9pOCAqIDMsIDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MgKz0gaGNMZW4gKiAzO1xuICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBiaXRzXG4gICAgICAgICAgdmFyIGNsYiA9IG1heChjbHQpLFxuICAgICAgICAgICAgY2xibXNrID0gKDEgPDwgY2xiKSAtIDE7XG4gICAgICAgICAgLy8gY29kZSBsZW5ndGhzIG1hcFxuICAgICAgICAgIHZhciBjbG0gPSBoTWFwKGNsdCwgY2xiLCAxKTtcbiAgICAgICAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCB0bDspIHtcbiAgICAgICAgICAgIHZhciByID0gY2xtW2JpdHMoZGF0LCBwb3MsIGNsYm1zayldO1xuICAgICAgICAgICAgLy8gYml0cyByZWFkXG4gICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgLy8gc3ltYm9sXG4gICAgICAgICAgICB2YXIgX3MgPSByID4+IDQ7XG4gICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICBpZiAoX3MgPCAxNikge1xuICAgICAgICAgICAgICBsZHRbX2k5KytdID0gX3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAgY29weSAgIGNvdW50XG4gICAgICAgICAgICAgIHZhciBjID0gMCxcbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgaWYgKF9zID09IDE2KSBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtfaTkgLSAxXTtlbHNlIGlmIChfcyA9PSAxNykgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCA3KSwgcG9zICs9IDM7ZWxzZSBpZiAoX3MgPT0gMTgpIG4gPSAxMSArIGJpdHMoZGF0LCBwb3MsIDEyNyksIHBvcyArPSA3O1xuICAgICAgICAgICAgICB3aGlsZSAobi0tKSBsZHRbX2k5KytdID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gICAgbGVuZ3RoIHRyZWUgICAgICAgICAgICAgICAgIGRpc3RhbmNlIHRyZWVcbiAgICAgICAgICB2YXIgbHQgPSBsZHQuc3ViYXJyYXkoMCwgaExpdCksXG4gICAgICAgICAgICBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgIH0gZWxzZSBfZXJyKDEpO1xuICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgIGlmIChub1N0KSBfZXJyKDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGJ1ZmZlciBjYW4gaG9sZCB0aGlzICsgdGhlIGxhcmdlc3QgcG9zc2libGUgYWRkaXRpb25cbiAgICAgIC8vIE1heGltdW0gY2h1bmsgc2l6ZSAocHJhY3RpY2FsbHksIHRoZW9yZXRpY2FsbHkgaW5maW5pdGUpIGlzIDJeMTdcbiAgICAgIGlmIChyZXNpemUpIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLFxuICAgICAgICBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgIHZhciBscG9zID0gcG9zO1xuICAgICAgZm9yICg7OyBscG9zID0gcG9zKSB7XG4gICAgICAgIC8vIGJpdHMgcmVhZCwgY29kZVxuICAgICAgICB2YXIgX2MgPSBsbVtiaXRzMTYoZGF0LCBwb3MpICYgbG1zXSxcbiAgICAgICAgICBzeW0gPSBfYyA+PiA0O1xuICAgICAgICBwb3MgKz0gX2MgJiAxNTtcbiAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICBpZiAobm9TdCkgX2VycigwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9jKSBfZXJyKDIpO1xuICAgICAgICBpZiAoc3ltIDwgMjU2KSBidWZbYnQrK10gPSBzeW07ZWxzZSBpZiAoc3ltID09IDI1Nikge1xuICAgICAgICAgIGxwb3MgPSBwb3MsIGxtID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhZGQgPSBzeW0gLSAyNTQ7XG4gICAgICAgICAgLy8gbm8gZXh0cmEgYml0cyBuZWVkZWQgaWYgbGVzc1xuICAgICAgICAgIGlmIChzeW0gPiAyNjQpIHtcbiAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICB2YXIgX2kwID0gc3ltIC0gMjU3LFxuICAgICAgICAgICAgICBiID0gZmxlYltfaTBdO1xuICAgICAgICAgICAgYWRkID0gYml0cyhkYXQsIHBvcywgKDEgPDwgYikgLSAxKSArIGZsW19pMF07XG4gICAgICAgICAgICBwb3MgKz0gYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGlzdFxuICAgICAgICAgIHZhciBkID0gZG1bYml0czE2KGRhdCwgcG9zKSAmIGRtc10sXG4gICAgICAgICAgICBkc3ltID0gZCA+PiA0O1xuICAgICAgICAgIGlmICghZCkgX2VycigzKTtcbiAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgIHZhciBfZHQgPSBmZFtkc3ltXTtcbiAgICAgICAgICBpZiAoZHN5bSA+IDMpIHtcbiAgICAgICAgICAgIHZhciBfYjIgPSBmZGViW2RzeW1dO1xuICAgICAgICAgICAgX2R0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoMSA8PCBfYjIpIC0gMSwgcG9zICs9IF9iMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvcyA+IHRidHMpIHtcbiAgICAgICAgICAgIGlmIChub1N0KSBfZXJyKDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNpemUpIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICAgIHZhciBlbmQgPSBidCArIGFkZDtcbiAgICAgICAgICBpZiAoYnQgPCBfZHQpIHtcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IGRsIC0gX2R0LFxuICAgICAgICAgICAgICBkZW5kID0gTWF0aC5taW4oX2R0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKHNoaWZ0ICsgYnQgPCAwKSBfZXJyKDMpO1xuICAgICAgICAgICAgZm9yICg7IGJ0IDwgZGVuZDsgKytidCkgYnVmW2J0XSA9IGRpY3Rbc2hpZnQgKyBidF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgKytidCkgYnVmW2J0XSA9IGJ1ZltidCAtIF9kdF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0LmwgPSBsbSwgc3QucCA9IGxwb3MsIHN0LmIgPSBidCwgc3QuZiA9IGZpbmFsO1xuICAgICAgaWYgKGxtKSBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIC8vIGRvbid0IHJlYWxsb2NhdGUgZm9yIHN0cmVhbXMgb3IgdXNlciBidWZmZXJzXG4gICAgcmV0dXJuIGJ0ICE9IGJ1Zi5sZW5ndGggJiYgbm9CdWYgPyBzbGMoYnVmLCAwLCBidCkgOiBidWYuc3ViYXJyYXkoMCwgYnQpO1xuICB9O1xuICAvLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBob2xkIHYgdG8gZFxuICB2YXIgd2JpdHMgPSBmdW5jdGlvbiB3Yml0cyhkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSBwIC8gOCB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4gODtcbiAgfTtcbiAgLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgKD44KSB0aGF0IGNhbiBob2xkIHYgdG8gZFxuICB2YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIHdiaXRzMTYoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gcCAvIDggfCAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+IDg7XG4gICAgZFtvICsgMl0gfD0gdiA+PiAxNjtcbiAgfTtcbiAgLy8gY3JlYXRlcyBjb2RlIGxlbmd0aHMgZnJvbSBhIGZyZXF1ZW5jeSB0YWJsZVxuICB2YXIgaFRyZWUgPSBmdW5jdGlvbiBoVHJlZShkLCBtYikge1xuICAgIC8vIE5lZWQgZXh0cmEgaW5mbyB0byBtYWtlIGEgdHJlZVxuICAgIHZhciB0ID0gW107XG4gICAgZm9yICh2YXIgX2kxID0gMDsgX2kxIDwgZC5sZW5ndGg7ICsrX2kxKSB7XG4gICAgICBpZiAoZFtfaTFdKSB0LnB1c2goe1xuICAgICAgICBzOiBfaTEsXG4gICAgICAgIGY6IGRbX2kxXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcykgcmV0dXJuIHtcbiAgICAgIHQ6IGV0LFxuICAgICAgbDogMFxuICAgIH07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICB2W3RbMF0uc10gPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdDogdixcbiAgICAgICAgbDogMVxuICAgICAgfTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5mIC0gYi5mO1xuICAgIH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7XG4gICAgICBzOiAtMSxcbiAgICAgIGY6IDI1MDAxXG4gICAgfSk7XG4gICAgdmFyIGwgPSB0WzBdLFxuICAgICAgciA9IHRbMV0sXG4gICAgICBpMCA9IDAsXG4gICAgICBpMSA9IDEsXG4gICAgICBpMiA9IDI7XG4gICAgdFswXSA9IHtcbiAgICAgIHM6IC0xLFxuICAgICAgZjogbC5mICsgci5mLFxuICAgICAgbDogbCxcbiAgICAgIHI6IHJcbiAgICB9O1xuICAgIC8vIGVmZmljaWVudCBhbGdvcml0aG0gZnJvbSBVWklQLmpzXG4gICAgLy8gaTAgaXMgbG9va2JlaGluZCwgaTIgaXMgbG9va2FoZWFkIC0gYWZ0ZXIgcHJvY2Vzc2luZyB0d28gbG93LWZyZXFcbiAgICAvLyBzeW1ib2xzIHRoYXQgY29tYmluZWQgaGF2ZSBoaWdoIGZyZXEsIHdpbGwgc3RhcnQgcHJvY2Vzc2luZyBpMiAoaGlnaC1mcmVxLFxuICAgIC8vIG5vbi1jb21wb3NpdGUpIHN5bWJvbHMgaW5zdGVhZFxuICAgIC8vIHNlZSBodHRwczovL3JlZGRpdC5jb20vci9waG90b3BlYS9jb21tZW50cy9pa2VraHQvdXppcGpzX3F1ZXN0aW9ucy9cbiAgICB3aGlsZSAoaTEgIT0gcyAtIDEpIHtcbiAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICB0W2kxKytdID0ge1xuICAgICAgICBzOiAtMSxcbiAgICAgICAgZjogbC5mICsgci5mLFxuICAgICAgICBsOiBsLFxuICAgICAgICByOiByXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBfaTEwID0gMTsgX2kxMCA8IHM7ICsrX2kxMCkge1xuICAgICAgaWYgKHQyW19pMTBdLnMgPiBtYXhTeW0pIG1heFN5bSA9IHQyW19pMTBdLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBfbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAvLyBtb3JlIGFsZ29yaXRobXMgZnJvbSBVWklQLmpzXG4gICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICB2YXIgX2kxMSA9IDAsXG4gICAgICAgIGR0ID0gMDtcbiAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsXG4gICAgICAgIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgdDIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdHJbYi5zXSAtIHRyW2Euc10gfHwgYS5mIC0gYi5mO1xuICAgICAgfSk7XG4gICAgICBmb3IgKDsgX2kxMSA8IHM7ICsrX2kxMSkge1xuICAgICAgICB2YXIgX2kxMiA9IHQyW19pMTFdLnM7XG4gICAgICAgIGlmICh0cltfaTEyXSA+IG1iKSB7XG4gICAgICAgICAgZHQgKz0gY3N0IC0gKDEgPDwgbWJ0IC0gdHJbX2kxMl0pO1xuICAgICAgICAgIHRyW19pMTJdID0gbWI7XG4gICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICAgIGR0ID4+PSBsZnQ7XG4gICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgIHZhciBfaTEzID0gdDJbX2kxMV0ucztcbiAgICAgICAgaWYgKHRyW19pMTNdIDwgbWIpIGR0IC09IDEgPDwgbWIgLSB0cltfaTEzXSsrIC0gMTtlbHNlICsrX2kxMTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBfaTExID49IDAgJiYgZHQ7IC0tX2kxMSkge1xuICAgICAgICB2YXIgX2kxNCA9IHQyW19pMTFdLnM7XG4gICAgICAgIGlmICh0cltfaTE0XSA9PSBtYikge1xuICAgICAgICAgIC0tdHJbX2kxNF07XG4gICAgICAgICAgKytkdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0OiBuZXcgdTgodHIpLFxuICAgICAgbDogbWJ0XG4gICAgfTtcbiAgfTtcbiAgLy8gZ2V0IHRoZSBtYXggbGVuZ3RoIGFuZCBhc3NpZ24gbGVuZ3RoIGNvZGVzXG4gIHZhciBfbG4gPSBmdW5jdGlvbiBsbihuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMSA/IE1hdGgubWF4KF9sbihuLmwsIGwsIGQgKyAxKSwgX2xuKG4uciwgbCwgZCArIDEpKSA6IGxbbi5zXSA9IGQ7XG4gIH07XG4gIC8vIGxlbmd0aCBjb2RlcyBnZW5lcmF0aW9uXG4gIHZhciBsYyA9IGZ1bmN0aW9uIGxjKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pO1xuICAgIHZhciBjbCA9IG5ldyB1MTYoKytzKTtcbiAgICAvLyAgaW5kICAgICAgbnVtICAgICAgICAgc3RyZWFrXG4gICAgdmFyIGNsaSA9IDAsXG4gICAgICBjbG4gPSBjWzBdLFxuICAgICAgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uIHcodikge1xuICAgICAgY2xbY2xpKytdID0gdjtcbiAgICB9O1xuICAgIGZvciAodmFyIF9pMTUgPSAxOyBfaTE1IDw9IHM7ICsrX2kxNSkge1xuICAgICAgaWYgKGNbX2kxNV0gPT0gY2xuICYmIF9pMTUgIT0gcykgKytjbHM7ZWxzZSB7XG4gICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KSB3KDMyNzU0KTtcbiAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgdyhjbHMgPiAxMCA/IGNscyAtIDExIDw8IDUgfCAyODY5MCA6IGNscyAtIDMgPDwgNSB8IDEyMzA1KTtcbiAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNikgdyg4MzA0KTtcbiAgICAgICAgICBpZiAoY2xzID4gMikgdyhjbHMgLSAzIDw8IDUgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2xzLS0pIHcoY2xuKTtcbiAgICAgICAgY2xzID0gMTtcbiAgICAgICAgY2xuID0gY1tfaTE1XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGM6IGNsLnN1YmFycmF5KDAsIGNsaSksXG4gICAgICBuOiBzXG4gICAgfTtcbiAgfTtcbiAgLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2Ygb3V0cHV0IGZyb20gdHJlZSwgY29kZSBsZW5ndGhzXG4gIHZhciBjbGVuID0gZnVuY3Rpb24gY2xlbihjZiwgY2wpIHtcbiAgICB2YXIgbCA9IDA7XG4gICAgZm9yICh2YXIgX2kxNiA9IDA7IF9pMTYgPCBjbC5sZW5ndGg7ICsrX2kxNikgbCArPSBjZltfaTE2XSAqIGNsW19pMTZdO1xuICAgIHJldHVybiBsO1xuICB9O1xuICAvLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuICAvLyByZXR1cm5zIHRoZSBuZXcgYml0IHBvc1xuICB2YXIgd2ZibGsgPSBmdW5jdGlvbiB3ZmJsayhvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4gODtcbiAgICBvdXRbbyArIDJdID0gb3V0W29dIF4gMjU1O1xuICAgIG91dFtvICsgM10gPSBvdXRbbyArIDFdIF4gMjU1O1xuICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgczsgKytfaTE3KSBvdXRbbyArIF9pMTcgKyA0XSA9IGRhdFtfaTE3XTtcbiAgICByZXR1cm4gKG8gKyA0ICsgcykgKiA4O1xuICB9O1xuICAvLyB3cml0ZXMgYSBibG9ja1xuICB2YXIgd2JsayA9IGZ1bmN0aW9uIHdibGsoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9oVHJlZSA9IGhUcmVlKGxmLCAxNSksXG4gICAgICBkbHQgPSBfaFRyZWUudCxcbiAgICAgIG1sYiA9IF9oVHJlZS5sO1xuICAgIHZhciBfaFRyZWUyID0gaFRyZWUoZGYsIDE1KSxcbiAgICAgIGRkdCA9IF9oVHJlZTIudCxcbiAgICAgIG1kYiA9IF9oVHJlZTIubDtcbiAgICB2YXIgX2xjID0gbGMoZGx0KSxcbiAgICAgIGxjbHQgPSBfbGMuYyxcbiAgICAgIG5sYyA9IF9sYy5uO1xuICAgIHZhciBfbGMyID0gbGMoZGR0KSxcbiAgICAgIGxjZHQgPSBfbGMyLmMsXG4gICAgICBuZGMgPSBfbGMyLm47XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIF9pMTggPSAwOyBfaTE4IDwgbGNsdC5sZW5ndGg7ICsrX2kxOCkgKytsY2ZyZXFbbGNsdFtfaTE4XSAmIDMxXTtcbiAgICBmb3IgKHZhciBfaTE5ID0gMDsgX2kxOSA8IGxjZHQubGVuZ3RoOyArK19pMTkpICsrbGNmcmVxW2xjZHRbX2kxOV0gJiAzMV07XG4gICAgdmFyIF9oVHJlZTMgPSBoVHJlZShsY2ZyZXEsIDcpLFxuICAgICAgbGN0ID0gX2hUcmVlMy50LFxuICAgICAgbWxjYiA9IF9oVHJlZTMubDtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKTtcbiAgICB2YXIgZmxlbiA9IGJsICsgNSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArIDIgKiBsY2ZyZXFbMTZdICsgMyAqIGxjZnJlcVsxN10gKyA3ICogbGNmcmVxWzE4XTtcbiAgICBpZiAoYnMgPj0gMCAmJiBmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgIHZhciBsbG0gPSBoTWFwKGxjdCwgbWxjYiwgMCk7XG4gICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgIHdiaXRzKG91dCwgcCArIDEwLCBubGNjIC0gNCk7XG4gICAgICBwICs9IDE0O1xuICAgICAgZm9yICh2YXIgX2kyMCA9IDA7IF9pMjAgPCBubGNjOyArK19pMjApIHdiaXRzKG91dCwgcCArIDMgKiBfaTIwLCBsY3RbY2xpbVtfaTIwXV0pO1xuICAgICAgcCArPSAzICogbmxjYztcbiAgICAgIHZhciBsY3RzID0gW2xjbHQsIGxjZHRdO1xuICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgdmFyIGNsY3QgPSBsY3RzW2l0XTtcbiAgICAgICAgZm9yICh2YXIgX2kyMSA9IDA7IF9pMjEgPCBjbGN0Lmxlbmd0aDsgKytfaTIxKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGNsY3RbX2kyMV0gJiAzMTtcbiAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICBpZiAobGVuID4gMTUpIHdiaXRzKG91dCwgcCwgY2xjdFtfaTIxXSA+PiA1ICYgMTI3KSwgcCArPSBjbGN0W19pMjFdID4+IDEyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxtID0gZmxtLCBsbCA9IGZsdCwgZG0gPSBmZG0sIGRsID0gZmR0O1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTIyID0gMDsgX2kyMiA8IGxpOyArK19pMjIpIHtcbiAgICAgIHZhciBzeW0gPSBzeW1zW19pMjJdO1xuICAgICAgaWYgKHN5bSA+IDI1NSkge1xuICAgICAgICB2YXIgX2xlbiA9IHN5bSA+PiAxOCAmIDMxO1xuICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bX2xlbiArIDI1N10pLCBwICs9IGxsW19sZW4gKyAyNTddO1xuICAgICAgICBpZiAoX2xlbiA+IDcpIHdiaXRzKG91dCwgcCwgc3ltID4+IDIzICYgMzEpLCBwICs9IGZsZWJbX2xlbl07XG4gICAgICAgIHZhciBkc3QgPSBzeW0gJiAzMTtcbiAgICAgICAgd2JpdHMxNihvdXQsIHAsIGRtW2RzdF0pLCBwICs9IGRsW2RzdF07XG4gICAgICAgIGlmIChkc3QgPiAzKSB3Yml0czE2KG91dCwgcCwgc3ltID4+IDUgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltXSksIHAgKz0gbGxbc3ltXTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbiAgfTtcbiAgLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG4gIHZhciBkZW8gPSAvKiNfX1BVUkVfXyovbmV3IGkzMihbNjU1NDAsIDEzMTA4MCwgMTMxMDg4LCAxMzExMDQsIDI2MjE3NiwgMTA0ODcwNCwgMTA0ODgzMiwgMjExNDU2MCwgMjExNzYzMl0pO1xuICAvLyBlbXB0eVxuICB2YXIgZXQgPSAvKiNfX1BVUkVfXyovbmV3IHU4KDApO1xuICAvLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxuICB2YXIgZGZsdCA9IGZ1bmN0aW9uIGRmbHQoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgc3QpIHtcbiAgICB2YXIgcyA9IHN0LnogfHwgZGF0Lmxlbmd0aDtcbiAgICB2YXIgbyA9IG5ldyB1OChwcmUgKyBzICsgNSAqICgxICsgTWF0aC5jZWlsKHMgLyA3MDAwKSkgKyBwb3N0KTtcbiAgICAvLyB3cml0aW5nIHRvIHRoaXMgd3JpdGVzIHRvIHRoZSBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIHcgPSBvLnN1YmFycmF5KHByZSwgby5sZW5ndGggLSBwb3N0KTtcbiAgICB2YXIgbHN0ID0gc3QubDtcbiAgICB2YXIgcG9zID0gKHN0LnIgfHwgMCkgJiA3O1xuICAgIGlmIChsdmwpIHtcbiAgICAgIGlmIChwb3MpIHdbMF0gPSBzdC5yID4+IDM7XG4gICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgdmFyIG4gPSBvcHQgPj4gMTMsXG4gICAgICAgIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgdmFyIG1zayA9ICgxIDw8IHBsdmwpIC0gMTtcbiAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgdmFyIHByZXYgPSBzdC5wIHx8IG5ldyB1MTYoMzI3NjgpLFxuICAgICAgICBoZWFkID0gc3QuaCB8fCBuZXcgdTE2KG1zayArIDEpO1xuICAgICAgdmFyIGJzMSA9IE1hdGguY2VpbChwbHZsIC8gMyksXG4gICAgICAgIGJzMiA9IDIgKiBiczE7XG4gICAgICB2YXIgaHNoID0gZnVuY3Rpb24gaHNoKGkpIHtcbiAgICAgICAgcmV0dXJuIChkYXRbaV0gXiBkYXRbaSArIDFdIDw8IGJzMSBeIGRhdFtpICsgMl0gPDwgYnMyKSAmIG1zaztcbiAgICAgIH07XG4gICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgIC8vIDQyNCBidWZmZXIgZm9yIGxhc3QgYmxvY2tcbiAgICAgIHZhciBzeW1zID0gbmV3IGkzMigyNTAwMCk7XG4gICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgdmFyIGxmID0gbmV3IHUxNigyODgpLFxuICAgICAgICBkZiA9IG5ldyB1MTYoMzIpO1xuICAgICAgLy8gIGwvbGNudCAgZXhiaXRzICBpbmRleCAgICAgICAgICBsL2xpbmQgIHdhaXRkeCAgICAgICAgICBibGtwb3NcbiAgICAgIHZhciBfbGMzID0gMCxcbiAgICAgICAgZWIgPSAwLFxuICAgICAgICBfaTIzID0gc3QuaSB8fCAwLFxuICAgICAgICBsaSA9IDAsXG4gICAgICAgIHdpID0gc3QudyB8fCAwLFxuICAgICAgICBicyA9IDA7XG4gICAgICBmb3IgKDsgX2kyMyArIDIgPCBzOyArK19pMjMpIHtcbiAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICB2YXIgaHYgPSBoc2goX2kyMyk7XG4gICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgdmFyIGltb2QgPSBfaTIzICYgMzI3NjcsXG4gICAgICAgICAgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICBoZWFkW2h2XSA9IGltb2Q7XG4gICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgIGlmICh3aSA8PSBfaTIzKSB7XG4gICAgICAgICAgLy8gYnl0ZXMgcmVtYWluaW5nXG4gICAgICAgICAgdmFyIHJlbSA9IHMgLSBfaTIzO1xuICAgICAgICAgIGlmICgoX2xjMyA+IDcwMDAgfHwgbGkgPiAyNDU3NikgJiYgKHJlbSA+IDQyMyB8fCAhbHN0KSkge1xuICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgX2kyMyAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgbGkgPSBfbGMzID0gZWIgPSAwLCBicyA9IF9pMjM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKSBsZltqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgMzA7ICsrX2opIGRmW19qXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgdmFyIGwgPSAyLFxuICAgICAgICAgICAgZCA9IDAsXG4gICAgICAgICAgICBjaCA9IGMsXG4gICAgICAgICAgICBkaWYgPSBpbW9kIC0gcGltb2QgJiAzMjc2NztcbiAgICAgICAgICBpZiAocmVtID4gMiAmJiBodiA9PSBoc2goX2kyMyAtIGRpZikpIHtcbiAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBfaTIzKTtcbiAgICAgICAgICAgIC8vIG1heCBwb3NzaWJsZSBsZW5ndGhcbiAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgd2hpbGUgKGRpZiA8PSBtYXhkICYmIC0tY2ggJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICBpZiAoZGF0W19pMjMgKyBsXSA9PSBkYXRbX2kyMyArIGwgLSBkaWZdKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5sID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbmwgPCBtbCAmJiBkYXRbX2kyMyArIG5sXSA9PSBkYXRbX2kyMyArIG5sIC0gZGlmXTsgKytubCk7XG4gICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgbCA9IG5sLCBkID0gZGlmO1xuICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGxlbmd0aCBvZiBsaXRlcmFscyBhbmQgc2VhcmNoIGZvciB0aGF0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgdmFyIG1kID0gMDtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG1tZDsgKytfajIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpID0gX2kyMyAtIGRpZiArIF9qMiAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHRpID0gcHJldlt0aV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZCA9IHRpIC0gcHRpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZCA+IG1kKSBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgcHJldmlvdXMgbWF0Y2hcbiAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgIGRpZiArPSBpbW9kIC0gcGltb2QgJiAzMjc2NztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIGludDMyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgIHN5bXNbbGkrK10gPSAyNjg0MzU0NTYgfCByZXZmbFtsXSA8PCAxOCB8IHJldmZkW2RdO1xuICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsXG4gICAgICAgICAgICAgIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICBlYiArPSBmbGViW2xpbl0gKyBmZGViW2Rpbl07XG4gICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICB3aSA9IF9pMjMgKyBsO1xuICAgICAgICAgICAgKytfbGMzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW1zW2xpKytdID0gZGF0W19pMjNdO1xuICAgICAgICAgICAgKytsZltkYXRbX2kyM11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChfaTIzID0gTWF0aC5tYXgoX2kyMywgd2kpOyBfaTIzIDwgczsgKytfaTIzKSB7XG4gICAgICAgIHN5bXNbbGkrK10gPSBkYXRbX2kyM107XG4gICAgICAgICsrbGZbZGF0W19pMjNdXTtcbiAgICAgIH1cbiAgICAgIHBvcyA9IHdibGsoZGF0LCB3LCBsc3QsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgX2kyMyAtIGJzLCBwb3MpO1xuICAgICAgaWYgKCFsc3QpIHtcbiAgICAgICAgc3QuciA9IHBvcyAmIDcgfCB3W3BvcyAvIDggfCAwXSA8PCAzO1xuICAgICAgICAvLyBzaGZ0KHBvcykgbm93IDEgbGVzcyBpZiBwb3MgJiA3ICE9IDBcbiAgICAgICAgcG9zIC09IDc7XG4gICAgICAgIHN0LmggPSBoZWFkLCBzdC5wID0gcHJldiwgc3QuaSA9IF9pMjMsIHN0LncgPSB3aTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2kyNCA9IHN0LncgfHwgMDsgX2kyNCA8IHMgKyBsc3Q7IF9pMjQgKz0gNjU1MzUpIHtcbiAgICAgICAgLy8gZW5kXG4gICAgICAgIHZhciBlID0gX2kyNCArIDY1NTM1O1xuICAgICAgICBpZiAoZSA+PSBzKSB7XG4gICAgICAgICAgLy8gd3JpdGUgZmluYWwgYmxvY2tcbiAgICAgICAgICB3W3BvcyAvIDggfCAwXSA9IGxzdDtcbiAgICAgICAgICBlID0gcztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MgKyAxLCBkYXQuc3ViYXJyYXkoX2kyNCwgZSkpO1xuICAgICAgfVxuICAgICAgc3QuaSA9IHM7XG4gICAgfVxuICAgIHJldHVybiBzbGMobywgMCwgcHJlICsgc2hmdChwb3MpICsgcG9zdCk7XG4gIH07XG4gIC8vIEFkbGVyMzJcbiAgdmFyIGFkbGVyID0gZnVuY3Rpb24gYWRsZXIoKSB7XG4gICAgdmFyIGEgPSAxLFxuICAgICAgYiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IGZ1bmN0aW9uIHAoZCkge1xuICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgIHZhciBuID0gYSxcbiAgICAgICAgICBtID0gYjtcbiAgICAgICAgdmFyIGwgPSBkLmxlbmd0aCB8IDA7XG4gICAgICAgIGZvciAodmFyIF9pMjUgPSAwOyBfaTI1ICE9IGw7KSB7XG4gICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihfaTI1ICsgMjY1NSwgbCk7XG4gICAgICAgICAgZm9yICg7IF9pMjUgPCBlOyArK19pMjUpIG0gKz0gbiArPSBkW19pMjVdO1xuICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgfVxuICAgICAgICBhID0gbiwgYiA9IG07XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgcmV0dXJuIChhICYgMjU1KSA8PCAyNCB8IChhICYgMHhGRjAwKSA8PCA4IHwgKGIgJiAyNTUpIDw8IDggfCBiID4+IDg7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbiAgdmFyIGRvcHQgPSBmdW5jdGlvbiBkb3B0KGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgaWYgKCFzdCkge1xuICAgICAgc3QgPSB7XG4gICAgICAgIGw6IDFcbiAgICAgIH07XG4gICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAgICAgdmFyIGRpY3QgPSBvcHQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO1xuICAgICAgICB2YXIgbmV3RGF0ID0gbmV3IHU4KGRpY3QubGVuZ3RoICsgZGF0Lmxlbmd0aCk7XG4gICAgICAgIG5ld0RhdC5zZXQoZGljdCk7XG4gICAgICAgIG5ld0RhdC5zZXQoZGF0LCBkaWN0Lmxlbmd0aCk7XG4gICAgICAgIGRhdCA9IG5ld0RhdDtcbiAgICAgICAgc3QudyA9IGRpY3QubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGZsdChkYXQsIG9wdC5sZXZlbCA9PSBudWxsID8gNiA6IG9wdC5sZXZlbCwgb3B0Lm1lbSA9PSBudWxsID8gc3QubCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAyMCA6IDEyICsgb3B0Lm1lbSwgcHJlLCBwb3N0LCBzdCk7XG4gIH07XG4gIC8vIHdyaXRlIGJ5dGVzXG4gIHZhciB3Ynl0ZXMgPSBmdW5jdGlvbiB3Ynl0ZXMoZCwgYiwgdikge1xuICAgIGZvciAoOyB2OyArK2IpIGRbYl0gPSB2LCB2ID4+Pj0gODtcbiAgfTtcbiAgLy8gemxpYiBoZWFkZXJcbiAgdmFyIHpsaCA9IGZ1bmN0aW9uIHpsaChjLCBvKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgbHYgPSAoX2EgPSBvLmxldmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgZmwgPSBsdiA9PSAwID8gMCA6IGx2IDwgNiA/IDEgOiBsdiA9PSA5ID8gMyA6IDI7XG4gICAgY1swXSA9IDEyMCwgY1sxXSA9IGZsIDw8IDYgfCAoKChfYiA9IG8uZGljdGlvbmFyeSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgJiYgMzIpO1xuICAgIGNbMV0gfD0gMzEgLSAoY1swXSA8PCA4IHwgY1sxXSkgJSAzMTtcbiAgICBpZiAoby5kaWN0aW9uYXJ5KSB7XG4gICAgICB2YXIgaCA9IGFkbGVyKCk7XG4gICAgICBoLnAoby5kaWN0aW9uYXJ5KTtcbiAgICAgIHdieXRlcyhjLCAyLCBoLmQoKSk7XG4gICAgfVxuICB9O1xuICAvLyB6bGliIHN0YXJ0XG4gIHZhciB6bHMgPSBmdW5jdGlvbiB6bHMoZCwgZGljdCkge1xuICAgIGlmICgoZFswXSAmIDE1KSAhPSA4IHx8IGRbMF0gPj4gNCA+IDcgfHwgKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpIF9lcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhJyk7XG4gICAgaWYgKChkWzFdID4+IDUgJiAxKSA9PSArIWRpY3QpIF9lcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhOiAnICsgKGRbMV0gJiAzMiA/ICduZWVkJyA6ICd1bmV4cGVjdGVkJykgKyAnIGRpY3Rpb25hcnknKTtcbiAgICByZXR1cm4gKGRbMV0gPj4gMyAmIDQpICsgMjtcbiAgfTtcbiAgLy8gYmVmb3JlIHlvdSB5ZWxsIGF0IG1lIGZvciBub3QganVzdCB1c2luZyBleHRlbmRzLCBteSByZWFzb24gaXMgdGhhdCBUUyBpbmhlcml0YW5jZSBpcyBoYXJkIHRvIHdvcmtlcml6ZS5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gemxpYlN5bmMoZGF0YSkge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYSA9IGFkbGVyKCk7XG4gICAgYS5wKGRhdGEpO1xuICAgIHZhciBkID0gZG9wdChkYXRhLCBvcHRzLCBvcHRzLmRpY3Rpb25hcnkgPyA2IDogMiwgNCk7XG4gICAgcmV0dXJuIHpsaChkLCBvcHRzKSwgd2J5dGVzKGQsIGQubGVuZ3RoIC0gNCwgYS5kKCkpLCBkO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmRzIFpsaWIgZGF0YVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gICAqIEBwYXJhbSBvcHRzIFRoZSBkZWNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEpIHtcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoemxzKGRhdGEsIG9wdHMuZGljdGlvbmFyeSksIC00KSwge1xuICAgICAgaTogMlxuICAgIH0sIG9wdHMgJiYgb3B0cy5vdXQsIG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5KTtcbiAgfVxuICB2YXIgQ1JDMzIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENSQzMyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENSQzMyKTtcbiAgICAgIHRoaXMuY2FjaGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENSQzMyLCBbe1xuICAgICAga2V5OiBcImNhbGN1bGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZShidWZmKSB7XG4gICAgICAgIGlmICghKGJ1ZmYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhY2hlcyA9IHRoaXMuY2FjaGVzO1xuICAgICAgICB2YXIga2V5ID0gcGxhdGZvcm0uZGVjb2RlLmJ5dGVzVG9TdHJpbmcoYnVmZik7XG4gICAgICAgIGlmIChjYWNoZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcmMgPSBDUkMzMi5XSElURV9DT0xPUjtcbiAgICAgICAgLy8g5L2/55So5L2N6L+Q566X5LyY5YyWXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIENSQzMyLnRhYmxlWyhjcmMgXiBidWZmW2ldKSAmIDB4ZmZdO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlcy5zZXQoa2V5LCAoY3JjIF4gQ1JDMzIuV0hJVEVfQ09MT1IpID4+PiAwKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlcy5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jYWNoZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgLy8gQ1JDMzIgVGFibGUg5Yid5aeL5YyWXG4gIENSQzMyLnRhYmxlID0gVWludDMyQXJyYXkuZnJvbShBcnJheSgyNTYpLCBmdW5jdGlvbiAoXywgaSkge1xuICAgIHZhciBjID0gaTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgYyA9IGMgJiAxID8gMHhlZGI4ODMyMCBeIGMgPj4+IDEgOiBjID4+PiAxO1xuICAgIH1cbiAgICByZXR1cm4gYyA+Pj4gMDtcbiAgfSk7XG4gIENSQzMyLldISVRFX0NPTE9SID0gMHhmZmZmZmZmZjtcbiAgdmFyIFBOR0VuY29kZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBOR0VuY29kZXIod2lkdGgsIGhlaWdodCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBOR0VuY29kZXIpO1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmNyYzMyID0gbmV3IENSQzMyKCk7XG4gICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDQgKiB3aWR0aCAqIGhlaWdodCkpO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBOR0VuY29kZXIsIFt7XG4gICAgICBrZXk6IFwiY3JlYXRlQ2h1bmtcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaHVuayh0eXBlLCBkYXRhKSB7XG4gICAgICAgIC8vIOmVv+W6pu+8iDTlrZfoioLvvIzlpKfnq6/luo/vvIlcbiAgICAgICAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcobGVuZ3RoLmJ1ZmZlcikuc2V0VWludDMyKDAsIGRhdGEubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIC8vIOWdl+exu+Wei++8iDTlrZfoioLvvIwgQVNDSUnvvIlcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IFVpbnQ4QXJyYXkuZnJvbSh0eXBlLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyDorqHnrpcgQ1JDMzIg5qCh6aqM77yI57G75Z6LICsg5pWw5o2u77yJXG4gICAgICAgIHZhciBwYXJ0aWFsQ2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVua1R5cGUubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICBwYXJ0aWFsQ2h1bmsuc2V0KGNodW5rVHlwZSk7XG4gICAgICAgIHBhcnRpYWxDaHVuay5zZXQoZGF0YSwgY2h1bmtUeXBlLmxlbmd0aCk7XG4gICAgICAgIHZhciBjcmMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNyYy5idWZmZXIpLnNldFVpbnQzMigwLCB0aGlzLmNyYzMyLmNhbGN1bGF0ZShwYXJ0aWFsQ2h1bmspID4+PiAwLCBmYWxzZSk7XG4gICAgICAgIC8vIOaxh+aAu+aIkOWujOaVtOeahGNodW5r5pWw5o2uXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgubGVuZ3RoICsgcGFydGlhbENodW5rLmxlbmd0aCArIGNyYy5sZW5ndGgpO1xuICAgICAgICByZXN1bHQuc2V0KGxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQocGFydGlhbENodW5rLCBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmVzdWx0LnNldChjcmMsIGxlbmd0aC5sZW5ndGggKyBwYXJ0aWFsQ2h1bmsubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlSUhEUkNodW5rXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSUhEUkNodW5rKCkge1xuICAgICAgICB2YXIgaWhkckRhdGEgPSBuZXcgVWludDhBcnJheSgxMyk7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGloZHJEYXRhLmJ1ZmZlcik7XG4gICAgICAgIC8vIOWuveW6plxuICAgICAgICB2aWV3LnNldFVpbnQzMigwLCB0aGlzLndpZHRoLCBmYWxzZSk7XG4gICAgICAgIC8vIOmrmOW6plxuICAgICAgICB2aWV3LnNldFVpbnQzMig0LCB0aGlzLmhlaWdodCwgZmFsc2UpO1xuICAgICAgICAvLyDkvY3mt7HluqZcbiAgICAgICAgdmlldy5zZXRVaW50OCg4LCA4KTtcbiAgICAgICAgLy8g6aKc6Imy57G75Z6LXG4gICAgICAgIHZpZXcuc2V0VWludDgoOSwgNik7XG4gICAgICAgIC8vIOWOi+e8qeaWueazlVxuICAgICAgICB2aWV3LnNldFVpbnQ4KDEwLCAwKTtcbiAgICAgICAgLy8g6L+H5ruk5Zmo5pa55rOVXG4gICAgICAgIHZpZXcuc2V0VWludDgoMTEsIDApO1xuICAgICAgICAvLyDkuqTplJnmlrnms5VcbiAgICAgICAgdmlldy5zZXRVaW50OCgxMiwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNodW5rKFwiSUhEUlwiLCBpaGRyRGF0YSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNyZWF0ZUlEQVRDaHVua1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUlEQVRDaHVuaygpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIHZhbGlkUm93U2l6ZSA9IHdpZHRoICogNDtcbiAgICAgICAgLy8g5q+P6KGM5byA5aS05re75Yqg5LiA5L2N6L+H5ruk5aS05pWw5o2uXG4gICAgICAgIHZhciByb3dTaXplID0gdmFsaWRSb3dTaXplICsgMTtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShyb3dTaXplICogaGVpZ2h0KTtcbiAgICAgICAgLy8g5bCGVWludDMy5pWw5o2u6L2s5o2i5Li6VWludDjmlbDmja5cbiAgICAgICAgdmFyIHBpeGVsc0RhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnZpZXcuYnVmZmVyKTtcbiAgICAgICAgdmFyIHN0YXJ0SWR4O1xuICAgICAgICB2YXIgc3JjU3RhcnQ7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICBzdGFydElkeCA9IHkgKiByb3dTaXplO1xuICAgICAgICAgIGRhdGFbc3RhcnRJZHhdID0gMHgwMDsgLy8g6L+H5ruk5aS0XG4gICAgICAgICAgLy8g4pyFIOWkjeWItumihOWFiOi9rOaNouWlveeahCBSR0JBIOaVsOaNrlxuICAgICAgICAgIHNyY1N0YXJ0ID0geSAqIHZhbGlkUm93U2l6ZTsgLy8gVWludDMyID0+IOavj+S4quWFg+e0oOWNoCA0IOWtl+iKglxuICAgICAgICAgIGRhdGEuc2V0KHBpeGVsc0RhdGEuc3ViYXJyYXkoc3JjU3RhcnQsIHNyY1N0YXJ0ICsgdmFsaWRSb3dTaXplKSwgc3RhcnRJZHggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyDkvb/nlKggemxpYiDov5vooYzljovnvKksIOW5s+ihoeWOi+e8qeeOh+acieWIqeS6juaPkOWNh+aWh+S7tueUn+aIkOmAn+W6plxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaHVuayhcIklEQVRcIiwgemxpYlN5bmMoZGF0YSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRQaXhlbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBpeGVsKHgsIHksIHBpeGVsKSB7XG4gICAgICAgIHRoaXMudmlldy5zZXRVaW50MzIoKHkgKiB0aGlzLndpZHRoICsgeCkgKiA0LCBwaXhlbCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ3cml0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKHBpeGVscykge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIHZhciBiO1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgdmFyIHBpeGVsO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBwb3MgPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xuICAgICAgICAgICAgciA9IHBpeGVsc1twb3NdO1xuICAgICAgICAgICAgZyA9IHBpeGVsc1twb3MgKyAxXTtcbiAgICAgICAgICAgIGIgPSBwaXhlbHNbcG9zICsgMl07XG4gICAgICAgICAgICBhID0gcGl4ZWxzW3BvcyArIDNdO1xuICAgICAgICAgICAgcGl4ZWwgPSAociA8PCAyNCB8IGcgPDwgMTYgfCBiIDw8IDggfCBhKSA+Pj4gMDtcbiAgICAgICAgICAgIHRoaXMuc2V0UGl4ZWwoeCwgeSwgcGl4ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmx1c2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLy8g6aKE5YWI5Yib5bu65omA5pyJ5Z2XXG4gICAgICAgIHZhciBpSERSQ2h1bmsgPSB0aGlzLmNyZWF0ZUlIRFJDaHVuaygpO1xuICAgICAgICB2YXIgaURBVENodW5rID0gdGhpcy5jcmVhdGVJREFUQ2h1bmsoKTtcbiAgICAgICAgdmFyIGlFTkRDaHVuayA9IHRoaXMuY3JlYXRlQ2h1bmsoXCJJRU5EXCIsIG5ldyBVaW50OEFycmF5KDApKTtcbiAgICAgICAgLy8g5LiA5qyh5oCn5YiG6YWN5YaF5a2Y77yI55u05o6l6K6h566X5oC75aSn5bCP77yJXG4gICAgICAgIHZhciBwbmdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoOCArIGlIRFJDaHVuay5sZW5ndGggKyBpREFUQ2h1bmsubGVuZ3RoICsgaUVORENodW5rLmxlbmd0aCk7XG4gICAgICAgIC8qIC0tLS0tLSDmjInpobrluo/lhpnlhaXmlbDmja4gLS0tLS0tICovXG4gICAgICAgIC8vIDEuIOWGmeWFpeaWh+S7tuWktO+8iOWbuuWumiA4IOWtl+iKgu+8iVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgcG5nRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoWzEzNywgODAsIDc4LCA3MSwgMTMsIDEwLCAyNiwgMTBdKSwgb2Zmc2V0KTtcbiAgICAgICAgLy8gMi4g5YaZ5YWlSUhEUuWdl1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgcG5nRGF0YS5zZXQoaUhEUkNodW5rLCBvZmZzZXQpO1xuICAgICAgICAvLyAzLiDlhpnlhaVJREFU5Z2XXG4gICAgICAgIG9mZnNldCArPSBpSERSQ2h1bmsubGVuZ3RoO1xuICAgICAgICBwbmdEYXRhLnNldChpREFUQ2h1bmssIG9mZnNldCk7XG4gICAgICAgIC8vIDQuIOWGmeWFpUlFTkTlnZdcbiAgICAgICAgb2Zmc2V0ICs9IGlEQVRDaHVuay5sZW5ndGg7XG4gICAgICAgIHBuZ0RhdGEuc2V0KGlFTkRDaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgLyogLS0tLS0tIOa4heepuiBDUkMzMiDnvJPlrZggLS0tLS0tICovXG4gICAgICAgIHRoaXMuY3JjMzIuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHBuZ0RhdGE7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxckJpdEJ1ZmZlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIEJpdEJ1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQml0QnVmZmVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJpdEJ1ZmZlcik7XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5sZW5ndGhJbkJpdHMgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJpdEJ1ZmZlciwgW3tcbiAgICAgIGtleTogXCJnZXRBdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0KGkpIHtcbiAgICAgICAgdmFyIGJ1ZkluZGV4ID0gfn4oaSAvIDgpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYnVmZmVyW2J1ZkluZGV4XSA+Pj4gNyAtIGkgJSA4ICYgMSkgPT09IDE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInB1dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dChudW0sIGxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5wdXRCaXQoKG51bSA+Pj4gbGVuZ3RoIC0gaSAtIDEgJiAxKSA9PT0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHV0Qml0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHV0Qml0KGJpdCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGhJbkJpdHMsXG4gICAgICAgICAgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHZhciBidWZJbmRleCA9IH5+KGxlbiAvIDgpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8PSBidWZJbmRleCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICBidWZmZXJbYnVmSW5kZXhdIHw9IDB4ODAgPj4+IGxlbiAlIDg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGhJbkJpdHMgKz0gMTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTW9kZVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIFFSTW9kZSA9IHtcbiAgICBNT0RFX05VTUJFUjogMSA8PCAwLFxuICAgIE1PREVfQUxQSEFfTlVNOiAxIDw8IDEsXG4gICAgTU9ERV84QklUX0JZVEU6IDEgPDwgMixcbiAgICBNT0RFX0tBTkpJOiAxIDw8IDNcbiAgfTtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSRXJyb3JDb3JyZWN0TGV2ZWxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBRUkVycm9yQ29ycmVjdExldmVsID0ge1xuICAgIEw6IDEsXG4gICAgTTogMCxcbiAgICBROiAzLFxuICAgIEg6IDJcbiAgfTtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTWFza1BhdHRlcm5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBRUk1hc2tQYXR0ZXJuID0ge1xuICAgIFBBVFRFUk4wMDA6IDAsXG4gICAgUEFUVEVSTjAwMTogMSxcbiAgICBQQVRURVJOMDEwOiAyLFxuICAgIFBBVFRFUk4wMTE6IDMsXG4gICAgUEFUVEVSTjEwMDogNCxcbiAgICBQQVRURVJOMTAxOiA1LFxuICAgIFBBVFRFUk4xMTA6IDYsXG4gICAgUEFUVEVSTjExMTogN1xuICB9O1xuICB2YXIgQml0Qnl0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQml0Qnl0ZShkYXRhKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQml0Qnl0ZSk7XG4gICAgICB2YXIgcGFyc2VkRGF0YSA9IFtdO1xuICAgICAgLy8gQWRkZWQgdG8gc3VwcG9ydCBVVEYtOCBDaGFyYWN0ZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY29kZSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDEwMDAwKSB7XG4gICAgICAgICAgYnl0ZUFycmF5WzBdID0gMHhmMCB8IChjb2RlICYgMHgxYzAwMDApID4+PiAxODtcbiAgICAgICAgICBieXRlQXJyYXlbMV0gPSAweDgwIHwgKGNvZGUgJiAweDNmMDAwKSA+Pj4gMTI7XG4gICAgICAgICAgYnl0ZUFycmF5WzJdID0gMHg4MCB8IChjb2RlICYgMHhmYzApID4+PiA2O1xuICAgICAgICAgIGJ5dGVBcnJheVszXSA9IDB4ODAgfCBjb2RlICYgMHgzZjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID4gMHg4MDApIHtcbiAgICAgICAgICBieXRlQXJyYXlbMF0gPSAweGUwIHwgKGNvZGUgJiAweGYwMDApID4+PiAxMjtcbiAgICAgICAgICBieXRlQXJyYXlbMV0gPSAweDgwIHwgKGNvZGUgJiAweGZjMCkgPj4+IDY7XG4gICAgICAgICAgYnl0ZUFycmF5WzJdID0gMHg4MCB8IGNvZGUgJiAweDNmO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPiAweDgwKSB7XG4gICAgICAgICAgYnl0ZUFycmF5WzBdID0gMHhjMCB8IChjb2RlICYgMHg3YzApID4+PiA2O1xuICAgICAgICAgIGJ5dGVBcnJheVsxXSA9IDB4ODAgfCBjb2RlICYgMHgzZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlQXJyYXlbMF0gPSBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpeCBVbmljb2RlIGNvcnJ1cHRpb24gYnVnXG4gICAgICAgIHBhcnNlZERhdGEucHVzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5ieXRlcyA9IHBhcnNlZERhdGEuZmxhdCgxKTtcbiAgICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXM7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBieXRlcy51bnNoaWZ0KDE5MSk7XG4gICAgICAgIGJ5dGVzLnVuc2hpZnQoMTg3KTtcbiAgICAgICAgYnl0ZXMudW5zaGlmdCgyMzkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJpdEJ5dGUsIFt7XG4gICAgICBrZXk6IFwibW9kZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBRUk1vZGUuTU9ERV84QklUX0JZVEU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwid3JpdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShidWZmKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmLnB1dChieXRlc1tpXSwgOCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFJTX0JMT0NLX1RBQkxFID0gW1sxLCAyNiwgMTldLCBbMSwgMjYsIDE2XSwgWzEsIDI2LCAxM10sIFsxLCAyNiwgOV0sIFsxLCA0NCwgMzRdLCBbMSwgNDQsIDI4XSwgWzEsIDQ0LCAyMl0sIFsxLCA0NCwgMTZdLCBbMSwgNzAsIDU1XSwgWzEsIDcwLCA0NF0sIFsyLCAzNSwgMTddLCBbMiwgMzUsIDEzXSwgWzEsIDEwMCwgODBdLCBbMiwgNTAsIDMyXSwgWzIsIDUwLCAyNF0sIFs0LCAyNSwgOV0sIFsxLCAxMzQsIDEwOF0sIFsyLCA2NywgNDNdLCBbMiwgMzMsIDE1LCAyLCAzNCwgMTZdLCBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLCBbMiwgODYsIDY4XSwgWzQsIDQzLCAyN10sIFs0LCA0MywgMTldLCBbNCwgNDMsIDE1XSwgWzIsIDk4LCA3OF0sIFs0LCA0OSwgMzFdLCBbMiwgMzIsIDE0LCA0LCAzMywgMTVdLCBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLCBbMiwgMTIxLCA5N10sIFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sIFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sIFsyLCAxNDYsIDExNl0sIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sIFs0LCAzNiwgMTYsIDQsIDM3LCAxN10sIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sIFsyLCA4NiwgNjgsIDIsIDg3LCA2OV0sIFs0LCA2OSwgNDMsIDEsIDcwLCA0NF0sIFs2LCA0MywgMTksIDIsIDQ0LCAyMF0sIFs2LCA0MywgMTUsIDIsIDQ0LCAxNl0sIFs0LCAxMDEsIDgxXSwgWzEsIDgwLCA1MCwgNCwgODEsIDUxXSwgWzQsIDUwLCAyMiwgNCwgNTEsIDIzXSwgWzMsIDM2LCAxMiwgOCwgMzcsIDEzXSwgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLCBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLCBbNCwgNDYsIDIwLCA2LCA0NywgMjFdLCBbNywgNDIsIDE0LCA0LCA0MywgMTVdLCBbNCwgMTMzLCAxMDddLCBbOCwgNTksIDM3LCAxLCA2MCwgMzhdLCBbOCwgNDQsIDIwLCA0LCA0NSwgMjFdLCBbMTIsIDMzLCAxMSwgNCwgMzQsIDEyXSwgWzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sIFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sIFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLCBbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSwgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLCBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLCBbNSwgNTQsIDI0LCA3LCA1NSwgMjVdLCBbMTEsIDM2LCAxMl0sIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSwgWzcsIDczLCA0NSwgMywgNzQsIDQ2XSwgWzE1LCA0MywgMTksIDIsIDQ0LCAyMF0sIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLCBbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSwgWzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sIFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLCBbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSwgWzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sIFs5LCA2OSwgNDMsIDQsIDcwLCA0NF0sIFsxNywgNTAsIDIyLCAxLCA1MSwgMjNdLCBbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSwgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sIFszLCA3MCwgNDQsIDExLCA3MSwgNDVdLCBbMTcsIDQ3LCAyMSwgNCwgNDgsIDIyXSwgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sIFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLCBbMywgNjcsIDQxLCAxMywgNjgsIDQyXSwgWzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sIFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSwgWzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sIFsxNywgNjgsIDQyXSwgWzE3LCA1MCwgMjIsIDYsIDUxLCAyM10sIFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLCBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSwgWzE3LCA3NCwgNDZdLCBbNywgNTQsIDI0LCAxNiwgNTUsIDI1XSwgWzM0LCAzNywgMTNdLCBbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSwgWzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sIFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLCBbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSwgWzYsIDczLCA0NSwgMTQsIDc0LCA0Nl0sIFsxMSwgNTQsIDI0LCAxNiwgNTUsIDI1XSwgWzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLCBbOCwgNzUsIDQ3LCAxMywgNzYsIDQ4XSwgWzcsIDU0LCAyNCwgMjIsIDU1LCAyNV0sIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSwgWzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLCBbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSwgWzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sIFszMywgNDYsIDE2LCA0LCA0NywgMTddLCBbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSwgWzIyLCA3MywgNDUsIDMsIDc0LCA0Nl0sIFs4LCA1MywgMjMsIDI2LCA1NCwgMjRdLCBbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSwgWzMsIDczLCA0NSwgMjMsIDc0LCA0Nl0sIFs0LCA1NCwgMjQsIDMxLCA1NSwgMjVdLCBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sIFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLCBbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSwgWzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sIFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSwgWzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLCBbMTksIDc1LCA0NywgMTAsIDc2LCA0OF0sIFsxNSwgNTQsIDI0LCAyNSwgNTUsIDI1XSwgWzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLCBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sIFsyLCA3NCwgNDYsIDI5LCA3NSwgNDddLCBbNDIsIDU0LCAyNCwgMSwgNTUsIDI1XSwgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLCBbMTcsIDE0NSwgMTE1XSwgWzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLCBbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sIFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSwgWzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLCBbMTQsIDc0LCA0NiwgMjEsIDc1LCA0N10sIFsyOSwgNTQsIDI0LCAxOSwgNTUsIDI1XSwgWzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLCBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sIFsxNCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSwgWzQ0LCA1NCwgMjQsIDcsIDU1LCAyNV0sIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLCBbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sIFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSwgWzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLCBbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sIFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSwgWzYsIDc1LCA0NywgMzQsIDc2LCA0OF0sIFs0NiwgNTQsIDI0LCAxMCwgNTUsIDI1XSwgWzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSwgWzI5LCA3NCwgNDYsIDE0LCA3NSwgNDddLCBbNDksIDU0LCAyNCwgMTAsIDU1LCAyNV0sIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSwgWzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLCBbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sIFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLCBbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sIFs0MCwgNzUsIDQ3LCA3LCA3NiwgNDhdLCBbNDMsIDU0LCAyNCwgMjIsIDU1LCAyNV0sIFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSwgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLCBbMTgsIDc1LCA0NywgMzEsIDc2LCA0OF0sIFszNCwgNTQsIDI0LCAzNCwgNTUsIDI1XSwgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXTtcbiAgdmFyIFJTQmxvY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJTQmxvY2soKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUlNCbG9jayk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUlNCbG9jaywgW3tcbiAgICAgIGtleTogXCJnZXRSU0Jsb2NrVGFibGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSU0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcbiAgICAgICAgdmFyIEwgPSBRUkVycm9yQ29ycmVjdExldmVsLkwsXG4gICAgICAgICAgTSA9IFFSRXJyb3JDb3JyZWN0TGV2ZWwuTSxcbiAgICAgICAgICBRID0gUVJFcnJvckNvcnJlY3RMZXZlbC5RLFxuICAgICAgICAgIEggPSBRUkVycm9yQ29ycmVjdExldmVsLkg7XG4gICAgICAgIHZhciBwb3MgPSAodHlwZU51bWJlciAtIDEpICogNDtcbiAgICAgICAgc3dpdGNoIChlcnJvckNvcnJlY3RMZXZlbCkge1xuICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVtwb3MgKyAwXTtcbiAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbcG9zICsgMV07XG4gICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFW3BvcyArIDJdO1xuICAgICAgICAgIGNhc2UgSDpcbiAgICAgICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVtwb3MgKyAzXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJzIGJsb2NrIEAgdHlwZU51bWJlcjpcIi5jb25jYXQodHlwZU51bWJlciwgXCIvZXJyb3JDb3JyZWN0TGV2ZWw6IFwiKS5jb25jYXQoZXJyb3JDb3JyZWN0TGV2ZWwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRSU0Jsb2Nrc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG4gICAgICAgIHZhciByc0Jsb2NrID0gdGhpcy5nZXRSU0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcnNCbG9jay5sZW5ndGggLyAzO1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gcnNCbG9ja1tpICogM107XG4gICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XG4gICAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAyXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgIHRvdGFsQ291bnQ6IHRvdGFsQ291bnQsXG4gICAgICAgICAgICAgIGRhdGFDb3VudDogZGF0YUNvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUk1hdGhcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBFWFBfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgdmFyIExPR19UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAvLyBpbml0aWFsaXplIHRhYmxlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIEVYUF9UQUJMRVtpXSA9IDEgPDwgaTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IDg7IF9pIDwgMjU2OyBfaSsrKSB7XG4gICAgRVhQX1RBQkxFW19pXSA9IEVYUF9UQUJMRVtfaSAtIDRdIF4gRVhQX1RBQkxFW19pIC0gNV0gXiBFWFBfVEFCTEVbX2kgLSA2XSBeIEVYUF9UQUJMRVtfaSAtIDhdO1xuICB9XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDI1NTsgX2kyKyspIHtcbiAgICBMT0dfVEFCTEVbRVhQX1RBQkxFW19pMl1dID0gX2kyO1xuICB9XG4gIHZhciBRUk1hdGggPSB7XG4gICAgZ2xvZzogZnVuY3Rpb24gZ2xvZyhuKSB7XG4gICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2xvZyhcIi5jb25jYXQobiwgXCIpXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBMT0dfVEFCTEVbbl07XG4gICAgfSxcbiAgICBnZXhwOiBmdW5jdGlvbiBnZXhwKG4pIHtcbiAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICBuID0gMjU1ICsgbiAlIDI1NTtcbiAgICAgIH0gZWxzZSBpZiAobiA+IDI1NSkge1xuICAgICAgICBuICU9IDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFWFBfVEFCTEVbbl07XG4gICAgfVxuICB9O1xuICB2YXIgUG9seW5vbWlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seW5vbWlhbCk7XG4gICAgICB2YXIgbGVuZ3RoID0gbnVtLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobGVuZ3RoLCBcIi9cIikuY29uY2F0KHNoaWZ0KSk7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiYgbnVtW29mZnNldF0gPT09IDApIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gbGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgdGhpcy5udW0gPSBuZXcgQXJyYXkobGVuICsgc2hpZnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLm51bVtpXSA9IG51bVtpICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb2x5bm9taWFsLCBbe1xuICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEF0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXQoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1baV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm11bHRpcGx5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHkoZSkge1xuICAgICAgICB2YXIgZ2xvZyA9IFFSTWF0aC5nbG9nLFxuICAgICAgICAgIGdleHAgPSBRUk1hdGguZ2V4cDtcbiAgICAgICAgdmFyIG51bSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG51bVtpICsgal0gXj0gZ2V4cChnbG9nKHRoaXMuZ2V0QXQoaSkpICsgZ2xvZyhlLmdldEF0KGopKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChudW0sIDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb2RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggLSBlLmxlbmd0aCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2xvZyA9IFFSTWF0aC5nbG9nLFxuICAgICAgICAgIGdleHAgPSBRUk1hdGguZ2V4cDtcbiAgICAgICAgdmFyIHJhdGlvID0gZ2xvZyh0aGlzLmdldEF0KDApKSAtIGdsb2coZS5nZXRBdCgwKSk7XG4gICAgICAgIHZhciBudW0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLmdldEF0KGkpO1xuICAgICAgICAgIG51bVtpXSA9IGkgPCBlLmxlbmd0aCA/IG4gXiBnZXhwKGdsb2coZS5nZXRBdChpKSkgKyByYXRpbykgOiBuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChudW0sIDApLm1vZChlKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFBBVFRFUk5fUE9TSVRJT05fVEFCTEUgPSBbW10sIFs2LCAxOF0sIFs2LCAyMl0sIFs2LCAyNl0sIFs2LCAzMF0sIFs2LCAzNF0sIFs2LCAyMiwgMzhdLCBbNiwgMjQsIDQyXSwgWzYsIDI2LCA0Nl0sIFs2LCAyOCwgNTBdLCBbNiwgMzAsIDU0XSwgWzYsIDMyLCA1OF0sIFs2LCAzNCwgNjJdLCBbNiwgMjYsIDQ2LCA2Nl0sIFs2LCAyNiwgNDgsIDcwXSwgWzYsIDI2LCA1MCwgNzRdLCBbNiwgMzAsIDU0LCA3OF0sIFs2LCAzMCwgNTYsIDgyXSwgWzYsIDMwLCA1OCwgODZdLCBbNiwgMzQsIDYyLCA5MF0sIFs2LCAyOCwgNTAsIDcyLCA5NF0sIFs2LCAyNiwgNTAsIDc0LCA5OF0sIFs2LCAzMCwgNTQsIDc4LCAxMDJdLCBbNiwgMjgsIDU0LCA4MCwgMTA2XSwgWzYsIDMyLCA1OCwgODQsIDExMF0sIFs2LCAzMCwgNTgsIDg2LCAxMTRdLCBbNiwgMzQsIDYyLCA5MCwgMTE4XSwgWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjJdLCBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLCBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLCBbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzRdLCBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLCBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLCBbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdLCBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSwgWzYsIDI4LCA1NCwgODAsIDEwNiwgMTMyLCAxNThdLCBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSwgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyLCAxNzBdXTtcbiAgdmFyIEcxNSA9IDEgPDwgMTAgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDQgfCAxIDw8IDIgfCAxIDw8IDEgfCAxIDw8IDA7XG4gIHZhciBHMTggPSAxIDw8IDEyIHwgMSA8PCAxMSB8IDEgPDwgMTAgfCAxIDw8IDkgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDIgfCAxIDw8IDA7XG4gIHZhciBHMTVfTUFTSyA9IDEgPDwgMTQgfCAxIDw8IDEyIHwgMSA8PCAxMCB8IDEgPDwgNCB8IDEgPDwgMTtcbiAgdmFyIGdlbkJDSERpZ2l0ID0gZnVuY3Rpb24gZ2VuQkNIRGlnaXQoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSAwID8gMCA6IE1hdGgubG9nMihkYXRhKTtcbiAgfTtcbiAgdmFyIEJDSF9HMTUgPSBnZW5CQ0hEaWdpdChHMTUpO1xuICB2YXIgQkNIX0cxOCA9IGdlbkJDSERpZ2l0KEcxOCk7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUlV0aWxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBVdGlsID0ge1xuICAgIGdldEJDSFR5cGVJbmZvOiBmdW5jdGlvbiBnZXRCQ0hUeXBlSW5mbyhkYXRhKSB7XG4gICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICB3aGlsZSAoZ2VuQkNIRGlnaXQoZCkgLSBCQ0hfRzE1ID49IDApIHtcbiAgICAgICAgZCBePSBHMTUgPDwgZ2VuQkNIRGlnaXQoZCkgLSBCQ0hfRzE1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIChkYXRhIDw8IDEwIHwgZCkgXiBHMTVfTUFTSztcbiAgICB9LFxuICAgIGdldEJDSFR5cGVOdW1iZXI6IGZ1bmN0aW9uIGdldEJDSFR5cGVOdW1iZXIoZGF0YSkge1xuICAgICAgdmFyIGQgPSBkYXRhIDw8IDEyO1xuICAgICAgd2hpbGUgKGdlbkJDSERpZ2l0KGQpIC0gQkNIX0cxOCA+PSAwKSB7XG4gICAgICAgIGQgXj0gRzE4IDw8IGdlbkJDSERpZ2l0KGQpIC0gQkNIX0cxODtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhIDw8IDEyIHwgZDtcbiAgICB9LFxuICAgIGdldFBhdHRlcm5Qb3NpdGlvbjogZnVuY3Rpb24gZ2V0UGF0dGVyblBvc2l0aW9uKHR5cGVOdW1iZXIpIHtcbiAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICB9LFxuICAgIGdldE1hc2tGdW5jdGlvbjogZnVuY3Rpb24gZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKSB7XG4gICAgICB2YXIgUEFUVEVSTjAwMCA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMCxcbiAgICAgICAgUEFUVEVSTjAwMSA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMSxcbiAgICAgICAgUEFUVEVSTjAxMCA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMCxcbiAgICAgICAgUEFUVEVSTjAxMSA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMSxcbiAgICAgICAgUEFUVEVSTjEwMCA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMCxcbiAgICAgICAgUEFUVEVSTjEwMSA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMSxcbiAgICAgICAgUEFUVEVSTjExMCA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMCxcbiAgICAgICAgUEFUVEVSTjExMSA9IFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMTtcbiAgICAgIHN3aXRjaCAobWFza1BhdHRlcm4pIHtcbiAgICAgICAgY2FzZSBQQVRURVJOMDAwOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIChpICsgaikgJSAyID09PSAwO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgUEFUVEVSTjAwMTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICUgMiA9PT0gMDtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBBVFRFUk4wMTA6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIGogJSAzID09PSAwO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgUEFUVEVSTjAxMTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiAoaSArIGopICUgMyA9PT0gMDtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBBVFRFUk4xMDA6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gKH5+KGkgLyAyKSArIH5+KGogLyAzKSkgJSAyID09PSAwO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgUEFUVEVSTjEwMTpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiBpICogaiAlIDIgKyBpICogaiAlIDMgPT09IDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBQQVRURVJOMTEwOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIChpICogaiAlIDIgKyBpICogaiAlIDMpICUgMiA9PT0gMDtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBBVFRFUk4xMTE6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gKGkgKiBqICUgMyArIChpICsgaikgJSAyKSAlIDIgPT09IDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbWFza1BhdHRlcm46IFwiLmNvbmNhdChtYXNrUGF0dGVybikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbDogZnVuY3Rpb24gZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlcnJvckNvcnJlY3RMZW5ndGgpIHtcbiAgICAgIHZhciBhID0gbmV3IFBvbHlub21pYWwoWzFdLCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JDb3JyZWN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYSA9IGEubXVsdGlwbHkobmV3IFBvbHlub21pYWwoWzEsIFFSTWF0aC5nZXhwKGkpXSwgMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcbiAgICBnZXRMZW5ndGhJbkJpdHM6IGZ1bmN0aW9uIGdldExlbmd0aEluQml0cyhtb2RlLCB0eXBlKSB7XG4gICAgICB2YXIgTU9ERV9OVU1CRVIgPSBRUk1vZGUuTU9ERV9OVU1CRVIsXG4gICAgICAgIE1PREVfQUxQSEFfTlVNID0gUVJNb2RlLk1PREVfQUxQSEFfTlVNLFxuICAgICAgICBNT0RFXzhCSVRfQllURSA9IFFSTW9kZS5NT0RFXzhCSVRfQllURSxcbiAgICAgICAgTU9ERV9LQU5KSSA9IFFSTW9kZS5NT0RFX0tBTkpJO1xuICAgICAgaWYgKHR5cGUgPCAxIHx8IHR5cGUgPiA0MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBcIi5jb25jYXQodHlwZSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPj0gMSAmJiB0eXBlIDwgMTApIHtcbiAgICAgICAgLy8gMSAtIDlcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgY2FzZSBNT0RFX05VTUJFUjpcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICBjYXNlIE1PREVfQUxQSEFfTlVNOlxuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgY2FzZSBNT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgIGNhc2UgTU9ERV9LQU5KSTpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA8IDI3KSB7XG4gICAgICAgIC8vIDEwIC0gMjZcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgY2FzZSBNT0RFX05VTUJFUjpcbiAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICBjYXNlIE1PREVfQUxQSEFfTlVNOlxuICAgICAgICAgICAgcmV0dXJuIDExO1xuICAgICAgICAgIGNhc2UgTU9ERV84QklUX0JZVEU6XG4gICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgICAgY2FzZSBNT0RFX0tBTkpJOlxuICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA8PSA0MCkge1xuICAgICAgICAvLyAyNyAtIDQwXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgIGNhc2UgTU9ERV9OVU1CRVI6XG4gICAgICAgICAgICByZXR1cm4gMTQ7XG4gICAgICAgICAgY2FzZSBNT0RFX0FMUEhBX05VTTpcbiAgICAgICAgICAgIHJldHVybiAxMztcbiAgICAgICAgICBjYXNlIE1PREVfOEJJVF9CWVRFOlxuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgIGNhc2UgTU9ERV9LQU5KSTpcbiAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZTogXCIuY29uY2F0KG1vZGUpKTtcbiAgICB9LFxuICAgIGdldExvc3RQb2ludDogZnVuY3Rpb24gZ2V0TG9zdFBvaW50KHFyKSB7XG4gICAgICB2YXIgbW9kdWxlQ291bnQgPSBxci5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgdmFyIGxvc3RQb2ludCA9IDA7XG4gICAgICAvLyBMRVZFTDFcbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3crKykge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sKyspIHtcbiAgICAgICAgICB2YXIgZGFyayA9IHFyLmlzRGFyayhyb3csIGNvbCk7XG4gICAgICAgICAgdmFyIHNhbWVDb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDE7IHIrKykge1xuICAgICAgICAgICAgdmFyIG5Sb3cgPSByb3cgKyByO1xuICAgICAgICAgICAgaWYgKG5Sb3cgPCAwIHx8IG1vZHVsZUNvdW50IDw9IG5Sb3cpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDE7IGMrKykge1xuICAgICAgICAgICAgICB2YXIgbkNvbCA9IGNvbCArIGM7XG4gICAgICAgICAgICAgIGlmIChuQ29sIDwgMCB8fCBtb2R1bGVDb3VudCA8PSBuQ29sKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKHIgPT09IDAgJiYgYyA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICAgIGlmIChkYXJrID09PSBxci5pc0RhcmsoblJvdywgbkNvbCkpIHtcbiAgICAgICAgICAgICAgICBzYW1lQ291bnQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IHNhbWVDb3VudCArIDMgLSA1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTEVWRUwyXG4gICAgICBmb3IgKHZhciBfcm93ID0gMDsgX3JvdyA8IG1vZHVsZUNvdW50IC0gMTsgX3JvdysrKSB7XG4gICAgICAgIGZvciAodmFyIF9jb2wgPSAwOyBfY29sIDwgbW9kdWxlQ291bnQgLSAxOyBfY29sKyspIHtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIGlmIChxci5pc0RhcmsoX3JvdywgX2NvbCkpIGNvdW50Kys7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93ICsgMSwgX2NvbCkpIGNvdW50Kys7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93LCBfY29sICsgMSkpIGNvdW50Kys7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93ICsgMSwgX2NvbCArIDEpKSBjb3VudCsrO1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCB8fCBjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMRVZFTDNcbiAgICAgIGZvciAodmFyIF9yb3cyID0gMDsgX3JvdzIgPCBtb2R1bGVDb3VudDsgX3JvdzIrKykge1xuICAgICAgICBmb3IgKHZhciBfY29sMiA9IDA7IF9jb2wyIDwgbW9kdWxlQ291bnQgLSA2OyBfY29sMisrKSB7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93MiwgX2NvbDIpICYmICFxci5pc0RhcmsoX3JvdzIsIF9jb2wyICsgMSkgJiYgcXIuaXNEYXJrKF9yb3cyLCBfY29sMiArIDIpICYmIHFyLmlzRGFyayhfcm93MiwgX2NvbDIgKyAzKSAmJiBxci5pc0RhcmsoX3JvdzIsIF9jb2wyICsgNCkgJiYgIXFyLmlzRGFyayhfcm93MiwgX2NvbDIgKyA1KSAmJiBxci5pc0RhcmsoX3JvdzIsIF9jb2wyICsgNikpIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9jb2wzID0gMDsgX2NvbDMgPCBtb2R1bGVDb3VudDsgX2NvbDMrKykge1xuICAgICAgICBmb3IgKHZhciBfcm93MyA9IDA7IF9yb3czIDwgbW9kdWxlQ291bnQgLSA2OyBfcm93MysrKSB7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93MywgX2NvbDMpICYmICFxci5pc0RhcmsoX3JvdzMgKyAxLCBfY29sMykgJiYgcXIuaXNEYXJrKF9yb3czICsgMiwgX2NvbDMpICYmIHFyLmlzRGFyayhfcm93MyArIDMsIF9jb2wzKSAmJiBxci5pc0RhcmsoX3JvdzMgKyA0LCBfY29sMykgJiYgIXFyLmlzRGFyayhfcm93MyArIDUsIF9jb2wzKSAmJiBxci5pc0RhcmsoX3JvdzMgKyA2LCBfY29sMykpIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExFVkVMNFxuICAgICAgdmFyIGRhcmtDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBfY29sNCA9IDA7IF9jb2w0IDwgbW9kdWxlQ291bnQ7IF9jb2w0KyspIHtcbiAgICAgICAgZm9yICh2YXIgX3JvdzQgPSAwOyBfcm93NCA8IG1vZHVsZUNvdW50OyBfcm93NCsrKSB7XG4gICAgICAgICAgaWYgKHFyLmlzRGFyayhfcm93NCwgX2NvbDQpKSB7XG4gICAgICAgICAgICBkYXJrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIE1hdGgucG93KG1vZHVsZUNvdW50LCAyKSAtIDUwKSAvIDU7XG4gICAgICByZXR1cm4gbG9zdFBvaW50ICsgcmF0aW8gKiAxMDtcbiAgICB9XG4gIH07XG4gIHZhciBQQUQwID0gMHhlYztcbiAgdmFyIFBBRDEgPSAweDExO1xuICAvKipcbiAgICogUVJDb2Rl5a6e546wXG4gICAqIGh0dHBzOi8vd3d3LmNuYmxvZ3MuY29tL2xlZXN0YXI1NC9wLzE1NzgyOTI5Lmh0bWxcbiAgICogQHBhcmFtIHR5cGVOdW1iZXIgMSB0byA0MFxuICAgKiBAcGFyYW0gZXJyb3JDb3JyZWN0TGV2ZWwgJ0wnLCdNJywnUScsJ0gnXG4gICAqL1xuICB2YXIgUVJDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRUkNvZGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRUkNvZGUpO1xuICAgICAgdGhpcy50eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgdGhpcy5tb2R1bGVDb3VudCA9IDA7XG4gICAgICB0aGlzLmRhdGFDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmRhdGFMaXN0ID0gW107XG4gICAgICB0aGlzLmVycm9yQ29ycmVjdExldmVsID0gUVJFcnJvckNvcnJlY3RMZXZlbFtlcnJvckNvcnJlY3RMZXZlbF07XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUVJDb2RlLCBbe1xuICAgICAga2V5OiBcIm1ha2VJbXBsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZUltcGwodGVzdCwgbWFza1BhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5tb2R1bGVDb3VudCA9IHRoaXMudHlwZU51bWJlciAqIDQgKyAxNztcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gZnVuY3Rpb24gKG1vZHVsZUNvdW50KSB7XG4gICAgICAgICAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAvLyDpooTorr7kuIDkuKogbW9kdWxlQ291bnQgKiBtb2R1bGVDb3VudCDnmoTnqbrnmb3nn6npmLVcbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgIG1vZHVsZXNbcm93XSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIG1vZHVsZXNbcm93XVtjb2xdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZHVsZXM7XG4gICAgICAgIH0odGhpcy5tb2R1bGVDb3VudCk7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMubW9kdWxlQ291bnQgLSA3O1xuICAgICAgICB0aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihjb3VudCwgMCk7XG4gICAgICAgIHRoaXMuc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCBjb3VudCk7XG4gICAgICAgIHRoaXMuc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4oKTtcbiAgICAgICAgdGhpcy5zZXR1cFRpbWluZ1BhdHRlcm4oKTtcbiAgICAgICAgdGhpcy5zZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZU51bWJlciA+PSA3KSB7XG4gICAgICAgICAgdGhpcy5zZXR1cFR5cGVOdW1iZXIodGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGF0YUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kYXRhQ2FjaGUgPSB0aGlzLmNyZWF0ZURhdGEodGhpcy50eXBlTnVtYmVyLCB0aGlzLmVycm9yQ29ycmVjdExldmVsLCB0aGlzLmRhdGFMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcERhdGEodGhpcy5kYXRhQ2FjaGUsIG1hc2tQYXR0ZXJuKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBQb3NpdGlvblByb2JlUGF0dGVyblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4ocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIG1vZHVsZXMgPSB0aGlzLm1vZHVsZXMsXG4gICAgICAgICAgbW9kdWxlQ291bnQgPSB0aGlzLm1vZHVsZUNvdW50O1xuICAgICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgcisrKSB7XG4gICAgICAgICAgdmFyIG5yID0gcm93ICsgcjtcbiAgICAgICAgICBpZiAobnIgPD0gLTEgfHwgbW9kdWxlQ291bnQgPD0gbnIpIGNvbnRpbnVlO1xuICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjKyspIHtcbiAgICAgICAgICAgIHZhciBuYyA9IGNvbCArIGM7XG4gICAgICAgICAgICBpZiAobmMgPD0gLTEgfHwgbW9kdWxlQ291bnQgPD0gbmMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbW9kdWxlc1tucl1bbmNdID0gciA+PSAwICYmIHIgPD0gNiAmJiAoYyA9PT0gMCB8fCBjID09PSA2KSB8fCBjID49IDAgJiYgYyA8PSA2ICYmIChyID09PSAwIHx8IHIgPT09IDYpIHx8IHIgPj0gMiAmJiByIDw9IDQgJiYgYyA+PSAyICYmIGMgPD0gNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpIHtcbiAgICAgICAgdmFyIHR5cGVOdW1iZXIgPSB0aGlzLnR5cGVOdW1iZXIsXG4gICAgICAgICAgbW9kdWxlcyA9IHRoaXMubW9kdWxlcztcbiAgICAgICAgdmFyIHBvcyA9IFV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKHR5cGVOdW1iZXIpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcG9zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBwb3NbaV07XG4gICAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xuICAgICAgICAgICAgaWYgKG1vZHVsZXNbcm93XVtjb2xdICE9IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IC0yOyByIDw9IDI7IHIrKykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBjID0gLTI7IGMgPD0gMjsgYysrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHIgPT09IC0yIHx8IHIgPT09IDIgfHwgYyA9PT0gLTIgfHwgYyA9PT0gMiB8fCByID09PSAwICYmIGMgPT09IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0dXBUaW1pbmdQYXR0ZXJuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBUaW1pbmdQYXR0ZXJuKCkge1xuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSB0aGlzLm1vZHVsZUNvdW50LFxuICAgICAgICAgIG1vZHVsZXMgPSB0aGlzLm1vZHVsZXM7XG4gICAgICAgIHZhciBjb3VudCA9IG1vZHVsZUNvdW50IC0gODtcbiAgICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBjb3VudDsgcisrKSB7XG4gICAgICAgICAgaWYgKG1vZHVsZXNbcl1bNl0gIT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgbW9kdWxlc1tyXVs2XSA9IHIgJSAyID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGMgPSA4OyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgIGlmIChtb2R1bGVzWzZdW2NdICE9IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgIG1vZHVsZXNbNl1bY10gPSBjICUgMiA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXR1cFR5cGVJbmZvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybikge1xuICAgICAgICB2YXIgZXJyb3JDb3JyZWN0TGV2ZWwgPSB0aGlzLmVycm9yQ29ycmVjdExldmVsLFxuICAgICAgICAgIG1vZHVsZXMgPSB0aGlzLm1vZHVsZXMsXG4gICAgICAgICAgbW9kdWxlQ291bnQgPSB0aGlzLm1vZHVsZUNvdW50O1xuICAgICAgICB2YXIgZGF0YSA9IGVycm9yQ29ycmVjdExldmVsIDw8IDMgfCBtYXNrUGF0dGVybjtcbiAgICAgICAgdmFyIGJpdHMgPSBVdGlsLmdldEJDSFR5cGVJbmZvKGRhdGEpO1xuICAgICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaSAmIDEpID09PSAxO1xuICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgbW9kdWxlc1tpXVs4XSA9IG1vZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA4KSB7XG4gICAgICAgICAgICBtb2R1bGVzW2kgKyAxXVs4XSA9IG1vZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlc1ttb2R1bGVDb3VudCAtIDE1ICsgaV1bOF0gPSBtb2Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhvcml6b250YWxcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDE1OyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9tb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBfaSAmIDEpID09PSAxO1xuICAgICAgICAgIGlmIChfaSA8IDgpIHtcbiAgICAgICAgICAgIG1vZHVsZXNbOF1bbW9kdWxlQ291bnQgLSBfaSAtIDFdID0gX21vZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9pIDwgOSkge1xuICAgICAgICAgICAgbW9kdWxlc1s4XVsxNSAtIF9pXSA9IF9tb2Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZXNbOF1bMTUgLSBfaSAtIDFdID0gX21vZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZml4ZWQgbW9kdWxlXG4gICAgICAgIG1vZHVsZXNbbW9kdWxlQ291bnQgLSA4XVs4XSA9ICF0ZXN0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRCZXN0TWFza1BhdHRlcm5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCZXN0TWFza1BhdHRlcm4oKSB7XG4gICAgICAgIHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xuICAgICAgICB2YXIgcGF0dGVybiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5tYWtlSW1wbCh0cnVlLCBpKTtcbiAgICAgICAgICB2YXIgbG9zdFBvaW50ID0gVXRpbC5nZXRMb3N0UG9pbnQodGhpcyk7XG4gICAgICAgICAgaWYgKGkgPT09IDAgfHwgbWluTG9zdFBvaW50ID4gbG9zdFBvaW50KSB7XG4gICAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG4gICAgICAgICAgICBwYXR0ZXJuID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldHVwVHlwZU51bWJlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwVHlwZU51bWJlcih0ZXN0KSB7XG4gICAgICAgIHZhciB0eXBlTnVtYmVyID0gdGhpcy50eXBlTnVtYmVyLFxuICAgICAgICAgIG1vZHVsZXMgPSB0aGlzLm1vZHVsZXMsXG4gICAgICAgICAgbW9kdWxlQ291bnQgPSB0aGlzLm1vZHVsZUNvdW50O1xuICAgICAgICB2YXIgYml0cyA9IFV0aWwuZ2V0QkNIVHlwZU51bWJlcih0eXBlTnVtYmVyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkgJiAxKSA9PT0gMTtcbiAgICAgICAgICBtb2R1bGVzW35+KGkgLyAzKV1baSAlIDMgKyBtb2R1bGVDb3VudCAtIDggLSAzXSA9IG1vZDtcbiAgICAgICAgICBtb2R1bGVzW2kgJSAzICsgbW9kdWxlQ291bnQgLSA4IC0gM11bfn4oaSAvIDMpXSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjcmVhdGVEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRGF0YSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCwgZGF0YUxpc3QpIHtcbiAgICAgICAgdmFyIHJzQmxvY2tzID0gbmV3IFJTQmxvY2soKS5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQml0QnVmZmVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xuICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5tb2RlLCA0KTtcbiAgICAgICAgICBidWZmZXIucHV0KGRhdGEubGVuZ3RoLCBVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLm1vZGUsIHR5cGVOdW1iZXIpKTtcbiAgICAgICAgICBkYXRhLndyaXRlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsYyBudW0gbWF4IGRhdGEuXG4gICAgICAgIHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHJzQmxvY2tzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB0b3RhbERhdGFDb3VudCArPSByc0Jsb2Nrc1tfaTJdLmRhdGFDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWxDb3VudCA9IHRvdGFsRGF0YUNvdW50ICogODtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGhJbkJpdHMgPiB0b3RhbENvdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29kZSBsZW5ndGggb3ZlcmZsb3cuIChcIi5jb25jYXQoYnVmZmVyLmxlbmd0aEluQml0cywgXCIgPiBcIikuY29uY2F0KHRvdGFsQ291bnQsIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kIGNvZGVcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGhJbkJpdHMgKyA0IDw9IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICBidWZmZXIucHV0KDAsIDQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGhJbkJpdHMgJSA4ICE9PSAwKSB7XG4gICAgICAgICAgYnVmZmVyLnB1dEJpdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoSW5CaXRzID49IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHV0KFBBRDAsIDgpO1xuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoSW5CaXRzID49IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHV0KFBBRDEsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJ5dGVzKGJ1ZmZlciwgcnNCbG9ja3MpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXBEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwRGF0YShkYXRhLCBtYXNrUGF0dGVybikge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IHRoaXMubW9kdWxlcyxcbiAgICAgICAgICBtb2R1bGVDb3VudCA9IHRoaXMubW9kdWxlQ291bnQ7XG4gICAgICAgIHZhciBtYXNrRnVuYyA9IFV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgdmFyIGluYyA9IC0xO1xuICAgICAgICB2YXIgcm93ID0gbW9kdWxlQ291bnQgLSAxO1xuICAgICAgICB2YXIgYml0SW5kZXggPSA3O1xuICAgICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgY29sID0gcm93OyBjb2wgPiAwOyBjb2wgLT0gMikge1xuICAgICAgICAgIGlmIChjb2wgPT09IDYpIGNvbCAtPSAxO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMrKykge1xuICAgICAgICAgICAgICBpZiAobW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGFyayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZGFyayA9IChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4ICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXNrRnVuYyhyb3csIGNvbCAtIGMpKSB7XG4gICAgICAgICAgICAgICAgICBkYXJrID0gIWRhcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZHVsZXNbcm93XVtjb2wgLSBjXSA9IGRhcms7XG4gICAgICAgICAgICAgICAgYml0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBieXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGJpdEluZGV4ID0gNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyArPSBpbmM7XG4gICAgICAgICAgICBpZiAocm93IDwgMCB8fCBtb2R1bGVDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgcm93IC09IGluYztcbiAgICAgICAgICAgICAgaW5jID0gLWluYztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNyZWF0ZUJ5dGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnl0ZXMoYml0QnVmZmVyLCByc0Jsb2Nrcykge1xuICAgICAgICB2YXIgZGNkYXRhID0gW107XG4gICAgICAgIHZhciBlY2RhdGEgPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhEY0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgdmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcbiAgICAgICAgICBtYXhEY0NvdW50ID0gTWF0aC5tYXgobWF4RGNDb3VudCwgZGNDb3VudCk7XG4gICAgICAgICAgbWF4RWNDb3VudCA9IE1hdGgubWF4KG1heEVjQ291bnQsIGVjQ291bnQpO1xuICAgICAgICAgIGRjZGF0YVtyXSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBkY2RhdGFbcl1baV0gPSAweGZmICYgYml0QnVmZmVyLmJ1ZmZlcltpICsgb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ICs9IGRjQ291bnQ7XG4gICAgICAgICAgdmFyIHJzUG9seSA9IFV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgICB2YXIgcmF3UG9seSA9IG5ldyBQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIHZhciBtb2RQb2x5ID0gcmF3UG9seS5tb2QocnNQb2x5KTtcbiAgICAgICAgICBlY2RhdGFbcl0gPSBuZXcgQXJyYXkocnNQb2x5Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVjZGF0YVtyXS5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgbW9kSW5kZXggPSBfaTMgKyBtb2RQb2x5Lmxlbmd0aCAtIGVjZGF0YVtyXS5sZW5ndGg7XG4gICAgICAgICAgICBlY2RhdGFbcl1bX2kzXSA9IG1vZEluZGV4ID49IDAgPyBtb2RQb2x5LmdldEF0KG1vZEluZGV4KSA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHJzQmxvY2tzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tfaTRdLnRvdGFsQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBtYXhEY0NvdW50OyBfaTUrKykge1xuICAgICAgICAgIGZvciAodmFyIF9yID0gMDsgX3IgPCByc0Jsb2Nrcy5sZW5ndGg7IF9yKyspIHtcbiAgICAgICAgICAgIGlmIChfaTUgPCBkY2RhdGFbX3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkYXRhW2luZGV4KytdID0gZGNkYXRhW19yXVtfaTVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBtYXhFY0NvdW50OyBfaTYrKykge1xuICAgICAgICAgIGZvciAodmFyIF9yMiA9IDA7IF9yMiA8IHJzQmxvY2tzLmxlbmd0aDsgX3IyKyspIHtcbiAgICAgICAgICAgIGlmIChfaTYgPCBlY2RhdGFbX3IyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCsrXSA9IGVjZGF0YVtfcjJdW19pNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc0RhcmtcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Rhcmsocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIG1vZHVsZUNvdW50ID0gdGhpcy5tb2R1bGVDb3VudDtcbiAgICAgICAgaWYgKHJvdyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHJvdywgXCIsIFwiKS5jb25jYXQoY29sKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlc1tyb3ddW2NvbF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZERhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhTGlzdC5wdXNoKG5ldyBCaXRCeXRlKGRhdGEpKTtcbiAgICAgICAgdGhpcy5kYXRhQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRNb2R1bGVDb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZHVsZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVDb3VudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWFrZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2UoKSB7XG4gICAgICAgIHRoaXMubWFrZUltcGwoZmFsc2UsIHRoaXMuZ2V0QmVzdE1hc2tQYXR0ZXJuKCkpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpOyAvKipcbiAgICAgICAqIFNWR0Eg5LiL6L296Kej5p6Q5ZmoXG4gICAgICAgKi9cbiAgdmFyIFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlcik7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBudWxsLCBbe1xuICAgICAga2V5OiBcImRlY29tcHJlc3NcIixcbiAgICAgIHZhbHVlOlxuICAgICAgLyoqXG4gICAgICAgKiDop6Pljovop4bpopHmupDmlofku7ZcbiAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHVuemxpYlN5bmMobmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6Kej5p6Q6KeG6aKR5a6e5L2TXG4gICAgICAgKiBAcGFyYW0gZGF0YSDop4bpopHkuozov5vliLbmlbDmja5cbiAgICAgICAqIEBwYXJhbSB1cmwg6KeG6aKR5Zyw5Z2AXG4gICAgICAgKiBAcGFyYW0gbmVlZERlY29tcHJlc3Mg5piv5ZCm6Kej5Y6LXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnNlVmlkZW9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVZpZGVvKGRhdGEsIHVybCkge1xuICAgICAgICB2YXIgbmVlZERlY29tcHJlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICAgIHJldHVybiBjcmVhdGVWaWRlb0VudGl0eShuZXcgVWludDhBcnJheShuZWVkRGVjb21wcmVzcyA/IHRoaXMuZGVjb21wcmVzcyhkYXRhKSA6IGRhdGEpLCBwbGF0Zm9ybS5wYXRoLmZpbGVuYW1lKHVybCkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDor7vlj5bmlofku7botYTmupBcbiAgICAgICAqIEBwYXJhbSB1cmwg5paH5Lu26LWE5rqQ5Zyw5Z2AXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImRvd25sb2FkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWQodXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIGdsb2JhbHMsIHJlbW90ZSwgcGF0aCwgbG9jYWwsIGVudiwgc3VwcG9ydExvY2FsLCBmaWxlcGF0aCwgYnVmZiwgX3Q7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wID0gX2NvbnRleHQubikge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZ2xvYmFscyA9IHBsYXRmb3JtLmdsb2JhbHMsIHJlbW90ZSA9IHBsYXRmb3JtLnJlbW90ZSwgcGF0aCA9IHBsYXRmb3JtLnBhdGgsIGxvY2FsID0gcGxhdGZvcm0ubG9jYWw7XG4gICAgICAgICAgICAgICAgZW52ID0gZ2xvYmFscy5lbnY7XG4gICAgICAgICAgICAgICAgc3VwcG9ydExvY2FsID0gZW52ICE9PSBcImg1XCIgJiYgZW52ICE9PSBcInR0XCI7XG4gICAgICAgICAgICAgICAgZmlsZXBhdGggPSBwYXRoLmlzKHVybCkgPyB1cmwgOiBwYXRoLnJlc29sdmUocGF0aC5maWxlbmFtZSh1cmwpKTsgLy8g5pys5Zyw6K+75Y+WXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0TG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbC5leGlzdHMoZmlsZXBhdGgpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dC52KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyLCBsb2NhbC5yZWFkKGZpbGVwYXRoKSk7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlLmZldGNoKHVybCk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBidWZmID0gX2NvbnRleHQudjtcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRMb2NhbCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucCA9IDQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsLndyaXRlKGJ1ZmYsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucCA9IDY7XG4gICAgICAgICAgICAgICAgX3QgPSBfY29udGV4dC52O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihfdCk7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyLCBidWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzQsIDZdXSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6YCa6L+HIHVybCDkuIvovb3lubbop6PmnpAgU1ZHQSDmlofku7ZcbiAgICAgICAqIEBwYXJhbSB1cmwgU1ZHQSDmlofku7bnmoTkuIvovb3pk77mjqVcbiAgICAgICAqIEByZXR1cm5zIFByb21pc2U8U1ZHQSDmlbDmja7mupBcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgdmFyIF90MiwgX3QzLCBfdDQ7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF90MiA9IFBhcnNlcjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlci5kb3dubG9hZCh1cmwpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX3QzID0gX2NvbnRleHQyLnY7XG4gICAgICAgICAgICAgICAgX3Q0ID0gdXJsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYSgyLCBfdDIucGFyc2VWaWRlby5jYWxsKF90MiwgX3QzLCBfdDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIG5vb3AgPSBwbGF0Zm9ybS5ub29wO1xuICB2YXIgUGFpbnRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZVxuICAgICAqIEBwYXJhbSBXIOa1t+aKpeaooeW8j+W/hemhu+S8oOWFpVxuICAgICAqIEBwYXJhbSBIIOa1t+aKpeaooeW8j+W/hemhu+S8oOWFpVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhaW50ZXIoKSB7XG4gICAgICB2YXIgbW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJkdWFsXCI7XG4gICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhaW50ZXIpO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIC8qKlxuICAgICAgICog5Li75bGP55qEIENhbnZhcyDlhYPntKBcbiAgICAgICAqIEZyb250IFNjcmVlblxuICAgICAgICovXG4gICAgICB0aGlzLkYgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiDkuLvlsY/nmoQgQ29udGV4dCDlr7nosaFcbiAgICAgICAqIEZyb250IENvbnRleHRcbiAgICAgICAqL1xuICAgICAgdGhpcy5GQyA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIOWJr+Wxj+eahCBDYW52YXMg5YWD57SgXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNjcmVlblxuICAgICAgICovXG4gICAgICB0aGlzLkIgPSBudWxsO1xuICAgICAgLyoqXG4gICAgICAgKiDlia/lsY/nmoQgQ29udGV4dCDlr7nosaFcbiAgICAgICAqIEJhY2tncm91bmQgQ29udGV4dFxuICAgICAgICovXG4gICAgICB0aGlzLkJDID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICog57KJ5Yi35qih5byPXG4gICAgICAgKi9cbiAgICAgIHRoaXMubW9kZWwgPSB7fTtcbiAgICAgIC8qKlxuICAgICAgICog5riy5p+T5Zmo5a6e5L6LXG4gICAgICAgKi9cbiAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgICAgdGhpcy5jbGVhckNvbnRhaW5lciA9IG5vb3A7XG4gICAgICB0aGlzLmNsZWFyU2Vjb25kYXJ5ID0gbm9vcDtcbiAgICAgIHRoaXMucmVzaXplID0gbm9vcDtcbiAgICAgIHRoaXMuZHJhdyA9IG5vb3A7XG4gICAgICB0aGlzLnN0aWNrID0gbm9vcDtcbiAgICAgIHZhciBkcHIgPSBwbGF0Zm9ybS5nbG9iYWxzLmRwcjtcbiAgICAgIHRoaXMuVyA9IHdpZHRoICogZHByO1xuICAgICAgdGhpcy5IID0gaGVpZ2h0ICogZHByO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorr7nva4gQ2FudmFzIOeahOWkhOeQhuaooeW8j1xuICAgICAqIC0gQ++8muS7o+ihqCBDYW52YXNcbiAgICAgKiAtIE/vvJrku6PooaggT2Zmc2NyZWVuQ2FudmFzXG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQYWludGVyLCBbe1xuICAgICAga2V5OiBcInNldEFjdGlvbk1vZGVsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QWN0aW9uTW9kZWwodHlwZSkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZW52ID0gcGxhdGZvcm0uZ2xvYmFscy5lbnY7XG4gICAgICAgIC8vIHNldCB0eXBlXG4gICAgICAgIG1vZGVsLnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyBzZXQgY2xlYXJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiT1wiICYmIGVudiA9PT0gXCJ0dFwiIHx8IGVudiA9PT0gXCJhbGlwYXlcIikge1xuICAgICAgICAgIG1vZGVsLmNsZWFyID0gXCJDTFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLmNsZWFyID0gXCJSRVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOazqOWGjOeUu+eslO+8jOagueaNrueOr+Wig+WIpOaWreeUn+aIkOacgOS8mOeahOe7mOWItuaWueW8j1xuICAgICAgICogQHBhcmFtIHNlbGVjdG9yXG4gICAgICAgKiBAcGFyYW0gb2ZzU2VsZWN0b3JcbiAgICAgICAqIEBwYXJhbSBjb21wb25lbnRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHNlbGVjdG9yLCBvZnNTZWxlY3RvciwgY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIG1vZGVsLCBtb2RlLCBnZXRDYW52YXMsIGdldE9mc0NhbnZhcywgZW52LCBfVywgX0gsIF9nZXRPZnNDYW52YXMsIGNhbnZhcywgY29udGV4dCwgX3lpZWxkJGdldENhbnZhcywgX2NhbnZhcywgX2NvbnRleHQsIEZDLCBGLCBXLCBILCBjbGVhclR5cGUsIG9mc1Jlc3VsdCwgX0JDLCBfQiwgQiwgQkMsIHJlbmRlcmVyO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDIpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWwsIG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICAgICAgZ2V0Q2FudmFzID0gcGxhdGZvcm0uZ2V0Q2FudmFzLCBnZXRPZnNDYW52YXMgPSBwbGF0Zm9ybS5nZXRPZnNDYW52YXM7XG4gICAgICAgICAgICAgICAgZW52ID0gcGxhdGZvcm0uZ2xvYmFscy5lbnY7IC8vICNyZWdpb24gc2V0IG1haW4gc2NyZWVuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0tIOWIm+W7uuS4u+WxjyAtLS0tLS0tLS1cbiAgICAgICAgICAgICAgICBpZiAoIShtb2RlID09PSBcInNpbmdsZVwiICYmIChlbnYgIT09IFwiaDVcIiB8fCBcIk9mZnNjcmVlbkNhbnZhc1wiIGluIGdsb2JhbFRoaXMpKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9XID0gdGhpcy5XLCBfSCA9IHRoaXMuSDtcbiAgICAgICAgICAgICAgICBfZ2V0T2ZzQ2FudmFzID0gZ2V0T2ZzQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBfVyxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogX0hcbiAgICAgICAgICAgICAgICB9KSwgY2FudmFzID0gX2dldE9mc0NhbnZhcy5jYW52YXMsIGNvbnRleHQgPSBfZ2V0T2ZzQ2FudmFzLmNvbnRleHQ7IC8vIOa3u+WKoOS4u+Wxj1xuICAgICAgICAgICAgICAgIHRoaXMuRiA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICB0aGlzLkZDID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGlvbk1vZGVsKFwiT1wiKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENhbnZhcyhzZWxlY3RvciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF95aWVsZCRnZXRDYW52YXMgPSBfY29udGV4dDIudjtcbiAgICAgICAgICAgICAgICBfY2FudmFzID0gX3lpZWxkJGdldENhbnZhcy5jYW52YXM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQgPSBfeWllbGQkZ2V0Q2FudmFzLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgLy8g5re75Yqg5Li75bGPXG4gICAgICAgICAgICAgICAgdGhpcy5GID0gX2NhbnZhcztcbiAgICAgICAgICAgICAgICB0aGlzLkZDID0gX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3Rpb25Nb2RlbChcIkNcIik7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgIF9jYW52YXMud2lkdGggPSB0aGlzLlc7XG4gICAgICAgICAgICAgICAgICBfY2FudmFzLmhlaWdodCA9IHRoaXMuSDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5XID0gX2NhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuSCA9IF9jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vICNlbmRyZWdpb24gc2V0IG1haW4gc2NyZWVuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIEZDID0gdGhpcy5GQywgRiA9IHRoaXMuRiwgVyA9IHRoaXMuVywgSCA9IHRoaXMuSDtcbiAgICAgICAgICAgICAgICBjbGVhclR5cGUgPSBtb2RlbC5jbGVhcjtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ29udGFpbmVyID0gUmVuZGVyZXIyREV4dGVuc2lvbi5jbGVhcihjbGVhclR5cGUsIEZDLCBGLCBXLCBIKTtcbiAgICAgICAgICAgICAgICBpZiAoIShtb2RlID09PSBcInNpbmdsZVwiKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuQiA9IEY7XG4gICAgICAgICAgICAgICAgdGhpcy5CQyA9IEZDO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWNvbmRhcnkgPSB0aGlzLmNsZWFyQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2sgPSBub29wO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBvZnNTZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBvZnNTZWxlY3RvciAhPT0gXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENhbnZhcyhvZnNTZWxlY3RvciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG9mc1Jlc3VsdCA9IF9jb250ZXh0Mi52O1xuICAgICAgICAgICAgICAgIG9mc1Jlc3VsdC5jYW52YXMud2lkdGggPSBXO1xuICAgICAgICAgICAgICAgIG9mc1Jlc3VsdC5jYW52YXMuaGVpZ2h0ID0gSDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGlvbk1vZGVsKFwiQ1wiKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBvZnNSZXN1bHQgPSBnZXRPZnNDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IFcsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IEhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGlvbk1vZGVsKFwiT1wiKTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHRoaXMuQiA9IG9mc1Jlc3VsdC5jYW52YXM7XG4gICAgICAgICAgICAgICAgdGhpcy5CQyA9IG9mc1Jlc3VsdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIC8vICNlbmRyZWdpb24gc2V0IHNlY29uZGFyeSBzY3JlZW4gaW1wbGVtZW50XG4gICAgICAgICAgICAgICAgX0JDID0gdGhpcy5CQywgX0IgPSB0aGlzLkI7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlY29uZGFyeSA9IFJlbmRlcmVyMkRFeHRlbnNpb24uY2xlYXIoY2xlYXJUeXBlLCBfQkMsIF9CLCBXLCBIKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0aWNrID0gUmVuZGVyZXIyREV4dGVuc2lvbi5zdGljayhGQywgX0IpO1xuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgLy8gI3JlZ2lvbiBvdGhlciBtZXRob2RzIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0g55Sf5oiQ5YW25LuW5pa55rOVIC0tLS0tLS0tXG4gICAgICAgICAgICAgICAgQiA9IHRoaXMuQiwgQkMgPSB0aGlzLkJDO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcjJEKEJDKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uIChjb250ZW50TW9kZSwgdmlkZW9TaXplKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIucmVzaXplKGNvbnRlbnRNb2RlLCB2aWRlb1NpemUsIEIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKHZpZGVvRW50aXR5LCBtYXRlcmlhbHMsIGR5bmFtaWNNYXRlcmlhbHMsIGN1cnJlbnRGcmFtZSwgaGVhZCwgdGFpbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnJlbmRlcih2aWRlb0VudGl0eSwgbWF0ZXJpYWxzLCBkeW5hbWljTWF0ZXJpYWxzLCBjdXJyZW50RnJhbWUsIGhlYWQsIHRhaWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8vICNlbmRyZWdpb24gb3RoZXIgbWV0aG9kcyBpbXBsZW1lbnRcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDplIDmr4HnlLvnrJRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNsZWFyQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWNvbmRhcnkoKTtcbiAgICAgICAgdGhpcy5GID0gdGhpcy5GQyA9IHRoaXMuQiA9IHRoaXMuQkMgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyQ29udGFpbmVyID0gdGhpcy5jbGVhclNlY29uZGFyeSA9IHRoaXMuc3RpY2sgPSBub29wO1xuICAgICAgICAoX2EgPSB0aGlzLnJlbmRlcmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuICB2YXIgQ29uZmlnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maWcoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlnKTtcbiAgICAgIC8qKlxuICAgICAgICog5pyA5ZCO5YGc55WZ55qE55uu5qCH5qih5byP77yM57G75Ly85LqOIGFuaW1hdGlvbi1maWxsLW1vZGXvvIzpu5jorqTlgLwgZm9yd2FyZHPjgIJcbiAgICAgICAqL1xuICAgICAgdGhpcy5maWxsTW9kZSA9IFwiYmFja3dhcmRzXCIgLyogUExBWUVSX0ZJTExfTU9ERS5CQUNLV0FSRFMgKi87XG4gICAgICAvKipcbiAgICAgICAqIOaSreaUvuaooeW8j++8jOm7mOiupOWAvCBmb3J3YXJkc1xuICAgICAgICovXG4gICAgICB0aGlzLnBsYXlNb2RlID0gXCJmb3J3YXJkc1wiIC8qIFBMQVlFUl9QTEFZX01PREUuRk9SV0FSRFMgKi87XG4gICAgICAvKipcbiAgICAgICAqIOWhq+WFheaooeW8j++8jOexu+S8vOS6jiBjb250ZW50LW1vZGXjgIJcbiAgICAgICAqL1xuICAgICAgdGhpcy5jb250ZW50TW9kZSA9IFwiZmlsbFwiIC8qIFBMQVlFUl9DT05URU5UX01PREUuRklMTCAqLztcbiAgICAgIC8qKlxuICAgICAgICog5byA5aeL5pKt5pS+55qE5bin77yM6buY6K6k5YC8IDBcbiAgICAgICAqL1xuICAgICAgdGhpcy5zdGFydEZyYW1lID0gMDtcbiAgICAgIC8qKlxuICAgICAgICog57uT5p2f5pKt5pS+55qE5bin77yM6buY6K6k5YC8IDBcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbmRGcmFtZSA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIOW+queOr+aSreaUvueahOW8gOWni+W4p++8jOm7mOiupOWAvCAwXG4gICAgICAgKi9cbiAgICAgIHRoaXMubG9vcFN0YXJ0RnJhbWUgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiDlvqrnjq/mrKHmlbDvvIzpu5jorqTlgLwgMO+8iOaXoOmZkOW+queOr++8iVxuICAgICAgICovXG4gICAgICB0aGlzLmxvb3AgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbmZpZywgW3tcbiAgICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5sb29wID09PSBcIm51bWJlclwiICYmIGNvbmZpZy5sb29wID49IDApIHtcbiAgICAgICAgICB0aGlzLmxvb3AgPSBjb25maWcubG9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmZpbGxNb2RlICYmIFtcImZvcndhcmRzXCIgLyogUExBWUVSX0ZJTExfTU9ERS5GT1JXQVJEUyAqLywgXCJiYWNrd2FyZHNcIiAvKiBQTEFZRVJfRklMTF9NT0RFLkJBQ0tXQVJEUyAqLywgXCJub25lXCIgLyogUExBWUVSX0ZJTExfTU9ERS5OT05FICovXS5pbmNsdWRlcyhjb25maWcuZmlsbE1vZGUpKSB7XG4gICAgICAgICAgdGhpcy5maWxsTW9kZSA9IGNvbmZpZy5maWxsTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnBsYXlNb2RlICYmIFtcImZvcndhcmRzXCIgLyogUExBWUVSX1BMQVlfTU9ERS5GT1JXQVJEUyAqLywgXCJmYWxsYmFja3NcIiAvKiBQTEFZRVJfUExBWV9NT0RFLkZBTExCQUNLUyAqL10uaW5jbHVkZXMoY29uZmlnLnBsYXlNb2RlKSkge1xuICAgICAgICAgIHRoaXMucGxheU1vZGUgPSBjb25maWcucGxheU1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuc3RhcnRGcmFtZSA9PT0gXCJudW1iZXJcIiAmJiBjb25maWcuc3RhcnRGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5zdGFydEZyYW1lID0gY29uZmlnLnN0YXJ0RnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZW5kRnJhbWUgPT09IFwibnVtYmVyXCIgJiYgY29uZmlnLmVuZEZyYW1lID49IDApIHtcbiAgICAgICAgICB0aGlzLmVuZEZyYW1lID0gY29uZmlnLmVuZEZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmxvb3BTdGFydEZyYW1lID09PSBcIm51bWJlclwiICYmIGNvbmZpZy5sb29wU3RhcnRGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5sb29wU3RhcnRGcmFtZSA9IGNvbmZpZy5sb29wU3RhcnRGcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50TW9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMuY29udGVudE1vZGUgPSBjb25maWcuY29udGVudE1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0SXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDb25maWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25maWcoZW50aXR5KSB7XG4gICAgICAgIHZhciBwbGF5TW9kZSA9IHRoaXMucGxheU1vZGUsXG4gICAgICAgICAgbG9vcFN0YXJ0RnJhbWUgPSB0aGlzLmxvb3BTdGFydEZyYW1lLFxuICAgICAgICAgIHN0YXJ0RnJhbWUgPSB0aGlzLnN0YXJ0RnJhbWUsXG4gICAgICAgICAgZW5kRnJhbWUgPSB0aGlzLmVuZEZyYW1lLFxuICAgICAgICAgIGZpbGxNb2RlID0gdGhpcy5maWxsTW9kZSxcbiAgICAgICAgICBsb29wID0gdGhpcy5sb29wO1xuICAgICAgICB2YXIgZnBzID0gZW50aXR5LmZwcyxcbiAgICAgICAgICBzcHJpdGVzID0gZW50aXR5LnNwcml0ZXM7XG4gICAgICAgIHZhciBmcmFtZXMgPSBlbnRpdHkuZnJhbWVzO1xuICAgICAgICB2YXIgc3ByaXRlQ291bnQgPSBzcHJpdGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRGcmFtZSA+IDAgPyBzdGFydEZyYW1lIDogMDtcbiAgICAgICAgdmFyIGVuZCA9IGVuZEZyYW1lID4gMCAmJiBlbmRGcmFtZSA8IGZyYW1lcyA/IGVuZEZyYW1lIDogZnJhbWVzO1xuICAgICAgICAvLyDmr4/luKfmjIHnu63nmoTml7bpl7RcbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gZnBzO1xuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFydEZyYW1lIHNob3VsZCBncmVhdGVyIHRoYW4gRW5kRnJhbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5pu05paw5rS75Yqo5bin5oC75pWwXG4gICAgICAgIGlmIChlbmQgPCBmcmFtZXMpIHtcbiAgICAgICAgICBmcmFtZXMgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IDApIHtcbiAgICAgICAgICBmcmFtZXMgLT0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5mbG9vcihmcmFtZXMgKiBmcmFtZUR1cmF0aW9uICogTWF0aC5wb3coMTAsIDYpKSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgdmFyIGN1cnJGcmFtZSA9IDA7XG4gICAgICAgIHZhciBleHRGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsb29wU3RhcnQ7XG4gICAgICAgIC8vIOmhuuW6j+aSreaUvi/lgJLlj5nmkq3mlL5cbiAgICAgICAgaWYgKHBsYXlNb2RlID09PSBcImZvcndhcmRzXCIgLyogUExBWUVSX1BMQVlfTU9ERS5GT1JXQVJEUyAqLykge1xuICAgICAgICAgIC8vIOmHjee9ruS4uuW8gOWni+W4p1xuICAgICAgICAgIGN1cnJGcmFtZSA9IE1hdGgubWF4KGxvb3BTdGFydEZyYW1lLCBzdGFydEZyYW1lKTtcbiAgICAgICAgICBpZiAoZmlsbE1vZGUgPT09IFwiZm9yd2FyZHNcIiAvKiBQTEFZRVJfRklMTF9NT0RFLkZPUldBUkRTICovKSB7XG4gICAgICAgICAgICBleHRGcmFtZSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvb3BTdGFydCA9IGxvb3BTdGFydEZyYW1lID4gc3RhcnQgPyAobG9vcFN0YXJ0RnJhbWUgLSBzdGFydCkgKiBmcmFtZUR1cmF0aW9uIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDph43nva7kuLrlvIDlp4vluKdcbiAgICAgICAgICBjdXJyRnJhbWUgPSBNYXRoLm1pbihsb29wU3RhcnRGcmFtZSwgZW5kIC0gMSk7XG4gICAgICAgICAgaWYgKGZpbGxNb2RlID09PSBcImJhY2t3YXJkc1wiIC8qIFBMQVlFUl9GSUxMX01PREUuQkFDS1dBUkRTICovKSB7XG4gICAgICAgICAgICBleHRGcmFtZSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvb3BTdGFydCA9IGxvb3BTdGFydEZyYW1lIDwgZW5kID8gKGVuZCAtIGxvb3BTdGFydEZyYW1lKSAqIGZyYW1lRHVyYXRpb24gOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VyckZyYW1lOiBjdXJyRnJhbWUsXG4gICAgICAgICAgc3RhcnRGcmFtZTogc3RhcnQsXG4gICAgICAgICAgZW5kRnJhbWU6IGVuZCxcbiAgICAgICAgICB0b3RhbEZyYW1lOiBmcmFtZXMsXG4gICAgICAgICAgc3ByaXRlQ291bnQ6IHNwcml0ZUNvdW50LFxuICAgICAgICAgIGFuaUNvbmZpZzoge1xuICAgICAgICAgICAgLy8g5Y2V5Liq5ZGo5pyf55qE6L+Q6KGM5pe26ZW/XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkajmnJ/lvIDlp4vml7bpl7TlgY/np7vph49cbiAgICAgICAgICAgIGxvb3BTdGFydDogbG9vcFN0YXJ0LFxuICAgICAgICAgICAgLy8g5b6q546v5qyh5pWwXG4gICAgICAgICAgICBsb29wOiBsb29wID09PSAwID8gSW5maW5pdHkgOiBsb29wLFxuICAgICAgICAgICAgLy8g5pyA5ZCO5LiA5bin5LiN5Zyo5ZGo5pyf5YaF77yM6ZyA6KaB5Y2V54us6K6h566XXG4gICAgICAgICAgICBmaWxsVmFsdWU6IGV4dEZyYW1lICogZnJhbWVEdXJhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTsgLyoqXG4gICAgICAgKiBTVkdBIOaSreaUvuWZqFxuICAgICAgICovXG4gIHZhciBQbGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYXllcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpO1xuICAgICAgLyoqXG4gICAgICAgKiDlvZPliY3phY3nva7poblcbiAgICAgICAqL1xuICAgICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKCk7XG4gICAgICAvKipcbiAgICAgICAqIOi1hOa6kOeuoeeQhuWZqFxuICAgICAgICovXG4gICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICog5Yi35aS05a6e5L6LXG4gICAgICAgKi9cbiAgICAgIHRoaXMucGFpbnRlciA9IG5ldyBQYWludGVyKCk7XG4gICAgICAvKipcbiAgICAgICAqIOWKqOeUu+WunuS+i1xuICAgICAgICovXG4gICAgICB0aGlzLmFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuvue9rumFjee9rumhuVxuICAgICAqIEBwYXJhbSBvcHRpb25zIOWPr+mFjee9rumhuVxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXIg5Li75bGP77yM5pKt5pS+5Yqo55S755qEIENhbnZhcyDlhYPntKBcbiAgICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5IOWJr+Wxj++8jOaSreaUvuWKqOeUu+eahCBDYW52YXMg5YWD57SgXG4gICAgICogQHByb3BlcnR5IGxvb3Ag5b6q546v5qyh5pWw77yM6buY6K6k5YC8IDDvvIjml6DpmZDlvqrnjq/vvIlcbiAgICAgKiBAcHJvcGVydHkgZmlsbE1vZGUg5pyA5ZCO5YGc55WZ55qE55uu5qCH5qih5byP77yM57G75Ly85LqOIGFuaW1hdGlvbi1maWxsLW1vZGXvvIzmjqXlj5flgLwgZm9yd2FyZHMg5ZKMIGZhbGxiYWNrc++8jOm7mOiupOWAvCBmb3J3YXJkc+OAglxuICAgICAqIEBwcm9wZXJ0eSBwbGF5TW9kZSDmkq3mlL7mqKHlvI/vvIzmjqXlj5flgLwgZm9yd2FyZHMg5ZKMIGZhbGxiYWNrcyDvvIzpu5jorqTlgLwgZm9yd2FyZHPjgIJcbiAgICAgKiBAcHJvcGVydHkgc3RhcnRGcmFtZSDljZXkuKrlvqrnjq/lkajmnJ/lhoXlvIDlp4vmkq3mlL7nmoTluKfmlbDvvIzpu5jorqTlgLwgMFxuICAgICAqIEBwcm9wZXJ0eSBlbmRGcmFtZSDljZXkuKrlvqrnjq/lkajmnJ/lhoXnu5PmnZ/mkq3mlL7nmoTluKfmlbDvvIzpu5jorqTlgLwgMFxuICAgICAqIEBwcm9wZXJ0eSBsb29wU3RhcnRGcmFtZSDlvqrnjq/mkq3mlL7nmoTlvIDlp4vluKfvvIzku4XlvbHlk43nrKzkuIDkuKrlkajmnJ/nmoTlvIDlp4vluKfvvIzpu5jorqTlgLwgMFxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVJbk9ic2VydmVyIOaYr+WQpuWQr+eUqCBJbnRlcnNlY3Rpb25PYnNlcnZlciDnm5HlkKzlrrnlmajmmK/lkKblpITkuo7mtY/op4jlmajop4bnqpflhoXvvIzpu5jorqTlgLwgZmFsc2VcbiAgICAgKi9cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBsYXllciwgW3tcbiAgICAgIGtleTogXCJzZXRDb25maWdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb25maWcob3B0aW9ucywgY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIGNvbmZpZywgY29udGFpbmVyLCBzZWNvbmRhcnk7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb25maWcgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0gOiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIsIHNlY29uZGFyeSA9IGNvbmZpZy5zZWNvbmRhcnk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucmVnaXN0ZXIoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAvLyDnm5HlkKzlrrnlmajmmK/lkKblpITkuo7mtY/op4jlmajop4bnqpflhoVcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnNldEludGVyc2VjdGlvbk9ic2VydmVyKClcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLnJlZ2lzdGVyKGNvbnRhaW5lciwgc2Vjb25kYXJ5LCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIodGhpcy5wYWludGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdG9yLm9uQW5pbWF0ZSA9IHBsYXRmb3JtLnJBRi5iaW5kKG51bGwsIHRoaXMucGFpbnRlci5GKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOabtOaWsOmFjee9rlxuICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0SXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDoo4Xovb0gU1ZHQSDmlbDmja7lhYNcbiAgICAgICAqIEBwYXJhbSB2aWRlb0VudGl0eSBTVkdBIOaVsOaNrua6kFxuICAgICAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQodmlkZW9FbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgdmFyIGltYWdlcywgZmlsZW5hbWU7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh2aWRlb0VudGl0eSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZpZGVvRW50aXR5IHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGltYWdlcyA9IHZpZGVvRW50aXR5LmltYWdlcywgZmlsZW5hbWUgPSB2aWRlb0VudGl0eS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdG9yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJTZWNvbmRhcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlLnJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGl0eSA9IHZpZGVvRW50aXR5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZS5sb2FkSW1hZ2VzV2l0aFJlY29yZChpbWFnZXMsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog5byA5aeL5pKt5pS+XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIChfYSA9IHRoaXMub25TdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOmHjeaWsOaSreaUvlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc3VtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5yZXN1bWUoKSkge1xuICAgICAgICAgIChfYSA9IHRoaXMub25SZXN1bWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOaaguWBnOaSreaUvlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0b3IucGF1c2UoKSkge1xuICAgICAgICAgIChfYSA9IHRoaXMub25QYXVzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog5YGc5q2i5pKt5pS+XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RvcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hbmltYXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5jbGVhckNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJTZWNvbmRhcnkoKTtcbiAgICAgICAgKF9hID0gdGhpcy5vblN0b3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDplIDmr4Hlrp7kvotcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5hbmltYXRvci5zdG9wKCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5kZXN0cm95KCk7XG4gICAgICAgIChfYSA9IHRoaXMucmVzb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWxlYXNlKCk7XG4gICAgICAgIChfYiA9IHRoaXMucmVzb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGVhbnVwKCk7XG4gICAgICAgIHRoaXMuZW50aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDot7PovazliLDmjIflrprluKdcbiAgICAgICAqIEBwYXJhbSBmcmFtZSDnm67moIfluKdcbiAgICAgICAqIEBwYXJhbSBhbmRQbGF5IOaYr+WQpueri+WNs+aSreaUvlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0ZXBUb0ZyYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcFRvRnJhbWUoZnJhbWUpIHtcbiAgICAgICAgdmFyIGFuZFBsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuZW50aXR5IHx8IGZyYW1lIDwgMCB8fCBmcmFtZSA+PSB0aGlzLmVudGl0eS5mcmFtZXMpIHJldHVybjtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5sb29wU3RhcnRGcmFtZSA9IGZyYW1lO1xuICAgICAgICBpZiAoYW5kUGxheSkge1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDot7PovazliLDmjIflrprnmb7liIbmr5RcbiAgICAgICAqIEBwYXJhbSBwZXJjZW50IOebruagh+eZvuWIhuavlFxuICAgICAgICogQHBhcmFtIGFuZFBsYXkg5piv5ZCm56uL5Y2z5pKt5pS+XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RlcFRvUGVyY2VudGFnZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXBUb1BlcmNlbnRhZ2UocGVyY2VudCkge1xuICAgICAgICB2YXIgYW5kUGxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5lbnRpdHkpIHJldHVybjtcbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZW50aXR5LmZyYW1lcztcbiAgICAgICAgdmFyIGZyYW1lID0gcGVyY2VudCA8IDAgPyAwIDogTWF0aC5yb3VuZChwZXJjZW50ICogZnJhbWVzKTtcbiAgICAgICAgaWYgKGZyYW1lID49IGZyYW1lcykge1xuICAgICAgICAgIGZyYW1lID0gZnJhbWVzIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgdGhpcy5zdGVwVG9GcmFtZShmcmFtZSwgYW5kUGxheSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOW8gOWni+e7mOWItuWKqOeUu1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0YXJ0QW5pbWF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLmVudGl0eSxcbiAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBhbmltYXRvciA9IHRoaXMuYW5pbWF0b3IsXG4gICAgICAgICAgcGFpbnRlciA9IHRoaXMucGFpbnRlcixcbiAgICAgICAgICByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2U7XG4gICAgICAgIHBhaW50ZXIuVztcbiAgICAgICAgcGFpbnRlci5IO1xuICAgICAgICB2YXIgbWF0ZXJpYWxzID0gcmVzb3VyY2UubWF0ZXJpYWxzLFxuICAgICAgICAgIGR5bmFtaWNNYXRlcmlhbHMgPSByZXNvdXJjZS5keW5hbWljTWF0ZXJpYWxzO1xuICAgICAgICB2YXIgZmlsbE1vZGUgPSBjb25maWcuZmlsbE1vZGUsXG4gICAgICAgICAgcGxheU1vZGUgPSBjb25maWcucGxheU1vZGUsXG4gICAgICAgICAgY29udGVudE1vZGUgPSBjb25maWcuY29udGVudE1vZGU7XG4gICAgICAgIHZhciBfY29uZmlnJGdldENvbmZpZyA9IGNvbmZpZy5nZXRDb25maWcoZW50aXR5KSxcbiAgICAgICAgICBjdXJyRnJhbWUgPSBfY29uZmlnJGdldENvbmZpZy5jdXJyRnJhbWUsXG4gICAgICAgICAgc3RhcnRGcmFtZSA9IF9jb25maWckZ2V0Q29uZmlnLnN0YXJ0RnJhbWUsXG4gICAgICAgICAgZW5kRnJhbWUgPSBfY29uZmlnJGdldENvbmZpZy5lbmRGcmFtZSxcbiAgICAgICAgICB0b3RhbEZyYW1lID0gX2NvbmZpZyRnZXRDb25maWcudG90YWxGcmFtZSxcbiAgICAgICAgICBzcHJpdGVDb3VudCA9IF9jb25maWckZ2V0Q29uZmlnLnNwcml0ZUNvdW50LFxuICAgICAgICAgIGFuaUNvbmZpZyA9IF9jb25maWckZ2V0Q29uZmlnLmFuaUNvbmZpZztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pQ29uZmlnLmR1cmF0aW9uLFxuICAgICAgICAgIGxvb3BTdGFydCA9IGFuaUNvbmZpZy5sb29wU3RhcnQsXG4gICAgICAgICAgbG9vcCA9IGFuaUNvbmZpZy5sb29wLFxuICAgICAgICAgIGZpbGxWYWx1ZSA9IGFuaUNvbmZpZy5maWxsVmFsdWU7XG4gICAgICAgIHZhciBpc1JldmVyc2VNb2RlID0gcGxheU1vZGUgPT09IFwiZmFsbGJhY2tzXCIgLyogUExBWUVSX1BMQVlfTU9ERS5GQUxMQkFDS1MgKi87XG4gICAgICAgIC8vIOW9k+WJjeW4p1xuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gY3VyckZyYW1lO1xuICAgICAgICAvLyDniYfmrrXnu5jliLbnu5PmnZ/kvY3nva5cbiAgICAgICAgdmFyIHRhaWwgPSAwO1xuICAgICAgICB2YXIgbmV4dFRhaWw7XG4gICAgICAgIC8vIOS4iuS4gOW4p1xuICAgICAgICB2YXIgbGF0ZXN0RnJhbWU7XG4gICAgICAgIC8vIOS4i+S4gOW4p1xuICAgICAgICB2YXIgbmV4dEZyYW1lO1xuICAgICAgICAvLyDnsr7noa7luKdcbiAgICAgICAgdmFyIGV4YWN0RnJhbWU7XG4gICAgICAgIC8vIOW9k+WJjeW3suWujOaIkOeahOeZvuWIhuavlFxuICAgICAgICB2YXIgcGVyY2VudDtcbiAgICAgICAgLy8g5piv5ZCm6L+Y5pyJ5Ymp5L2Z5pe26Ze0XG4gICAgICAgIHZhciBoYXNSZW1haW5lZDtcbiAgICAgICAgLy8g5pu05paw5Yqo55S75Z+656GA5L+h5oGvXG4gICAgICAgIGFuaW1hdG9yLnNldENvbmZpZyhkdXJhdGlvbiwgbG9vcFN0YXJ0LCBsb29wLCBmaWxsVmFsdWUpO1xuICAgICAgICBwYWludGVyLnJlc2l6ZShjb250ZW50TW9kZSwgZW50aXR5LnNpemUpO1xuICAgICAgICAvLyDliIbmrrXmuLLmn5Plh73mlbBcbiAgICAgICAgdmFyIE1BWF9EUkFXX1RJTUVfUEVSX0ZSQU1FID0gODtcbiAgICAgICAgdmFyIE1BWF9BQ0NFTEVSQVRFX0RSQVdfVElNRV9QRVJfRlJBTUUgPSAzO1xuICAgICAgICB2YXIgTUFYX0RZTkFNSUNfQ0hVTktfU0laRSA9IDM0O1xuICAgICAgICB2YXIgTUlOX0RZTkFNSUNfQ0hVTktfU0laRSA9IDE7XG4gICAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoaGVhZCwgdGFpbCkge1xuICAgICAgICAgIHJldHVybiBwYWludGVyLmRyYXcoZW50aXR5LCBtYXRlcmlhbHMsIGR5bmFtaWNNYXRlcmlhbHMsIGN1cnJlbnRGcmFtZSwgaGVhZCwgdGFpbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIOWKqOaAgeiwg+aVtOavj+asoee7mOWItueahOWdl+Wkp+Wwj1xuICAgICAgICB2YXIgZHluYW1pY0NodW5rU2l6ZSA9IDQ7IC8vIOWIneWni+Wdl+Wkp+Wwj1xuICAgICAgICB2YXIgc3RhcnRUaW1lO1xuICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgIHZhciBlbGFwc2VkO1xuICAgICAgICAvLyDkvb/nlKhg5oyH5pWw6YCA6YG/566X5rOVYOW5s+ihoea4suafk+mAn+W6puWSjOa1geeVheW6plxuICAgICAgICB2YXIgcGF0Y2hEcmF3ID0gZnVuY3Rpb24gcGF0Y2hEcmF3KGJlZm9yZSkge1xuICAgICAgICAgIHN0YXJ0VGltZSA9IHBsYXRmb3JtLm5vdygpO1xuICAgICAgICAgIGJlZm9yZSgpO1xuICAgICAgICAgIHdoaWxlICh0YWlsIDwgc3ByaXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIOagueaNruW9k+WJjeWdl+Wkp+Wwj+iuoeeul25leHRUYWlsXG4gICAgICAgICAgICBjaHVuayA9IE1hdGgubWluKGR5bmFtaWNDaHVua1NpemUsIHNwcml0ZUNvdW50IC0gdGFpbCk7XG4gICAgICAgICAgICBuZXh0VGFpbCA9IHRhaWwgKyBjaHVuayB8IDA7XG4gICAgICAgICAgICByZW5kZXIodGFpbCwgbmV4dFRhaWwpO1xuICAgICAgICAgICAgdGFpbCA9IG5leHRUYWlsO1xuICAgICAgICAgICAgLy8g5Yqo5oCB6LCD5pW05Z2X5aSn5bCPXG4gICAgICAgICAgICBlbGFwc2VkID0gcGxhdGZvcm0ubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA8IE1BWF9BQ0NFTEVSQVRFX0RSQVdfVElNRV9QRVJfRlJBTUUpIHtcbiAgICAgICAgICAgICAgZHluYW1pY0NodW5rU2l6ZSA9IE1hdGgubWluKGR5bmFtaWNDaHVua1NpemUgKiAyLCBNQVhfRFlOQU1JQ19DSFVOS19TSVpFKTsgLy8g5Yqg5b+r57uY5Yi2XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsYXBzZWQgPiBNQVhfRFJBV19USU1FX1BFUl9GUkFNRSkge1xuICAgICAgICAgICAgICBkeW5hbWljQ2h1bmtTaXplID0gTWF0aC5tYXgoZHluYW1pY0NodW5rU2l6ZSAvIDIsIE1JTl9EWU5BTUlDX0NIVU5LX1NJWkUpOyAvLyDlh4/mhaLnu5jliLZcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyDliqjnlLvnu5jliLbov4fnqItcbiAgICAgICAgYW5pbWF0b3Iub25VcGRhdGUgPSBmdW5jdGlvbiAodGltZVBlcmNlbnQpIHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcGF0Y2hEcmF3KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSBpc1JldmVyc2VNb2RlID8gMSAtIHRpbWVQZXJjZW50IDogdGltZVBlcmNlbnQ7XG4gICAgICAgICAgICBleGFjdEZyYW1lID0gcGVyY2VudCAqIHRvdGFsRnJhbWU7XG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlTW9kZSkge1xuICAgICAgICAgICAgICBuZXh0RnJhbWUgPSAodGltZVBlcmNlbnQgPT09IDAgPyBlbmRGcmFtZSA6IE1hdGguY2VpbChleGFjdEZyYW1lKSkgLSAxO1xuICAgICAgICAgICAgICAvLyBGSVhNRTog5YCS5bqP5Lya5pyJ5LiA5bin55qE5YGP5beu77yM6ZyA6KaB5qCh5YeG5b2T5YmN5binXG4gICAgICAgICAgICAgIHBlcmNlbnQgPSBjdXJyZW50RnJhbWUgLyB0b3RhbEZyYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV4dEZyYW1lID0gdGltZVBlcmNlbnQgPT09IDEgPyBzdGFydEZyYW1lIDogTWF0aC5mbG9vcihleGFjdEZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc1JlbWFpbmVkID0gY3VycmVudEZyYW1lID09PSBuZXh0RnJhbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGhhc1JlbWFpbmVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKHRhaWwgPCBzcHJpdGVDb3VudCkge1xuICAgICAgICAgICAgcmVuZGVyKHRhaWwsIHNwcml0ZUNvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFpbnRlci5jbGVhckNvbnRhaW5lcigpO1xuICAgICAgICAgIHBhaW50ZXIuc3RpY2soKTtcbiAgICAgICAgICBwYWludGVyLmNsZWFyU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgbGF0ZXN0RnJhbWUgPSBjdXJyZW50RnJhbWU7XG4gICAgICAgICAgY3VycmVudEZyYW1lID0gbmV4dEZyYW1lO1xuICAgICAgICAgIHRhaWwgPSAwO1xuICAgICAgICAgIChfYSA9IF90aGlzLm9uUHJvY2VzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoX3RoaXMsIH5+KHBlcmNlbnQgKiAxMDApIC8gMTAwLCBsYXRlc3RGcmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdG9yLm9uU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW50aXR5LmxvY2tlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdG9yLm9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBlbnRpdHkubG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgLy8g5aaC5p6c5LiN5L+d55WZ5pyA5ZCO5LiA5bin5riy5p+T77yM5YiZ5riF56m655S75biDXG4gICAgICAgICAgaWYgKGZpbGxNb2RlID09PSBcIm5vbmVcIiAvKiBQTEFZRVJfRklMTF9NT0RFLk5PTkUgKi8pIHtcbiAgICAgICAgICAgIHBhaW50ZXIuY2xlYXJDb250YWluZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9hID0gX3RoaXMub25FbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFBvc3RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9zdGVyKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3N0ZXIpO1xuICAgICAgLyoqXG4gICAgICAgKiDmtbfmiqXphY3nva7poblcbiAgICAgICAqL1xuICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuLvlsY/vvIznu5jliLbmtbfmiqXnmoQgQ2FudmFzIOWFg+e0oFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyOiBcIlwiLFxuICAgICAgICAvKipcbiAgICAgICAgICog5aGr5YWF5qih5byP77yM57G75Ly85LqOIGNvbnRlbnQtbW9kZeOAglxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudE1vZGU6IFwiZmlsbFwiIC8qIFBMQVlFUl9DT05URU5UX01PREUuRklMTCAqLyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Yi25oiQ5rW35oql55qE5bin77yM6buY6K6k5pivMOOAglxuICAgICAgICAgKi9cbiAgICAgICAgZnJhbWU6IDBcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpumFjee9ruWujOaIkFxuICAgICAgICovXG4gICAgICB0aGlzLmlzQ29uZmlndXJlZCA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiDotYTmupDnrqHnkIblmahcbiAgICAgICAqL1xuICAgICAgdGhpcy5yZXNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcihcInNpbmdsZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5rOo5YaMIFNWR0Eg5rW35oqlXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIOWuueWZqOmAieaLqeWZqFxuICAgICAqIEBwYXJhbSBjb21wb25lbnQg57uE5Lu2XG4gICAgICovXG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb3N0ZXIsIFt7XG4gICAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucGFpbnRlci5yZWdpc3RlcihzZWxlY3RvciwgXCJcIiwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBfdGhpcy5yZXNvdXJjZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoX3RoaXMucGFpbnRlcik7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDorr7nva7phY3nva7poblcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zIOWPr+mFjee9rumhuVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldENvbmZpZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIubikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuY29uZmlnLmNvbnRhaW5lciA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzMi5jb25maWcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXMyLmlzQ29uZmlndXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlZ2lzdGVyKF90aGlzMi5jb25maWcuY29udGFpbmVyLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYSgyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDkv67mlLnlhoXlrrnmqKHlvI9cbiAgICAgICAqIEBwYXJhbSBjb250ZW50TW9kZVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldENvbnRlbnRNb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGVudE1vZGUoY29udGVudE1vZGUpIHtcbiAgICAgICAgdGhpcy5jb25maWcuY29udGVudE1vZGUgPSBjb250ZW50TW9kZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6K6+572u5b2T5YmN5binXG4gICAgICAgKiBAcGFyYW0gZnJhbWVcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRGcmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyYW1lKGZyYW1lKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmZyYW1lID0gZnJhbWU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOijhei9vSBTVkdBIOaVsOaNruWFg1xuICAgICAgICogQHBhcmFtIHZpZGVvRW50aXR5IFNWR0Eg5pWw5o2u5rqQXG4gICAgICAgKiBAcGFyYW0gY3VyckZyYW1lXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW91bnQodmlkZW9FbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgdmFyIGltYWdlcywgZmlsZW5hbWU7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLm4pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh2aWRlb0VudGl0eSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZpZGVvRW50aXR5IHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29uZmlndXJlZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcigpO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaW1hZ2VzID0gdmlkZW9FbnRpdHkuaW1hZ2VzLCBmaWxlbmFtZSA9IHZpZGVvRW50aXR5LmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhckNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2UucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5ID0gdmlkZW9FbnRpdHk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc291cmNlLmxvYWRJbWFnZXNXaXRoUmVjb3JkKGltYWdlcywgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDnu5jliLbmtbfmiqVcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudGl0eSkgcmV0dXJuO1xuICAgICAgICB2YXIgcGFpbnRlciA9IHRoaXMucGFpbnRlcixcbiAgICAgICAgICByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2UsXG4gICAgICAgICAgZW50aXR5ID0gdGhpcy5lbnRpdHksXG4gICAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHBhaW50ZXIucmVzaXplKGNvbmZpZy5jb250ZW50TW9kZSwgZW50aXR5LnNpemUpO1xuICAgICAgICBwYWludGVyLmRyYXcoZW50aXR5LCByZXNvdXJjZS5tYXRlcmlhbHMsIHJlc291cmNlLmR5bmFtaWNNYXRlcmlhbHMsIGNvbmZpZy5mcmFtZSwgMCwgZW50aXR5LnNwcml0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6I635Y+W5rW35oql55qEIEltYWdlRGF0YSDmlbDmja5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0ltYWdlRGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSW1hZ2VEYXRhKCkge1xuICAgICAgICB2YXIgX3RoaXMkcGFpbnRlciA9IHRoaXMucGFpbnRlcixcbiAgICAgICAgICBGQyA9IF90aGlzJHBhaW50ZXIuRkMsXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyRwYWludGVyLlcsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcGFpbnRlci5IO1xuICAgICAgICByZXR1cm4gRkMuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDplIDmr4HmtbfmiqVcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5wYWludGVyLmRlc3Ryb3koKTtcbiAgICAgICAgKF9hID0gdGhpcy5yZXNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbGVhc2UoKTtcbiAgICAgICAgKF9iID0gdGhpcy5yZXNvdXJjZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5lbnRpdHkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHZhciB0eXBlTnVtYmVyID0gKF9hID0gb3B0aW9ucy50eXBlTnVtYmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiA0O1xuICAgIHZhciBjb3JyZWN0TGV2ZWwgPSAoX2IgPSBvcHRpb25zLmNvcnJlY3RMZXZlbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJIXCI7XG4gICAgdmFyIGNvZGVDb2xvciA9IChfYyA9IG9wdGlvbnMuY29kZUNvbG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIiMwMDAwMDBcIjtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gKF9kID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiI0ZGRkZGRlwiO1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBvcHRpb25zLmNvZGUsXG4gICAgICBzaXplOiBvcHRpb25zLnNpemUsXG4gICAgICB0eXBlTnVtYmVyOiB0eXBlTnVtYmVyLFxuICAgICAgY29ycmVjdExldmVsOiBjb3JyZWN0TGV2ZWwsXG4gICAgICBjb2RlQ29sb3I6IGNvZGVDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgfTtcbiAgfVxuICB2YXIgY2FsY0NlbGxTaXplQW5kUGFkZGluZyA9IGZ1bmN0aW9uIGNhbGNDZWxsU2l6ZUFuZFBhZGRpbmcobW9kdWxlQ291bnQsIHNpemUpIHtcbiAgICB2YXIgY2VsbFNpemUgPSB+fihzaXplIC8gbW9kdWxlQ291bnQpO1xuICAgIHJldHVybiB7XG4gICAgICBwYWRkaW5nOiB+figoc2l6ZSAtIG1vZHVsZUNvdW50ICogY2VsbFNpemUpIC8gMiksXG4gICAgICBjZWxsU2l6ZTogY2VsbFNpemUgfHwgMlxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VCdWZmZXJGcm9tQ29kZShvcHRpb25zKSB7XG4gICAgdmFyIF9wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICBjb2RlID0gX3BhcnNlT3B0aW9ucy5jb2RlLFxuICAgICAgdHlwZU51bWJlciA9IF9wYXJzZU9wdGlvbnMudHlwZU51bWJlcixcbiAgICAgIGNvcnJlY3RMZXZlbCA9IF9wYXJzZU9wdGlvbnMuY29ycmVjdExldmVsLFxuICAgICAgc2l6ZSA9IF9wYXJzZU9wdGlvbnMuc2l6ZSxcbiAgICAgIGNvZGVDb2xvciA9IF9wYXJzZU9wdGlvbnMuY29kZUNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yID0gX3BhcnNlT3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdmFyIHFyO1xuICAgIHRyeSB7XG4gICAgICBxciA9IG5ldyBRUkNvZGUodHlwZU51bWJlciwgY29ycmVjdExldmVsKTtcbiAgICAgIHFyLmFkZERhdGEoY29kZSk7XG4gICAgICBxci5tYWtlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHR5cGVOdW1iZXIgPj0gNDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGV4dCB0b28gbG9uZyB0byBlbmNvZGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmNhbGxlZSh7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGNvcnJlY3RMZXZlbDogY29ycmVjdExldmVsLFxuICAgICAgICB0eXBlTnVtYmVyOiB0eXBlTnVtYmVyICsgMSxcbiAgICAgICAgY29kZUNvbG9yOiBjb2RlQ29sb3IsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2FsYyBjZWxsc2l6ZSBhbmQgbWFyZ2luXG4gICAgdmFyIG1vZHVsZUNvdW50ID0gcXIuZ2V0TW9kdWxlQ291bnQoKTtcbiAgICB2YXIgX2NhbGNDZWxsU2l6ZUFuZFBhZGRpID0gY2FsY0NlbGxTaXplQW5kUGFkZGluZyhtb2R1bGVDb3VudCwgc2l6ZSksXG4gICAgICBwYWRkaW5nID0gX2NhbGNDZWxsU2l6ZUFuZFBhZGRpLnBhZGRpbmcsXG4gICAgICBjZWxsU2l6ZSA9IF9jYWxjQ2VsbFNpemVBbmRQYWRkaS5jZWxsU2l6ZTtcbiAgICB2YXIgbWF4ID0gbW9kdWxlQ291bnQgKiBjZWxsU2l6ZSArIHBhZGRpbmc7XG4gICAgdmFyIENPREVfQ09MT1IgPSArXCJcIi5jb25jYXQoY29kZUNvbG9yLnJlcGxhY2UoXCIjXCIsIFwiMHhcIiksIFwiRkZcIik7XG4gICAgdmFyIEJBQ0tHUk9VTkRfQ09MT1IgPSArXCJcIi5jb25jYXQoYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoXCIjXCIsIFwiMHhcIiksIFwiRkZcIik7XG4gICAgdmFyIHBuZyA9IG5ldyBQTkdFbmNvZGVyKHNpemUsIHNpemUpO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2l6ZTsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNpemU7IHgrKykge1xuICAgICAgICBpZiAocGFkZGluZyA8PSB4ICYmIHggPCBtYXggJiYgcGFkZGluZyA8PSB5ICYmIHkgPCBtYXgpIHtcbiAgICAgICAgICB2YXIgYyA9IH5+KCh4IC0gcGFkZGluZykgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgdmFyIHIgPSB+figoeSAtIHBhZGRpbmcpIC8gY2VsbFNpemUpO1xuICAgICAgICAgIHBuZy5zZXRQaXhlbCh4LCB5LCBxci5pc0RhcmsociwgYykgPyBDT0RFX0NPTE9SIDogQkFDS0dST1VORF9DT0xPUik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG5nLnNldFBpeGVsKHgsIHksIEJBQ0tHUk9VTkRfQ09MT1IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbmcuZmx1c2goKTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlRnJvbUNvZGUob3B0aW9ucykge1xuICAgIHZhciBidWZmID0gZ2VuZXJhdGVJbWFnZUJ1ZmZlckZyb21Db2RlKG9wdGlvbnMpO1xuICAgIHJldHVybiBwbGF0Zm9ybS5kZWNvZGUudG9EYXRhVVJMKGJ1ZmYpO1xuICB9IC8qKlxuICAgICog5bCGIEltYWdlRGF0YSDovazmjaLkuLogUE5HIOagvOW8j+eahCBCdWZmZXJcbiAgICAqIEBwYXJhbSBpbWFnZURhdGFcbiAgICAqIEByZXR1cm5zIFBORyDmoLzlvI/nmoQgQnVmZmVyXG4gICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyT2ZJbWFnZURhdGEoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICByZXR1cm4gbmV3IFBOR0VuY29kZXIod2lkdGgsIGhlaWdodCkud3JpdGUoZGF0YSkuZmx1c2goKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQg6K+35L2/55SoIGNyZWF0ZUJ1ZmZlck9mSW1hZ2VEYXRhIOS7o+abv++8jOatpOaWueazleWPr+iDveWcqOWQjue7reeJiOacrOS4reenu+mZpFxuICAgKi9cbiAgdmFyIGdldEJ1ZmZlckZyb21JbWFnZURhdGEgPSBjcmVhdGVCdWZmZXJPZkltYWdlRGF0YTtcbiAgLyoqXG4gICAqIOWwhiBJbWFnZURhdGEg6L2s5o2i5Li6IFBORyDmoLzlvI/nmoQgQmFzZTY0IOWtl+espuS4slxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhXG4gICAqIEByZXR1cm5zIFBORyDmoLzlvI/nmoQgQmFzZTY0IOWtl+espuS4slxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhVXJsKGltYWdlRGF0YSkge1xuICAgIHJldHVybiBwbGF0Zm9ybS5kZWNvZGUudG9EYXRhVVJMKGNyZWF0ZUJ1ZmZlck9mSW1hZ2VEYXRhKGltYWdlRGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCDor7fkvb/nlKggY3JlYXRlSW1hZ2VEYXRhVXJsIOS7o+abv++8jOatpOaWueazleWPr+iDveWcqOWQjue7reeJiOacrOS4reenu+mZpFxuICAgKi9cbiAgdmFyIGdldERhdGFVUkxGcm9tSW1hZ2VEYXRhID0gY3JlYXRlSW1hZ2VEYXRhVXJsOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIOajgOafpeaVsOaNruaYr+WQpuS4unpsaWLljovnvKnmoLzlvI9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhIOW+heajgOafpeeahOS6jOi/m+WItuaVsOaNrlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMg5piv5ZCm5Li6emxpYuWOi+e8qeagvOW8j1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIGZ1bmN0aW9uIGlzWmxpYkNvbXByZXNzZWQoZGF0YSkge1xuICAgIC8vIOajgOafpeaVsOaNrumVv+W6puaYr+WQpui2s+Wkn++8iOiHs+WwkemcgOimgTLlrZfoioLlpLTpg6jlkow05a2X6IqCQURMRVItMzLmoKHpqozlkozvvIlcbiAgICBpZiAoZGF0YS5sZW5ndGggPCA2KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIOiOt+WPlkNNRuWSjEZMR+Wtl+iKglxuICAgIHZhciBjbWYgPSBkYXRhWzBdO1xuICAgIHZhciBmbGcgPSBkYXRhWzFdO1xuICAgIC8vIOajgOafpUNNRueahOWOi+e8qeaWueazle+8iOS9jjTkvY3kuLo46KGo56S6REVGTEFURe+8iVxuICAgIGlmICgoY21mICYgMHgwZikgIT09IDgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8g5qOA5p+l56qX5Y+j5aSn5bCP77yI6auYNOS9jemAmuW4uOS4ujfvvIzkvYbkuI3mmK/kuKXmoLzopoHmsYLvvIlcbiAgICAvLyAtIOi/memHjOS4jeW8uuWItuajgOafpe+8jOWboOS4uueQhuiuuuS4iuWPr+S7peaYr+WFtuS7luWAvFxuICAgIC8vIOmqjOivgeWktOmDqOagoemqjO+8iENNRiAqIDI1NiArIEZMR+W/hemhu+aYrzMx55qE5YCN5pWw77yJXG4gICAgaWYgKChjbWYgKiAyNTYgKyBmbGcpICUgMzEgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8g5qOA5p+l5a2X5YW45qCH5b+X5L2N77yI5aaC5p6c6K6+572u5LqG5a2X5YW477yM6ZyA6KaB6aKd5aSW6aqM6K+B77yM5L2G6L+Z56eN5oOF5Ya15b6I5bCR6KeB77yJXG4gICAgdmFyIGZkaWN0ID0gKGZsZyAmIDB4MjApICE9PSAwO1xuICAgIGlmIChmZGljdCkge1xuICAgICAgLy8g5qCH5YeGemxpYuWOi+e8qemAmuW4uOS4jeS9v+eUqOmihOWumuS5ieWtl+WFuFxuICAgICAgLy8g6L+Z6YeM5YGH6K6+5LiN5L2/55So5a2X5YW477yM6Iul5qOA5rWL5Yiw5a2X5YW45qCH5b+X5YiZ6K6k5Li65LiN5piv5qCH5YeGemxpYuagvOW8j1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyDlsJ3or5Xmj5Dlj5ZBRExFUi0zMuagoemqjOWSjOW5tumqjOivgeWFtuagvOW8j1xuICAgIC8vIOiZveeEtuaXoOazlemqjOivgeagoemqjOWSjOWAvO+8iOmcgOimgeino+WOi+WQjuiuoeeul++8ie+8jOS9huWPr+S7peajgOafpeWFtuaYr+WQpuS4uuWQiOeQhueahOaVsOWAvFxuICAgIHZhciBhZGxlcjMyQnl0ZXMgPSBkYXRhLnNsaWNlKC00KTtcbiAgICBpZiAoYWRsZXIzMkJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYWRsZXIzMiA9IGFkbGVyMzJCeXRlc1swXSA8PCAyNCB8IGFkbGVyMzJCeXRlc1sxXSA8PCAxNiB8IGFkbGVyMzJCeXRlc1syXSA8PCA4IHwgYWRsZXIzMkJ5dGVzWzNdO1xuICAgIC8vIOacieaViOeahEFETEVSLTMy5YC85bqU5aSn5LqOMO+8iOmZpOmdnuaYr+epuuaVsOaNru+8iVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDIgJiYgYWRsZXIzMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyDmiYDmnInmo4Dmn6Xpg73pgJrov4fvvIzmlbDmja7lj6/og73mmK96bGli5Y6L57yp5qC85byPXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIFZpZGVvTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlkZW9NYW5hZ2VyKGxvYWRNb2RlLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9NYW5hZ2VyKTtcbiAgICAgIC8qKlxuICAgICAgICog6KeG6aKR5rGg55qE5b2T5YmN5oyH6ZKI5L2N572uXG4gICAgICAgKi9cbiAgICAgIHRoaXMucG9pbnQgPSAwO1xuICAgICAgLyoqXG4gICAgICAgKiDop4bpopHnmoTmnIDlpKfnlZnlrZjmlbDph4/vvIzlhbbku5bop4bpopHlsIbmlL7lnKjno4Hnm5jkuIrnvJPlrZhcbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhSZW1haW4gPSAzO1xuICAgICAgLyoqXG4gICAgICAgKiDnlZnlrZjop4bpopHnmoTlvIDlp4vmjIfpkojkvY3nva5cbiAgICAgICAqL1xuICAgICAgdGhpcy5yZW1haW5TdGFydCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIOeVmeWtmOinhumikeeahOe7k+adn+aMh+mSiOS9jee9rlxuICAgICAgICovXG4gICAgICB0aGlzLnJlbWFpbkVuZCA9IDA7XG4gICAgICAvKipcbiAgICAgICAqIOinhumikeWKoOi9veaooeW8j1xuICAgICAgICogLSDlv6vpgJ/liqDovb3mqKHlvI/vvJrlj6/kv53or4HlvZPliY3op4bpopHliqDovb3lrozmiJDlkI7vvIzlsL3lv6vmkq3mlL7vvJvlhbbku5bor7fmsYLlsIbkvb/nlKhQcm9taXNl55qE5pa55byP5L+d5a2Y5ZyoYnVja2V05Lit77yM5Lul5L6b5ZCO57ut5L2/55SoXG4gICAgICAgKiAtIOWujOaVtOWKoOi9veaooeW8j++8muWPr+S/neivgeaJgOacieinhumikeWKoOi9veWujOaIkO+8jOehruS/neaSreaUvuWIh+aNoueahOa1geeVheaAp1xuICAgICAgICovXG4gICAgICB0aGlzLmxvYWRNb2RlID0gXCJmYXN0XCI7XG4gICAgICAvKipcbiAgICAgICAqIOinhumikeaxoOeahOaJgOacieaVsOaNrlxuICAgICAgICovXG4gICAgICB0aGlzLmJ1Y2tldHMgPSBbXTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmihOWkhOeQhuWKqOaViOaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0gdXJsXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwcm9jZXNzOiBmdW5jdGlvbiBwcmVwcm9jZXNzKGJ1Y2tldCkge1xuICAgICAgICAgIHJldHVybiBQYXJzZXIuZG93bmxvYWQoYnVja2V0Lm9yaWdpbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkI7lpITnkIbliqjmlYjmlbDmja5cbiAgICAgICAgICogQHBhcmFtIGJ1Y2tldFxuICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgcG9zdHByb2Nlc3M6IGZ1bmN0aW9uIHBvc3Rwcm9jZXNzKGJ1Y2tldCwgZGF0YSkge1xuICAgICAgICAgIHJldHVybiBQYXJzZXIucGFyc2VWaWRlbyhkYXRhLCBidWNrZXQub3JpZ2luLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heeQhuaVsOaNrlxuICAgICAgICAgKiBAcGFyYW0gYnVja2V0c1xuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cChidWNrZXRzKSB7XG4gICAgICAgICAgcGxhdGZvcm0uZ2xvYmFscztcbiAgICAgICAgICB2YXIgbG9jYWwgPSBwbGF0Zm9ybS5sb2NhbCxcbiAgICAgICAgICAgIHBhdGggPSBwbGF0Zm9ybS5wYXRoO1xuICAgICAgICAgIGJ1Y2tldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVja2V0KSB7XG4gICAgICAgICAgICBpZiAocGF0aC5pcyhidWNrZXQubG9jYWwpKSB7XG4gICAgICAgICAgICAgIGxvY2FsLnJlbW92ZShidWNrZXQubG9jYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBsb2FkTW9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLmxvYWRNb2RlID0gbG9hZE1vZGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOabtOaWsOeVmeWtmOaMh+mSiOS9jee9rlxuICAgICAqL1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoVmlkZW9NYW5hZ2VyLCBbe1xuICAgICAga2V5OiBcInNpemVcIixcbiAgICAgIGdldDpcbiAgICAgIC8qKlxuICAgICAgICog6I635Y+W6KeG6aKR5rGg5aSn5bCPXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0cy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZVJlbWFpblJhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUmVtYWluUmFuZ2UocG9pbnQsIG1heFJlbWFpbiwgdG90YWxDb3VudCkge1xuICAgICAgICBpZiAocG9pbnQgPCAwKSB7XG4gICAgICAgICAgdGhpcy5wb2ludCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnQgPj0gdG90YWxDb3VudCkge1xuICAgICAgICAgIHRoaXMucG9pbnQgPSB0b3RhbENvdW50IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9hZE1vZGUgPT09IFwid2hvbGVcIikge1xuICAgICAgICAgIHRoaXMucmVtYWluU3RhcnQgPSAwO1xuICAgICAgICAgIHRoaXMucmVtYWluRW5kID0gdG90YWxDb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWF4UmVtYWluIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5tYXhSZW1haW4gPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF4UmVtYWluID4gdG90YWxDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5tYXhSZW1haW4gPSB0b3RhbENvdW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1heFJlbWFpbiA9IG1heFJlbWFpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW1haW5TdGFydCA9IHRoaXMucG9pbnQgLSBNYXRoLmZsb29yKHRoaXMubWF4UmVtYWluIC8gMik7XG4gICAgICAgICAgaWYgKHRoaXMucmVtYWluU3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbWFpblN0YXJ0ID0gdG90YWxDb3VudCArIHRoaXMucmVtYWluU3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVtYWluRW5kID0gdGhpcy5yZW1haW5TdGFydCArIHRoaXMubWF4UmVtYWluO1xuICAgICAgICAgIGlmICh0aGlzLnJlbWFpbkVuZCA+IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtYWluRW5kID0gdGhpcy5yZW1haW5FbmQgJSB0b3RhbENvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmjIfpkojmmK/lkKblnKjnlZnlrZjnqbrpl7TlhoVcbiAgICAgICAqIEBwYXJhbSBwb2ludFxuICAgICAgICogQHJldHVybnNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbmNsdWRlUmVtYWluUmFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlUmVtYWluUmFuZ2UocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtYWluU3RhcnQgPCB0aGlzLnJlbWFpbkVuZCkge1xuICAgICAgICAgIHJldHVybiBwb2ludCA+PSB0aGlzLnJlbWFpblN0YXJ0ICYmIHBvaW50IDwgdGhpcy5yZW1haW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVtYWluU3RhcnQgPiB0aGlzLnJlbWFpbkVuZCkge1xuICAgICAgICAgIHJldHVybiBwb2ludCA+PSB0aGlzLnJlbWFpblN0YXJ0IHx8IHBvaW50IDwgdGhpcy5yZW1haW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRvd25sb2FkQW5kUGFyc2VWaWRlb1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkQW5kUGFyc2VWaWRlbyhidWNrZXRfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoYnVja2V0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbmVlZFBhcnNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Lm4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucHJlcHJvY2VzcyhidWNrZXQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC52O1xuICAgICAgICAgICAgICAgICAgaWYgKCFuZWVkUGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubiA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMiwgb3B0aW9ucy5wb3N0cHJvY2VzcyhidWNrZXQsIGRhdGEpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOWIm+W7umJ1Y2tldFxuICAgICAgICogQHBhcmFtIHVybCDov5znqIvlnLDlnYBcbiAgICAgICAqIEBwYXJhbSBwb2ludCDmjIfpkojkvY3nva5cbiAgICAgICAqIEBwYXJhbSBuZWVkRG93bmxvYWRBbmRQYXJzZSDmmK/lkKbpnIDopoHkuIvovb3lubbop6PmnpBcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3JlYXRlQnVja2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQnVja2V0KHVybCwgcG9pbnQsIG5lZWREb3dubG9hZEFuZFBhcnNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgIHZhciBwYXRoLCBidWNrZXQ7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLm4pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHBhdGggPSBwbGF0Zm9ybS5wYXRoO1xuICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogdXJsLFxuICAgICAgICAgICAgICAgICAgbG9jYWw6IHBhdGgucmVzb2x2ZShwYXRoLmZpbGVuYW1lKHVybCkpLFxuICAgICAgICAgICAgICAgICAgZW50aXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgcHJvbWlzZTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5idWNrZXRzW3BvaW50XSA9IGJ1Y2tldDtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWREb3dubG9hZEFuZFBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkQW5kUGFyc2VWaWRlbyhidWNrZXQsIHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYnVja2V0LmVudGl0eSA9IF9jb250ZXh0Mi52O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2x1ZGVSZW1haW5SYW5nZShwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgIGJ1Y2tldC5wcm9taXNlID0gdGhpcy5kb3dubG9hZEFuZFBhcnNlVmlkZW8oYnVja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMiwgYnVja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6aKE5Yqg6L296KeG6aKR5Yiw5pys5Zyw56OB55uY5LitXG4gICAgICAgKiBAcGFyYW0gdXJscyDop4bpopHov5znqIvlnLDlnYBcbiAgICAgICAqIEBwYXJhbSBwb2ludCDlvZPliY3mjIfpkojkvY3nva5cbiAgICAgICAqIEBwYXJhbSBtYXhSZW1haW4g5pyA5aSn55WZ5a2Y5pWw6YePXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJlcGFyZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmUodXJsc18xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh1cmxzKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIHZhciBtYXhSZW1haW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDM7XG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgdmFyIGxvYWRNb2RlLCBjdXJyZW50UG9pbnQsIG5lZWREb3dubG9hZEFuZFBhcnNlLCBwcmVsb2FkQnVja2V0O1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcigpLncoZnVuY3Rpb24gKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMubikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIF90aGlzMi51cGRhdGVSZW1haW5SYW5nZShwb2ludCwgbWF4UmVtYWluLCB1cmxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBsb2FkTW9kZSA9IF90aGlzMi5sb2FkTW9kZSwgY3VycmVudFBvaW50ID0gX3RoaXMyLnBvaW50O1xuICAgICAgICAgICAgICAgICAgbmVlZERvd25sb2FkQW5kUGFyc2UgPSBsb2FkTW9kZSA9PT0gXCJ3aG9sZVwiOyAvLyDkvJjlhYjliqDovb3lvZPliY3liqjmlYhcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY3JlYXRlQnVja2V0KHVybHNbY3VycmVudFBvaW50XSwgY3VycmVudFBvaW50LCBuZWVkRG93bmxvYWRBbmRQYXJzZSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgcHJlbG9hZEJ1Y2tldCA9IF9jb250ZXh0My52O1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHVybHMubWFwKGZ1bmN0aW9uICh1cmwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gY3VycmVudFBvaW50ID8gcHJlbG9hZEJ1Y2tldCA6IF90aGlzMi5jcmVhdGVCdWNrZXQodXJsLCBpbmRleCwgbmVlZERvd25sb2FkQW5kUGFyc2UpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYSgyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDojrflj5blvZPliY3luKfnmoRidWNrZXRcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICB2YXIgYnVja2V0O1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbdGhpcy5wb2ludF07XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldC5lbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJ1Y2tldC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBidWNrZXQucHJvbWlzZSA9IHRoaXMuZG93bmxvYWRBbmRQYXJzZVZpZGVvKGJ1Y2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVja2V0LnByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5vcHRpb25zLnBvc3Rwcm9jZXNzKGJ1Y2tldCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBidWNrZXQuZW50aXR5ID0gX2NvbnRleHQ0LnY7XG4gICAgICAgICAgICAgICAgYnVja2V0LnByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hKDIsIGJ1Y2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOiOt+WPluW9k+WJjeeahOaMh+mSiOS9jee9rlxuICAgICAgICogQHJldHVybnNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6I635Y+W5oyH5a6a5L2N572u55qEYnVja2V0XG4gICAgICAgKiBAcGFyYW0gcG9zXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImdvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ28ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNpemUsIGJ1Y2tldHMsIGxvYWRNb2RlO1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDUpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NS5uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5zaXplLCBidWNrZXRzID0gdGhpcy5idWNrZXRzLCBsb2FkTW9kZSA9IHRoaXMubG9hZE1vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCEocG9pbnQgPCAwIHx8IHBvaW50ID49IHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubiA9IDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hKDIsIGJ1Y2tldHNbdGhpcy5wb2ludF0pO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZW1haW5SYW5nZShwb2ludCwgdGhpcy5tYXhSZW1haW4sIGJ1Y2tldHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZE1vZGUgPT09IFwiZmFzdFwiICYmIHRoaXMubWF4UmVtYWluICE9PSBidWNrZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgYnVja2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChidWNrZXQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczQuaW5jbHVkZVJlbWFpblJhbmdlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXQuZW50aXR5ID09PSBudWxsICYmIGJ1Y2tldC5wcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQucHJvbWlzZSA9IF90aGlzNC5kb3dubG9hZEFuZFBhcnNlVmlkZW8oYnVja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVja2V0LmVudGl0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgYnVja2V0LnByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hKDIsIHRoaXMuZ2V0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmuIXnkIbmiYDmnInnmoRidWNrZXRcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgICAgIHZhciBuZWVkUmVtb3ZlRmlsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldHM7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ni5uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgYnVja2V0cyA9IF90aGlzNS5idWNrZXRzO1xuICAgICAgICAgICAgICAgICAgX3RoaXM1LnBvaW50ID0gMDtcbiAgICAgICAgICAgICAgICAgIF90aGlzNS5yZW1haW5TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICBfdGhpczUucmVtYWluRW5kID0gMDtcbiAgICAgICAgICAgICAgICAgIF90aGlzNS5tYXhSZW1haW4gPSAzO1xuICAgICAgICAgICAgICAgICAgX3RoaXM1LmJ1Y2tldHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGlmICghbmVlZFJlbW92ZUZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDYubiA9IDE7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1Lm9wdGlvbnMuY2xlYW51cChidWNrZXRzKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmEoMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU2KTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgdmFyIFZpZGVvRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWRlb0VkaXRvcihwYWludGVyLCByZXNvdXJjZSwgZW50aXR5KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9FZGl0b3IpO1xuICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFZpZGVvRWRpdG9yLCBbe1xuICAgICAga2V5OiBcInNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXlfMSwgdmFsdWVfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiUlwiO1xuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgdmFyIGVudGl0eSwgcmVzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQubikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGVudGl0eSA9IF90aGlzLmVudGl0eSwgcmVzb3VyY2UgPSBfdGhpcy5yZXNvdXJjZTtcbiAgICAgICAgICAgICAgICAgIGlmICghKG1vZGUgPT09IFwiQVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZS5sb2FkSW1hZ2VzV2l0aFJlY29yZChfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpLCBlbnRpdHkuZmlsZW5hbWUsIFwiZHluYW1pY1wiKTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIGVudGl0eS5pbWFnZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog6I635Y+W6Ieq5a6a5LmJ57yW6L6R5ZmoXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLkJDO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDmmK/lkKbmmK/mnInmlYjnmoRLZXlcbiAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzVmFsaWRLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNWYWxpZEtleShrZXkpIHtcbiAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuZW50aXR5LmltYWdlcztcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuaGFzT3duID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihpbWFnZXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbWFnZXMsIGtleSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOWKoOi9veW5tue8k+WtmOWbvueJh1xuICAgICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAgICogQHBhcmFtIHVybFxuICAgICAgICogQHJldHVybnNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkSW1hZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkSW1hZ2Uoc291cmNlLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb3VyY2UubG9hZEV4dEltYWdlKHNvdXJjZSwgcGxhdGZvcm0ucGF0aC5maWxlbmFtZSh1cmwpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICog5Yib5bu655S75biD5Zu+54mHXG4gICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAqIEByZXR1cm5zXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q2FudmFzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FudmFzKGtleSwgY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGltYWdlRGF0YTtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIubikge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVudGl0eS5sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMik7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgICAgICAgICAgICB3aWR0aCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyU2Vjb25kYXJ5KCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm4gPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChrZXksIG5ldyBVaW50OEFycmF5KGNyZWF0ZUJ1ZmZlck9mSW1hZ2VEYXRhKGltYWdlRGF0YSkpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSk7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmEoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOWIm+W7uuS6jOi/m+WItuWbvueJh1xuICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICogQHBhcmFtIGJ1ZmZcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgKiBAcmV0dXJuc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEltYWdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2Uoa2V5LCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcigpLm0oZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgdmFyIF90LCBfdDIsIF90MywgX3Q0LCBfdDUsIF90NjtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMubikge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVudGl0eS5sb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmEoMik7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKFwiZGF0YTppbWFnZVwiKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm4gPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCB1cmwsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF90ID0gdGhpcztcbiAgICAgICAgICAgICAgICBfdDIgPSBrZXk7XG4gICAgICAgICAgICAgICAgX3QzID0gVWludDhBcnJheTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubiA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlci5kb3dubG9hZCh1cmwpO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX3Q0ID0gX2NvbnRleHQzLnY7XG4gICAgICAgICAgICAgICAgX3Q1ID0gbmV3IF90MyhfdDQpO1xuICAgICAgICAgICAgICAgIF90NiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Quc2V0LmNhbGwoX3QsIF90MiwgX3Q1LCBfdDYpO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiDliJvlu7rkuoznu7TnoIHlm77niYdcbiAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAqIEBwYXJhbSBjb2RlXG4gICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICogQHJldHVybnNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRRUkNvZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRRUkNvZGUoa2V5LCBjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dDQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NC5uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW50aXR5LmxvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm4gPSAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYSgyKTtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCBuZXcgVWludDhBcnJheShnZW5lcmF0ZUltYWdlQnVmZmVyRnJvbUNvZGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgICAgICAgICAgY29kZTogY29kZVxuICAgICAgICAgICAgICAgIH0pKSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgZXhwb3J0cy5FbmhhbmNlZFBsYXRmb3JtID0gRW5oYW5jZWRQbGF0Zm9ybTtcbiAgZXhwb3J0cy5QYWludGVyID0gUGFpbnRlcjtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gIGV4cG9ydHMuUGxheWVyID0gUGxheWVyO1xuICBleHBvcnRzLlBvc3RlciA9IFBvc3RlcjtcbiAgZXhwb3J0cy5WaWRlb0VkaXRvciA9IFZpZGVvRWRpdG9yO1xuICBleHBvcnRzLlZpZGVvTWFuYWdlciA9IFZpZGVvTWFuYWdlcjtcbiAgZXhwb3J0cy5jcmVhdGVCdWZmZXJPZkltYWdlRGF0YSA9IGNyZWF0ZUJ1ZmZlck9mSW1hZ2VEYXRhO1xuICBleHBvcnRzLmNyZWF0ZUltYWdlRGF0YVVybCA9IGNyZWF0ZUltYWdlRGF0YVVybDtcbiAgZXhwb3J0cy5nZW5lcmF0ZUltYWdlQnVmZmVyRnJvbUNvZGUgPSBnZW5lcmF0ZUltYWdlQnVmZmVyRnJvbUNvZGU7XG4gIGV4cG9ydHMuZ2VuZXJhdGVJbWFnZUZyb21Db2RlID0gZ2VuZXJhdGVJbWFnZUZyb21Db2RlO1xuICBleHBvcnRzLmdldEJ1ZmZlckZyb21JbWFnZURhdGEgPSBnZXRCdWZmZXJGcm9tSW1hZ2VEYXRhO1xuICBleHBvcnRzLmdldERhdGFVUkxGcm9tSW1hZ2VEYXRhID0gZ2V0RGF0YVVSTEZyb21JbWFnZURhdGE7XG4gIGV4cG9ydHMuaXNabGliQ29tcHJlc3NlZCA9IGlzWmxpYkNvbXByZXNzZWQ7XG4gIGV4cG9ydHMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/fuck-svga.js\n");

/***/ }),

/***/ "./utils/svga-2dfire.js":
/*!******************************!*\
  !*** ./utils/svga-2dfire.js ***!
  \******************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*! For license information please see svga.js.LICENSE.txt */\n// 暂不支持api has.arrayBufferToBase64 TODO// 暂不支持api has.createOffscreenCanvas TODO\n// 暂不支持api has.arrayBufferToBase64 TODO// 暂不支持api has.createOffscreenCanvas TODO\n!function (t, e) {\n   true ? module.exports = e() : 0;\n}(self, () => (() => {\n  var t = {\n      700: (t, e, r) => {\n        t.exports = function () {\n          var t = {};\n          function e() {\n            t.converter._configure(), t.decoder._configure(), t.Field._configure(), t.MapField._configure(), t.Message._configure(), t.Namespace._configure(), t.Method._configure(), t.ReflectionObject._configure(), t.OneOf._configure(), t.parse._configure(), t.Reader._configure(), t.Root._configure(), t.Service._configure(), t.verifier._configure(), t.Type._configure(), t.types._configure(), t.wrappers._configure(), t.Writer._configure();\n          }\n          if (t.build = \"minimal\", t.Writer = r(443), t.Reader = r(795), t.util = r(916), t.rpc = r(153), t.roots = r(587), t.verifier = r(122), t.tokenize = r(941), t.parse = r(121), t.common = r(453), t.ReflectionObject = r(719), t.Namespace = r(625), t.Root = r(572), t.Enum = r(421), t.Type = r(24), t.Field = r(238), t.OneOf = r(803), t.MapField = r(718), t.Service = r(673), t.Method = r(493), t.converter = r(954), t.decoder = r(910), t.Message = r(853), t.wrappers = r(432), t.types = r(471), t.util = r(916), t.configure = e, t.load = function (e, r, i) {\n            return \"function\" == typeof r ? (i = r, r = new t.Root()) : r || (r = new t.Root()), r.load(e, i);\n          }, t.loadSync = function (e, r) {\n            return r || (r = new t.Root()), r.loadSync(e);\n          }, t.parseFromPbString = function (e, r, i) {\n            return \"function\" == typeof r ? (i = r, r = new t.Root()) : r || (r = new t.Root()), r.parseFromPbString(e, i);\n          }, e(), arguments && arguments.length) for (var i = 0; i < arguments.length; i++) {\n            var n = arguments[i];\n            if (n.hasOwnProperty(\"exports\")) return void (n.exports = t);\n          }\n          return t;\n        }();\n      },\n      770: t => {\n        \"use strict\";\n\n        function e() {\n          this._listeners = {};\n        }\n        t.exports = e, e.prototype.on = function (t, e, r) {\n          return (this._listeners[t] || (this._listeners[t] = [])).push({\n            fn: e,\n            ctx: r || this\n          }), this;\n        }, e.prototype.off = function (t, e) {\n          if (void 0 === t) this._listeners = {};else if (void 0 === e) this._listeners[t] = [];else for (var r = this._listeners[t], i = 0; i < r.length;) r[i].fn === e ? r.splice(i, 1) : ++i;\n          return this;\n        }, e.prototype.emit = function (t) {\n          var e = this._listeners[t];\n          if (e) {\n            for (var r = [], i = 1; i < arguments.length;) r.push(arguments[i++]);\n            for (i = 0; i < e.length;) e[i].fn.apply(e[i++].ctx, r);\n          }\n          return this;\n        };\n      },\n      347: t => {\n        \"use strict\";\n\n        t.exports = function (t, e) {\n          for (var r = new Array(arguments.length - 1), i = 0, n = 2, s = !0; n < arguments.length;) r[i++] = arguments[n++];\n          return new Promise(function (n, o) {\n            r[i] = function (t) {\n              if (s) if (s = !1, t) o(t);else {\n                for (var e = new Array(arguments.length - 1), r = 0; r < e.length;) e[r++] = arguments[r];\n                n.apply(null, e);\n              }\n            };\n            try {\n              t.apply(e || null, r);\n            } catch (t) {\n              s && (s = !1, o(t));\n            }\n          });\n        };\n      },\n      203: t => {\n        \"use strict\";\n\n        var e = t.exports;\n        e.length = function (t) {\n          var e = t.length;\n          if (!e) return 0;\n          for (var r = 0; --e % 4 > 1 && \"=\" === t.charAt(e);) ++r;\n          return Math.ceil(3 * t.length) / 4 - r;\n        };\n        for (var r = new Array(64), i = new Array(123), n = 0; n < 64;) i[r[n] = n < 26 ? n + 65 : n < 52 ? n + 71 : n < 62 ? n - 4 : n - 59 | 43] = n++;\n        e.encode = function (t, e, i) {\n          for (var n, s = null, o = [], a = 0, h = 0; e < i;) {\n            var u = t[e++];\n            switch (h) {\n              case 0:\n                o[a++] = r[u >> 2], n = (3 & u) << 4, h = 1;\n                break;\n              case 1:\n                o[a++] = r[n | u >> 4], n = (15 & u) << 2, h = 2;\n                break;\n              case 2:\n                o[a++] = r[n | u >> 6], o[a++] = r[63 & u], h = 0;\n            }\n            a > 8191 && ((s || (s = [])).push(String.fromCharCode.apply(String, o)), a = 0);\n          }\n          return h && (o[a++] = r[n], o[a++] = 61, 1 === h && (o[a++] = 61)), s ? (a && s.push(String.fromCharCode.apply(String, o.slice(0, a))), s.join(\"\")) : String.fromCharCode.apply(String, o.slice(0, a));\n        };\n        var s = \"invalid encoding\";\n        e.decode = function (t, e, r) {\n          for (var n, o = r, a = 0, h = 0; h < t.length;) {\n            var u = t.charCodeAt(h++);\n            if (61 === u && a > 1) break;\n            if (void 0 === (u = i[u])) throw Error(s);\n            switch (a) {\n              case 0:\n                n = u, a = 1;\n                break;\n              case 1:\n                e[r++] = n << 2 | (48 & u) >> 4, n = u, a = 2;\n                break;\n              case 2:\n                e[r++] = (15 & n) << 4 | (60 & u) >> 2, n = u, a = 3;\n                break;\n              case 3:\n                e[r++] = (3 & n) << 6 | u, a = 0;\n            }\n          }\n          if (1 === a) throw Error(s);\n          return r - o;\n        }, e.test = function (t) {\n          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t);\n        };\n      },\n      453: t => {\n        t.exports = i;\n        var e,\n          r = /\\/|\\./;\n        function i(t, e) {\n          r.test(t) || (t = \"google/protobuf/\" + t + \".proto\", e = {\n            nested: {\n              google: {\n                nested: {\n                  protobuf: {\n                    nested: e\n                  }\n                }\n              }\n            }\n          }), i[t] = e;\n        }\n        i(\"any\", {\n          Any: {\n            fields: {\n              type_url: {\n                type: \"string\",\n                id: 1\n              },\n              value: {\n                type: \"bytes\",\n                id: 2\n              }\n            }\n          }\n        }), i(\"duration\", {\n          Duration: e = {\n            fields: {\n              seconds: {\n                type: \"int64\",\n                id: 1\n              },\n              nanos: {\n                type: \"int32\",\n                id: 2\n              }\n            }\n          }\n        }), i(\"timestamp\", {\n          Timestamp: e\n        }), i(\"empty\", {\n          Empty: {\n            fields: {}\n          }\n        }), i(\"struct\", {\n          Struct: {\n            fields: {\n              fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n              }\n            }\n          },\n          Value: {\n            oneofs: {\n              kind: {\n                oneof: [\"nullValue\", \"numberValue\", \"stringValue\", \"boolValue\", \"structValue\", \"listValue\"]\n              }\n            },\n            fields: {\n              nullValue: {\n                type: \"NullValue\",\n                id: 1\n              },\n              numberValue: {\n                type: \"double\",\n                id: 2\n              },\n              stringValue: {\n                type: \"string\",\n                id: 3\n              },\n              boolValue: {\n                type: \"bool\",\n                id: 4\n              },\n              structValue: {\n                type: \"Struct\",\n                id: 5\n              },\n              listValue: {\n                type: \"ListValue\",\n                id: 6\n              }\n            }\n          },\n          NullValue: {\n            values: {\n              NULL_VALUE: 0\n            }\n          },\n          ListValue: {\n            fields: {\n              values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n              }\n            }\n          }\n        }), i(\"wrappers\", {\n          DoubleValue: {\n            fields: {\n              value: {\n                type: \"double\",\n                id: 1\n              }\n            }\n          },\n          FloatValue: {\n            fields: {\n              value: {\n                type: \"float\",\n                id: 1\n              }\n            }\n          },\n          Int64Value: {\n            fields: {\n              value: {\n                type: \"int64\",\n                id: 1\n              }\n            }\n          },\n          UInt64Value: {\n            fields: {\n              value: {\n                type: \"uint64\",\n                id: 1\n              }\n            }\n          },\n          Int32Value: {\n            fields: {\n              value: {\n                type: \"int32\",\n                id: 1\n              }\n            }\n          },\n          UInt32Value: {\n            fields: {\n              value: {\n                type: \"uint32\",\n                id: 1\n              }\n            }\n          },\n          BoolValue: {\n            fields: {\n              value: {\n                type: \"bool\",\n                id: 1\n              }\n            }\n          },\n          StringValue: {\n            fields: {\n              value: {\n                type: \"string\",\n                id: 1\n              }\n            }\n          },\n          BytesValue: {\n            fields: {\n              value: {\n                type: \"bytes\",\n                id: 1\n              }\n            }\n          }\n        }), i(\"field_mask\", {\n          FieldMask: {\n            fields: {\n              paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n              }\n            }\n          }\n        }), i.get = function (t) {\n          return i[t] || null;\n        };\n      },\n      954: (t, e, r) => {\n        var i,\n          n,\n          s = r(535).default,\n          o = t.exports;\n        function a(t, e, r, o) {\n          var a = o.m,\n            h = o.d,\n            u = o.types,\n            l = o.ksi,\n            f = void 0 !== l;\n          if (t.resolvedType) {\n            if (t.resolvedType instanceof i) {\n              for (var c = f ? h[r][l] : h[r], d = t.resolvedType.values, p = Object.keys(d), y = 0; y < p.length; y++) if (!(t.repeated && d[p[y]] === t.typeDefault || p[y] != c && d[p[y]] != c)) {\n                f ? a[r][l] = d[p[y]] : a[r] = d[p[y]];\n                break;\n              }\n            } else {\n              if (\"object\" !== s(f ? h[r][l] : h[r])) throw TypeError(t.fullName + \": object expected\");\n              f ? a[r][l] = u[e].fromObject(h[r][l]) : a[r] = u[e].fromObject(h[r]);\n            }\n          } else {\n            var v = !1;\n            switch (t.type) {\n              case \"double\":\n              case \"float\":\n                f ? a[r][l] = Number(h[r][l]) : a[r] = Number(h[r]);\n                break;\n              case \"uint32\":\n              case \"fixed32\":\n                f ? a[r][l] = h[r][l] >>> 0 : a[r] = h[r] >>> 0;\n                break;\n              case \"int32\":\n              case \"sint32\":\n              case \"sfixed32\":\n                f ? a[r][l] = 0 | h[r][l] : a[r] = 0 | h[r];\n                break;\n              case \"uint64\":\n                v = !0;\n              case \"int64\":\n              case \"sint64\":\n              case \"fixed64\":\n              case \"sfixed64\":\n                n.Long ? f ? a[r][l] = n.Long.fromValue(h[r][l]).unsigned = v : a[r] = n.Long.fromValue(h[r]).unsigned = v : \"string\" == typeof (f ? h[r][l] : h[r]) ? f ? a[r][l] = parseInt(h[r][l], 10) : a[r] = parseInt(h[r], 10) : \"number\" == typeof (f ? h[r][l] : h[r]) ? f ? a[r][l] = h[r][l] : a[r] = h[r] : \"object\" === s(f ? h[r][l] : h[r]) && (f ? a[r][l] = new n.LongBits(h[r][l].low >>> 0, h[r][l].high >>> 0).toNumber(v) : a[r] = new n.LongBits(h[r].low >>> 0, h[r].high >>> 0).toNumber(v));\n                break;\n              case \"bytes\":\n                \"string\" == typeof (f ? h[r][l] : h[r]) ? f ? n.base64.decode(h[r][l], a[r][l] = n.newBuffer(n.base64.length(h[r][l])), 0) : n.base64.decode(h[r], a[r] = n.newBuffer(n.base64.length(h[r])), 0) : (f ? h[r][l] : h[r]).length && (f ? a[r][l] = h[r][l] : a[r] = h[r]);\n                break;\n              case \"string\":\n                f ? a[r][l] = String(h[r][l]) : a[r] = String(h[r]);\n                break;\n              case \"bool\":\n                f ? a[r][l] = Boolean(h[r][l]) : a[r] = Boolean(h[r]);\n            }\n          }\n        }\n        function h(t, e, r, s) {\n          var o = s.m,\n            a = s.d,\n            h = s.types,\n            u = s.ksi,\n            l = s.o,\n            f = void 0 !== u;\n          if (t.resolvedType) t.resolvedType instanceof i ? f ? a[r][u] = l.enums === String ? h[e].values[o[r][u]] : o[r][u] : a[r] = l.enums === String ? h[e].values[o[r]] : o[r] : f ? a[r][u] = h[e].toObject(o[r][u], l) : a[r] = h[e].toObject(o[r], l);else {\n            var c = !1;\n            switch (t.type) {\n              case \"double\":\n              case \"float\":\n                f ? a[r][u] = l.json && !isFinite(o[r][u]) ? String(o[r][u]) : o[r][u] : a[r] = l.json && !isFinite(o[r]) ? String(o[r]) : o[r];\n                break;\n              case \"uint64\":\n                c = !0;\n              case \"int64\":\n              case \"sint64\":\n              case \"fixed64\":\n              case \"sfixed64\":\n                \"number\" == typeof o[r][u] ? f ? a[r][u] = l.longs === String ? String(o[r][u]) : o[r][u] : a[r] = l.longs === String ? String(o[r]) : o[r] : f ? a[r][u] = l.longs === String ? n.Long.prototype.toString.call(o[r][u]) : l.longs === Number ? new n.LongBits(o[r][u].low >>> 0, o[r][u].high >>> 0).toNumber(c) : o[r][u] : a[r] = l.longs === String ? n.Long.prototype.toString.call(o[r]) : l.longs === Number ? new n.LongBits(o[r].low >>> 0, o[r].high >>> 0).toNumber(c) : o[r];\n                break;\n              case \"bytes\":\n                f ? a[r][u] = l.bytes === String ? n.base64.encode(o[r][u], 0, o[r][u].length) : l.bytes === Array ? Array.prototype.slice.call(o[r][u]) : o[r][u] : a[r] = l.bytes === String ? n.base64.encode(o[r], 0, o[r].length) : l.bytes === Array ? Array.prototype.slice.call(o[r]) : o[r];\n                break;\n              default:\n                f ? a[r][u] = o[r][u] : a[r] = o[r];\n            }\n          }\n        }\n        o._configure = function () {\n          i = r(421), n = r(916);\n        }, o.fromObject = function (t) {\n          var e = t.fieldsArray;\n          return function (t) {\n            return function (r) {\n              if (r instanceof this.ctor) return r;\n              if (!e.length) return new this.ctor();\n              for (var o = new this.ctor(), h = 0; h < e.length; ++h) {\n                var u,\n                  l = e[h].resolve(),\n                  f = l.name;\n                if (l.map) {\n                  if (r[f]) {\n                    if (\"object\" !== s(r[f])) throw TypeError(l.fullName + \": object expected\");\n                    o[f] = {};\n                  }\n                  var c = Object.keys(r[f]);\n                  for (u = 0; u < c.length; ++u) a(l, h, f, n.merge(n.copy(t), {\n                    m: o,\n                    d: r,\n                    ksi: c[u]\n                  }));\n                } else if (l.repeated) {\n                  if (r[f]) {\n                    if (!Array.isArray(r[f])) throw TypeError(l.fullName + \": array expected\");\n                    for (o[f] = [], u = 0; u < r[f].length; ++u) a(l, h, f, n.merge(n.copy(t), {\n                      m: o,\n                      d: r,\n                      ksi: u\n                    }));\n                  }\n                } else (l.resolvedType instanceof i || null != r[f]) && a(l, h, f, n.merge(n.copy(t), {\n                  m: o,\n                  d: r\n                }));\n              }\n              return o;\n            };\n          };\n        }, o.toObject = function (t) {\n          var e = t.fieldsArray.slice().sort(n.compareFieldsById);\n          return function (r) {\n            return e.length ? function (s, o) {\n              o = o || {};\n              for (var a, u, l = {}, f = [], c = [], d = [], p = 0; p < e.length; ++p) e[p].partOf || (e[p].resolve().repeated ? f : e[p].map ? c : d).push(e[p]);\n              if (f.length && (o.arrays || o.defaults)) for (p = 0; p < f.length; ++p) l[f[p].name] = [];\n              if (c.length && (o.objects || o.defaults)) for (p = 0; p < c.length; ++p) l[c[p].name] = {};\n              if (d.length && o.defaults) for (p = 0; p < d.length; ++p) if (u = (a = d[p]).name, a.resolvedType instanceof i) l[u] = o.enums = String ? a.resolvedType.valuesById[a.typeDefault] : a.typeDefault;else if (a.long) {\n                if (n.Long) {\n                  var y = new n.Long(a.typeDefault.low, a.typeDefault.high, a.typeDefault.unsigned);\n                  l[u] = o.longs === String ? y.toString() : o.longs === Number ? y.toNumber() : y;\n                } else l[u] = o.longs === String ? a.typeDefault.toString() : a.typeDefault.toNumber();\n              } else a.bytes ? l[u] = o.bytes === String ? String.fromCharCode.apply(String, a.typeDefault) : Array.prototype.slice.call(a.typeDefault).join(\"*..*\").split(\"*..*\") : l[u] = a.typeDefault;\n              var v = !1;\n              for (p = 0; p < e.length; ++p) {\n                u = (a = e[p]).name;\n                var g,\n                  m,\n                  _ = t._fieldsArray.indexOf(a);\n                if (a.map) {\n                  if (v || (v = !0), s[u] && (g = Object.keys(s[u]).length)) for (l[u] = {}, m = 0; m < g.length; ++m) h(a, _, u, n.merge(n.copy(r), {\n                    m: s,\n                    d: l,\n                    ksi: g[m],\n                    o\n                  }));\n                } else if (a.repeated) {\n                  if (s[u] && s[u].length) for (l[u] = [], m = 0; m < s[u].length; ++m) h(a, _, u, n.merge(n.copy(r), {\n                    m: s,\n                    d: l,\n                    ksi: m,\n                    o\n                  }));\n                } else null != s[u] && s.hasOwnProperty(u) && h(a, _, u, n.merge(n.copy(r), {\n                  m: s,\n                  d: l,\n                  o\n                })), a.partOf && o.oneofs && (l[a.partOf.name] = u);\n              }\n              return l;\n            } : function () {\n              return {};\n            };\n          };\n        };\n      },\n      910: (t, e, r) => {\n        var i,\n          n,\n          s,\n          o = r(535).default;\n        function a(t) {\n          return \"missing required '\" + t.name + \"'\";\n        }\n        function h(t) {\n          return function (e) {\n            var r = e.Reader,\n              h = e.types,\n              u = e.util;\n            return function (e, l) {\n              e instanceof r || (e = r.create(e));\n              for (var f, c = void 0 === l ? e.len : e.pos + l, d = new this.ctor(); e.pos < c;) {\n                var p = e.uint32();\n                if (t.group && 4 == (7 & p)) break;\n                for (var y = p >>> 3, v = 0, g = !1; v < t.fieldsArray.length; ++v) {\n                  var m = t._fieldsArray[v].resolve(),\n                    _ = m.name,\n                    w = m.resolvedType instanceof i ? \"int32\" : m.type;\n                  if (y == m.id) {\n                    if (g = !0, m.map) e.skip().pos++, d[_] === u.emptyObject && (d[_] = {}), f = e[m.keyType](), e.pos++, n.long[m.keyType], null == n.basic[w] ? d[_][\"object\" === o(f) ? u.longToHash(f) : f] = h[v].decode(e, e.uint32()) : d[_][\"object\" === o(f) ? u.longToHash(f) : f] = e[w]();else if (m.repeated) {\n                      if (d[_] && d[_].length || (d[_] = []), null != n.packed[w] && 2 == (7 & p)) for (var b = e.uint32() + e.pos; e.pos < b;) d[_].push(e[w]());else null == n.basic[w] ? m.resolvedType.group ? d[_].push(h[v].decode(e)) : d[_].push(h[v].decode(e, e.uint32())) : d[_].push(e[w]());\n                    } else null == n.basic[w] ? m.resolvedType.group ? d[_] = h[v].decode(e) : d[_] = h[v].decode(e, e.uint32()) : d[_] = e[w]();\n                    break;\n                  }\n                }\n                g || (console.log(\"t\", p), e.skipType(7 & p));\n              }\n              for (v = 0; v < t._fieldsArray.length; ++v) {\n                var x = t._fieldsArray[v];\n                if (x.required && !d.hasOwnProperty(x.name)) throw s.ProtocolError(a(x), {\n                  instance: d\n                });\n              }\n              return d;\n            };\n          };\n        }\n        t.exports = h, h._configure = function () {\n          i = r(421), n = r(471), s = r(916);\n        };\n      },\n      421: (t, e, r) => {\n        var i = r(535).default;\n        t.exports = o;\n        var n = r(719);\n        ((o.prototype = Object.create(n.prototype)).constructor = o).className = \"Enum\";\n        var s = r(625);\n        function o(t, e, r, s, o) {\n          if (n.call(this, t, r), e && \"object\" !== i(e)) throw TypeError(\"values must be an object\");\n          if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = s, this.comments = o || {}, this.reserved = void 0, e) for (var a = Object.keys(e), h = 0; h < a.length; ++h) \"number\" == typeof e[a[h]] && (this.valuesById[this.values[a[h]] = e[a[h]]] = a[h]);\n        }\n        o.fromJSON = function (t, e) {\n          var r = new o(t, e.values, e.options, e.comment, e.comments);\n          return r.reserved = e.reserved, r;\n        }, o.prototype.toJSON = function (t) {\n          var e = !!t && Boolean(t.keepComments);\n          return util.toObject([\"options\", this.options, \"values\", this.values, \"reserved\", this.reserved && this.reserved.length ? this.reserved : void 0, \"comment\", e ? this.comment : void 0, \"comments\", e ? this.comments : void 0]);\n        }, o.prototype.add = function (t, e, r) {\n          if (!util.isString(t)) throw TypeError(\"name must be a string\");\n          if (!util.isInteger(e)) throw TypeError(\"id must be an integer\");\n          if (void 0 !== this.values[t]) throw Error(\"duplicate name '\" + t + \"' in \" + this);\n          if (this.isReservedId(e)) throw Error(\"id \" + e + \" is reserved in \" + this);\n          if (this.isReservedName(t)) throw Error(\"name '\" + t + \"' is reserved in \" + this);\n          if (void 0 !== this.valuesById[e]) {\n            if (!this.options || !this.options.allow_alias) throw Error(\"duplicate id \" + e + \" in \" + this);\n            this.values[t] = e;\n          } else this.valuesById[this.values[t] = e] = t;\n          return this.comments[t] = r || null, this;\n        }, o.prototype.remove = function (t) {\n          if (!util.isString(t)) throw TypeError(\"name must be a string\");\n          var e = this.values[t];\n          if (null == e) throw Error(\"name '\" + t + \"' does not exist in \" + this);\n          return delete this.valuesById[e], delete this.values[t], delete this.comments[t], this;\n        }, o.prototype.isReservedId = function (t) {\n          return s.isReservedId(this.reserved, t);\n        }, o.prototype.isReservedName = function (t) {\n          return s.isReservedName(this.reserved, t);\n        };\n      },\n      238: (t, e, r) => {\n        var i = r(535).default;\n        t.exports = l;\n        var n,\n          s,\n          o,\n          a,\n          h = r(719);\n        ((l.prototype = Object.create(h.prototype)).constructor = l).className = \"Field\";\n        var u = /^required|optional|repeated$/;\n        function l(t, e, r, i, n, a, l) {\n          if (o.isObject(i) ? (l = n, a = i, i = n = void 0) : o.isObject(n) && (l = a, a = n, n = void 0), h.call(this, t, a), !o.isInteger(e) || e < 0) throw TypeError(\"id must be a non-negative integer\");\n          if (!o.isString(r)) throw TypeError(\"type must be a string\");\n          if (void 0 !== i && !u.test(i = i.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");\n          if (void 0 !== n && !o.isString(n)) throw TypeError(\"extend must be a string\");\n          this.rule = i && \"optional\" !== i ? i : void 0, this.type = r, this.id = e, this.extend = n || void 0, this.required = \"required\" === i, this.optional = !this.required, this.repeated = \"repeated\" === i, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!o.Long && void 0 !== s.long[r], this.bytes = \"bytes\" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;\n        }\n        l.fromJSON = function (t, e) {\n          return new l(t, e.id, e.type, e.rule, e.extend, e.options, e.comment);\n        }, Object.defineProperty(l.prototype, \"packed\", {\n          get: function () {\n            return null === this._packed && (this._packed = !1 !== this.getOption(\"packed\")), this._packed;\n          }\n        }), l.prototype.setOption = function (t, e, r) {\n          return \"packed\" === t && (this._packed = null), h.prototype.setOption.call(this, t, e, r);\n        }, l.prototype.toJSON = function (t) {\n          var e = !!t && Boolean(t.keepComments);\n          return o.toObject([\"rule\", \"optional\" !== this.rule && this.rule || void 0, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", e ? this.comment : void 0]);\n        }, l.prototype.resolve = function () {\n          if (this.resolved) return this;\n          if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof a ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof n && \"string\" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof n) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = o.Long.fromNumber(this.typeDefault, \"u\" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && \"string\" == typeof this.typeDefault) {\n            var t;\n            o.utf8.write(this.typeDefault, t = o.newBuffer(o.utf8.length(this.typeDefault)), 0), this.typeDefault = t;\n          }\n          return this.map ? this.defaultValue = o.emptyObject : this.repeated ? this.defaultValue = o.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof a && (this.parent.ctor.prototype[this.name] = this.defaultValue), h.prototype.resolve.call(this);\n        }, l.d = function (t, e, r, n) {\n          return \"function\" == typeof e ? e = o.decorateType(e).name : e && \"object\" === i(e) && (e = o.decorateEnum(e).name), function (i, s) {\n            o.decorateType(i.constructor).add(new l(s, t, e, r, {\n              default: n\n            }));\n          };\n        }, l._configure = function () {\n          a = r(24), n = r(421), s = r(471), o = r(916);\n        };\n      },\n      620: t => {\n        function e(t) {\n          return \"undefined\" != typeof Float32Array ? function () {\n            var e = new Float32Array([-0]),\n              r = new Uint8Array(e.buffer),\n              i = 128 === r[3];\n            function n(t, i, n) {\n              e[0] = t, i[n] = r[0], i[n + 1] = r[1], i[n + 2] = r[2], i[n + 3] = r[3];\n            }\n            function s(t, i, n) {\n              e[0] = t, i[n] = r[3], i[n + 1] = r[2], i[n + 2] = r[1], i[n + 3] = r[0];\n            }\n            function o(t, i) {\n              return r[0] = t[i], r[1] = t[i + 1], r[2] = t[i + 2], r[3] = t[i + 3], e[0];\n            }\n            function a(t, i) {\n              return r[3] = t[i], r[2] = t[i + 1], r[1] = t[i + 2], r[0] = t[i + 3], e[0];\n            }\n            t.writeFloatLE = i ? n : s, t.writeFloatBE = i ? s : n, t.readFloatLE = i ? o : a, t.readFloatBE = i ? a : o;\n          }() : function () {\n            function e(t, e, r, i) {\n              var n = e < 0 ? 1 : 0;\n              if (n && (e = -e), 0 === e) t(1 / e > 0 ? 0 : 2147483648, r, i);else if (isNaN(e)) t(2143289344, r, i);else if (e > 34028234663852886e22) t((n << 31 | 2139095040) >>> 0, r, i);else if (e < 11754943508222875e-54) t((n << 31 | Math.round(e / 1401298464324817e-60)) >>> 0, r, i);else {\n                var s = Math.floor(Math.log(e) / Math.LN2);\n                t((n << 31 | s + 127 << 23 | 8388607 & Math.round(e * Math.pow(2, -s) * 8388608)) >>> 0, r, i);\n              }\n            }\n            function o(t, e, r) {\n              var i = t(e, r),\n                n = 2 * (i >> 31) + 1,\n                s = i >>> 23 & 255,\n                o = 8388607 & i;\n              return 255 === s ? o ? NaN : n * (1 / 0) : 0 === s ? 1401298464324817e-60 * n * o : n * Math.pow(2, s - 150) * (o + 8388608);\n            }\n            t.writeFloatLE = e.bind(null, r), t.writeFloatBE = e.bind(null, i), t.readFloatLE = o.bind(null, n), t.readFloatBE = o.bind(null, s);\n          }(), \"undefined\" != typeof Float64Array ? function () {\n            var e = new Float64Array([-0]),\n              r = new Uint8Array(e.buffer),\n              i = 128 === r[7];\n            function n(t, i, n) {\n              e[0] = t, i[n] = r[0], i[n + 1] = r[1], i[n + 2] = r[2], i[n + 3] = r[3], i[n + 4] = r[4], i[n + 5] = r[5], i[n + 6] = r[6], i[n + 7] = r[7];\n            }\n            function s(t, i, n) {\n              e[0] = t, i[n] = r[7], i[n + 1] = r[6], i[n + 2] = r[5], i[n + 3] = r[4], i[n + 4] = r[3], i[n + 5] = r[2], i[n + 6] = r[1], i[n + 7] = r[0];\n            }\n            function o(t, i) {\n              return r[0] = t[i], r[1] = t[i + 1], r[2] = t[i + 2], r[3] = t[i + 3], r[4] = t[i + 4], r[5] = t[i + 5], r[6] = t[i + 6], r[7] = t[i + 7], e[0];\n            }\n            function a(t, i) {\n              return r[7] = t[i], r[6] = t[i + 1], r[5] = t[i + 2], r[4] = t[i + 3], r[3] = t[i + 4], r[2] = t[i + 5], r[1] = t[i + 6], r[0] = t[i + 7], e[0];\n            }\n            t.writeDoubleLE = i ? n : s, t.writeDoubleBE = i ? s : n, t.readDoubleLE = i ? o : a, t.readDoubleBE = i ? a : o;\n          }() : function () {\n            function e(t, e, r, i, n, s) {\n              var o = i < 0 ? 1 : 0;\n              if (o && (i = -i), 0 === i) t(0, n, s + e), t(1 / i > 0 ? 0 : 2147483648, n, s + r);else if (isNaN(i)) t(0, n, s + e), t(2146959360, n, s + r);else if (i > 17976931348623157e292) t(0, n, s + e), t((o << 31 | 2146435072) >>> 0, n, s + r);else {\n                var a;\n                if (i < 22250738585072014e-324) t((a = i / 5e-324) >>> 0, n, s + e), t((o << 31 | a / 4294967296) >>> 0, n, s + r);else {\n                  var h = Math.floor(Math.log(i) / Math.LN2);\n                  1024 === h && (h = 1023), t(4503599627370496 * (a = i * Math.pow(2, -h)) >>> 0, n, s + e), t((o << 31 | h + 1023 << 20 | 1048576 * a & 1048575) >>> 0, n, s + r);\n                }\n              }\n            }\n            function o(t, e, r, i, n) {\n              var s = t(i, n + e),\n                o = t(i, n + r),\n                a = 2 * (o >> 31) + 1,\n                h = o >>> 20 & 2047,\n                u = 4294967296 * (1048575 & o) + s;\n              return 2047 === h ? u ? NaN : a * (1 / 0) : 0 === h ? 5e-324 * a * u : a * Math.pow(2, h - 1075) * (u + 4503599627370496);\n            }\n            t.writeDoubleLE = e.bind(null, r, 0, 4), t.writeDoubleBE = e.bind(null, i, 4, 0), t.readDoubleLE = o.bind(null, n, 0, 4), t.readDoubleBE = o.bind(null, s, 4, 0);\n          }(), t;\n        }\n        function r(t, e, r) {\n          e[r] = 255 & t, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;\n        }\n        function i(t, e, r) {\n          e[r] = t >>> 24, e[r + 1] = t >>> 16 & 255, e[r + 2] = t >>> 8 & 255, e[r + 3] = 255 & t;\n        }\n        function n(t, e) {\n          return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;\n        }\n        function s(t, e) {\n          return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;\n        }\n        t.exports = e(e);\n      },\n      470: t => {\n        t.exports = r;\n        var e = null;\n        try {\n          e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n        } catch (t) {}\n        function r(t, e, r) {\n          this.low = 0 | t, this.high = 0 | e, this.unsigned = !!r;\n        }\n        function i(t) {\n          return !0 === (t && t.__isLong__);\n        }\n        r.prototype.__isLong__, Object.defineProperty(r.prototype, \"__isLong__\", {\n          value: !0\n        }), r.isLong = i;\n        var n = {},\n          s = {};\n        function o(t, e) {\n          var r, i, o;\n          return e ? (o = 0 <= (t >>>= 0) && t < 256) && (i = s[t]) ? i : (r = h(t, (0 | t) < 0 ? -1 : 0, !0), o && (s[t] = r), r) : (o = -128 <= (t |= 0) && t < 128) && (i = n[t]) ? i : (r = h(t, t < 0 ? -1 : 0, !1), o && (n[t] = r), r);\n        }\n        function a(t, e) {\n          if (isNaN(t)) return e ? g : v;\n          if (e) {\n            if (t < 0) return g;\n            if (t >= d) return x;\n          } else {\n            if (t <= -p) return k;\n            if (t + 1 >= p) return b;\n          }\n          return t < 0 ? a(-t, e).neg() : h(t % c | 0, t / c | 0, e);\n        }\n        function h(t, e, i) {\n          return new r(t, e, i);\n        }\n        r.fromInt = o, r.fromNumber = a, r.fromBits = h;\n        var u = Math.pow;\n        function l(t, e, r) {\n          if (0 === t.length) throw Error(\"empty string\");\n          if (\"NaN\" === t || \"Infinity\" === t || \"+Infinity\" === t || \"-Infinity\" === t) return v;\n          if (\"number\" == typeof e ? (r = e, e = !1) : e = !!e, (r = r || 10) < 2 || 36 < r) throw RangeError(\"radix\");\n          var i;\n          if ((i = t.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n          if (0 === i) return l(t.substring(1), e, r).neg();\n          for (var n = a(u(r, 8)), s = v, o = 0; o < t.length; o += 8) {\n            var h = Math.min(8, t.length - o),\n              f = parseInt(t.substring(o, o + h), r);\n            if (h < 8) {\n              var c = a(u(r, h));\n              s = s.mul(c).add(a(f));\n            } else s = (s = s.mul(n)).add(a(f));\n          }\n          return s.unsigned = e, s;\n        }\n        function f(t, e) {\n          return \"number\" == typeof t ? a(t, e) : \"string\" == typeof t ? l(t, e) : h(t.low, t.high, \"boolean\" == typeof e ? e : t.unsigned);\n        }\n        r.fromString = l, r.fromValue = f;\n        var c = 4294967296,\n          d = c * c,\n          p = d / 2,\n          y = o(1 << 24),\n          v = o(0);\n        r.ZERO = v;\n        var g = o(0, !0);\n        r.UZERO = g;\n        var m = o(1);\n        r.ONE = m;\n        var _ = o(1, !0);\n        r.UONE = _;\n        var w = o(-1);\n        r.NEG_ONE = w;\n        var b = h(-1, 2147483647, !1);\n        r.MAX_VALUE = b;\n        var x = h(-1, -1, !0);\n        r.MAX_UNSIGNED_VALUE = x;\n        var k = h(0, -2147483648, !1);\n        r.MIN_VALUE = k;\n        var A = r.prototype;\n        A.toInt = function () {\n          return this.unsigned ? this.low >>> 0 : this.low;\n        }, A.toNumber = function () {\n          return this.unsigned ? (this.high >>> 0) * c + (this.low >>> 0) : this.high * c + (this.low >>> 0);\n        }, A.toString = function (t) {\n          if ((t = t || 10) < 2 || 36 < t) throw RangeError(\"radix\");\n          if (this.isZero()) return \"0\";\n          if (this.isNegative()) {\n            if (this.eq(k)) {\n              var e = a(t),\n                r = this.div(e),\n                i = r.mul(e).sub(this);\n              return r.toString(t) + i.toInt().toString(t);\n            }\n            return \"-\" + this.neg().toString(t);\n          }\n          for (var n = a(u(t, 6), this.unsigned), s = this, o = \"\";;) {\n            var h = s.div(n),\n              l = (s.sub(h.mul(n)).toInt() >>> 0).toString(t);\n            if ((s = h).isZero()) return l + o;\n            for (; l.length < 6;) l = \"0\" + l;\n            o = \"\" + l + o;\n          }\n        }, A.getHighBits = function () {\n          return this.high;\n        }, A.getHighBitsUnsigned = function () {\n          return this.high >>> 0;\n        }, A.getLowBits = function () {\n          return this.low;\n        }, A.getLowBitsUnsigned = function () {\n          return this.low >>> 0;\n        }, A.getNumBitsAbs = function () {\n          if (this.isNegative()) return this.eq(k) ? 64 : this.neg().getNumBitsAbs();\n          for (var t = 0 != this.high ? this.high : this.low, e = 31; e > 0 && !(t & 1 << e); e--);\n          return 0 != this.high ? e + 33 : e + 1;\n        }, A.isZero = function () {\n          return 0 === this.high && 0 === this.low;\n        }, A.eqz = A.isZero, A.isNegative = function () {\n          return !this.unsigned && this.high < 0;\n        }, A.isPositive = function () {\n          return this.unsigned || this.high >= 0;\n        }, A.isOdd = function () {\n          return !(1 & ~this.low);\n        }, A.isEven = function () {\n          return !(1 & this.low);\n        }, A.equals = function (t) {\n          return i(t) || (t = f(t)), (this.unsigned === t.unsigned || this.high >>> 31 != 1 || t.high >>> 31 != 1) && this.high === t.high && this.low === t.low;\n        }, A.eq = A.equals, A.notEquals = function (t) {\n          return !this.eq(t);\n        }, A.neq = A.notEquals, A.ne = A.notEquals, A.lessThan = function (t) {\n          return this.comp(t) < 0;\n        }, A.lt = A.lessThan, A.lessThanOrEqual = function (t) {\n          return this.comp(t) <= 0;\n        }, A.lte = A.lessThanOrEqual, A.le = A.lessThanOrEqual, A.greaterThan = function (t) {\n          return this.comp(t) > 0;\n        }, A.gt = A.greaterThan, A.greaterThanOrEqual = function (t) {\n          return this.comp(t) >= 0;\n        }, A.gte = A.greaterThanOrEqual, A.ge = A.greaterThanOrEqual, A.compare = function (t) {\n          if (i(t) || (t = f(t)), this.eq(t)) return 0;\n          var e = this.isNegative(),\n            r = t.isNegative();\n          return e && !r ? -1 : !e && r ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n        }, A.comp = A.compare, A.negate = function () {\n          return !this.unsigned && this.eq(k) ? k : this.not().add(m);\n        }, A.neg = A.negate, A.add = function (t) {\n          i(t) || (t = f(t));\n          var e = this.high >>> 16,\n            r = 65535 & this.high,\n            n = this.low >>> 16,\n            s = 65535 & this.low,\n            o = t.high >>> 16,\n            a = 65535 & t.high,\n            u = t.low >>> 16,\n            l = 0,\n            c = 0,\n            d = 0,\n            p = 0;\n          return d += (p += s + (65535 & t.low)) >>> 16, c += (d += n + u) >>> 16, l += (c += r + a) >>> 16, l += e + o, h((d &= 65535) << 16 | (p &= 65535), (l &= 65535) << 16 | (c &= 65535), this.unsigned);\n        }, A.subtract = function (t) {\n          return i(t) || (t = f(t)), this.add(t.neg());\n        }, A.sub = A.subtract, A.multiply = function (t) {\n          if (this.isZero()) return v;\n          if (i(t) || (t = f(t)), e) return h(e.mul(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned);\n          if (t.isZero()) return v;\n          if (this.eq(k)) return t.isOdd() ? k : v;\n          if (t.eq(k)) return this.isOdd() ? k : v;\n          if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n          if (t.isNegative()) return this.mul(t.neg()).neg();\n          if (this.lt(y) && t.lt(y)) return a(this.toNumber() * t.toNumber(), this.unsigned);\n          var r = this.high >>> 16,\n            n = 65535 & this.high,\n            s = this.low >>> 16,\n            o = 65535 & this.low,\n            u = t.high >>> 16,\n            l = 65535 & t.high,\n            c = t.low >>> 16,\n            d = 65535 & t.low,\n            p = 0,\n            g = 0,\n            m = 0,\n            _ = 0;\n          return m += (_ += o * d) >>> 16, g += (m += s * d) >>> 16, m &= 65535, g += (m += o * c) >>> 16, p += (g += n * d) >>> 16, g &= 65535, p += (g += s * c) >>> 16, g &= 65535, p += (g += o * l) >>> 16, p += r * d + n * c + s * l + o * u, h((m &= 65535) << 16 | (_ &= 65535), (p &= 65535) << 16 | (g &= 65535), this.unsigned);\n        }, A.mul = A.multiply, A.divide = function (t) {\n          if (i(t) || (t = f(t)), t.isZero()) throw Error(\"division by zero\");\n          var r, n, s;\n          if (e) return this.unsigned || -2147483648 !== this.high || -1 !== t.low || -1 !== t.high ? h((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this;\n          if (this.isZero()) return this.unsigned ? g : v;\n          if (this.unsigned) {\n            if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return g;\n            if (t.gt(this.shru(1))) return _;\n            s = g;\n          } else {\n            if (this.eq(k)) return t.eq(m) || t.eq(w) ? k : t.eq(k) ? m : (r = this.shr(1).div(t).shl(1)).eq(v) ? t.isNegative() ? m : w : (n = this.sub(t.mul(r)), s = r.add(n.div(t)));\n            if (t.eq(k)) return this.unsigned ? g : v;\n            if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n            if (t.isNegative()) return this.div(t.neg()).neg();\n            s = v;\n          }\n          for (n = this; n.gte(t);) {\n            r = Math.max(1, Math.floor(n.toNumber() / t.toNumber()));\n            for (var o = Math.ceil(Math.log(r) / Math.LN2), l = o <= 48 ? 1 : u(2, o - 48), c = a(r), d = c.mul(t); d.isNegative() || d.gt(n);) d = (c = a(r -= l, this.unsigned)).mul(t);\n            c.isZero() && (c = m), s = s.add(c), n = n.sub(d);\n          }\n          return s;\n        }, A.div = A.divide, A.modulo = function (t) {\n          return i(t) || (t = f(t)), e ? h((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this.sub(this.div(t).mul(t));\n        }, A.mod = A.modulo, A.rem = A.modulo, A.not = function () {\n          return h(~this.low, ~this.high, this.unsigned);\n        }, A.and = function (t) {\n          return i(t) || (t = f(t)), h(this.low & t.low, this.high & t.high, this.unsigned);\n        }, A.or = function (t) {\n          return i(t) || (t = f(t)), h(this.low | t.low, this.high | t.high, this.unsigned);\n        }, A.xor = function (t) {\n          return i(t) || (t = f(t)), h(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n        }, A.shiftLeft = function (t) {\n          return i(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? h(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : h(0, this.low << t - 32, this.unsigned);\n        }, A.shl = A.shiftLeft, A.shiftRight = function (t) {\n          return i(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? h(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : h(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n        }, A.shr = A.shiftRight, A.shiftRightUnsigned = function (t) {\n          if (i(t) && (t = t.toInt()), 0 == (t &= 63)) return this;\n          var e = this.high;\n          return t < 32 ? h(this.low >>> t | e << 32 - t, e >>> t, this.unsigned) : h(32 === t ? e : e >>> t - 32, 0, this.unsigned);\n        }, A.shru = A.shiftRightUnsigned, A.shr_u = A.shiftRightUnsigned, A.toSigned = function () {\n          return this.unsigned ? h(this.low, this.high, !1) : this;\n        }, A.toUnsigned = function () {\n          return this.unsigned ? this : h(this.low, this.high, !0);\n        }, A.toBytes = function (t) {\n          return t ? this.toBytesLE() : this.toBytesBE();\n        }, A.toBytesLE = function () {\n          var t = this.high,\n            e = this.low;\n          return [255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24, 255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24];\n        }, A.toBytesBE = function () {\n          var t = this.high,\n            e = this.low;\n          return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t, e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e];\n        }, r.fromBytes = function (t, e, i) {\n          return i ? r.fromBytesLE(t, e) : r.fromBytesBE(t, e);\n        }, r.fromBytesLE = function (t, e) {\n          return new r(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, e);\n        }, r.fromBytesBE = function (t, e) {\n          return new r(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], e);\n        };\n      },\n      218: t => {\n        function e(t, e) {\n          this.lo = t >>> 0, this.hi = e >>> 0;\n        }\n        t.exports = e;\n        var r = e.zero = new e(0, 0);\n        r.toNumber = function () {\n          return 0;\n        }, r.zzEncode = r.zzDecode = function () {\n          return this;\n        }, r.length = function () {\n          return 1;\n        };\n        var i = e.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n        e.fromNumber = function (t) {\n          if (0 === t) return r;\n          var i = t < 0;\n          i && (t = -t);\n          var n = t >>> 0,\n            s = (t - n) / 4294967296 >>> 0;\n          return i && (s = ~s >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++s > 4294967295 && (s = 0))), new e(n, s);\n        }, e.from = function (t) {\n          return \"number\" == typeof t ? e.fromNumber(t) : \"string\" == typeof t || t instanceof String ? e.fromNumber(parseInt(t, 10)) : t.low || t.high ? new e(t.low >>> 0, t.high >>> 0) : r;\n        }, e.prototype.toNumber = function (t) {\n          if (!t && this.hi >>> 31) {\n            var e = 1 + ~this.lo >>> 0,\n              r = ~this.hi >>> 0;\n            return e || (r = r + 1 >>> 0), -(e + 4294967296 * r);\n          }\n          return this.lo + 4294967296 * this.hi;\n        }, e.prototype.toLong = function (t) {\n          return {\n            low: 0 | this.lo,\n            high: 0 | this.hi,\n            unsigned: Boolean(t)\n          };\n        };\n        var n = String.prototype.charCodeAt;\n        e.fromHash = function (t) {\n          return t === i ? r : new e((n.call(t, 0) | n.call(t, 1) << 8 | n.call(t, 2) << 16 | n.call(t, 3) << 24) >>> 0, (n.call(t, 4) | n.call(t, 5) << 8 | n.call(t, 6) << 16 | n.call(t, 7) << 24) >>> 0);\n        }, e.prototype.toHash = function () {\n          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n        }, e.prototype.zzEncode = function () {\n          var t = this.hi >> 31;\n          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this;\n        }, e.prototype.zzDecode = function () {\n          var t = -(1 & this.lo);\n          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this;\n        }, e.prototype.length = function () {\n          var t = this.lo,\n            e = (this.lo >>> 28 | this.hi << 4) >>> 0,\n            r = this.hi >>> 24;\n          return 0 === r ? 0 === e ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : e < 16384 ? e < 128 ? 5 : 6 : e < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;\n        };\n      },\n      718: (t, e, r) => {\n        var i = r(535).default;\n        t.exports = a;\n        var n,\n          s,\n          o = r(238);\n        function a(t, e, r, i, n, a) {\n          if (o.call(this, t, e, i, void 0, void 0, n, a), !s.isString(r)) throw TypeError(\"keyType must be a string\");\n          this.keyType = r, this.resolvedKeyType = null, this.map = !0;\n        }\n        ((a.prototype = Object.create(o.prototype)).constructor = a).className = \"MapField\", a.fromJSON = function (t, e) {\n          return new a(t, e.id, e.keyType, e.type, e.options, e.comment);\n        }, a.prototype.toJSON = function (t) {\n          var e = !!t && Boolean(t.keepComments);\n          return s.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", e ? this.comment : void 0]);\n        }, a.prototype.resolve = function () {\n          if (this.resolved) return this;\n          if (void 0 === n.mapKey[this.keyType]) throw Error(\"invalid key type: \" + this.keyType);\n          return o.prototype.resolve.call(this);\n        }, a.d = function (t, e, r) {\n          return \"function\" == typeof r ? r = s.decorateType(r).name : r && \"object\" === i(r) && (r = s.decorateEnum(r).name), function (i, n) {\n            s.decorateType(i.constructor).add(new a(n, t, e, r));\n          };\n        }, a._configure = function () {\n          n = r(471), s = r(916);\n        };\n      },\n      853: (t, e, r) => {\n        \"use strict\";\n\n        var i;\n        function n(t) {\n          if (t) for (var e = Object.keys(t), r = 0; r < e.length; ++r) this[e[r]] = t[e[r]];\n        }\n        t.exports = n, n.create = function (t) {\n          return this.$type.create(t);\n        }, n.encode = function (t, e) {\n          return arguments.length ? 1 == arguments.length ? this.$type.encode(arguments[0]) : this.$type.encode(arguments[0], arguments[1]) : this.$type.encode(this);\n        }, n.encodeDelimited = function (t, e) {\n          return this.$type.encodeDelimited(t, e);\n        }, n.decode = function (t) {\n          return this.$type.decode(t);\n        }, n.decodeDelimited = function (t) {\n          return this.$type.decodeDelimited(t);\n        }, n.verify = function (t) {\n          return this.$type.verify(t);\n        }, n.fromObject = function (t) {\n          return this.$type.fromObject(t);\n        }, n.toObject = function (t, e) {\n          return t = t || this, this.$type.toObject(t, e);\n        }, n.prototype.toJSON = function () {\n          return this.$type.toObject(this, i.toJSONOptions);\n        }, n.set = function (t, e) {\n          n[t] = e;\n        }, n.get = function (t) {\n          return n[t];\n        }, n._configure = function () {\n          i = r(916);\n        };\n      },\n      493: (t, e, r) => {\n        \"use strict\";\n\n        t.exports = s;\n        var i,\n          n = r(719);\n        function s(t, e, r, s, o, a, h, u) {\n          if (i.isObject(o) ? (h = o, o = a = void 0) : i.isObject(a) && (h = a, a = void 0), void 0 !== e && !i.isString(e)) throw TypeError(\"type must be a string\");\n          if (!i.isString(r)) throw TypeError(\"requestType must be a string\");\n          if (!i.isString(s)) throw TypeError(\"responseType must be a string\");\n          n.call(this, t, h), this.type = e || \"rpc\", this.requestType = r, this.requestStream = !!o || void 0, this.responseType = s, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;\n        }\n        ((s.prototype = Object.create(n.prototype)).constructor = s).className = \"Method\", s.fromJSON = function (t, e) {\n          return new s(t, e.type, e.requestType, e.responseType, e.requestStream, e.responseStream, e.options, e.comment);\n        }, s.prototype.toJSON = function (t) {\n          var e = !!t && Boolean(t.keepComments);\n          return i.toObject([\"type\", \"rpc\" !== this.type && this.type || void 0, \"requestType\", this.requestType, \"requestStream\", this.requestStream, \"responseType\", this.responseType, \"responseStream\", this.responseStream, \"options\", this.options, \"comment\", e ? this.comment : void 0]);\n        }, s.prototype.resolve = function () {\n          return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));\n        }, s._configure = function () {\n          i = r(916);\n        };\n      },\n      625: (t, e, r) => {\n        t.exports = l;\n        var i,\n          n,\n          s,\n          o,\n          a,\n          h = r(719);\n        function u(t, e) {\n          if (t && t.length) {\n            for (var r = {}, i = 0; i < t.length; ++i) r[t[i].name] = t[i].toJSON(e);\n            return r;\n          }\n        }\n        function l(t, e) {\n          h.call(this, t, e), this.nested = void 0, this._nestedArray = null;\n        }\n        function f(t) {\n          return t._nestedArray = null, t;\n        }\n        ((l.prototype = Object.create(h.prototype)).constructor = l).className = \"Namespace\", l.fromJSON = function (t, e) {\n          return new l(t, e.options).addJSON(e.nested);\n        }, l.arrayToJSON = u, l.isReservedId = function (t, e) {\n          if (t) for (var r = 0; r < t.length; ++r) if (\"string\" != typeof t[r] && t[r][0] <= e && t[r][1] >= e) return !0;\n          return !1;\n        }, l.isReservedName = function (t, e) {\n          if (t) for (var r = 0; r < t.length; ++r) if (t[r] === e) return !0;\n          return !1;\n        }, Object.defineProperty(l.prototype, \"nestedArray\", {\n          get: function () {\n            return this._nestedArray || (this._nestedArray = s.toArray(this.nested));\n          }\n        }), l.prototype.toJSON = function (t) {\n          return s.toObject([\"options\", this.options, \"nested\", u(this.nestedArray, t)]);\n        }, l.prototype.addJSON = function (t) {\n          if (t) for (var e, r = Object.keys(t), s = 0; s < r.length; ++s) e = t[r[s]], this.add((void 0 !== e.fields ? o.fromJSON : void 0 !== e.values ? i.fromJSON : void 0 !== e.methods ? a.fromJSON : void 0 !== e.id ? n.fromJSON : l.fromJSON)(r[s], e));\n          return this;\n        }, l.prototype.get = function (t) {\n          return this.nested && this.nested[t] || null;\n        }, l.prototype.getEnum = function (t) {\n          if (this.nested && this.nested[t] instanceof i) return this.nested[t].values;\n          throw Error(\"no such enum: \" + t);\n        }, l.prototype.add = function (t) {\n          if (!(t instanceof n && void 0 !== t.extend || t instanceof o || t instanceof i || t instanceof a || t instanceof l)) throw TypeError(\"object must be a valid nested object\");\n          if (this.nested) {\n            var e = this.get(t.name);\n            if (e) {\n              if (!(e instanceof l && t instanceof l) || e instanceof o || e instanceof a) throw Error(\"duplicate name '\" + t.name + \"' in \" + this);\n              for (var r = e.nestedArray, s = 0; s < r.length; ++s) t.add(r[s]);\n              this.remove(e), this.nested || (this.nested = {}), t.setOptions(e.options, !0);\n            }\n          } else this.nested = {};\n          return this.nested[t.name] = t, t.onAdd(this), f(this);\n        }, l.prototype.remove = function (t) {\n          if (!(t instanceof h)) throw TypeError(\"object must be a ReflectionObject\");\n          if (t.parent !== this) throw Error(t + \" is not a member of \" + this);\n          return delete this.nested[t.name], Object.keys(this.nested).length || (this.nested = void 0), t.onRemove(this), f(this);\n        }, l.prototype.define = function (t, e) {\n          if (s.isString(t)) t = t.split(\".\");else if (!Array.isArray(t)) throw TypeError(\"illegal path\");\n          if (t && t.length && \"\" === t[0]) throw Error(\"path must be relative\");\n          for (var r = this; t.length > 0;) {\n            var i = t.shift();\n            if (r.nested && r.nested[i]) {\n              if (!((r = r.nested[i]) instanceof l)) throw Error(\"path conflicts with non-namespace objects\");\n            } else r.add(r = new l(i));\n          }\n          return e && r.addJSON(e), r;\n        }, l.prototype.resolveAll = function () {\n          for (var t = this.nestedArray, e = 0; e < t.length;) t[e] instanceof l ? t[e++].resolveAll() : t[e++].resolve();\n          return this.resolve();\n        }, l.prototype.lookup = function (t, e, r) {\n          if (\"boolean\" == typeof e ? (r = e, e = void 0) : e && !Array.isArray(e) && (e = [e]), s.isString(t) && t.length) {\n            if (\".\" === t) return this.root;\n            t = t.split(\".\");\n          } else if (!t.length) return this;\n          if (\"\" === t[0]) return this.root.lookup(t.slice(1), e);\n          var i = this.get(t[0]);\n          if (i) {\n            if (1 === t.length) {\n              if (!e || e.indexOf(i.constructor) > -1) return i;\n            } else if (i instanceof l && (i = i.lookup(t.slice(1), e, !0))) return i;\n          } else for (var n = 0; n < this.nestedArray.length; ++n) if (this._nestedArray[n] instanceof l && (i = this._nestedArray[n].lookup(t, e, !0))) return i;\n          return null === this.parent || r ? null : this.parent.lookup(t, e);\n        }, l.prototype.lookupType = function (t) {\n          var e = this.lookup(t, [o]);\n          if (!e) throw Error(\"no such type: \" + t);\n          return e;\n        }, l.prototype.lookupEnum = function (t) {\n          var e = this.lookup(t, [i]);\n          if (!e) throw Error(\"no such Enum '\" + t + \"' in \" + this);\n          return e;\n        }, l.prototype.lookupTypeOrEnum = function (t) {\n          var e = this.lookup(t, [o, i]);\n          if (!e) throw Error(\"no such Type or Enum '\" + t + \"' in \" + this);\n          return e;\n        }, l.prototype.lookupService = function (t) {\n          var e = this.lookup(t, [a]);\n          if (!e) throw Error(\"no such Service '\" + t + \"' in \" + this);\n          return e;\n        }, l._configure = function () {\n          i = r(421), n = r(238), s = r(916), o = r(24), a = r(673);\n        };\n      },\n      719: (t, e, r) => {\n        \"use strict\";\n\n        var i, n;\n        function s(t, e) {\n          if (!i.isString(t)) throw TypeError(\"name must be a string\");\n          if (e && !i.isObject(e)) throw TypeError(\"options must be an object\");\n          this.options = e, this.name = t, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;\n        }\n        t.exports = s, s.className = \"ReflectionObject\", Object.defineProperties(s.prototype, {\n          root: {\n            get: function () {\n              for (var t = this; null !== t.parent;) t = t.parent;\n              return t;\n            }\n          },\n          fullName: {\n            get: function () {\n              for (var t = [this.name], e = this.parent; e;) t.unshift(e.name), e = e.parent;\n              return t.join(\".\");\n            }\n          }\n        }), s.prototype.toJSON = function () {\n          throw Error();\n        }, s.prototype.onAdd = function (t) {\n          this.parent && this.parent !== t && this.parent.remove(this), this.parent = t, this.resolved = !1;\n          var e = t.root;\n          e instanceof n && e._handleAdd(this);\n        }, s.prototype.onRemove = function (t) {\n          var e = t.root;\n          e instanceof n && e._handleRemove(this), this.parent = null, this.resolved = !1;\n        }, s.prototype.resolve = function () {\n          return this.resolved || this.root instanceof n && (this.resolved = !0), this;\n        }, s.prototype.getOption = function (t) {\n          if (this.options) return this.options[t];\n        }, s.prototype.setOption = function (t, e, r) {\n          return r && this.options && void 0 !== this.options[t] || ((this.options || (this.options = {}))[t] = e), this;\n        }, s.prototype.setOptions = function (t, e) {\n          if (t) for (var r = Object.keys(t), i = 0; i < r.length; ++i) this.setOption(r[i], t[r[i]], e);\n          return this;\n        }, s.prototype.toString = function () {\n          var t = this.constructor.className,\n            e = this.fullName;\n          return e.length ? t + \" \" + e : t;\n        }, s._configure = function (t) {\n          n = r(572), i = r(916);\n        };\n      },\n      803: (t, e, r) => {\n        t.exports = o;\n        var i,\n          n,\n          s = r(719);\n        function o(t, e, r, i) {\n          if (Array.isArray(e) || (r = e, e = void 0), s.call(this, t, r), void 0 !== e && !Array.isArray(e)) throw TypeError(\"fieldNames must be an Array\");\n          this.oneof = e || [], this.fieldsArray = [], this.comment = i;\n        }\n        function a(t) {\n          if (t.parent) for (var e = 0; e < t.fieldsArray.length; ++e) t.fieldsArray[e].parent || t.parent.add(t.fieldsArray[e]);\n        }\n        ((o.prototype = Object.create(s.prototype)).constructor = o).className = \"OneOf\", o.fromJSON = function (t, e) {\n          return new o(t, e.oneof, e.options, e.comment);\n        }, o.prototype.toJSON = function (t) {\n          var e = !!t && Boolean(t.keepComments);\n          return n.toObject([\"options\", this.options, \"oneof\", this.oneof, \"comment\", e ? this.comment : void 0]);\n        }, o.prototype.add = function (t) {\n          if (!(t instanceof i)) throw TypeError(\"field must be a Field\");\n          return t.parent && t.parent !== this.parent && t.parent.remove(t), this.oneof.push(t.name), this.fieldsArray.push(t), t.partOf = this, a(this), this;\n        }, o.prototype.remove = function (t) {\n          if (!(t instanceof i)) throw TypeError(\"field must be a Field\");\n          var e = this.fieldsArray.indexOf(t);\n          if (e < 0) throw Error(t + \" is not a member of \" + this);\n          return this.fieldsArray.splice(e, 1), (e = this.oneof.indexOf(t.name)) > -1 && this.oneof.splice(e, 1), t.partOf = null, this;\n        }, o.prototype.onAdd = function (t) {\n          s.prototype.onAdd.call(this, t);\n          for (var e = 0; e < this.oneof.length; ++e) {\n            var r = t.get(this.oneof[e]);\n            r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));\n          }\n          a(this);\n        }, o.prototype.onRemove = function (t) {\n          for (var e, r = 0; r < this.fieldsArray.length; ++r) (e = this.fieldsArray[r]).parent && e.parent.remove(e);\n          s.prototype.onRemove.call(this, t);\n        }, o.d = function () {\n          for (var t = new Array(arguments.length), e = 0; e < arguments.length;) t[e] = arguments[e++];\n          return function (e, r) {\n            n.decorateType(e.constructor).add(new o(r, t)), Object.defineProperty(e, r, {\n              get: n.oneOfGetter(t),\n              set: n.oneOfSetter(t)\n            });\n          };\n        }, o._configure = function () {\n          i = r(238), n = r(916);\n        };\n      },\n      121: (t, e, r) => {\n        \"use strict\";\n\n        var i, n, s, o, a, h, u, l, f, c, d;\n        t.exports = A, A.filename = null, A.defaults = {\n          keepCase: !1\n        };\n        var p = /^[1-9][0-9]*$/,\n          y = /^-?[1-9][0-9]*$/,\n          v = /^0[x][0-9a-fA-F]+$/,\n          g = /^-?0[x][0-9a-fA-F]+$/,\n          m = /^0[0-7]+$/,\n          _ = /^-?0[0-7]+$/,\n          w = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n          b = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n          x = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,\n          k = /^(?:\\.[a-zA-Z][a-zA-Z_0-9]*)+$/;\n        function A(t, e, r) {\n          e instanceof n || (r = e, e = new n()), r || (r = A.defaults);\n          var S,\n            O,\n            E,\n            T,\n            z,\n            B = i(t, r.alternateCommentMode || !1),\n            I = B.next,\n            N = B.push,\n            F = B.peek,\n            j = B.skip,\n            L = B.cmnt,\n            C = !0,\n            R = !1,\n            D = e,\n            M = r.keepCase ? function (t) {\n              return t;\n            } : d.camelCase;\n          function P(t, e, r) {\n            var i = A.filename;\n            return r || (A.filename = null), Error(\"illegal \" + (e || \"token\") + \" '\" + t + \"' (\" + (i ? i + \", \" : \"\") + \"line \" + B.line + \")\");\n          }\n          function U() {\n            var t,\n              e = [];\n            do {\n              if ('\"' !== (t = I()) && \"'\" !== t) throw P(t);\n              e.push(I()), j(t), t = F();\n            } while ('\"' === t || \"'\" === t);\n            return e.join(\"\");\n          }\n          function Z(t) {\n            var e = I();\n            switch (e) {\n              case \"'\":\n              case '\"':\n                return N(e), U();\n              case \"true\":\n              case \"TRUE\":\n                return !0;\n              case \"false\":\n              case \"FALSE\":\n                return !1;\n            }\n            try {\n              return function (t, e) {\n                var r = 1;\n                switch (\"-\" === t.charAt(0) && (r = -1, t = t.substring(1)), t) {\n                  case \"inf\":\n                  case \"INF\":\n                  case \"Inf\":\n                    return r * (1 / 0);\n                  case \"nan\":\n                  case \"NAN\":\n                  case \"Nan\":\n                  case \"NaN\":\n                    return NaN;\n                  case \"0\":\n                    return 0;\n                }\n                if (p.test(t)) return r * parseInt(t, 10);\n                if (v.test(t)) return r * parseInt(t, 16);\n                if (m.test(t)) return r * parseInt(t, 8);\n                if (w.test(t)) return r * parseFloat(t);\n                throw P(t, \"number\", !0);\n              }(e);\n            } catch (r) {\n              if (t && x.test(e)) return e;\n              throw P(e, \"value\");\n            }\n          }\n          function q(t, e) {\n            var r, i;\n            do {\n              !e || '\"' !== (r = F()) && \"'\" !== r ? t.push([i = J(I()), j(\"to\", !0) ? J(I()) : i]) : t.push(U());\n            } while (j(\",\", !0));\n            j(\";\");\n          }\n          function J(t, e) {\n            switch (t) {\n              case \"max\":\n              case \"MAX\":\n              case \"Max\":\n                return 536870911;\n              case \"0\":\n                return 0;\n            }\n            if (!e && \"-\" === t.charAt(0)) throw P(t, \"id\");\n            if (y.test(t)) return parseInt(t, 10);\n            if (g.test(t)) return parseInt(t, 16);\n            if (_.test(t)) return parseInt(t, 8);\n            throw P(t, \"id\");\n          }\n          function V() {\n            if (void 0 !== S) throw P(\"package\");\n            if (S = I(), !x.test(S)) throw P(S, \"name\");\n            D = D.define(S), j(\";\");\n          }\n          function H() {\n            var t,\n              e = F();\n            switch (e) {\n              case \"weak\":\n                t = E || (E = []), I();\n                break;\n              case \"public\":\n                I();\n              default:\n                t = O || (O = []);\n            }\n            e = U(), j(\";\"), t.push(e);\n          }\n          function $() {\n            if (j(\"=\"), T = U(), !(R = \"proto3\" === T) && \"proto2\" !== T) throw P(T, \"syntax\");\n            j(\";\");\n          }\n          function K(t, e) {\n            switch (e) {\n              case \"option\":\n                return G(t, e), j(\";\"), !0;\n              case \"message\":\n                return function (t, e) {\n                  if (!b.test(e = I())) throw P(e, \"type name\");\n                  var r = new s(e);\n                  X(r, function (t) {\n                    if (!K(r, t)) switch (t) {\n                      case \"map\":\n                        !function (t) {\n                          j(\"<\");\n                          var e = I();\n                          if (void 0 === c.mapKey[e]) throw P(e, \"type\");\n                          j(\",\");\n                          var r = I();\n                          if (!x.test(r)) throw P(r, \"type\");\n                          j(\">\");\n                          var i = I();\n                          if (!b.test(i)) throw P(i, \"name\");\n                          j(\"=\");\n                          var n = new a(M(i), J(I()), e, r);\n                          X(n, function (t) {\n                            if (\"option\" !== t) throw P(t);\n                            G(n, t), j(\";\");\n                          }, function () {\n                            tt(n);\n                          }), t.add(n);\n                        }(r);\n                        break;\n                      case \"required\":\n                      case \"optional\":\n                      case \"repeated\":\n                        Y(r, t);\n                        break;\n                      case \"oneof\":\n                        !function (t, e) {\n                          if (!b.test(e = I())) throw P(e, \"name\");\n                          var r = new h(M(e));\n                          X(r, function (t) {\n                            \"option\" === t ? (G(r, t), j(\";\")) : (N(t), Y(r, \"optional\"));\n                          }), t.add(r);\n                        }(r, t);\n                        break;\n                      case \"extensions\":\n                        q(r.extensions || (r.extensions = []));\n                        break;\n                      case \"reserved\":\n                        q(r.reserved || (r.reserved = []), !0);\n                        break;\n                      default:\n                        if (!R || !x.test(t)) throw P(t);\n                        N(t), Y(r, \"optional\");\n                    }\n                  }), t.add(r);\n                }(t, e), !0;\n              case \"enum\":\n                return function (t, e) {\n                  if (!b.test(e = I())) throw P(e, \"name\");\n                  var r = new u(e);\n                  X(r, function (t) {\n                    switch (t) {\n                      case \"option\":\n                        G(r, t), j(\";\");\n                        break;\n                      case \"reserved\":\n                        q(r.reserved || (r.reserved = []), !0);\n                        break;\n                      default:\n                        !function (t, e) {\n                          if (!b.test(e)) throw P(e, \"name\");\n                          j(\"=\");\n                          var r = J(I(), !0),\n                            i = {};\n                          X(i, function (t) {\n                            if (\"option\" !== t) throw P(t);\n                            G(i, t), j(\";\");\n                          }, function () {\n                            tt(i);\n                          }), t.add(e, r, i.comment);\n                        }(r, t);\n                    }\n                  }), t.add(r);\n                }(t, e), !0;\n              case \"service\":\n                return function (t, e) {\n                  if (!b.test(e = I())) throw P(e, \"service name\");\n                  var r = new l(e);\n                  X(r, function (t) {\n                    if (!K(r, t)) {\n                      if (\"rpc\" !== t) throw P(t);\n                      !function (t, e) {\n                        var r = e;\n                        if (!b.test(e = I())) throw P(e, \"name\");\n                        var i,\n                          n,\n                          s,\n                          o,\n                          a = e;\n                        if (j(\"(\"), j(\"stream\", !0) && (n = !0), !x.test(e = I())) throw P(e);\n                        if (i = e, j(\")\"), j(\"returns\"), j(\"(\"), j(\"stream\", !0) && (o = !0), !x.test(e = I())) throw P(e);\n                        s = e, j(\")\");\n                        var h = new f(a, r, i, s, n, o);\n                        X(h, function (t) {\n                          if (\"option\" !== t) throw P(t);\n                          G(h, t), j(\";\");\n                        }), t.add(h);\n                      }(r, t);\n                    }\n                  }), t.add(r);\n                }(t, e), !0;\n              case \"extend\":\n                return function (t, e) {\n                  if (!x.test(e = I())) throw P(e, \"reference\");\n                  var r = e;\n                  X(null, function (e) {\n                    switch (e) {\n                      case \"required\":\n                      case \"repeated\":\n                      case \"optional\":\n                        Y(t, e, r);\n                        break;\n                      default:\n                        if (!R || !x.test(e)) throw P(e);\n                        N(e), Y(t, \"optional\", r);\n                    }\n                  });\n                }(t, e), !0;\n            }\n            return !1;\n          }\n          function X(t, e, r) {\n            var i = B.line;\n            if (t && (t.comment = L(), t.filename = A.filename), j(\"{\", !0)) {\n              for (var n; \"}\" !== (n = I());) e(n);\n              j(\";\", !0);\n            } else r && r(), j(\";\"), t && \"string\" != typeof t.comment && (t.comment = L(i));\n          }\n          function Y(t, e, r) {\n            var i = I();\n            if (\"group\" !== i) {\n              if (!x.test(i)) throw P(i, \"type\");\n              var n = I();\n              if (!b.test(n)) throw P(n, \"name\");\n              n = M(n), j(\"=\");\n              var a = new o(n, J(I()), i, e, r);\n              X(a, function (t) {\n                if (\"option\" !== t) throw P(t);\n                G(a, t), j(\";\");\n              }, function () {\n                tt(a);\n              }), t.add(a), R || !a.repeated || void 0 === c.packed[i] && void 0 !== c.basic[i] || a.setOption(\"packed\", !1, !0);\n            } else !function (t, e) {\n              var r = I();\n              if (!b.test(r)) throw P(r, \"name\");\n              var i = d.lcFirst(r);\n              r === i && (r = d.ucFirst(r)), j(\"=\");\n              var n = J(I()),\n                a = new s(r);\n              a.group = !0;\n              var h = new o(i, n, r, e);\n              h.filename = A.filename, X(a, function (t) {\n                switch (t) {\n                  case \"option\":\n                    G(a, t), j(\";\");\n                    break;\n                  case \"required\":\n                  case \"optional\":\n                  case \"repeated\":\n                    Y(a, t);\n                    break;\n                  default:\n                    throw P(t);\n                }\n              }), t.add(a).add(h);\n            }(t, e);\n          }\n          function G(t, e) {\n            var r = j(\"(\", !0);\n            if (!x.test(e = I())) throw P(e, \"name\");\n            var i = e;\n            r && (j(\")\"), i = \"(\" + i + \")\", e = F(), k.test(e) && (i += e, I())), j(\"=\"), W(t, i);\n          }\n          function W(t, e) {\n            if (j(\"{\", !0)) do {\n              if (!b.test(z = I())) throw P(z, \"name\");\n              \"{\" === F() ? W(t, e + \".\" + z) : (j(\":\"), \"{\" === F() ? W(t, e + \".\" + z) : Q(t, e + \".\" + z, Z(!0)));\n            } while (!j(\"}\", !0));else Q(t, e, Z(!0));\n          }\n          function Q(t, e, r) {\n            t.setOption && t.setOption(e, r);\n          }\n          function tt(t) {\n            if (j(\"[\", !0)) {\n              do {\n                G(t, \"option\");\n              } while (j(\",\", !0));\n              j(\"]\");\n            }\n            return t;\n          }\n          for (; null !== (z = I());) switch (z) {\n            case \"package\":\n              if (!C) throw P(z);\n              V();\n              break;\n            case \"import\":\n              if (!C) throw P(z);\n              H();\n              break;\n            case \"syntax\":\n              if (!C) throw P(z);\n              $();\n              break;\n            case \"option\":\n              if (!C) throw P(z);\n              G(D, z), j(\";\");\n              break;\n            default:\n              if (K(D, z)) {\n                C = !1;\n                continue;\n              }\n              throw P(z);\n          }\n          return A.filename = null, {\n            package: S,\n            imports: O,\n            weakImports: E,\n            syntax: T,\n            root: e\n          };\n        }\n        A._configure = function () {\n          i = r(941), n = r(572), s = r(24), o = r(238), a = r(718), h = r(803), u = r(421), l = r(673), f = r(493), c = r(471), d = r(916);\n        };\n      },\n      915: t => {\n        var e = t.exports,\n          r = e.isAbsolute = function (t) {\n            return /^(?:\\/|\\w+:)/.test(t);\n          },\n          i = e.normalize = function (t) {\n            var e = (t = t.replace(/\\\\/g, \"/\").replace(/\\/{2,}/g, \"/\")).split(\"/\"),\n              i = r(t),\n              n = \"\";\n            i && (n = e.shift() + \"/\");\n            for (var s = 0; s < e.length;) \"..\" === e[s] ? s > 0 && \"..\" !== e[s - 1] ? e.splice(--s, 2) : i ? e.splice(s, 1) : ++s : \".\" === e[s] ? e.splice(s, 1) : ++s;\n            return n + e.join(\"/\");\n          };\n        e.resolve = function (t, e, n) {\n          return n || (e = i(e)), r(e) ? e : (n || (t = i(t)), (t = t.replace(/(?:\\/|^)[^/]+$/, \"\")).length ? i(t + \"/\" + e) : e);\n        };\n      },\n      266: t => {\n        t.exports = function (t, e, r) {\n          var i = r || 8192,\n            n = i >>> 1,\n            s = null,\n            o = i;\n          return function (r) {\n            if (r < 1 || r > n) return t(r);\n            o + r > i && (s = t(i), o = 0);\n            var a = e.call(s, o, o += r);\n            return 7 & o && (o = 1 + (7 | o)), a;\n          };\n        };\n      },\n      795: (t, e, r) => {\n        t.exports = a;\n        var i,\n          n,\n          s = r(916);\n        function o(t, e) {\n          return RangeError(\"index out of range: \" + t.pos + \" + \" + (e || 1) + \" > \" + t.len);\n        }\n        function a(t) {\n          this.buf = t, this.pos = 0, this.len = t.length;\n        }\n        var h,\n          u = \"undefined\" != typeof Uint8Array ? function (t) {\n            if (t instanceof Uint8Array || Array.isArray(t)) return new a(t);\n            if (\"undefined\" != typeof ArrayBuffer && t instanceof ArrayBuffer) return new a(new Uint8Array(t));\n            throw Error(\"illegal buffer\");\n          } : function (t) {\n            if (Array.isArray(t)) return new a(t);\n            throw Error(\"illegal buffer\");\n          };\n        function l() {\n          var t = new i(0, 0),\n            e = 0;\n          if (!(this.len - this.pos > 4)) {\n            for (; e < 3; ++e) {\n              if (this.pos >= this.len) throw o(this);\n              if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n            }\n            return t.lo = (t.lo | (127 & this.buf[this.pos++]) << 7 * e) >>> 0, t;\n          }\n          for (; e < 4; ++e) if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n          if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t.hi = (t.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t;\n          if (e = 0, this.len - this.pos > 4) {\n            for (; e < 5; ++e) if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n          } else for (; e < 5; ++e) {\n            if (this.pos >= this.len) throw o(this);\n            if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n          }\n          throw Error(\"invalid varint encoding\");\n        }\n        function f(t, e) {\n          return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;\n        }\n        function c() {\n          if (this.pos + 8 > this.len) throw o(this, 8);\n          return new i(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));\n        }\n        a.create = s.Buffer ? function (t) {\n          return (a.create = function (t) {\n            return s.Buffer.isBuffer(t) ? new (void 0)(t) : u(t);\n          })(t);\n        } : u, a.prototype._slice = s.Array.prototype.subarray || s.Array.prototype.slice, a.prototype.uint32 = (h = 4294967295, function () {\n          if (h = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return h;\n          if (h = (h | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return h;\n          if (h = (h | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return h;\n          if (h = (h | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return h;\n          if (h = (h | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return h;\n          if ((this.pos += 5) > this.len) throw this.pos = this.len, o(this, 10);\n          return h;\n        }), a.prototype.int32 = function () {\n          return 0 | this.uint32();\n        }, a.prototype.sint32 = function () {\n          var t = this.uint32();\n          return t >>> 1 ^ -(1 & t);\n        }, a.prototype.bool = function () {\n          return 0 !== this.uint32();\n        }, a.prototype.fixed32 = function () {\n          if (this.pos + 4 > this.len) throw o(this, 4);\n          return f(this.buf, this.pos += 4);\n        }, a.prototype.sfixed32 = function () {\n          if (this.pos + 4 > this.len) throw o(this, 4);\n          return 0 | f(this.buf, this.pos += 4);\n        }, a.prototype.float = function () {\n          if (this.pos + 4 > this.len) throw o(this, 4);\n          var t = s.float.readFloatLE(this.buf, this.pos);\n          return this.pos += 4, t;\n        }, a.prototype.double = function () {\n          if (this.pos + 8 > this.len) throw o(this, 4);\n          var t = s.float.readDoubleLE(this.buf, this.pos);\n          return this.pos += 8, t;\n        }, a.prototype.bytes = function () {\n          var t = this.uint32(),\n            e = this.pos,\n            r = this.pos + t;\n          if (r > this.len) throw o(this, t);\n          return this.pos += t, Array.isArray(this.buf) ? this.buf.slice(e, r) : e === r ? new this.buf.constructor(0) : this._slice.call(this.buf, e, r);\n        }, a.prototype.string = function () {\n          var t = this.bytes();\n          return n.read(t, 0, t.length);\n        }, a.prototype.skip = function (t) {\n          if (\"number\" == typeof t) {\n            if (this.pos + t > this.len) throw o(this, t);\n            this.pos += t;\n          } else do {\n            if (this.pos >= this.len) throw o(this);\n          } while (128 & this.buf[this.pos++]);\n          return this;\n        }, a.prototype.skipType = function (t) {\n          switch (t) {\n            case 0:\n              this.skip();\n              break;\n            case 1:\n              this.skip(8);\n              break;\n            case 2:\n              this.skip(this.uint32());\n              break;\n            case 3:\n              for (; 4 != (t = 7 & this.uint32());) this.skipType(t);\n              break;\n            case 5:\n              this.skip(4);\n              break;\n            default:\n              throw Error(\"invalid wire type \" + t + \" at offset \" + this.pos);\n          }\n          return this;\n        }, a._configure = function () {\n          i = r(218), n = r(187);\n          var t = s.Long ? \"toLong\" : \"toNumber\";\n          s.merge(a.prototype, {\n            int64: function () {\n              return l.call(this)[t](!1);\n            },\n            uint64: function () {\n              return l.call(this)[t](!0);\n            },\n            sint64: function () {\n              return l.call(this).zzDecode()[t](!1);\n            },\n            fixed64: function () {\n              return c.call(this)[t](!0);\n            },\n            sfixed64: function () {\n              return c.call(this)[t](!1);\n            }\n          });\n        };\n      },\n      572: (t, e, r) => {\n        var i = r(535).default;\n        t.exports = c;\n        var n = r(625);\n        ((c.prototype = Object.create(n.prototype)).constructor = c).className = \"Root\";\n        var s,\n          o,\n          a,\n          h = r(238),\n          u = r(421),\n          l = r(803),\n          f = r(916);\n        function c(t) {\n          n.call(this, \"\", t), this.deferred = [], this.files = [], this.names = [];\n        }\n        function d() {}\n        c.fromJSON = function (t, e) {\n          return t = \"string\" == typeof t ? JSON.parse(t) : t, e || (e = new c()), t.options && e.setOptions(t.options), e.addJSON(t.nested);\n        }, c.prototype.resolvePath = f.path.resolve, c.prototype.parseFromPbString = function t(e, r, n) {\n          \"function\" == typeof r && (n = r, r = void 0);\n          var s = this;\n          if (!n) return f.asPromise(t, s, e, r);\n          var h = null;\n          if (\"string\" == typeof e) h = JSON.parse(e);else {\n            if (\"object\" !== i(e)) return void console.log(\"pb格式转化失败\");\n            h = e;\n          }\n          function u(t, e) {\n            if (n) {\n              var r = n;\n              n = null, r(t, e);\n            }\n          }\n          function l(t, e) {\n            try {\n              if (f.isString(e) && \"{\" === e.charAt(0) && (e = JSON.parse(e)), f.isString(e)) {\n                o.filename = t;\n                var i,\n                  n = o(e, s, r),\n                  a = 0;\n                if (n.imports) for (; a < n.imports.length; ++a) c(i = n.imports[a]);\n                if (n.weakImports) {\n                  for (a = 0; a < n.weakImports.length; ++a) i = n.weakImports[a];\n                  c(i);\n                }\n              } else s.setOptions(e.options).addJSON(e.nested);\n            } catch (t) {\n              u(t);\n            }\n            u(null, s);\n          }\n          function c(t) {\n            s.names.indexOf(t) > -1 || (s.names.push(t), t in a && l(t, a[t]));\n          }\n          l(h.name, h.pbJsonStr);\n        }, c.prototype.load = function t(e, r, i) {\n          \"function\" == typeof r && (i = r, r = void 0);\n          var n = this;\n          if (!i) return f.asPromise(t, n, e, r);\n          var s = i === d;\n          function h(t, e) {\n            if (i) {\n              var r = i;\n              if (i = null, s) throw t;\n              r(t, e);\n            }\n          }\n          function u(t, e) {\n            try {\n              if (f.isString(e) && \"{\" === e.charAt(0) && (e = JSON.parse(e)), f.isString(e)) {\n                o.filename = t;\n                var i,\n                  a = o(e, n, r),\n                  u = 0;\n                if (a.imports) for (; u < a.imports.length; ++u) (i = n.resolvePath(t, a.imports[u])) && l(i);\n                if (a.weakImports) for (u = 0; u < a.weakImports.length; ++u) (i = n.resolvePath(t, a.weakImports[u])) && l(i, !0);\n              } else n.setOptions(e.options).addJSON(e.nested);\n            } catch (t) {\n              h(t);\n            }\n            s || c || h(null, n);\n          }\n          function l(t, e) {\n            var r = t.lastIndexOf(\"google/protobuf/\");\n            if (r > -1) {\n              var o = t.substring(r);\n              o in a && (t = o);\n            }\n            if (!(n.files.indexOf(t) > -1)) if (n.files.push(t), t in a) s ? u(t, a[t]) : (++c, setTimeout(function () {\n              --c, u(t, a[t]);\n            }));else if (s) {\n              var l;\n              try {\n                l = f.fs.readFileSync(t).toString(\"utf8\");\n              } catch (t) {\n                return void (e || h(t));\n              }\n              u(t, l);\n            } else ++c, f.fetch(t, function (r, s) {\n              --c, i && (r ? e ? c || h(null, n) : h(r) : u(t, s));\n            });\n          }\n          var c = 0;\n          f.isString(e) && (e = [e]);\n          for (var p, y = 0; y < e.length; ++y) (p = n.resolvePath(\"\", e[y])) && l(p);\n          if (s) return n;\n          c || h(null, n);\n        }, c.prototype.loadSync = function (t, e) {\n          if (!f.isNode) throw Error(\"not supported\");\n          return this.load(t, e, d);\n        }, c.prototype.resolveAll = function () {\n          if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function (t) {\n            return \"'extend \" + t.extend + \"' in \" + t.parent.fullName;\n          }).join(\", \"));\n          return n.prototype.resolveAll.call(this);\n        };\n        var p = /^[A-Z]/;\n        function y(t, e) {\n          var r = e.parent.lookup(e.extend);\n          if (r) {\n            var i = new h(e.fullName, e.id, e.type, e.rule, void 0, e.options);\n            return i.declaringField = e, e.extensionField = i, r.add(i), !0;\n          }\n          return !1;\n        }\n        c.prototype._handleAdd = function (t) {\n          if (t instanceof h) void 0 === t.extend || t.extensionField || y(0, t) || this.deferred.push(t);else if (t instanceof u) p.test(t.name) && (t.parent[t.name] = t.values);else if (!(t instanceof l)) {\n            if (t instanceof s) for (var e = 0; e < this.deferred.length;) y(0, this.deferred[e]) ? this.deferred.splice(e, 1) : ++e;\n            for (var r = 0; r < t.nestedArray.length; ++r) this._handleAdd(t._nestedArray[r]);\n            p.test(t.name) && (t.parent[t.name] = t);\n          }\n        }, c.prototype._handleRemove = function (t) {\n          if (t instanceof h) {\n            if (void 0 !== t.extend) if (t.extensionField) t.extensionField.parent.remove(t.extensionField), t.extensionField = null;else {\n              var e = this.deferred.indexOf(t);\n              e > -1 && this.deferred.splice(e, 1);\n            }\n          } else if (t instanceof u) p.test(t.name) && delete t.parent[t.name];else if (t instanceof n) {\n            for (var r = 0; r < t.nestedArray.length; ++r) this._handleRemove(t._nestedArray[r]);\n            p.test(t.name) && delete t.parent[t.name];\n          }\n        }, c._configure = function () {\n          s = r(24), o = r(121), a = r(453), h = r(238), u = r(421), l = r(803), f = r(916);\n        };\n      },\n      587: t => {\n        t.exports = {};\n      },\n      153: (t, e, r) => {\n        \"use strict\";\n\n        t.exports = n;\n        var i = r(916);\n        function n(t, e, r) {\n          if (\"function\" != typeof t) throw TypeError(\"rpcImpl must be a function\");\n          i.EventEmitter.call(this), this.rpcImpl = t, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(r);\n        }\n        (n.prototype = Object.create(i.EventEmitter.prototype)).constructor = n, n.prototype.rpcCall = function t(e, r, n, s, o) {\n          if (!s) throw TypeError(\"request must be specified\");\n          var a = this;\n          if (!o) return i.asPromise(t, a, e, r, n, s);\n          if (a.rpcImpl) try {\n            return a.rpcImpl(e, r[a.requestDelimited ? \"encodeDelimited\" : \"encode\"](s).finish(), function (t, r) {\n              if (t) return a.emit(\"error\", t, e), o(t);\n              if (null !== r) {\n                if (!(r instanceof n)) try {\n                  r = n[a.responseDelimited ? \"decodeDelimited\" : \"decode\"](r);\n                } catch (t) {\n                  return a.emit(\"error\", t, e), o(t);\n                }\n                return a.emit(\"data\", r, e), o(null, r);\n              }\n              a.end(!0);\n            });\n          } catch (t) {\n            return a.emit(\"error\", t, e), void setTimeout(function () {\n              o(t);\n            }, 0);\n          } else setTimeout(function () {\n            o(Error(\"already ended\"));\n          }, 0);\n        }, n.prototype.end = function (t) {\n          return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n        };\n      },\n      673: (t, e, r) => {\n        \"use strict\";\n\n        t.exports = a;\n        var i,\n          n,\n          s,\n          o = r(625);\n        function a(t, e) {\n          o.call(this, t, e), this.methods = {}, this._methodsArray = null;\n        }\n        function h(t) {\n          return t._methodsArray = null, t;\n        }\n        ((a.prototype = Object.create(o.prototype)).constructor = a).className = \"Service\", a.fromJSON = function (t, e) {\n          var r = new a(t, e.options);\n          if (e.methods) for (var n = Object.keys(e.methods), s = 0; s < n.length; ++s) r.add(i.fromJSON(n[s], e.methods[n[s]]));\n          return e.nested && r.addJSON(e.nested), r.comment = e.comment, r;\n        }, a.prototype.toJSON = function (t) {\n          var e = o.prototype.toJSON.call(this, t),\n            r = !!t && Boolean(t.keepComments);\n          return n.toObject([\"options\", e && e.options || void 0, \"methods\", o.arrayToJSON(this.methodsArray, t) || {}, \"nested\", e && e.nested || void 0, \"comment\", r ? this.comment : void 0]);\n        }, Object.defineProperty(a.prototype, \"methodsArray\", {\n          get: function () {\n            return this._methodsArray || (this._methodsArray = n.toArray(this.methods));\n          }\n        }), a.prototype.get = function (t) {\n          return this.methods[t] || o.prototype.get.call(this, t);\n        }, a.prototype.resolveAll = function () {\n          for (var t = this.methodsArray, e = 0; e < t.length; ++e) t[e].resolve();\n          return o.prototype.resolve.call(this);\n        }, a.prototype.add = function (t) {\n          if (this.get(t.name)) throw Error(\"duplicate name '\" + t.name + \"' in \" + this);\n          return t instanceof i ? (this.methods[t.name] = t, t.parent = this, h(this)) : o.prototype.add.call(this, t);\n        }, a.prototype.remove = function (t) {\n          if (t instanceof i) {\n            if (this.methods[t.name] !== t) throw Error(t + \" is not a member of \" + this);\n            return delete this.methods[t.name], t.parent = null, h(this);\n          }\n          return o.prototype.remove.call(this, t);\n        }, a.prototype.create = function (t, e, r) {\n          for (var i, o = new s.Service(t, e, r), a = 0; a < this.methodsArray.length; ++a) {\n            var h = n.lcFirst((i = this._methodsArray[a]).resolve().name).replace(/[^$\\w_]/g, \"\");\n            o[h] = n.codegen([\"r\", \"c\"], n.isReserved(h) ? h + \"_\" : h)(\"return this.rpcCall(m,q,s,r,c)\")({\n              m: i,\n              q: i.resolvedRequestType.ctor,\n              s: i.resolvedResponseType.ctor\n            });\n          }\n          return o;\n        }, a._configure = function () {\n          i = r(493), n = r(916), s = r(153);\n        };\n      },\n      941: t => {\n        t.exports = f;\n        var e = /[\\s{}=;:[\\],'\"()<>]/g,\n          r = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n          i = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g,\n          n = /^ *[*/]+ */,\n          s = /^\\s*\\*?\\/*/,\n          o = /\\n/g,\n          a = /\\s/,\n          h = /\\\\(.?)/g,\n          u = {\n            0: \"\\0\",\n            r: \"\\r\",\n            n: \"\\n\",\n            t: \"\\t\"\n          };\n        function l(t) {\n          return t.replace(h, function (t, e) {\n            switch (e) {\n              case \"\\\\\":\n              case \"\":\n                return e;\n              default:\n                return u[e] || \"\";\n            }\n          });\n        }\n        function f(t, h) {\n          t = t.toString();\n          var u = 0,\n            f = t.length,\n            c = 1,\n            d = null,\n            p = null,\n            y = 0,\n            v = !1,\n            g = [],\n            m = null;\n          function _(t) {\n            return Error(\"illegal \" + t + \" (line \" + c + \")\");\n          }\n          function w(e) {\n            return t.charAt(e);\n          }\n          function b(e, r) {\n            d = t.charAt(e++), y = c, v = !1;\n            var i,\n              a = e - (h ? 2 : 3);\n            do {\n              if (--a < 0 || \"\\n\" === (i = t.charAt(a))) {\n                v = !0;\n                break;\n              }\n            } while (\" \" === i || \"\\t\" === i);\n            for (var u = t.substring(e, r).split(o), l = 0; l < u.length; ++l) u[l] = u[l].replace(h ? s : n, \"\").trim();\n            p = u.join(\"\\n\").trim();\n          }\n          function x(e) {\n            var r = k(e),\n              i = t.substring(e, r);\n            return /^\\s*\\/{1,2}/.test(i);\n          }\n          function k(t) {\n            for (var e = t; e < f && \"\\n\" !== w(e);) e++;\n            return e;\n          }\n          function A() {\n            if (g.length > 0) return g.shift();\n            if (m) return function () {\n              var e = \"'\" === m ? i : r;\n              e.lastIndex = u - 1;\n              var n = e.exec(t);\n              if (!n) throw _(\"string\");\n              return u = e.lastIndex, S(m), m = null, l(n[1]);\n            }();\n            var n, s, o, d, p;\n            do {\n              if (u === f) return null;\n              for (n = !1; a.test(o = w(u));) if (\"\\n\" === o && ++c, ++u === f) return null;\n              if (\"/\" === w(u)) {\n                if (++u === f) throw _(\"comment\");\n                if (\"/\" === w(u)) {\n                  if (h) {\n                    if (d = u, p = !1, x(u)) {\n                      p = !0;\n                      do {\n                        if ((u = k(u)) === f) break;\n                        u++;\n                      } while (x(u));\n                    } else u = Math.min(f, k(u) + 1);\n                    p && b(d, u), c++, n = !0;\n                  } else {\n                    for (p = \"/\" === w(d = u + 1); \"\\n\" !== w(++u);) if (u === f) return null;\n                    ++u, p && b(d, u - 1), ++c, n = !0;\n                  }\n                } else {\n                  if (\"*\" !== (o = w(u))) return \"/\";\n                  d = u + 1, p = h || \"*\" === w(d);\n                  do {\n                    if (\"\\n\" === o && ++c, ++u === f) throw _(\"comment\");\n                    s = o, o = w(u);\n                  } while (\"*\" !== s || \"/\" !== o);\n                  ++u, p && b(d, u - 2), n = !0;\n                }\n              }\n            } while (n);\n            var y = u;\n            if (e.lastIndex = 0, !e.test(w(y++))) for (; y < f && !e.test(w(y));) ++y;\n            var v = t.substring(u, u = y);\n            return '\"' !== v && \"'\" !== v || (m = v), v;\n          }\n          function S(t) {\n            g.push(t);\n          }\n          function O() {\n            if (!g.length) {\n              var t = A();\n              if (null === t) return null;\n              S(t);\n            }\n            return g[0];\n          }\n          return Object.defineProperty({\n            next: A,\n            peek: O,\n            push: S,\n            skip: function (t, e) {\n              var r = O();\n              if (r === t) return A(), !0;\n              if (!e) throw _(\"token '\" + r + \"', '\" + t + \"' expected\");\n              return !1;\n            },\n            cmnt: function (t) {\n              var e = null;\n              return void 0 === t ? y === c - 1 && (h || \"*\" === d || v) && (e = p) : (y < t && O(), y !== t || v || !h && \"/\" !== d || (e = p)), e;\n            }\n          }, \"line\", {\n            get: function () {\n              return c;\n            }\n          });\n        }\n        f.unescape = l;\n      },\n      24: (t, e, r) => {\n        t.exports = v;\n        var i,\n          n,\n          s,\n          o,\n          a,\n          h,\n          u,\n          l,\n          f,\n          c,\n          d,\n          p,\n          y = r(625);\n        function v(t, e) {\n          y.call(this, t, e), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;\n        }\n        function g(t) {\n          return t._fieldsById = t._fieldsArray = t._oneofsArray = null, delete t.encode, delete t.decode, delete t.verify, t;\n        }\n        ((v.prototype = Object.create(y.prototype)).constructor = v).className = \"Type\", Object.defineProperties(v.prototype, {\n          fieldsById: {\n            get: function () {\n              if (this._fieldsById) return this._fieldsById;\n              this._fieldsById = {};\n              for (var t = Object.keys(this.fields), e = 0; e < t.length; ++e) {\n                var r = this.fields[t[e]],\n                  i = r.id;\n                if (this._fieldsById[i]) throw Error(\"duplicate id \" + i + \" in \" + this);\n                this._fieldsById[i] = r;\n              }\n              return this._fieldsById;\n            }\n          },\n          fieldsArray: {\n            get: function () {\n              return this._fieldsArray || (this._fieldsArray = h.toArray(this.fields));\n            }\n          },\n          oneofsArray: {\n            get: function () {\n              return this._oneofsArray || (this._oneofsArray = h.toArray(this.oneofs));\n            }\n          },\n          ctor: {\n            get: function () {\n              return this._ctor || (this.ctor = v.generateConstructor(this));\n            },\n            set: function (t) {\n              var e = t.prototype;\n              e instanceof s || ((t.prototype = new s()).constructor = t, h.merge(t.prototype, e)), t.$type = t.prototype.$type = this, h.merge(t, s, !0), h.merge(t.prototype, s, !0), this._ctor = t;\n              for (var r = 0; r < this.fieldsArray.length; ++r) this._fieldsArray[r].resolve();\n              var i = {};\n              for (r = 0; r < this.oneofsArray.length; ++r) {\n                var n = this._oneofsArray[r].resolve().name,\n                  o = function (t) {\n                    for (var e = {}, r = 0; r < t.length; ++r) e[t[r]] = 0;\n                    return {\n                      setter: function (r) {\n                        if (!(t.indexOf(r) < 0)) {\n                          e[r] = 1;\n                          for (var i = 0; i < t.length; ++i) t[i] !== r && delete this[t[i]];\n                        }\n                      },\n                      getter: function () {\n                        for (var t = Object.keys(this), r = t.length - 1; r > -1; --r) if (1 === e[t[r]] && void 0 !== this[t[r]] && null !== this[t[r]]) return t[r];\n                      }\n                    };\n                  }(this._oneofsArray[r].oneof);\n                i[n] = {\n                  get: o.getter,\n                  set: o.setter\n                };\n              }\n              r && Object.defineProperties(t.prototype, i);\n            }\n          }\n        }), v.generateConstructor = function (t) {\n          return function (e) {\n            for (var r, i = 0; i < t.fieldsArray.length; i++) (r = t._fieldsArray[i]).map ? this[r.name] = {} : r.repeated && (this[r.name] = []);\n            if (e) for (var n = Object.keys(e), s = 0; s < n.length; ++s) null != e[n[s]] && (this[n[s]] = e[n[s]]);\n          };\n        }, v.fromJSON = function (t, e) {\n          var r = new v(t, e.options);\n          r.extensions = e.extensions, r.reserved = e.reserved;\n          for (var s = Object.keys(e.fields), a = 0; a < s.length; ++a) r.add((void 0 !== e.fields[s[a]].keyType ? p.fromJSON : n.fromJSON)(s[a], e.fields[s[a]]));\n          if (e.oneofs) for (s = Object.keys(e.oneofs), a = 0; a < s.length; ++a) r.add(o.fromJSON(s[a], e.oneofs[s[a]]));\n          if (e.nested) for (s = Object.keys(e.nested), a = 0; a < s.length; ++a) {\n            var h = e.nested[s[a]];\n            r.add((void 0 !== h.id ? n.fromJSON : void 0 !== h.fields ? v.fromJSON : void 0 !== h.values ? i.fromJSON : void 0 !== h.methods ? f.fromJSON : y.fromJSON)(s[a], h));\n          }\n          return e.extensions && e.extensions.length && (r.extensions = e.extensions), e.reserved && e.reserved.length && (r.reserved = e.reserved), e.group && (r.group = !0), e.comment && (r.comment = e.comment), r;\n        }, v.prototype.toJSON = function (t) {\n          var e = y.prototype.toJSON.call(this, t),\n            r = !!t && Boolean(t.keepComments);\n          return {\n            options: e && e.options || void 0,\n            oneofs: y.arrayToJSON(this.oneofsArray, t),\n            fields: y.arrayToJSON(this.fieldsArray.filter(function (t) {\n              return !t.declaringField;\n            }), t) || {},\n            extensions: this.extensions && this.extensions.length ? this.extensions : void 0,\n            reserved: this.reserved && this.reserved.length ? this.reserved : void 0,\n            group: this.group || void 0,\n            nested: e && e.nested || void 0,\n            comment: r ? this.comment : void 0\n          };\n        }, v.prototype.resolveAll = function () {\n          for (var t = this.fieldsArray, e = 0; e < t.length;) t[e++].resolve();\n          var r = this.oneofsArray;\n          for (e = 0; e < r.length;) r[e++].resolve();\n          return y.prototype.resolveAll.call(this);\n        }, v.prototype.get = function (t) {\n          return this.fields[t] || this.oneofs && this.oneofs[t] || this.nested && this.nested[t] || null;\n        }, v.prototype.add = function (t) {\n          if (this.get(t.name)) throw Error(\"duplicate name '\" + t.name + \"' in \" + this);\n          if (t instanceof n && void 0 === t.extend) {\n            if (this._fieldsById && this._fieldsById[t.id]) throw Error(\"duplicate id \" + t.id + \" in \" + this);\n            if (this.isReservedId(t.id)) throw Error(\"id \" + t.id + \" is reserved in \" + this);\n            if (this.isReservedName(t.name)) throw Error(\"name '\" + t.name + \"' is reserved in \" + this);\n            return t.parent && t.parent.remove(t), this.fields[t.name] = t, t.message = this, t.onAdd(this), g(this);\n          }\n          return t instanceof o ? (this.oneofs || (this.oneofs = {}), this.oneofs[t.name] = t, t.onAdd(this), g(this)) : y.prototype.add.call(this, t);\n        }, v.prototype.remove = function (t) {\n          if (t instanceof n && void 0 === t.extend) {\n            if (!this.fields || this.fields[t.name] !== t) throw Error(t + \" is not a member of \" + this);\n            return delete this.fields[t.name], t.parent = null, t.onRemove(this), g(this);\n          }\n          if (t instanceof o) {\n            if (!this.oneofs || this.oneofs[t.name] !== t) throw Error(t + \" is not a member of \" + this);\n            return delete this.oneofs[t.name], t.parent = null, t.onRemove(this), g(this);\n          }\n          return y.prototype.remove.call(this, t);\n        }, v.prototype.isReservedId = function (t) {\n          return y.isReservedId(this.reserved, t);\n        }, v.prototype.isReservedName = function (t) {\n          return y.isReservedName(this.reserved, t);\n        }, v.prototype.create = function (t) {\n          return new this.ctor(t);\n        }, v.prototype.setup = function () {\n          for (var t = this.fullName, e = [], r = 0; r < this.fieldsArray.length; ++r) e.push(this._fieldsArray[r].resolve().resolvedType);\n          this.decode = l(this)({\n            Reader: a,\n            types: e,\n            util: h\n          }), this.verify = u(this)({\n            types: e,\n            util: h\n          }), this.fromObject = d.fromObject(this)({\n            types: e,\n            util: h\n          }), this.toObject = d.toObject(this)({\n            types: e,\n            util: h\n          });\n          var i = c[t];\n          if (i) {\n            var n = Object.create(this);\n            n.fromObject = this.fromObject, this.fromObject = i.fromObject.bind(n), n.toObject = this.toObject, this.toObject = i.toObject.bind(n);\n          }\n          return this;\n        }, v.prototype.encode = function (t, e) {\n          return this.setup().encode(t, e);\n        }, v.prototype.encodeDelimited = function (t, e) {\n          return this.encode(t, e && e.len ? e.fork() : e).ldelim();\n        }, v.prototype.decode = function (t, e) {\n          return this.setup().decode(t, e);\n        }, v.prototype.decodeDelimited = function (t) {\n          return t instanceof a || (t = a.create(t)), this.decode(t, t.uint32());\n        }, v.prototype.verify = function (t) {\n          return this.setup().verify(t);\n        }, v.prototype.fromObject = function (t) {\n          return this.setup().fromObject(t);\n        }, v.prototype.toObject = function (t, e) {\n          return this.setup().toObject(t, e);\n        }, v.d = function (t) {\n          return function (e) {\n            h.decorateType(e, t);\n          };\n        }, v._configure = function () {\n          i = r(421), n = r(238), s = r(853), o = r(803), r(443), a = r(795), h = r(916), u = r(122), l = r(910), f = r(673), c = r(432), d = r(954), p = r(718);\n        };\n      },\n      471: (t, e, r) => {\n        \"use strict\";\n\n        var i = t.exports,\n          n = r(916),\n          s = [\"double\", \"float\", \"int32\", \"uint32\", \"sint32\", \"fixed32\", \"sfixed32\", \"int64\", \"uint64\", \"sint64\", \"fixed64\", \"sfixed64\", \"bool\", \"string\", \"bytes\"];\n        function o(t, e) {\n          var r = 0,\n            i = {};\n          for (e |= 0; r < t.length;) i[s[r + e]] = t[r++];\n          return i;\n        }\n        i.basic = o([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), i.defaults = o([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, \"\", n.emptyArray, null]), i.long = o([0, 0, 0, 1, 1], 7), i.mapKey = o([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), i.packed = o([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]), i._configure = function () {\n          n = r(916);\n        };\n      },\n      187: t => {\n        \"use strict\";\n\n        var e = t.exports;\n        e.length = function (t) {\n          for (var e = 0, r = 0, i = 0; i < t.length; ++i) (r = t.charCodeAt(i)) < 128 ? e += 1 : r < 2048 ? e += 2 : 55296 == (64512 & r) && 56320 == (64512 & t.charCodeAt(i + 1)) ? (++i, e += 4) : e += 3;\n          return e;\n        }, e.read = function (t, e, r) {\n          if (r - e < 1) return \"\";\n          for (var i, n = null, s = [], o = 0; e < r;) (i = t[e++]) < 128 ? s[o++] = i : i > 191 && i < 224 ? s[o++] = (31 & i) << 6 | 63 & t[e++] : i > 239 && i < 365 ? (i = ((7 & i) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536, s[o++] = 55296 + (i >> 10), s[o++] = 56320 + (1023 & i)) : s[o++] = (15 & i) << 12 | (63 & t[e++]) << 6 | 63 & t[e++], o > 8191 && ((n || (n = [])).push(String.fromCharCode.apply(String, s)), o = 0);\n          return n ? (o && n.push(String.fromCharCode.apply(String, s.slice(0, o))), n.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, o));\n        }, e.write = function (t, e, r) {\n          for (var i, n, s = r, o = 0; o < t.length; ++o) (i = t.charCodeAt(o)) < 128 ? e[r++] = i : i < 2048 ? (e[r++] = i >> 6 | 192, e[r++] = 63 & i | 128) : 55296 == (64512 & i) && 56320 == (64512 & (n = t.charCodeAt(o + 1))) ? (i = 65536 + ((1023 & i) << 10) + (1023 & n), ++o, e[r++] = i >> 18 | 240, e[r++] = i >> 12 & 63 | 128, e[r++] = i >> 6 & 63 | 128, e[r++] = 63 & i | 128) : (e[r++] = i >> 12 | 224, e[r++] = i >> 6 & 63 | 128, e[r++] = 63 & i | 128);\n          return r - s;\n        };\n      },\n      916: (t, e, r) => {\n        var i = r(535).default,\n          n = t.exports,\n          s = r(587);\n        n.LongBits = r(218), n.Long = r(470), n.pool = r(266), n.float = r(620), n.asPromise = r(347), n.EventEmitter = r(770), n.path = r(915), n.base64 = r(203), n.utf8 = r(187), n.compareFieldsById = function (t, e) {\n          return t.id - e.id;\n        }, n.toArray = function (t) {\n          if (t) {\n            for (var e = Object.keys(t), r = new Array(e.length), i = 0; i < e.length;) r[i] = t[e[i++]];\n            return r;\n          }\n          return [];\n        }, n.toObject = function (t) {\n          for (var e = {}, r = 0; r < t.length;) {\n            var i = t[r++],\n              n = t[r++];\n            void 0 !== n && (e[i] = n);\n          }\n          return e;\n        }, n.isString = function (t) {\n          return \"string\" == typeof t || t instanceof String;\n        }, n.isReserved = function (t) {\n          return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(t);\n        }, n.isObject = function (t) {\n          return t && \"object\" === i(t);\n        }, n.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, n.oneOfGetter = function (t) {\n          for (var e = {}, r = 0; r < t.length; ++r) e[t[r]] = 1;\n          return function () {\n            for (var t = Object.keys(this), r = t.length - 1; r > -1; --r) if (1 === e[t[r]] && void 0 !== this[t[r]] && null !== this[t[r]]) return t[r];\n          };\n        }, n.oneOfSetter = function (t) {\n          return function (e) {\n            for (var r = 0; r < t.length; ++r) t[r] !== e && delete this[t[r]];\n          };\n        }, n.merge = function (t, e, r) {\n          for (var i = Object.keys(e), n = 0; n < i.length; ++n) void 0 !== t[i[n]] && r || (t[i[n]] = e[i[n]]);\n          return t;\n        }, n.decorateType = function (t, e) {\n          if (t.$type) return e && t.$type.name !== e && (n.decorateRoot.remove(t.$type), t.$type.name = e, n.decorateRoot.add(t.$type)), t.$type;\n          Type || (Type = r(24));\n          var i = new Type(e || t.name);\n          return n.decorateRoot.add(i), i.ctor = t, Object.defineProperty(t, \"$type\", {\n            value: i,\n            enumerable: !1\n          }), Object.defineProperty(t.prototype, \"$type\", {\n            value: i,\n            enumerable: !1\n          }), i;\n        }, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.longToHash = function (t) {\n          return t ? n.LongBits.from(t).toHash() : n.LongBits.zeroHash;\n        }, n.copy = function (t) {\n          if (\"object\" != i(t)) return t;\n          var e = {};\n          for (var r in t) e[r] = t[r];\n          return e;\n        }, n.deepCopy = function t(e) {\n          if (\"object\" != i(e)) return e;\n          var r = {};\n          for (var n in e) r[n] = t(e[n]);\n          return r;\n        }, n.ProtocolError = function (t) {\n          function e(t, r) {\n            if (!(this instanceof e)) return new e(t, r);\n            Object.defineProperty(this, \"message\", {\n              get: function () {\n                return t;\n              }\n            }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n              value: new Error().stack || \"\"\n            }), r && merge(this, r);\n          }\n          return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, \"name\", {\n            get: function () {\n              return t;\n            }\n          }), e.prototype.toString = function () {\n            return this.name + \": \" + this.message;\n          }, e;\n        }, n.toJSONOptions = {\n          longs: String,\n          enums: String,\n          bytes: String,\n          json: !0\n        }, n.Buffer = null, n.newBuffer = function (t) {\n          return \"number\" == typeof t ? new n.Array(t) : \"undefined\" == typeof Uint8Array ? t : new Uint8Array(t);\n        }, n.stringToBytes = function (t) {\n          var e,\n            r,\n            i = [];\n          e = t.length;\n          for (var n = 0; n < e; n++) (r = t.charCodeAt(n)) >= 65536 && r <= 1114111 ? (i.push(r >> 18 & 7 | 240), i.push(r >> 12 & 63 | 128), i.push(r >> 6 & 63 | 128), i.push(63 & r | 128)) : r >= 2048 && r <= 65535 ? (i.push(r >> 12 & 15 | 224), i.push(r >> 6 & 63 | 128), i.push(63 & r | 128)) : r >= 128 && r <= 2047 ? (i.push(r >> 6 & 31 | 192), i.push(63 & r | 128)) : i.push(255 & r);\n          return i;\n        }, n.byteToString = function (t) {\n          if (\"string\" == typeof t) return t;\n          for (var e = \"\", r = t, i = 0; i < r.length; i++) {\n            var n = r[i].toString(2),\n              s = n.match(/^1+?(?=0)/);\n            if (s && 8 == n.length) {\n              for (var o = s[0].length, a = r[i].toString(2).slice(7 - o), h = 1; h < o; h++) a += r[h + i].toString(2).slice(2);\n              e += String.fromCharCode(parseInt(a, 2)), i += o - 1;\n            } else e += String.fromCharCode(r[i]);\n          }\n          return e;\n        }, n.isInteger = Number.isInteger || function (t) {\n          return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n        }, Object.defineProperty(n, \"decorateRoot\", {\n          get: function () {\n            return s.decorated || (s.decorated = new (r(572))());\n          }\n        });\n      },\n      122: (t, e, r) => {\n        var i,\n          n,\n          s = r(535).default;\n        function o(t, e) {\n          return t.name + \": \" + e + (t.repeated && \"array\" !== e ? \"[]\" : t.map && \"object\" !== e ? \"{k:\" + t.keyType + \"}\" : \"\") + \" expected\";\n        }\n        function a(t, e, r, s) {\n          var a = s.types;\n          if (t.resolvedType) {\n            if (t.resolvedType instanceof i) {\n              if (Object.keys(t.resolvedType.values).indexOf(r) < 0) return o(t, \"enum value\");\n            } else {\n              var h = a[e].verify(r);\n              if (h) return t.name + \".\" + h;\n            }\n          } else switch (t.type) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n              if (!n.isInteger(r)) return o(t, \"integer\");\n              break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n              if (!(n.isInteger(r) || r && n.isInteger(r.low) && n.isInteger(r.high))) return o(t, \"integer|Long\");\n              break;\n            case \"float\":\n            case \"double\":\n              if (\"number\" != typeof r) return o(t, \"number\");\n              break;\n            case \"bool\":\n              if (\"boolean\" != typeof r) return o(t, \"boolean\");\n              break;\n            case \"string\":\n              if (!n.isString(r)) return o(t, \"string\");\n              break;\n            case \"bytes\":\n              if (!(r && \"number\" == typeof r.length || n.isString(r))) return o(t, \"buffer\");\n          }\n        }\n        function h(t, e) {\n          switch (t.keyType) {\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n              if (!n.key32Re.test(e)) return o(t, \"integer key\");\n              break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n              if (!n.key64Re.test(e)) return o(t, \"integer|Long key\");\n              break;\n            case \"bool\":\n              if (!n.key2Re.test(e)) return o(t, \"boolean key\");\n          }\n        }\n        function u(t) {\n          return function (e) {\n            return function (r) {\n              var i;\n              if (\"object\" !== s(r) || null === r) return \"object expected\";\n              var u,\n                l = {};\n              t.oneofsArray.length && (u = {});\n              for (var f = 0; f < t.fieldsArray.length; ++f) {\n                var c,\n                  d = t._fieldsArray[f].resolve(),\n                  p = r[d.name];\n                if (!d.optional || null != p && r.hasOwnProperty(d.name)) if (d.map) {\n                  if (!n.isObject(p)) return o(d, \"object\");\n                  var y = Object.keys(p);\n                  for (c = 0; c < y.length; ++c) {\n                    if (i = h(d, y[c])) return i;\n                    if (i = a(d, f, p[y[c]], e)) return i;\n                  }\n                } else if (d.repeated) {\n                  if (!Array.isArray(p)) return o(d, \"array\");\n                  for (c = 0; c < p.length; ++c) if (i = a(d, f, p[c], e)) return i;\n                } else {\n                  if (d.partOf) {\n                    var v = d.partOf.name;\n                    if (1 === l[d.partOf.name] && 1 === u[v]) return d.partOf.name + \": multiple values\";\n                    u[v] = 1;\n                  }\n                  if (i = a(d, f, p, e)) return i;\n                }\n              }\n            };\n          };\n        }\n        t.exports = u, u._configure = function () {\n          i = r(421), n = r(916);\n        };\n      },\n      432: (t, e, r) => {\n        var i,\n          n = e;\n        n[\".google.protobuf.Any\"] = {\n          fromObject: function (t) {\n            if (t && t[\"@type\"]) {\n              var e = this.lookup(t[\"@type\"]);\n              if (e) {\n                var r = \".\" === t[\"@type\"].charAt(0) ? t[\"@type\"].substr(1) : t[\"@type\"];\n                return this.create({\n                  type_url: \"/\" + r,\n                  value: e.encode(e.fromObject(t)).finish()\n                });\n              }\n            }\n            return this.fromObject(t);\n          },\n          toObject: function (t, e) {\n            if (e && e.json && t.type_url && t.value) {\n              var r = t.type_url.substring(t.type_url.lastIndexOf(\"/\") + 1),\n                n = this.lookup(r);\n              n && (t = n.decode(t.value));\n            }\n            if (!(t instanceof this.ctor) && t instanceof i) {\n              var s = t.$type.toObject(t, e);\n              return s[\"@type\"] = t.$type.fullName, s;\n            }\n            return this.toObject(t, e);\n          }\n        }, n._configure = function () {\n          i = r(853);\n        };\n      },\n      443: (t, e, r) => {\n        t.exports = u;\n        var i,\n          n = r(916),\n          s = r(187);\n        function o(t, e, r) {\n          this.fn = t, this.len = e, this.next = void 0, this.val = r;\n        }\n        function a() {}\n        function h(t) {\n          this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;\n        }\n        function u() {\n          this.len = 0, this.head = new o(a, 0, 0), this.tail = this.head, this.states = null;\n        }\n        function l(t, e, r) {\n          e[r] = 255 & t;\n        }\n        function f(t, e) {\n          this.len = t, this.next = void 0, this.val = e;\n        }\n        function c(t, e, r) {\n          for (; t.hi;) e[r++] = 127 & t.lo | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;\n          for (; t.lo > 127;) e[r++] = 127 & t.lo | 128, t.lo = t.lo >>> 7;\n          e[r++] = t.lo;\n        }\n        function d(t, e, r) {\n          e[r] = 255 & t, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;\n        }\n        u.create = n.Buffer ? function () {\n          return (u.create = function () {\n            return new (void 0)();\n          })();\n        } : function () {\n          return new u();\n        }, u.alloc = function (t) {\n          return new n.Array(t);\n        }, n.Array !== Array && (u.alloc = n.pool(u.alloc, n.Array.prototype.subarray)), u.prototype._push = function (t, e, r) {\n          return this.tail = this.tail.next = new o(t, e, r), this.len += e, this;\n        }, f.prototype = Object.create(o.prototype), f.prototype.fn = function (t, e, r) {\n          for (; t > 127;) e[r++] = 127 & t | 128, t >>>= 7;\n          e[r] = t;\n        }, u.prototype.uint32 = function (t) {\n          return this.len += (this.tail = this.tail.next = new f((t >>>= 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5, t)).len, this;\n        }, u.prototype.int32 = function (t) {\n          return t < 0 ? this._push(c, 10, i.fromNumber(t)) : this.uint32(t);\n        }, u.prototype.sint32 = function (t) {\n          return this.uint32((t << 1 ^ t >> 31) >>> 0);\n        }, u.prototype.uint64 = function (t) {\n          var e = i.from(t);\n          return this._push(c, e.length(), e);\n        }, u.prototype.int64 = u.prototype.uint64, u.prototype.sint64 = function (t) {\n          var e = i.from(t).zzEncode();\n          return this._push(c, e.length(), e);\n        }, u.prototype.bool = function (t) {\n          return this._push(l, 1, t ? 1 : 0);\n        }, u.prototype.fixed32 = function (t) {\n          return this._push(d, 4, t >>> 0);\n        }, u.prototype.sfixed32 = u.prototype.fixed32, u.prototype.fixed64 = function (t) {\n          var e = i.from(t);\n          return this._push(d, 4, e.lo)._push(d, 4, e.hi);\n        }, u.prototype.sfixed64 = u.prototype.fixed64, u.prototype.float = function (t) {\n          return this._push(n.float.writeFloatLE, 4, t);\n        }, u.prototype.double = function (t) {\n          return this._push(n.float.writeDoubleLE, 8, t);\n        };\n        var p = n.Array.prototype.set ? function (t, e, r) {\n          e.set(t, r);\n        } : function (t, e, r) {\n          for (var i = 0; i < t.length; ++i) e[r + i] = t[i];\n        };\n        u.prototype.bytes = function (t) {\n          var e = t.length >>> 0;\n          if (!e) return this._push(l, 1, 0);\n          if (n.isString(t)) {\n            var r = u.alloc(e = s.length(t));\n            s.write(t, r, 0), t = r;\n          }\n          return this.uint32(e)._push(p, e, t);\n        }, u.prototype.string = function (t) {\n          var e = s.length(t);\n          return e ? this.uint32(e)._push(s.write, e, t) : this._push(l, 1, 0);\n        }, u.prototype.fork = function () {\n          return this.states = new h(this), this.head = this.tail = new o(a, 0, 0), this.len = 0, this;\n        }, u.prototype.reset = function () {\n          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new o(a, 0, 0), this.len = 0), this;\n        }, u.prototype.ldelim = function () {\n          var t = this.head,\n            e = this.tail,\n            r = this.len;\n          return this.reset().uint32(r), r && (this.tail.next = t.next, this.tail = e, this.len += r), this;\n        }, u.prototype.finish = function () {\n          for (var t = this.head.next, e = this.constructor.alloc(this.len), r = 0; t;) t.fn(t.val, e, r), r += t.len, t = t.next;\n          return e;\n        }, u._configure = function () {\n          i = r(218), r(203), s = r(187);\n        };\n      },\n      535: t => {\n        function e(r) {\n          return t.exports = e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n            return typeof t;\n          } : function (t) {\n            return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n          }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r);\n        }\n        t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;\n      }\n    },\n    e = {};\n  function r(i) {\n    var n = e[i];\n    if (void 0 !== n) return n.exports;\n    var s = e[i] = {\n      exports: {}\n    };\n    return t[i](s, s.exports, r), s.exports;\n  }\n  r.d = (t, e) => {\n    for (var i in e) r.o(e, i) && !r.o(t, i) && Object.defineProperty(t, i, {\n      enumerable: !0,\n      get: e[i]\n    });\n  }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  };\n  var i = {};\n  return (() => {\n    \"use strict\";\n\n    function t(e) {\n      return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, t(e);\n    }\n    function e() {\n      e = function () {\n        return i;\n      };\n      var r,\n        i = {},\n        n = Object.prototype,\n        s = n.hasOwnProperty,\n        o = Object.defineProperty || function (t, e, r) {\n          t[e] = r.value;\n        },\n        a = \"function\" == typeof Symbol ? Symbol : {},\n        h = a.iterator || \"@@iterator\",\n        u = a.asyncIterator || \"@@asyncIterator\",\n        l = a.toStringTag || \"@@toStringTag\";\n      function f(t, e, r) {\n        return Object.defineProperty(t, e, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }), t[e];\n      }\n      try {\n        f({}, \"\");\n      } catch (r) {\n        f = function (t, e, r) {\n          return t[e] = r;\n        };\n      }\n      function c(t, e, r, i) {\n        var n = e && e.prototype instanceof _ ? e : _,\n          s = Object.create(n.prototype),\n          a = new N(i || []);\n        return o(s, \"_invoke\", {\n          value: T(t, r, a)\n        }), s;\n      }\n      function d(t, e, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: t.call(e, r)\n          };\n        } catch (t) {\n          return {\n            type: \"throw\",\n            arg: t\n          };\n        }\n      }\n      i.wrap = c;\n      var p = \"suspendedStart\",\n        y = \"suspendedYield\",\n        v = \"executing\",\n        g = \"completed\",\n        m = {};\n      function _() {}\n      function w() {}\n      function b() {}\n      var x = {};\n      f(x, h, function () {\n        return this;\n      });\n      var k = Object.getPrototypeOf,\n        A = k && k(k(F([])));\n      A && A !== n && s.call(A, h) && (x = A);\n      var S = b.prototype = _.prototype = Object.create(x);\n      function O(t) {\n        [\"next\", \"throw\", \"return\"].forEach(function (e) {\n          f(t, e, function (t) {\n            return this._invoke(e, t);\n          });\n        });\n      }\n      function E(e, r) {\n        function i(n, o, a, h) {\n          var u = d(e[n], e, o);\n          if (\"throw\" !== u.type) {\n            var l = u.arg,\n              f = l.value;\n            return f && \"object\" == t(f) && s.call(f, \"__await\") ? r.resolve(f.__await).then(function (t) {\n              i(\"next\", t, a, h);\n            }, function (t) {\n              i(\"throw\", t, a, h);\n            }) : r.resolve(f).then(function (t) {\n              l.value = t, a(l);\n            }, function (t) {\n              return i(\"throw\", t, a, h);\n            });\n          }\n          h(u.arg);\n        }\n        var n;\n        o(this, \"_invoke\", {\n          value: function (t, e) {\n            function s() {\n              return new r(function (r, n) {\n                i(t, e, r, n);\n              });\n            }\n            return n = n ? n.then(s, s) : s();\n          }\n        });\n      }\n      function T(t, e, i) {\n        var n = p;\n        return function (s, o) {\n          if (n === v) throw Error(\"Generator is already running\");\n          if (n === g) {\n            if (\"throw\" === s) throw o;\n            return {\n              value: r,\n              done: !0\n            };\n          }\n          for (i.method = s, i.arg = o;;) {\n            var a = i.delegate;\n            if (a) {\n              var h = z(a, i);\n              if (h) {\n                if (h === m) continue;\n                return h;\n              }\n            }\n            if (\"next\" === i.method) i.sent = i._sent = i.arg;else if (\"throw\" === i.method) {\n              if (n === p) throw n = g, i.arg;\n              i.dispatchException(i.arg);\n            } else \"return\" === i.method && i.abrupt(\"return\", i.arg);\n            n = v;\n            var u = d(t, e, i);\n            if (\"normal\" === u.type) {\n              if (n = i.done ? g : y, u.arg === m) continue;\n              return {\n                value: u.arg,\n                done: i.done\n              };\n            }\n            \"throw\" === u.type && (n = g, i.method = \"throw\", i.arg = u.arg);\n          }\n        };\n      }\n      function z(t, e) {\n        var i = e.method,\n          n = t.iterator[i];\n        if (n === r) return e.delegate = null, \"throw\" === i && t.iterator.return && (e.method = \"return\", e.arg = r, z(t, e), \"throw\" === e.method) || \"return\" !== i && (e.method = \"throw\", e.arg = new TypeError(\"The iterator does not provide a '\" + i + \"' method\")), m;\n        var s = d(n, t.iterator, e.arg);\n        if (\"throw\" === s.type) return e.method = \"throw\", e.arg = s.arg, e.delegate = null, m;\n        var o = s.arg;\n        return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, \"return\" !== e.method && (e.method = \"next\", e.arg = r), e.delegate = null, m) : o : (e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, m);\n      }\n      function B(t) {\n        var e = {\n          tryLoc: t[0]\n        };\n        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n      }\n      function I(t) {\n        var e = t.completion || {};\n        e.type = \"normal\", delete e.arg, t.completion = e;\n      }\n      function N(t) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], t.forEach(B, this), this.reset(!0);\n      }\n      function F(e) {\n        if (e || \"\" === e) {\n          var i = e[h];\n          if (i) return i.call(e);\n          if (\"function\" == typeof e.next) return e;\n          if (!isNaN(e.length)) {\n            var n = -1,\n              o = function t() {\n                for (; ++n < e.length;) if (s.call(e, n)) return t.value = e[n], t.done = !1, t;\n                return t.value = r, t.done = !0, t;\n              };\n            return o.next = o;\n          }\n        }\n        throw new TypeError(t(e) + \" is not iterable\");\n      }\n      return w.prototype = b, o(S, \"constructor\", {\n        value: b,\n        configurable: !0\n      }), o(b, \"constructor\", {\n        value: w,\n        configurable: !0\n      }), w.displayName = f(b, l, \"GeneratorFunction\"), i.isGeneratorFunction = function (t) {\n        var e = \"function\" == typeof t && t.constructor;\n        return !!e && (e === w || \"GeneratorFunction\" === (e.displayName || e.name));\n      }, i.mark = function (t) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(t, b) : (t.__proto__ = b, f(t, l, \"GeneratorFunction\")), t.prototype = Object.create(S), t;\n      }, i.awrap = function (t) {\n        return {\n          __await: t\n        };\n      }, O(E.prototype), f(E.prototype, u, function () {\n        return this;\n      }), i.AsyncIterator = E, i.async = function (t, e, r, n, s) {\n        void 0 === s && (s = Promise);\n        var o = new E(c(t, e, r, n), s);\n        return i.isGeneratorFunction(e) ? o : o.next().then(function (t) {\n          return t.done ? t.value : o.next();\n        });\n      }, O(S), f(S, l, \"Generator\"), f(S, h, function () {\n        return this;\n      }), f(S, \"toString\", function () {\n        return \"[object Generator]\";\n      }), i.keys = function (t) {\n        var e = Object(t),\n          r = [];\n        for (var i in e) r.push(i);\n        return r.reverse(), function t() {\n          for (; r.length;) {\n            var i = r.pop();\n            if (i in e) return t.value = i, t.done = !1, t;\n          }\n          return t.done = !0, t;\n        };\n      }, i.values = F, N.prototype = {\n        constructor: N,\n        reset: function (t) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = r, this.tryEntries.forEach(I), !t) for (var e in this) \"t\" === e.charAt(0) && s.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = r);\n        },\n        stop: function () {\n          this.done = !0;\n          var t = this.tryEntries[0].completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function (t) {\n          if (this.done) throw t;\n          var e = this;\n          function i(i, n) {\n            return a.type = \"throw\", a.arg = t, e.next = i, n && (e.method = \"next\", e.arg = r), !!n;\n          }\n          for (var n = this.tryEntries.length - 1; n >= 0; --n) {\n            var o = this.tryEntries[n],\n              a = o.completion;\n            if (\"root\" === o.tryLoc) return i(\"end\");\n            if (o.tryLoc <= this.prev) {\n              var h = s.call(o, \"catchLoc\"),\n                u = s.call(o, \"finallyLoc\");\n              if (h && u) {\n                if (this.prev < o.catchLoc) return i(o.catchLoc, !0);\n                if (this.prev < o.finallyLoc) return i(o.finallyLoc);\n              } else if (h) {\n                if (this.prev < o.catchLoc) return i(o.catchLoc, !0);\n              } else {\n                if (!u) throw Error(\"try statement without catch or finally\");\n                if (this.prev < o.finallyLoc) return i(o.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function (t, e) {\n          for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n            var i = this.tryEntries[r];\n            if (i.tryLoc <= this.prev && s.call(i, \"finallyLoc\") && this.prev < i.finallyLoc) {\n              var n = i;\n              break;\n            }\n          }\n          n && (\"break\" === t || \"continue\" === t) && n.tryLoc <= e && e <= n.finallyLoc && (n = null);\n          var o = n ? n.completion : {};\n          return o.type = t, o.arg = e, n ? (this.method = \"next\", this.next = n.finallyLoc, m) : this.complete(o);\n        },\n        complete: function (t, e) {\n          if (\"throw\" === t.type) throw t.arg;\n          return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), m;\n        },\n        finish: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), I(r), m;\n          }\n        },\n        catch: function (t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.tryLoc === t) {\n              var i = r.completion;\n              if (\"throw\" === i.type) {\n                var n = i.arg;\n                I(r);\n              }\n              return n;\n            }\n          }\n          throw Error(\"illegal catch attempt\");\n        },\n        delegateYield: function (t, e, i) {\n          return this.delegate = {\n            iterator: F(t),\n            resultName: e,\n            nextLoc: i\n          }, \"next\" === this.method && (this.arg = r), m;\n        }\n      }, i;\n    }\n    function n(t, e, r, i, n, s, o) {\n      try {\n        var a = t[s](o),\n          h = a.value;\n      } catch (t) {\n        return void r(t);\n      }\n      a.done ? e(h) : Promise.resolve(h).then(i, n);\n    }\n    function s(t) {\n      return function () {\n        var e = this,\n          r = arguments;\n        return new Promise(function (i, s) {\n          var o = t.apply(e, r);\n          function a(t) {\n            n(o, i, s, a, h, \"next\", t);\n          }\n          function h(t) {\n            n(o, i, s, a, h, \"throw\", t);\n          }\n          a(void 0);\n        });\n      };\n    }\n    function o(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function a(e) {\n      var r = function (e, r) {\n        if (\"object\" != t(e) || !e) return e;\n        var i = e[Symbol.toPrimitive];\n        if (void 0 !== i) {\n          var n = i.call(e, \"string\");\n          if (\"object\" != t(n)) return n;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return String(e);\n      }(e);\n      return \"symbol\" == t(r) ? r : r + \"\";\n    }\n    function h(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, a(i.key), i);\n      }\n    }\n    function u(t, e, r) {\n      return e && h(t.prototype, e), r && h(t, r), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), t;\n    }\n    function l() {\n      if (\"undefined\" != typeof my) return my;\n      if (\"undefined\" != typeof tt) return tt;\n      if (\"undefined\" != typeof wx) return wx;\n      throw new Error(\"暂不支持当前环境\");\n    }\n    function f(t, e, r) {\n      return (e = a(e)) in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n    var c;\n    r.r(i), r.d(i, {\n      default: () => gi\n    });\n    var d = function () {\n      function t() {\n        o(this, t), f(this, \"_dataLength\", void 0), f(this, \"_bufferLength\", void 0), f(this, \"_state\", new Int32Array(4)), f(this, \"_buffer\", new ArrayBuffer(68)), f(this, \"_buffer8\", void 0), f(this, \"_buffer32\", void 0), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();\n      }\n      return u(t, [{\n        key: \"start\",\n        value: function () {\n          return this._dataLength = 0, this._bufferLength = 0, this._state.set(t.stateIdentity), this;\n        }\n      }, {\n        key: \"appendStr\",\n        value: function (e) {\n          var r,\n            i,\n            n = this._buffer8,\n            s = this._buffer32,\n            o = this._bufferLength;\n          for (i = 0; i < e.length; i += 1) {\n            if ((r = e.charCodeAt(i)) < 128) n[o++] = r;else if (r < 2048) n[o++] = 192 + (r >>> 6), n[o++] = 63 & r | 128;else if (r < 55296 || r > 56319) n[o++] = 224 + (r >>> 12), n[o++] = r >>> 6 & 63 | 128, n[o++] = 63 & r | 128;else {\n              if ((r = 1024 * (r - 55296) + (e.charCodeAt(++i) - 56320) + 65536) > 1114111) throw new Error(\"Unicode standard supports code points up to U+10FFFF\");\n              n[o++] = 240 + (r >>> 18), n[o++] = r >>> 12 & 63 | 128, n[o++] = r >>> 6 & 63 | 128, n[o++] = 63 & r | 128;\n            }\n            o >= 64 && (this._dataLength += 64, t._md5cycle(this._state, s), o -= 64, s[0] = s[16]);\n          }\n          return this._bufferLength = o, this;\n        }\n      }, {\n        key: \"appendAsciiStr\",\n        value: function (e) {\n          for (var r, i = this._buffer8, n = this._buffer32, s = this._bufferLength, o = 0;;) {\n            for (r = Math.min(e.length - o, 64 - s); r--;) i[s++] = e.charCodeAt(o++);\n            if (s < 64) break;\n            this._dataLength += 64, t._md5cycle(this._state, n), s = 0;\n          }\n          return this._bufferLength = s, this;\n        }\n      }, {\n        key: \"appendByteArray\",\n        value: function (e) {\n          for (var r, i = this._buffer8, n = this._buffer32, s = this._bufferLength, o = 0;;) {\n            for (r = Math.min(e.length - o, 64 - s); r--;) i[s++] = e[o++];\n            if (s < 64) break;\n            this._dataLength += 64, t._md5cycle(this._state, n), s = 0;\n          }\n          return this._bufferLength = s, this;\n        }\n      }, {\n        key: \"getState\",\n        value: function () {\n          var t = this,\n            e = t._state;\n          return {\n            buffer: String.fromCharCode.apply(null, t._buffer8),\n            buflen: t._bufferLength,\n            length: t._dataLength,\n            state: [e[0], e[1], e[2], e[3]]\n          };\n        }\n      }, {\n        key: \"setState\",\n        value: function (t) {\n          var e,\n            r = t.buffer,\n            i = t.state,\n            n = this._state;\n          for (this._dataLength = t.length, this._bufferLength = t.buflen, n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], e = 0; e < r.length; e += 1) this._buffer8[e] = r.charCodeAt(e);\n        }\n      }, {\n        key: \"end\",\n        value: function () {\n          var e,\n            r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n            i = this._bufferLength,\n            n = this._buffer8,\n            s = this._buffer32,\n            o = 1 + (i >> 2);\n          if (this._dataLength += i, n[i] = 128, n[i + 1] = n[i + 2] = n[i + 3] = 0, s.set(t.buffer32Identity.subarray(o), o), i > 55 && (t._md5cycle(this._state, s), s.set(t.buffer32Identity)), (e = 8 * this._dataLength) <= 4294967295) s[14] = e;else {\n            var a = e.toString(16).match(/(.*?)(.{0,8})$/);\n            if (null === a) return;\n            var h = parseInt(a[2], 16),\n              u = parseInt(a[1], 16) || 0;\n            s[14] = h, s[15] = u;\n          }\n          return t._md5cycle(this._state, s), r ? this._state : t._hex(this._state);\n        }\n      }], [{\n        key: \"hashStr\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n          return this.onePassHasher.start().appendStr(t).end(e);\n        }\n      }, {\n        key: \"hashAsciiStr\",\n        value: function (t) {\n          var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n          return this.onePassHasher.start().appendAsciiStr(t).end(e);\n        }\n      }, {\n        key: \"_hex\",\n        value: function (e) {\n          var r,\n            i,\n            n,\n            s,\n            o = t.hexChars,\n            a = t.hexOut;\n          for (s = 0; s < 4; s += 1) for (i = 8 * s, r = e[s], n = 0; n < 8; n += 2) a[i + 1 + n] = o.charAt(15 & r), r >>>= 4, a[i + 0 + n] = o.charAt(15 & r), r >>>= 4;\n          return a.join(\"\");\n        }\n      }, {\n        key: \"_md5cycle\",\n        value: function (t, e) {\n          var r = t[0],\n            i = t[1],\n            n = t[2],\n            s = t[3];\n          i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & n | ~i & s) + e[0] - 680876936 | 0) << 7 | r >>> 25) + i | 0) & i | ~r & n) + e[1] - 389564586 | 0) << 12 | s >>> 20) + r | 0) & r | ~s & i) + e[2] + 606105819 | 0) << 17 | n >>> 15) + s | 0) & s | ~n & r) + e[3] - 1044525330 | 0) << 22 | i >>> 10) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & n | ~i & s) + e[4] - 176418897 | 0) << 7 | r >>> 25) + i | 0) & i | ~r & n) + e[5] + 1200080426 | 0) << 12 | s >>> 20) + r | 0) & r | ~s & i) + e[6] - 1473231341 | 0) << 17 | n >>> 15) + s | 0) & s | ~n & r) + e[7] - 45705983 | 0) << 22 | i >>> 10) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & n | ~i & s) + e[8] + 1770035416 | 0) << 7 | r >>> 25) + i | 0) & i | ~r & n) + e[9] - 1958414417 | 0) << 12 | s >>> 20) + r | 0) & r | ~s & i) + e[10] - 42063 | 0) << 17 | n >>> 15) + s | 0) & s | ~n & r) + e[11] - 1990404162 | 0) << 22 | i >>> 10) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & n | ~i & s) + e[12] + 1804603682 | 0) << 7 | r >>> 25) + i | 0) & i | ~r & n) + e[13] - 40341101 | 0) << 12 | s >>> 20) + r | 0) & r | ~s & i) + e[14] - 1502002290 | 0) << 17 | n >>> 15) + s | 0) & s | ~n & r) + e[15] + 1236535329 | 0) << 22 | i >>> 10) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & s | n & ~s) + e[1] - 165796510 | 0) << 5 | r >>> 27) + i | 0) & n | i & ~n) + e[6] - 1069501632 | 0) << 9 | s >>> 23) + r | 0) & i | r & ~i) + e[11] + 643717713 | 0) << 14 | n >>> 18) + s | 0) & r | s & ~r) + e[0] - 373897302 | 0) << 20 | i >>> 12) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & s | n & ~s) + e[5] - 701558691 | 0) << 5 | r >>> 27) + i | 0) & n | i & ~n) + e[10] + 38016083 | 0) << 9 | s >>> 23) + r | 0) & i | r & ~i) + e[15] - 660478335 | 0) << 14 | n >>> 18) + s | 0) & r | s & ~r) + e[4] - 405537848 | 0) << 20 | i >>> 12) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & s | n & ~s) + e[9] + 568446438 | 0) << 5 | r >>> 27) + i | 0) & n | i & ~n) + e[14] - 1019803690 | 0) << 9 | s >>> 23) + r | 0) & i | r & ~i) + e[3] - 187363961 | 0) << 14 | n >>> 18) + s | 0) & r | s & ~r) + e[8] + 1163531501 | 0) << 20 | i >>> 12) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i & s | n & ~s) + e[13] - 1444681467 | 0) << 5 | r >>> 27) + i | 0) & n | i & ~n) + e[2] - 51403784 | 0) << 9 | s >>> 23) + r | 0) & i | r & ~i) + e[7] + 1735328473 | 0) << 14 | n >>> 18) + s | 0) & r | s & ~r) + e[12] - 1926607734 | 0) << 20 | i >>> 12) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i ^ n ^ s) + e[5] - 378558 | 0) << 4 | r >>> 28) + i | 0) ^ i ^ n) + e[8] - 2022574463 | 0) << 11 | s >>> 21) + r | 0) ^ r ^ i) + e[11] + 1839030562 | 0) << 16 | n >>> 16) + s | 0) ^ s ^ r) + e[14] - 35309556 | 0) << 23 | i >>> 9) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i ^ n ^ s) + e[1] - 1530992060 | 0) << 4 | r >>> 28) + i | 0) ^ i ^ n) + e[4] + 1272893353 | 0) << 11 | s >>> 21) + r | 0) ^ r ^ i) + e[7] - 155497632 | 0) << 16 | n >>> 16) + s | 0) ^ s ^ r) + e[10] - 1094730640 | 0) << 23 | i >>> 9) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i ^ n ^ s) + e[13] + 681279174 | 0) << 4 | r >>> 28) + i | 0) ^ i ^ n) + e[0] - 358537222 | 0) << 11 | s >>> 21) + r | 0) ^ r ^ i) + e[3] - 722521979 | 0) << 16 | n >>> 16) + s | 0) ^ s ^ r) + e[6] + 76029189 | 0) << 23 | i >>> 9) + n | 0, i = ((i += ((n = ((n += ((s = ((s += ((r = ((r += (i ^ n ^ s) + e[9] - 640364487 | 0) << 4 | r >>> 28) + i | 0) ^ i ^ n) + e[12] - 421815835 | 0) << 11 | s >>> 21) + r | 0) ^ r ^ i) + e[15] + 530742520 | 0) << 16 | n >>> 16) + s | 0) ^ s ^ r) + e[2] - 995338651 | 0) << 23 | i >>> 9) + n | 0, i = ((i += ((s = ((s += (i ^ ((r = ((r += (n ^ (i | ~s)) + e[0] - 198630844 | 0) << 6 | r >>> 26) + i | 0) | ~n)) + e[7] + 1126891415 | 0) << 10 | s >>> 22) + r | 0) ^ ((n = ((n += (r ^ (s | ~i)) + e[14] - 1416354905 | 0) << 15 | n >>> 17) + s | 0) | ~r)) + e[5] - 57434055 | 0) << 21 | i >>> 11) + n | 0, i = ((i += ((s = ((s += (i ^ ((r = ((r += (n ^ (i | ~s)) + e[12] + 1700485571 | 0) << 6 | r >>> 26) + i | 0) | ~n)) + e[3] - 1894986606 | 0) << 10 | s >>> 22) + r | 0) ^ ((n = ((n += (r ^ (s | ~i)) + e[10] - 1051523 | 0) << 15 | n >>> 17) + s | 0) | ~r)) + e[1] - 2054922799 | 0) << 21 | i >>> 11) + n | 0, i = ((i += ((s = ((s += (i ^ ((r = ((r += (n ^ (i | ~s)) + e[8] + 1873313359 | 0) << 6 | r >>> 26) + i | 0) | ~n)) + e[15] - 30611744 | 0) << 10 | s >>> 22) + r | 0) ^ ((n = ((n += (r ^ (s | ~i)) + e[6] - 1560198380 | 0) << 15 | n >>> 17) + s | 0) | ~r)) + e[13] + 1309151649 | 0) << 21 | i >>> 11) + n | 0, i = ((i += ((s = ((s += (i ^ ((r = ((r += (n ^ (i | ~s)) + e[4] - 145523070 | 0) << 6 | r >>> 26) + i | 0) | ~n)) + e[11] - 1120210379 | 0) << 10 | s >>> 22) + r | 0) ^ ((n = ((n += (r ^ (s | ~i)) + e[2] + 718787259 | 0) << 15 | n >>> 17) + s | 0) | ~r)) + e[9] - 343485551 | 0) << 21 | i >>> 11) + n | 0, t[0] = r + t[0] | 0, t[1] = i + t[1] | 0, t[2] = n + t[2] | 0, t[3] = s + t[3] | 0;\n        }\n      }]);\n    }();\n    c = d, f(d, \"stateIdentity\", new Int32Array([1732584193, -271733879, -1732584194, 271733878])), f(d, \"buffer32Identity\", new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), f(d, \"hexChars\", \"0123456789abcdef\"), f(d, \"hexOut\", []), f(d, \"onePassHasher\", new c()), \"5d41402abc4b2a76b9719d911017c592\" !== d.hashStr(\"hello\") && console.error(\"Md5 self test failed.\");\n    var p = \"\";\n    function y(t) {\n      for (var e, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];\n      (e = console).log.apply(e, [\"[svga]\".concat(t)].concat(i));\n    }\n    function v(t) {\n      return d.hashStr(t) || t;\n    }\n    function g(t) {\n      switch (p) {\n        case \"weapp\":\n          return has.arrayBufferToBase64(t);\n        case \"alipay\":\n          return my.arrayBufferToBase64(t);\n        case \"tt\":\n          return has.arrayBufferToBase64(t);\n        case \"h5\":\n          for (var e = \"\", r = t.byteLength, i = 0; i < r; i++) e += String.fromCharCode(t[i]);\n          return window.btoa(e);\n        default:\n          throw new Error(\"暂不支持当前环境\");\n      }\n    }\n    function m(t) {\n      p = t;\n    }\n    function _() {\n      return p;\n    }\n    function w() {\n      var t = l();\n      return \"\".concat(t.env.USER_DATA_PATH, \"/svga_cache\");\n    }\n    var b = u(function t(e, r, i) {\n        o(this, t), this.d = e, this.transform = r, this.styles = i, f(this, \"_d\", void 0), f(this, \"_transform\", void 0), f(this, \"_styles\", void 0), f(this, \"_shape\", void 0), this._d = e, this._transform = r, this._styles = i;\n      }),\n      x = u(function t(e) {\n        o(this, t), f(this, \"alpha\", 0), f(this, \"transform\", {\n          a: 1,\n          b: 0,\n          c: 0,\n          d: 1,\n          tx: 0,\n          ty: 0\n        }), f(this, \"layout\", {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        }), f(this, \"nx\", 0), f(this, \"ny\", 0), f(this, \"maskPath\", void 0), f(this, \"shapes\", []), this.alpha = parseFloat(e.alpha) || 0, e.layout && (this.layout.x = parseFloat(e.layout.x) || 0, this.layout.y = parseFloat(e.layout.y) || 0, this.layout.width = parseFloat(e.layout.width) || 0, this.layout.height = parseFloat(e.layout.height) || 0), e.transform && (this.transform.a = parseFloat(e.transform.a) || 1, this.transform.b = parseFloat(e.transform.b) || 0, this.transform.c = parseFloat(e.transform.c) || 0, this.transform.d = parseFloat(e.transform.d) || 1, this.transform.tx = parseFloat(e.transform.tx) || 0, this.transform.ty = parseFloat(e.transform.ty) || 0), e.clipPath && e.clipPath.length > 0 && (this.maskPath = new b(e.clipPath, void 0, {\n          fill: \"#000000\"\n        })), e.shapes && (e.shapes instanceof Array && e.shapes.forEach(function (t) {\n          switch (t.pathArgs = t.args, t.type) {\n            case 0:\n              t.type = \"shape\", t.pathArgs = t.shape;\n              break;\n            case 1:\n              t.type = \"rect\", t.pathArgs = t.rect;\n              break;\n            case 2:\n              t.type = \"ellipse\", t.pathArgs = t.ellipse;\n              break;\n            case 3:\n              t.type = \"keep\";\n          }\n          if (t.styles) {\n            t.styles.fill && (\"number\" == typeof t.styles.fill.r && (t.styles.fill[0] = t.styles.fill.r), \"number\" == typeof t.styles.fill.g && (t.styles.fill[1] = t.styles.fill.g), \"number\" == typeof t.styles.fill.b && (t.styles.fill[2] = t.styles.fill.b), \"number\" == typeof t.styles.fill.a && (t.styles.fill[3] = t.styles.fill.a)), t.styles.stroke && (\"number\" == typeof t.styles.stroke.r && (t.styles.stroke[0] = t.styles.stroke.r), \"number\" == typeof t.styles.stroke.g && (t.styles.stroke[1] = t.styles.stroke.g), \"number\" == typeof t.styles.stroke.b && (t.styles.stroke[2] = t.styles.stroke.b), \"number\" == typeof t.styles.stroke.a && (t.styles.stroke[3] = t.styles.stroke.a));\n            var e = t.styles.lineDash || [];\n            switch (t.styles.lineDashI > 0 && e.push(t.styles.lineDashI), t.styles.lineDashII > 0 && (e.length < 1 && e.push(0), e.push(t.styles.lineDashII), e.push(0)), t.styles.lineDashIII > 0 && (e.length < 2 && (e.push(0), e.push(0)), e[2] = t.styles.lineDashIII), t.styles.lineDash = e, t.styles.lineJoin) {\n              case 0:\n                t.styles.lineJoin = \"miter\";\n                break;\n              case 1:\n                t.styles.lineJoin = \"round\";\n                break;\n              case 2:\n                t.styles.lineJoin = \"bevel\";\n            }\n            switch (t.styles.lineCap) {\n              case 0:\n                t.styles.lineCap = \"butt\";\n                break;\n              case 1:\n                t.styles.lineCap = \"round\";\n                break;\n              case 2:\n                t.styles.lineCap = \"square\";\n            }\n          }\n        }), e.shapes[0] && \"keep\" === e.shapes[0].type ? this.shapes = t.lastShapes : (this.shapes = e.shapes, t.lastShapes = e.shapes));\n        var r = this.transform.a * this.layout.x + this.transform.c * this.layout.y + this.transform.tx,\n          i = this.transform.a * (this.layout.x + this.layout.width) + this.transform.c * this.layout.y + this.transform.tx,\n          n = this.transform.a * this.layout.x + this.transform.c * (this.layout.y + this.layout.height) + this.transform.tx,\n          s = this.transform.a * (this.layout.x + this.layout.width) + this.transform.c * (this.layout.y + this.layout.height) + this.transform.tx,\n          a = this.transform.b * this.layout.x + this.transform.d * this.layout.y + this.transform.ty,\n          h = this.transform.b * (this.layout.x + this.layout.width) + this.transform.d * this.layout.y + this.transform.ty,\n          u = this.transform.b * this.layout.x + this.transform.d * (this.layout.y + this.layout.height) + this.transform.ty,\n          l = this.transform.b * (this.layout.x + this.layout.width) + this.transform.d * (this.layout.y + this.layout.height) + this.transform.ty;\n        this.nx = Math.min(Math.min(n, s), Math.min(r, i)), this.ny = Math.min(Math.min(u, l), Math.min(a, h));\n      });\n    f(x, \"lastShapes\", void 0);\n    var k = u(function t(e) {\n        var r, i;\n        o(this, t), f(this, \"matteKey\", void 0), f(this, \"imageKey\", void 0), f(this, \"frames\", void 0), this.matteKey = e.matteKey, this.imageKey = e.imageKey, this.frames = null !== (r = null === (i = e.frames) || void 0 === i ? void 0 : i.map(function (t) {\n          return new x(t);\n        })) && void 0 !== r ? r : [];\n      }),\n      A = u(function t(e, r) {\n        var i, n;\n        o(this, t), this.spec = e, f(this, \"version\", \"2.0.0\"), f(this, \"videoSize\", void 0), f(this, \"src\", void 0), f(this, \"FPS\", void 0), f(this, \"frames\", void 0), f(this, \"sprites\", void 0), f(this, \"animateFrames\", []), f(this, \"decodedImages\", {}), this.version = e.ver, this.videoSize = {\n          width: e.params.viewBoxWidth || 0,\n          height: e.params.viewBoxHeight || 0\n        }, this.FPS = e.params.fps || 20, this.frames = e.params.frames || 0, this.sprites = null !== (i = null === (n = e.sprites) || void 0 === n ? void 0 : n.map(function (t) {\n          return new k(t);\n        })) && void 0 !== i ? i : [], this.src = r;\n      });\n    function S(t) {\n      for (var e = t.length; --e >= 0;) t[e] = 0;\n    }\n    var O = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),\n      E = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),\n      T = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),\n      z = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n      B = new Array(576);\n    S(B);\n    var I = new Array(60);\n    S(I);\n    var N = new Array(512);\n    S(N);\n    var F = new Array(256);\n    S(F);\n    var j = new Array(29);\n    S(j);\n    var L,\n      C,\n      R,\n      D = new Array(30);\n    function M(t, e, r, i, n) {\n      this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = i, this.max_length = n, this.has_stree = t && t.length;\n    }\n    function P(t, e) {\n      this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;\n    }\n    S(D);\n    var U = function (t) {\n        return t < 256 ? N[t] : N[256 + (t >>> 7)];\n      },\n      Z = function (t, e) {\n        t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;\n      },\n      q = function (t, e, r) {\n        t.bi_valid > 16 - r ? (t.bi_buf |= e << t.bi_valid & 65535, Z(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += r - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r);\n      },\n      J = function (t, e, r) {\n        q(t, r[2 * e], r[2 * e + 1]);\n      },\n      V = function (t, e) {\n        var r = 0;\n        do {\n          r |= 1 & t, t >>>= 1, r <<= 1;\n        } while (--e > 0);\n        return r >>> 1;\n      },\n      H = function (t, e, r) {\n        var i,\n          n,\n          s = new Array(16),\n          o = 0;\n        for (i = 1; i <= 15; i++) o = o + r[i - 1] << 1, s[i] = o;\n        for (n = 0; n <= e; n++) {\n          var a = t[2 * n + 1];\n          0 !== a && (t[2 * n] = V(s[a]++, a));\n        }\n      },\n      $ = function (t) {\n        var e;\n        for (e = 0; e < 286; e++) t.dyn_ltree[2 * e] = 0;\n        for (e = 0; e < 30; e++) t.dyn_dtree[2 * e] = 0;\n        for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;\n        t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0;\n      },\n      K = function (t) {\n        t.bi_valid > 8 ? Z(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;\n      },\n      X = function (t, e, r, i) {\n        var n = 2 * e,\n          s = 2 * r;\n        return t[n] < t[s] || t[n] === t[s] && i[e] <= i[r];\n      },\n      Y = function (t, e, r) {\n        for (var i = t.heap[r], n = r << 1; n <= t.heap_len && (n < t.heap_len && X(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !X(e, i, t.heap[n], t.depth));) t.heap[r] = t.heap[n], r = n, n <<= 1;\n        t.heap[r] = i;\n      },\n      G = function (t, e, r) {\n        var i,\n          n,\n          s,\n          o,\n          a = 0;\n        if (0 !== t.sym_next) do {\n          i = 255 & t.pending_buf[t.sym_buf + a++], i += (255 & t.pending_buf[t.sym_buf + a++]) << 8, n = t.pending_buf[t.sym_buf + a++], 0 === i ? J(t, n, e) : (s = F[n], J(t, s + 256 + 1, e), 0 !== (o = O[s]) && (n -= j[s], q(t, n, o)), i--, s = U(i), J(t, s, r), 0 !== (o = E[s]) && (i -= D[s], q(t, i, o)));\n        } while (a < t.sym_next);\n        J(t, 256, e);\n      },\n      W = function (t, e) {\n        var r,\n          i,\n          n,\n          s = e.dyn_tree,\n          o = e.stat_desc.static_tree,\n          a = e.stat_desc.has_stree,\n          h = e.stat_desc.elems,\n          u = -1;\n        for (t.heap_len = 0, t.heap_max = 573, r = 0; r < h; r++) 0 !== s[2 * r] ? (t.heap[++t.heap_len] = u = r, t.depth[r] = 0) : s[2 * r + 1] = 0;\n        for (; t.heap_len < 2;) s[2 * (n = t.heap[++t.heap_len] = u < 2 ? ++u : 0)] = 1, t.depth[n] = 0, t.opt_len--, a && (t.static_len -= o[2 * n + 1]);\n        for (e.max_code = u, r = t.heap_len >> 1; r >= 1; r--) Y(t, s, r);\n        n = h;\n        do {\n          r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], Y(t, s, 1), i = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = i, s[2 * n] = s[2 * r] + s[2 * i], t.depth[n] = (t.depth[r] >= t.depth[i] ? t.depth[r] : t.depth[i]) + 1, s[2 * r + 1] = s[2 * i + 1] = n, t.heap[1] = n++, Y(t, s, 1);\n        } while (t.heap_len >= 2);\n        t.heap[--t.heap_max] = t.heap[1], function (t, e) {\n          var r,\n            i,\n            n,\n            s,\n            o,\n            a,\n            h = e.dyn_tree,\n            u = e.max_code,\n            l = e.stat_desc.static_tree,\n            f = e.stat_desc.has_stree,\n            c = e.stat_desc.extra_bits,\n            d = e.stat_desc.extra_base,\n            p = e.stat_desc.max_length,\n            y = 0;\n          for (s = 0; s <= 15; s++) t.bl_count[s] = 0;\n          for (h[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; r < 573; r++) (s = h[2 * h[2 * (i = t.heap[r]) + 1] + 1] + 1) > p && (s = p, y++), h[2 * i + 1] = s, i > u || (t.bl_count[s]++, o = 0, i >= d && (o = c[i - d]), a = h[2 * i], t.opt_len += a * (s + o), f && (t.static_len += a * (l[2 * i + 1] + o)));\n          if (0 !== y) {\n            do {\n              for (s = p - 1; 0 === t.bl_count[s];) s--;\n              t.bl_count[s]--, t.bl_count[s + 1] += 2, t.bl_count[p]--, y -= 2;\n            } while (y > 0);\n            for (s = p; 0 !== s; s--) for (i = t.bl_count[s]; 0 !== i;) (n = t.heap[--r]) > u || (h[2 * n + 1] !== s && (t.opt_len += (s - h[2 * n + 1]) * h[2 * n], h[2 * n + 1] = s), i--);\n          }\n        }(t, e), H(s, u, t.bl_count);\n      },\n      Q = function (t, e, r) {\n        var i,\n          n,\n          s = -1,\n          o = e[1],\n          a = 0,\n          h = 7,\n          u = 4;\n        for (0 === o && (h = 138, u = 3), e[2 * (r + 1) + 1] = 65535, i = 0; i <= r; i++) n = o, o = e[2 * (i + 1) + 1], ++a < h && n === o || (a < u ? t.bl_tree[2 * n] += a : 0 !== n ? (n !== s && t.bl_tree[2 * n]++, t.bl_tree[32]++) : a <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, a = 0, s = n, 0 === o ? (h = 138, u = 3) : n === o ? (h = 6, u = 3) : (h = 7, u = 4));\n      },\n      et = function (t, e, r) {\n        var i,\n          n,\n          s = -1,\n          o = e[1],\n          a = 0,\n          h = 7,\n          u = 4;\n        for (0 === o && (h = 138, u = 3), i = 0; i <= r; i++) if (n = o, o = e[2 * (i + 1) + 1], !(++a < h && n === o)) {\n          if (a < u) do {\n            J(t, n, t.bl_tree);\n          } while (0 != --a);else 0 !== n ? (n !== s && (J(t, n, t.bl_tree), a--), J(t, 16, t.bl_tree), q(t, a - 3, 2)) : a <= 10 ? (J(t, 17, t.bl_tree), q(t, a - 3, 3)) : (J(t, 18, t.bl_tree), q(t, a - 11, 7));\n          a = 0, s = n, 0 === o ? (h = 138, u = 3) : n === o ? (h = 6, u = 3) : (h = 7, u = 4);\n        }\n      },\n      rt = !1,\n      it = function (t, e, r, i) {\n        q(t, 0 + (i ? 1 : 0), 3), K(t), Z(t, r), Z(t, ~r), r && t.pending_buf.set(t.window.subarray(e, e + r), t.pending), t.pending += r;\n      },\n      nt = function (t) {\n        rt || (function () {\n          var t,\n            e,\n            r,\n            i,\n            n,\n            s = new Array(16);\n          for (r = 0, i = 0; i < 28; i++) for (j[i] = r, t = 0; t < 1 << O[i]; t++) F[r++] = i;\n          for (F[r - 1] = i, n = 0, i = 0; i < 16; i++) for (D[i] = n, t = 0; t < 1 << E[i]; t++) N[n++] = i;\n          for (n >>= 7; i < 30; i++) for (D[i] = n << 7, t = 0; t < 1 << E[i] - 7; t++) N[256 + n++] = i;\n          for (e = 0; e <= 15; e++) s[e] = 0;\n          for (t = 0; t <= 143;) B[2 * t + 1] = 8, t++, s[8]++;\n          for (; t <= 255;) B[2 * t + 1] = 9, t++, s[9]++;\n          for (; t <= 279;) B[2 * t + 1] = 7, t++, s[7]++;\n          for (; t <= 287;) B[2 * t + 1] = 8, t++, s[8]++;\n          for (H(B, 287, s), t = 0; t < 30; t++) I[2 * t + 1] = 5, I[2 * t] = V(t, 5);\n          L = new M(B, O, 257, 286, 15), C = new M(I, E, 0, 30, 15), R = new M(new Array(0), T, 0, 19, 7);\n        }(), rt = !0), t.l_desc = new P(t.dyn_ltree, L), t.d_desc = new P(t.dyn_dtree, C), t.bl_desc = new P(t.bl_tree, R), t.bi_buf = 0, t.bi_valid = 0, $(t);\n      },\n      st = it,\n      ot = function (t, e, r, i) {\n        var n,\n          s,\n          o = 0;\n        t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function (t) {\n          var e,\n            r = 4093624447;\n          for (e = 0; e <= 31; e++, r >>>= 1) if (1 & r && 0 !== t.dyn_ltree[2 * e]) return 0;\n          if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;\n          for (e = 32; e < 256; e++) if (0 !== t.dyn_ltree[2 * e]) return 1;\n          return 0;\n        }(t)), W(t, t.l_desc), W(t, t.d_desc), o = function (t) {\n          var e;\n          for (Q(t, t.dyn_ltree, t.l_desc.max_code), Q(t, t.dyn_dtree, t.d_desc.max_code), W(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * z[e] + 1]; e--);\n          return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;\n        }(t), n = t.opt_len + 3 + 7 >>> 3, (s = t.static_len + 3 + 7 >>> 3) <= n && (n = s)) : n = s = r + 5, r + 4 <= n && -1 !== e ? it(t, e, r, i) : 4 === t.strategy || s === n ? (q(t, 2 + (i ? 1 : 0), 3), G(t, B, I)) : (q(t, 4 + (i ? 1 : 0), 3), function (t, e, r, i) {\n          var n;\n          for (q(t, e - 257, 5), q(t, r - 1, 5), q(t, i - 4, 4), n = 0; n < i; n++) q(t, t.bl_tree[2 * z[n] + 1], 3);\n          et(t, t.dyn_ltree, e - 1), et(t, t.dyn_dtree, r - 1);\n        }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), G(t, t.dyn_ltree, t.dyn_dtree)), $(t), i && K(t);\n      },\n      at = function (t, e, r) {\n        return t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = r, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (F[r] + 256 + 1)]++, t.dyn_dtree[2 * U(e)]++), t.sym_next === t.sym_end;\n      },\n      ht = function (t) {\n        q(t, 2, 3), J(t, 256, B), function (t) {\n          16 === t.bi_valid ? (Z(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);\n        }(t);\n      },\n      ut = function (t, e, r, i) {\n        for (var n = 65535 & t, s = t >>> 16 & 65535, o = 0; 0 !== r;) {\n          r -= o = r > 2e3 ? 2e3 : r;\n          do {\n            s = s + (n = n + e[i++] | 0) | 0;\n          } while (--o);\n          n %= 65521, s %= 65521;\n        }\n        return n | s << 16;\n      },\n      lt = new Uint32Array(function () {\n        for (var t, e = [], r = 0; r < 256; r++) {\n          t = r;\n          for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;\n          e[r] = t;\n        }\n        return e;\n      }()),\n      ft = function (t, e, r, i) {\n        var n = lt,\n          s = i + r;\n        t ^= -1;\n        for (var o = i; o < s; o++) t = t >>> 8 ^ n[255 & (t ^ e[o])];\n        return ~t;\n      },\n      ct = {\n        2: \"need dictionary\",\n        1: \"stream end\",\n        0: \"\",\n        \"-1\": \"file error\",\n        \"-2\": \"stream error\",\n        \"-3\": \"data error\",\n        \"-4\": \"insufficient memory\",\n        \"-5\": \"buffer error\",\n        \"-6\": \"incompatible version\"\n      },\n      dt = {\n        Z_NO_FLUSH: 0,\n        Z_PARTIAL_FLUSH: 1,\n        Z_SYNC_FLUSH: 2,\n        Z_FULL_FLUSH: 3,\n        Z_FINISH: 4,\n        Z_BLOCK: 5,\n        Z_TREES: 6,\n        Z_OK: 0,\n        Z_STREAM_END: 1,\n        Z_NEED_DICT: 2,\n        Z_ERRNO: -1,\n        Z_STREAM_ERROR: -2,\n        Z_DATA_ERROR: -3,\n        Z_MEM_ERROR: -4,\n        Z_BUF_ERROR: -5,\n        Z_NO_COMPRESSION: 0,\n        Z_BEST_SPEED: 1,\n        Z_BEST_COMPRESSION: 9,\n        Z_DEFAULT_COMPRESSION: -1,\n        Z_FILTERED: 1,\n        Z_HUFFMAN_ONLY: 2,\n        Z_RLE: 3,\n        Z_FIXED: 4,\n        Z_DEFAULT_STRATEGY: 0,\n        Z_BINARY: 0,\n        Z_TEXT: 1,\n        Z_UNKNOWN: 2,\n        Z_DEFLATED: 8\n      },\n      pt = nt,\n      yt = st,\n      vt = ot,\n      gt = at,\n      mt = ht,\n      _t = dt.Z_NO_FLUSH,\n      wt = dt.Z_PARTIAL_FLUSH,\n      bt = dt.Z_FULL_FLUSH,\n      xt = dt.Z_FINISH,\n      kt = dt.Z_BLOCK,\n      At = dt.Z_OK,\n      St = dt.Z_STREAM_END,\n      Ot = dt.Z_STREAM_ERROR,\n      Et = dt.Z_DATA_ERROR,\n      Tt = dt.Z_BUF_ERROR,\n      zt = dt.Z_DEFAULT_COMPRESSION,\n      Bt = dt.Z_FILTERED,\n      It = dt.Z_HUFFMAN_ONLY,\n      Nt = dt.Z_RLE,\n      Ft = dt.Z_FIXED,\n      jt = dt.Z_UNKNOWN,\n      Lt = dt.Z_DEFLATED,\n      Ct = 258,\n      Rt = 262,\n      Dt = 42,\n      Mt = 113,\n      Pt = 666,\n      Ut = function (t, e) {\n        return t.msg = ct[e], e;\n      },\n      Zt = function (t) {\n        return 2 * t - (t > 4 ? 9 : 0);\n      },\n      qt = function (t) {\n        for (var e = t.length; --e >= 0;) t[e] = 0;\n      },\n      Jt = function (t) {\n        var e,\n          r,\n          i,\n          n = t.w_size;\n        i = e = t.hash_size;\n        do {\n          r = t.head[--i], t.head[i] = r >= n ? r - n : 0;\n        } while (--e);\n        i = e = n;\n        do {\n          r = t.prev[--i], t.prev[i] = r >= n ? r - n : 0;\n        } while (--e);\n      },\n      Vt = function (t, e, r) {\n        return (e << t.hash_shift ^ r) & t.hash_mask;\n      },\n      Ht = function (t) {\n        var e = t.state,\n          r = e.pending;\n        r > t.avail_out && (r = t.avail_out), 0 !== r && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + r), t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0));\n      },\n      $t = function (t, e) {\n        vt(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Ht(t.strm);\n      },\n      Kt = function (t, e) {\n        t.pending_buf[t.pending++] = e;\n      },\n      Xt = function (t, e) {\n        t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;\n      },\n      Yt = function (t, e, r, i) {\n        var n = t.avail_in;\n        return n > i && (n = i), 0 === n ? 0 : (t.avail_in -= n, e.set(t.input.subarray(t.next_in, t.next_in + n), r), 1 === t.state.wrap ? t.adler = ut(t.adler, e, n, r) : 2 === t.state.wrap && (t.adler = ft(t.adler, e, n, r)), t.next_in += n, t.total_in += n, n);\n      },\n      Gt = function (t, e) {\n        var r,\n          i,\n          n = t.max_chain_length,\n          s = t.strstart,\n          o = t.prev_length,\n          a = t.nice_match,\n          h = t.strstart > t.w_size - Rt ? t.strstart - (t.w_size - Rt) : 0,\n          u = t.window,\n          l = t.w_mask,\n          f = t.prev,\n          c = t.strstart + Ct,\n          d = u[s + o - 1],\n          p = u[s + o];\n        t.prev_length >= t.good_match && (n >>= 2), a > t.lookahead && (a = t.lookahead);\n        do {\n          if (u[(r = e) + o] === p && u[r + o - 1] === d && u[r] === u[s] && u[++r] === u[s + 1]) {\n            s += 2, r++;\n            do {} while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < c);\n            if (i = Ct - (c - s), s = c - Ct, i > o) {\n              if (t.match_start = e, o = i, i >= a) break;\n              d = u[s + o - 1], p = u[s + o];\n            }\n          }\n        } while ((e = f[e & l]) > h && 0 != --n);\n        return o <= t.lookahead ? o : t.lookahead;\n      },\n      Wt = function (t) {\n        var e,\n          r,\n          i,\n          n = t.w_size;\n        do {\n          if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= n + (n - Rt) && (t.window.set(t.window.subarray(n, n + n - r), 0), t.match_start -= n, t.strstart -= n, t.block_start -= n, t.insert > t.strstart && (t.insert = t.strstart), Jt(t), r += n), 0 === t.strm.avail_in) break;\n          if (e = Yt(t.strm, t.window, t.strstart + t.lookahead, r), t.lookahead += e, t.lookahead + t.insert >= 3) for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = Vt(t, t.ins_h, t.window[i + 1]); t.insert && (t.ins_h = Vt(t, t.ins_h, t.window[i + 3 - 1]), t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < 3)););\n        } while (t.lookahead < Rt && 0 !== t.strm.avail_in);\n      },\n      Qt = function (t, e) {\n        var r,\n          i,\n          n,\n          s = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,\n          o = 0,\n          a = t.strm.avail_in;\n        do {\n          if (r = 65535, n = t.bi_valid + 42 >> 3, t.strm.avail_out < n) break;\n          if (n = t.strm.avail_out - n, r > (i = t.strstart - t.block_start) + t.strm.avail_in && (r = i + t.strm.avail_in), r > n && (r = n), r < s && (0 === r && e !== xt || e === _t || r !== i + t.strm.avail_in)) break;\n          o = e === xt && r === i + t.strm.avail_in ? 1 : 0, yt(t, 0, 0, o), t.pending_buf[t.pending - 4] = r, t.pending_buf[t.pending - 3] = r >> 8, t.pending_buf[t.pending - 2] = ~r, t.pending_buf[t.pending - 1] = ~r >> 8, Ht(t.strm), i && (i > r && (i = r), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, r -= i), r && (Yt(t.strm, t.strm.output, t.strm.next_out, r), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r);\n        } while (0 === o);\n        return (a -= t.strm.avail_in) && (a >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= a && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), o ? 4 : e !== _t && e !== xt && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (n = t.window_size - t.strstart, t.strm.avail_in > n && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, n += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), n > t.strm.avail_in && (n = t.strm.avail_in), n && (Yt(t.strm, t.window, t.strstart, n), t.strstart += n, t.insert += n > t.w_size - t.insert ? t.w_size - t.insert : n), t.high_water < t.strstart && (t.high_water = t.strstart), n = t.bi_valid + 42 >> 3, s = (n = t.pending_buf_size - n > 65535 ? 65535 : t.pending_buf_size - n) > t.w_size ? t.w_size : n, ((i = t.strstart - t.block_start) >= s || (i || e === xt) && e !== _t && 0 === t.strm.avail_in && i <= n) && (r = i > n ? n : i, o = e === xt && 0 === t.strm.avail_in && r === i ? 1 : 0, yt(t, t.block_start, r, o), t.block_start += r, Ht(t.strm)), o ? 3 : 1);\n      },\n      te = function (t, e) {\n        for (var r, i;;) {\n          if (t.lookahead < Rt) {\n            if (Wt(t), t.lookahead < Rt && e === _t) return 1;\n            if (0 === t.lookahead) break;\n          }\n          if (r = 0, t.lookahead >= 3 && (t.ins_h = Vt(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - Rt && (t.match_length = Gt(t, r)), t.match_length >= 3) {\n            if (i = gt(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) {\n              t.match_length--;\n              do {\n                t.strstart++, t.ins_h = Vt(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;\n              } while (0 != --t.match_length);\n              t.strstart++;\n            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Vt(t, t.ins_h, t.window[t.strstart + 1]);\n          } else i = gt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;\n          if (i && ($t(t, !1), 0 === t.strm.avail_out)) return 1;\n        }\n        return t.insert = t.strstart < 2 ? t.strstart : 2, e === xt ? ($t(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && ($t(t, !1), 0 === t.strm.avail_out) ? 1 : 2;\n      },\n      ee = function (t, e) {\n        for (var r, i, n;;) {\n          if (t.lookahead < Rt) {\n            if (Wt(t), t.lookahead < Rt && e === _t) return 1;\n            if (0 === t.lookahead) break;\n          }\n          if (r = 0, t.lookahead >= 3 && (t.ins_h = Vt(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - Rt && (t.match_length = Gt(t, r), t.match_length <= 5 && (t.strategy === Bt || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) {\n            n = t.strstart + t.lookahead - 3, i = gt(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;\n            do {\n              ++t.strstart <= n && (t.ins_h = Vt(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);\n            } while (0 != --t.prev_length);\n            if (t.match_available = 0, t.match_length = 2, t.strstart++, i && ($t(t, !1), 0 === t.strm.avail_out)) return 1;\n          } else if (t.match_available) {\n            if ((i = gt(t, 0, t.window[t.strstart - 1])) && $t(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1;\n          } else t.match_available = 1, t.strstart++, t.lookahead--;\n        }\n        return t.match_available && (i = gt(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, e === xt ? ($t(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && ($t(t, !1), 0 === t.strm.avail_out) ? 1 : 2;\n      };\n    function re(t, e, r, i, n) {\n      this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = i, this.func = n;\n    }\n    var ie = [new re(0, 0, 0, 0, Qt), new re(4, 4, 8, 4, te), new re(4, 5, 16, 8, te), new re(4, 6, 32, 32, te), new re(4, 4, 16, 16, ee), new re(8, 16, 32, 32, ee), new re(8, 16, 128, 128, ee), new re(8, 32, 128, 256, ee), new re(32, 128, 258, 1024, ee), new re(32, 258, 258, 4096, ee)];\n    function ne() {\n      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Lt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), qt(this.dyn_ltree), qt(this.dyn_dtree), qt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), qt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), qt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n    }\n    var se = function (t) {\n        if (!t) return 1;\n        var e = t.state;\n        return !e || e.strm !== t || e.status !== Dt && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && e.status !== Mt && e.status !== Pt ? 1 : 0;\n      },\n      oe = function (t) {\n        if (se(t)) return Ut(t, Ot);\n        t.total_in = t.total_out = 0, t.data_type = jt;\n        var e = t.state;\n        return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = 2 === e.wrap ? 57 : e.wrap ? Dt : Mt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = -2, pt(e), At;\n      },\n      ae = function (t) {\n        var e,\n          r = oe(t);\n        return r === At && ((e = t.state).window_size = 2 * e.w_size, qt(e.head), e.max_lazy_match = ie[e.level].max_lazy, e.good_match = ie[e.level].good_length, e.nice_match = ie[e.level].nice_length, e.max_chain_length = ie[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = 2, e.match_available = 0, e.ins_h = 0), r;\n      },\n      he = function (t, e, r, i, n, s) {\n        if (!t) return Ot;\n        var o = 1;\n        if (e === zt && (e = 6), i < 0 ? (o = 0, i = -i) : i > 15 && (o = 2, i -= 16), n < 1 || n > 9 || r !== Lt || i < 8 || i > 15 || e < 0 || e > 9 || s < 0 || s > Ft || 8 === i && 1 !== o) return Ut(t, Ot);\n        8 === i && (i = 9);\n        var a = new ne();\n        return t.state = a, a.strm = t, a.status = Dt, a.wrap = o, a.gzhead = null, a.w_bits = i, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = n + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << n + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = e, a.strategy = s, a.method = r, ae(t);\n      },\n      ue = he,\n      le = function (t, e) {\n        return se(t) || 2 !== t.state.wrap ? Ot : (t.state.gzhead = e, At);\n      },\n      fe = function (t, e) {\n        if (se(t) || e > kt || e < 0) return t ? Ut(t, Ot) : Ot;\n        var r = t.state;\n        if (!t.output || 0 !== t.avail_in && !t.input || r.status === Pt && e !== xt) return Ut(t, 0 === t.avail_out ? Tt : Ot);\n        var i = r.last_flush;\n        if (r.last_flush = e, 0 !== r.pending) {\n          if (Ht(t), 0 === t.avail_out) return r.last_flush = -1, At;\n        } else if (0 === t.avail_in && Zt(e) <= Zt(i) && e !== xt) return Ut(t, Tt);\n        if (r.status === Pt && 0 !== t.avail_in) return Ut(t, Tt);\n        if (r.status === Dt && 0 === r.wrap && (r.status = Mt), r.status === Dt) {\n          var n = Lt + (r.w_bits - 8 << 4) << 8;\n          if (n |= (r.strategy >= It || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3) << 6, 0 !== r.strstart && (n |= 32), Xt(r, n += 31 - n % 31), 0 !== r.strstart && (Xt(r, t.adler >>> 16), Xt(r, 65535 & t.adler)), t.adler = 1, r.status = Mt, Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n        }\n        if (57 === r.status) if (t.adler = 0, Kt(r, 31), Kt(r, 139), Kt(r, 8), r.gzhead) Kt(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), Kt(r, 255 & r.gzhead.time), Kt(r, r.gzhead.time >> 8 & 255), Kt(r, r.gzhead.time >> 16 & 255), Kt(r, r.gzhead.time >> 24 & 255), Kt(r, 9 === r.level ? 2 : r.strategy >= It || r.level < 2 ? 4 : 0), Kt(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (Kt(r, 255 & r.gzhead.extra.length), Kt(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (t.adler = ft(t.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69;else if (Kt(r, 0), Kt(r, 0), Kt(r, 0), Kt(r, 0), Kt(r, 0), Kt(r, 9 === r.level ? 2 : r.strategy >= It || r.level < 2 ? 4 : 0), Kt(r, 3), r.status = Mt, Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n        if (69 === r.status) {\n          if (r.gzhead.extra) {\n            for (var s = r.pending, o = (65535 & r.gzhead.extra.length) - r.gzindex; r.pending + o > r.pending_buf_size;) {\n              var a = r.pending_buf_size - r.pending;\n              if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + a), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > s && (t.adler = ft(t.adler, r.pending_buf, r.pending - s, s)), r.gzindex += a, Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n              s = 0, o -= a;\n            }\n            var h = new Uint8Array(r.gzhead.extra);\n            r.pending_buf.set(h.subarray(r.gzindex, r.gzindex + o), r.pending), r.pending += o, r.gzhead.hcrc && r.pending > s && (t.adler = ft(t.adler, r.pending_buf, r.pending - s, s)), r.gzindex = 0;\n          }\n          r.status = 73;\n        }\n        if (73 === r.status) {\n          if (r.gzhead.name) {\n            var u,\n              l = r.pending;\n            do {\n              if (r.pending === r.pending_buf_size) {\n                if (r.gzhead.hcrc && r.pending > l && (t.adler = ft(t.adler, r.pending_buf, r.pending - l, l)), Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n                l = 0;\n              }\n              u = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, Kt(r, u);\n            } while (0 !== u);\n            r.gzhead.hcrc && r.pending > l && (t.adler = ft(t.adler, r.pending_buf, r.pending - l, l)), r.gzindex = 0;\n          }\n          r.status = 91;\n        }\n        if (91 === r.status) {\n          if (r.gzhead.comment) {\n            var f,\n              c = r.pending;\n            do {\n              if (r.pending === r.pending_buf_size) {\n                if (r.gzhead.hcrc && r.pending > c && (t.adler = ft(t.adler, r.pending_buf, r.pending - c, c)), Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n                c = 0;\n              }\n              f = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, Kt(r, f);\n            } while (0 !== f);\n            r.gzhead.hcrc && r.pending > c && (t.adler = ft(t.adler, r.pending_buf, r.pending - c, c));\n          }\n          r.status = 103;\n        }\n        if (103 === r.status) {\n          if (r.gzhead.hcrc) {\n            if (r.pending + 2 > r.pending_buf_size && (Ht(t), 0 !== r.pending)) return r.last_flush = -1, At;\n            Kt(r, 255 & t.adler), Kt(r, t.adler >> 8 & 255), t.adler = 0;\n          }\n          if (r.status = Mt, Ht(t), 0 !== r.pending) return r.last_flush = -1, At;\n        }\n        if (0 !== t.avail_in || 0 !== r.lookahead || e !== _t && r.status !== Pt) {\n          var d = 0 === r.level ? Qt(r, e) : r.strategy === It ? function (t, e) {\n            for (var r;;) {\n              if (0 === t.lookahead && (Wt(t), 0 === t.lookahead)) {\n                if (e === _t) return 1;\n                break;\n              }\n              if (t.match_length = 0, r = gt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && ($t(t, !1), 0 === t.strm.avail_out)) return 1;\n            }\n            return t.insert = 0, e === xt ? ($t(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && ($t(t, !1), 0 === t.strm.avail_out) ? 1 : 2;\n          }(r, e) : r.strategy === Nt ? function (t, e) {\n            for (var r, i, n, s, o = t.window;;) {\n              if (t.lookahead <= Ct) {\n                if (Wt(t), t.lookahead <= Ct && e === _t) return 1;\n                if (0 === t.lookahead) break;\n              }\n              if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (i = o[n = t.strstart - 1]) === o[++n] && i === o[++n] && i === o[++n]) {\n                s = t.strstart + Ct;\n                do {} while (i === o[++n] && i === o[++n] && i === o[++n] && i === o[++n] && i === o[++n] && i === o[++n] && i === o[++n] && i === o[++n] && n < s);\n                t.match_length = Ct - (s - n), t.match_length > t.lookahead && (t.match_length = t.lookahead);\n              }\n              if (t.match_length >= 3 ? (r = gt(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = gt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && ($t(t, !1), 0 === t.strm.avail_out)) return 1;\n            }\n            return t.insert = 0, e === xt ? ($t(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && ($t(t, !1), 0 === t.strm.avail_out) ? 1 : 2;\n          }(r, e) : ie[r.level].func(r, e);\n          if (3 !== d && 4 !== d || (r.status = Pt), 1 === d || 3 === d) return 0 === t.avail_out && (r.last_flush = -1), At;\n          if (2 === d && (e === wt ? mt(r) : e !== kt && (yt(r, 0, 0, !1), e === bt && (qt(r.head), 0 === r.lookahead && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Ht(t), 0 === t.avail_out)) return r.last_flush = -1, At;\n        }\n        return e !== xt ? At : r.wrap <= 0 ? St : (2 === r.wrap ? (Kt(r, 255 & t.adler), Kt(r, t.adler >> 8 & 255), Kt(r, t.adler >> 16 & 255), Kt(r, t.adler >> 24 & 255), Kt(r, 255 & t.total_in), Kt(r, t.total_in >> 8 & 255), Kt(r, t.total_in >> 16 & 255), Kt(r, t.total_in >> 24 & 255)) : (Xt(r, t.adler >>> 16), Xt(r, 65535 & t.adler)), Ht(t), r.wrap > 0 && (r.wrap = -r.wrap), 0 !== r.pending ? At : St);\n      },\n      ce = function (t) {\n        if (se(t)) return Ot;\n        var e = t.state.status;\n        return t.state = null, e === Mt ? Ut(t, Et) : At;\n      },\n      de = function (t, e) {\n        var r = e.length;\n        if (se(t)) return Ot;\n        var i = t.state,\n          n = i.wrap;\n        if (2 === n || 1 === n && i.status !== Dt || i.lookahead) return Ot;\n        if (1 === n && (t.adler = ut(t.adler, e, r, 0)), i.wrap = 0, r >= i.w_size) {\n          0 === n && (qt(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);\n          var s = new Uint8Array(i.w_size);\n          s.set(e.subarray(r - i.w_size, r), 0), e = s, r = i.w_size;\n        }\n        var o = t.avail_in,\n          a = t.next_in,\n          h = t.input;\n        for (t.avail_in = r, t.next_in = 0, t.input = e, Wt(i); i.lookahead >= 3;) {\n          var u = i.strstart,\n            l = i.lookahead - 2;\n          do {\n            i.ins_h = Vt(i, i.ins_h, i.window[u + 3 - 1]), i.prev[u & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = u, u++;\n          } while (--l);\n          i.strstart = u, i.lookahead = 2, Wt(i);\n        }\n        return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t.next_in = a, t.input = h, t.avail_in = o, i.wrap = n, At;\n      },\n      pe = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      },\n      ye = {\n        assign: function (e) {\n          for (var r = Array.prototype.slice.call(arguments, 1); r.length;) {\n            var i = r.shift();\n            if (i) {\n              if (\"object\" !== t(i)) throw new TypeError(i + \"must be non-object\");\n              for (var n in i) pe(i, n) && (e[n] = i[n]);\n            }\n          }\n          return e;\n        },\n        flattenChunks: function (t) {\n          for (var e = 0, r = 0, i = t.length; r < i; r++) e += t[r].length;\n          for (var n = new Uint8Array(e), s = 0, o = 0, a = t.length; s < a; s++) {\n            var h = t[s];\n            n.set(h, o), o += h.length;\n          }\n          return n;\n        }\n      },\n      ve = !0;\n    try {\n      String.fromCharCode.apply(null, new Uint8Array(1));\n    } catch (t) {\n      ve = !1;\n    }\n    for (var ge = new Uint8Array(256), me = 0; me < 256; me++) ge[me] = me >= 252 ? 6 : me >= 248 ? 5 : me >= 240 ? 4 : me >= 224 ? 3 : me >= 192 ? 2 : 1;\n    ge[254] = ge[254] = 1;\n    var _e = {\n        string2buf: function (t) {\n          if (\"function\" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t);\n          var e,\n            r,\n            i,\n            n,\n            s,\n            o = t.length,\n            a = 0;\n          for (n = 0; n < o; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < o && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), a += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;\n          for (e = new Uint8Array(a), s = 0, n = 0; s < a; n++) 55296 == (64512 & (r = t.charCodeAt(n))) && n + 1 < o && 56320 == (64512 & (i = t.charCodeAt(n + 1))) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++), r < 128 ? e[s++] = r : r < 2048 ? (e[s++] = 192 | r >>> 6, e[s++] = 128 | 63 & r) : r < 65536 ? (e[s++] = 224 | r >>> 12, e[s++] = 128 | r >>> 6 & 63, e[s++] = 128 | 63 & r) : (e[s++] = 240 | r >>> 18, e[s++] = 128 | r >>> 12 & 63, e[s++] = 128 | r >>> 6 & 63, e[s++] = 128 | 63 & r);\n          return e;\n        },\n        buf2string: function (t, e) {\n          var r,\n            i,\n            n = e || t.length;\n          if (\"function\" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(t.subarray(0, e));\n          var s = new Array(2 * n);\n          for (i = 0, r = 0; r < n;) {\n            var o = t[r++];\n            if (o < 128) s[i++] = o;else {\n              var a = ge[o];\n              if (a > 4) s[i++] = 65533, r += a - 1;else {\n                for (o &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && r < n;) o = o << 6 | 63 & t[r++], a--;\n                a > 1 ? s[i++] = 65533 : o < 65536 ? s[i++] = o : (o -= 65536, s[i++] = 55296 | o >> 10 & 1023, s[i++] = 56320 | 1023 & o);\n              }\n            }\n          }\n          return function (t, e) {\n            if (e < 65534 && t.subarray && ve) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));\n            for (var r = \"\", i = 0; i < e; i++) r += String.fromCharCode(t[i]);\n            return r;\n          }(s, i);\n        },\n        utf8border: function (t, e) {\n          (e = e || t.length) > t.length && (e = t.length);\n          for (var r = e - 1; r >= 0 && 128 == (192 & t[r]);) r--;\n          return r < 0 || 0 === r ? e : r + ge[t[r]] > e ? r : e;\n        }\n      },\n      we = function () {\n        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n      },\n      be = Object.prototype.toString,\n      xe = dt.Z_NO_FLUSH,\n      ke = dt.Z_SYNC_FLUSH,\n      Ae = dt.Z_FULL_FLUSH,\n      Se = dt.Z_FINISH,\n      Oe = dt.Z_OK,\n      Ee = dt.Z_STREAM_END,\n      Te = dt.Z_DEFAULT_COMPRESSION,\n      ze = dt.Z_DEFAULT_STRATEGY,\n      Be = dt.Z_DEFLATED;\n    function Ie(t) {\n      this.options = ye.assign({\n        level: Te,\n        method: Be,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: ze\n      }, t || {});\n      var e = this.options;\n      e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new we(), this.strm.avail_out = 0;\n      var r = ue(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);\n      if (r !== Oe) throw new Error(ct[r]);\n      if (e.header && le(this.strm, e.header), e.dictionary) {\n        var i;\n        if (i = \"string\" == typeof e.dictionary ? _e.string2buf(e.dictionary) : \"[object ArrayBuffer]\" === be.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (r = de(this.strm, i)) !== Oe) throw new Error(ct[r]);\n        this._dict_set = !0;\n      }\n    }\n    Ie.prototype.push = function (t, e) {\n      var r,\n        i,\n        n = this.strm,\n        s = this.options.chunkSize;\n      if (this.ended) return !1;\n      for (i = e === ~~e ? e : !0 === e ? Se : xe, \"string\" == typeof t ? n.input = _e.string2buf(t) : \"[object ArrayBuffer]\" === be.call(t) ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;;) if (0 === n.avail_out && (n.output = new Uint8Array(s), n.next_out = 0, n.avail_out = s), (i === ke || i === Ae) && n.avail_out <= 6) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;else {\n        if ((r = fe(n, i)) === Ee) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), r = ce(this.strm), this.onEnd(r), this.ended = !0, r === Oe;\n        if (0 !== n.avail_out) {\n          if (i > 0 && n.next_out > 0) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;else if (0 === n.avail_in) break;\n        } else this.onData(n.output);\n      }\n      return !0;\n    }, Ie.prototype.onData = function (t) {\n      this.chunks.push(t);\n    }, Ie.prototype.onEnd = function (t) {\n      t === Oe && (this.result = ye.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;\n    };\n    var Ne = 16209,\n      Fe = function (t, e) {\n        var r,\n          i,\n          n,\n          s,\n          o,\n          a,\n          h,\n          u,\n          l,\n          f,\n          c,\n          d,\n          p,\n          y,\n          v,\n          g,\n          m,\n          _,\n          w,\n          b,\n          x,\n          k,\n          A,\n          S,\n          O = t.state;\n        r = t.next_in, A = t.input, i = r + (t.avail_in - 5), n = t.next_out, S = t.output, s = n - (e - t.avail_out), o = n + (t.avail_out - 257), a = O.dmax, h = O.wsize, u = O.whave, l = O.wnext, f = O.window, c = O.hold, d = O.bits, p = O.lencode, y = O.distcode, v = (1 << O.lenbits) - 1, g = (1 << O.distbits) - 1;\n        t: do {\n          d < 15 && (c += A[r++] << d, d += 8, c += A[r++] << d, d += 8), m = p[c & v];\n          e: for (;;) {\n            if (c >>>= _ = m >>> 24, d -= _, 0 == (_ = m >>> 16 & 255)) S[n++] = 65535 & m;else {\n              if (!(16 & _)) {\n                if (64 & _) {\n                  if (32 & _) {\n                    O.mode = 16191;\n                    break t;\n                  }\n                  t.msg = \"invalid literal/length code\", O.mode = Ne;\n                  break t;\n                }\n                m = p[(65535 & m) + (c & (1 << _) - 1)];\n                continue e;\n              }\n              for (w = 65535 & m, (_ &= 15) && (d < _ && (c += A[r++] << d, d += 8), w += c & (1 << _) - 1, c >>>= _, d -= _), d < 15 && (c += A[r++] << d, d += 8, c += A[r++] << d, d += 8), m = y[c & g];;) {\n                if (c >>>= _ = m >>> 24, d -= _, 16 & (_ = m >>> 16 & 255)) {\n                  if (b = 65535 & m, d < (_ &= 15) && (c += A[r++] << d, (d += 8) < _ && (c += A[r++] << d, d += 8)), (b += c & (1 << _) - 1) > a) {\n                    t.msg = \"invalid distance too far back\", O.mode = Ne;\n                    break t;\n                  }\n                  if (c >>>= _, d -= _, b > (_ = n - s)) {\n                    if ((_ = b - _) > u && O.sane) {\n                      t.msg = \"invalid distance too far back\", O.mode = Ne;\n                      break t;\n                    }\n                    if (x = 0, k = f, 0 === l) {\n                      if (x += h - _, _ < w) {\n                        w -= _;\n                        do {\n                          S[n++] = f[x++];\n                        } while (--_);\n                        x = n - b, k = S;\n                      }\n                    } else if (l < _) {\n                      if (x += h + l - _, (_ -= l) < w) {\n                        w -= _;\n                        do {\n                          S[n++] = f[x++];\n                        } while (--_);\n                        if (x = 0, l < w) {\n                          w -= _ = l;\n                          do {\n                            S[n++] = f[x++];\n                          } while (--_);\n                          x = n - b, k = S;\n                        }\n                      }\n                    } else if (x += l - _, _ < w) {\n                      w -= _;\n                      do {\n                        S[n++] = f[x++];\n                      } while (--_);\n                      x = n - b, k = S;\n                    }\n                    for (; w > 2;) S[n++] = k[x++], S[n++] = k[x++], S[n++] = k[x++], w -= 3;\n                    w && (S[n++] = k[x++], w > 1 && (S[n++] = k[x++]));\n                  } else {\n                    x = n - b;\n                    do {\n                      S[n++] = S[x++], S[n++] = S[x++], S[n++] = S[x++], w -= 3;\n                    } while (w > 2);\n                    w && (S[n++] = S[x++], w > 1 && (S[n++] = S[x++]));\n                  }\n                  break;\n                }\n                if (64 & _) {\n                  t.msg = \"invalid distance code\", O.mode = Ne;\n                  break t;\n                }\n                m = y[(65535 & m) + (c & (1 << _) - 1)];\n              }\n            }\n            break;\n          }\n        } while (r < i && n < o);\n        r -= w = d >> 3, c &= (1 << (d -= w << 3)) - 1, t.next_in = r, t.next_out = n, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = n < o ? o - n + 257 : 257 - (n - o), O.hold = c, O.bits = d;\n      },\n      je = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),\n      Le = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),\n      Ce = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),\n      Re = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),\n      De = function (t, e, r, i, n, s, o, a) {\n        var h,\n          u,\n          l,\n          f,\n          c,\n          d,\n          p,\n          y,\n          v,\n          g = a.bits,\n          m = 0,\n          _ = 0,\n          w = 0,\n          b = 0,\n          x = 0,\n          k = 0,\n          A = 0,\n          S = 0,\n          O = 0,\n          E = 0,\n          T = null,\n          z = new Uint16Array(16),\n          B = new Uint16Array(16),\n          I = null;\n        for (m = 0; m <= 15; m++) z[m] = 0;\n        for (_ = 0; _ < i; _++) z[e[r + _]]++;\n        for (x = g, b = 15; b >= 1 && 0 === z[b]; b--);\n        if (x > b && (x = b), 0 === b) return n[s++] = 20971520, n[s++] = 20971520, a.bits = 1, 0;\n        for (w = 1; w < b && 0 === z[w]; w++);\n        for (x < w && (x = w), S = 1, m = 1; m <= 15; m++) if (S <<= 1, (S -= z[m]) < 0) return -1;\n        if (S > 0 && (0 === t || 1 !== b)) return -1;\n        for (B[1] = 0, m = 1; m < 15; m++) B[m + 1] = B[m] + z[m];\n        for (_ = 0; _ < i; _++) 0 !== e[r + _] && (o[B[e[r + _]]++] = _);\n        if (0 === t ? (T = I = o, d = 20) : 1 === t ? (T = je, I = Le, d = 257) : (T = Ce, I = Re, d = 0), E = 0, _ = 0, m = w, c = s, k = x, A = 0, l = -1, f = (O = 1 << x) - 1, 1 === t && O > 852 || 2 === t && O > 592) return 1;\n        for (;;) {\n          p = m - A, o[_] + 1 < d ? (y = 0, v = o[_]) : o[_] >= d ? (y = I[o[_] - d], v = T[o[_] - d]) : (y = 96, v = 0), h = 1 << m - A, w = u = 1 << k;\n          do {\n            n[c + (E >> A) + (u -= h)] = p << 24 | y << 16 | v;\n          } while (0 !== u);\n          for (h = 1 << m - 1; E & h;) h >>= 1;\n          if (0 !== h ? (E &= h - 1, E += h) : E = 0, _++, 0 == --z[m]) {\n            if (m === b) break;\n            m = e[r + o[_]];\n          }\n          if (m > x && (E & f) !== l) {\n            for (0 === A && (A = x), c += w, S = 1 << (k = m - A); k + A < b && !((S -= z[k + A]) <= 0);) k++, S <<= 1;\n            if (O += 1 << k, 1 === t && O > 852 || 2 === t && O > 592) return 1;\n            n[l = E & f] = x << 24 | k << 16 | c - s;\n          }\n        }\n        return 0 !== E && (n[c + E] = m - A << 24 | 64 << 16), a.bits = x, 0;\n      },\n      Me = dt.Z_FINISH,\n      Pe = dt.Z_BLOCK,\n      Ue = dt.Z_TREES,\n      Ze = dt.Z_OK,\n      qe = dt.Z_STREAM_END,\n      Je = dt.Z_NEED_DICT,\n      Ve = dt.Z_STREAM_ERROR,\n      He = dt.Z_DATA_ERROR,\n      $e = dt.Z_MEM_ERROR,\n      Ke = dt.Z_BUF_ERROR,\n      Xe = dt.Z_DEFLATED,\n      Ye = 16180,\n      Ge = 16190,\n      We = 16191,\n      Qe = 16192,\n      tr = 16194,\n      er = 16199,\n      rr = 16200,\n      ir = 16206,\n      nr = 16209,\n      sr = function (t) {\n        return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);\n      };\n    function or() {\n      this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n    }\n    var ar,\n      hr,\n      ur = function (t) {\n        if (!t) return 1;\n        var e = t.state;\n        return !e || e.strm !== t || e.mode < Ye || e.mode > 16211 ? 1 : 0;\n      },\n      lr = function (t) {\n        if (ur(t)) return Ve;\n        var e = t.state;\n        return t.total_in = t.total_out = e.total = 0, t.msg = \"\", e.wrap && (t.adler = 1 & e.wrap), e.mode = Ye, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(852), e.distcode = e.distdyn = new Int32Array(592), e.sane = 1, e.back = -1, Ze;\n      },\n      fr = function (t) {\n        if (ur(t)) return Ve;\n        var e = t.state;\n        return e.wsize = 0, e.whave = 0, e.wnext = 0, lr(t);\n      },\n      cr = function (t, e) {\n        var r;\n        if (ur(t)) return Ve;\n        var i = t.state;\n        return e < 0 ? (r = 0, e = -e) : (r = 5 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Ve : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = r, i.wbits = e, fr(t));\n      },\n      dr = function (t, e) {\n        if (!t) return Ve;\n        var r = new or();\n        t.state = r, r.strm = t, r.window = null, r.mode = Ye;\n        var i = cr(t, e);\n        return i !== Ze && (t.state = null), i;\n      },\n      pr = !0,\n      yr = function (t) {\n        if (pr) {\n          ar = new Int32Array(512), hr = new Int32Array(32);\n          for (var e = 0; e < 144;) t.lens[e++] = 8;\n          for (; e < 256;) t.lens[e++] = 9;\n          for (; e < 280;) t.lens[e++] = 7;\n          for (; e < 288;) t.lens[e++] = 8;\n          for (De(1, t.lens, 0, 288, ar, 0, t.work, {\n            bits: 9\n          }), e = 0; e < 32;) t.lens[e++] = 5;\n          De(2, t.lens, 0, 32, hr, 0, t.work, {\n            bits: 5\n          }), pr = !1;\n        }\n        t.lencode = ar, t.lenbits = 9, t.distcode = hr, t.distbits = 5;\n      },\n      vr = function (t, e, r, i) {\n        var n,\n          s = t.state;\n        return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), i >= s.wsize ? (s.window.set(e.subarray(r - s.wsize, r), 0), s.wnext = 0, s.whave = s.wsize) : ((n = s.wsize - s.wnext) > i && (n = i), s.window.set(e.subarray(r - i, r - i + n), s.wnext), (i -= n) ? (s.window.set(e.subarray(r - i, r), 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += n, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += n))), 0;\n      },\n      gr = {\n        inflateReset: fr,\n        inflateReset2: cr,\n        inflateResetKeep: lr,\n        inflateInit: function (t) {\n          return dr(t, 15);\n        },\n        inflateInit2: dr,\n        inflate: function (t, e) {\n          var r,\n            i,\n            n,\n            s,\n            o,\n            a,\n            h,\n            u,\n            l,\n            f,\n            c,\n            d,\n            p,\n            y,\n            v,\n            g,\n            m,\n            _,\n            w,\n            b,\n            x,\n            k,\n            A,\n            S,\n            O = 0,\n            E = new Uint8Array(4),\n            T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n          if (ur(t) || !t.output || !t.input && 0 !== t.avail_in) return Ve;\n          (r = t.state).mode === We && (r.mode = Qe), o = t.next_out, n = t.output, h = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, u = r.hold, l = r.bits, f = a, c = h, k = Ze;\n          t: for (;;) switch (r.mode) {\n            case Ye:\n              if (0 === r.wrap) {\n                r.mode = Qe;\n                break;\n              }\n              for (; l < 16;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if (2 & r.wrap && 35615 === u) {\n                0 === r.wbits && (r.wbits = 15), r.check = 0, E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = ft(r.check, E, 2, 0), u = 0, l = 0, r.mode = 16181;\n                break;\n              }\n              if (r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) {\n                t.msg = \"incorrect header check\", r.mode = nr;\n                break;\n              }\n              if ((15 & u) !== Xe) {\n                t.msg = \"unknown compression method\", r.mode = nr;\n                break;\n              }\n              if (l -= 4, x = 8 + (15 & (u >>>= 4)), 0 === r.wbits && (r.wbits = x), x > 15 || x > r.wbits) {\n                t.msg = \"invalid window size\", r.mode = nr;\n                break;\n              }\n              r.dmax = 1 << r.wbits, r.flags = 0, t.adler = r.check = 1, r.mode = 512 & u ? 16189 : We, u = 0, l = 0;\n              break;\n            case 16181:\n              for (; l < 16;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if (r.flags = u, (255 & r.flags) !== Xe) {\n                t.msg = \"unknown compression method\", r.mode = nr;\n                break;\n              }\n              if (57344 & r.flags) {\n                t.msg = \"unknown header flags set\", r.mode = nr;\n                break;\n              }\n              r.head && (r.head.text = u >> 8 & 1), 512 & r.flags && 4 & r.wrap && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = ft(r.check, E, 2, 0)), u = 0, l = 0, r.mode = 16182;\n            case 16182:\n              for (; l < 32;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              r.head && (r.head.time = u), 512 & r.flags && 4 & r.wrap && (E[0] = 255 & u, E[1] = u >>> 8 & 255, E[2] = u >>> 16 & 255, E[3] = u >>> 24 & 255, r.check = ft(r.check, E, 4, 0)), u = 0, l = 0, r.mode = 16183;\n            case 16183:\n              for (; l < 16;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              r.head && (r.head.xflags = 255 & u, r.head.os = u >> 8), 512 & r.flags && 4 & r.wrap && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = ft(r.check, E, 2, 0)), u = 0, l = 0, r.mode = 16184;\n            case 16184:\n              if (1024 & r.flags) {\n                for (; l < 16;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                r.length = u, r.head && (r.head.extra_len = u), 512 & r.flags && 4 & r.wrap && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = ft(r.check, E, 2, 0)), u = 0, l = 0;\n              } else r.head && (r.head.extra = null);\n              r.mode = 16185;\n            case 16185:\n              if (1024 & r.flags && ((d = r.length) > a && (d = a), d && (r.head && (x = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(i.subarray(s, s + d), x)), 512 & r.flags && 4 & r.wrap && (r.check = ft(r.check, i, d, s)), a -= d, s += d, r.length -= d), r.length)) break t;\n              r.length = 0, r.mode = 16186;\n            case 16186:\n              if (2048 & r.flags) {\n                if (0 === a) break t;\n                d = 0;\n                do {\n                  x = i[s + d++], r.head && x && r.length < 65536 && (r.head.name += String.fromCharCode(x));\n                } while (x && d < a);\n                if (512 & r.flags && 4 & r.wrap && (r.check = ft(r.check, i, d, s)), a -= d, s += d, x) break t;\n              } else r.head && (r.head.name = null);\n              r.length = 0, r.mode = 16187;\n            case 16187:\n              if (4096 & r.flags) {\n                if (0 === a) break t;\n                d = 0;\n                do {\n                  x = i[s + d++], r.head && x && r.length < 65536 && (r.head.comment += String.fromCharCode(x));\n                } while (x && d < a);\n                if (512 & r.flags && 4 & r.wrap && (r.check = ft(r.check, i, d, s)), a -= d, s += d, x) break t;\n              } else r.head && (r.head.comment = null);\n              r.mode = 16188;\n            case 16188:\n              if (512 & r.flags) {\n                for (; l < 16;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                if (4 & r.wrap && u !== (65535 & r.check)) {\n                  t.msg = \"header crc mismatch\", r.mode = nr;\n                  break;\n                }\n                u = 0, l = 0;\n              }\n              r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = We;\n              break;\n            case 16189:\n              for (; l < 32;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              t.adler = r.check = sr(u), u = 0, l = 0, r.mode = Ge;\n            case Ge:\n              if (0 === r.havedict) return t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = a, r.hold = u, r.bits = l, Je;\n              t.adler = r.check = 1, r.mode = We;\n            case We:\n              if (e === Pe || e === Ue) break t;\n            case Qe:\n              if (r.last) {\n                u >>>= 7 & l, l -= 7 & l, r.mode = ir;\n                break;\n              }\n              for (; l < 3;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              switch (r.last = 1 & u, l -= 1, 3 & (u >>>= 1)) {\n                case 0:\n                  r.mode = 16193;\n                  break;\n                case 1:\n                  if (yr(r), r.mode = er, e === Ue) {\n                    u >>>= 2, l -= 2;\n                    break t;\n                  }\n                  break;\n                case 2:\n                  r.mode = 16196;\n                  break;\n                case 3:\n                  t.msg = \"invalid block type\", r.mode = nr;\n              }\n              u >>>= 2, l -= 2;\n              break;\n            case 16193:\n              for (u >>>= 7 & l, l -= 7 & l; l < 32;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if ((65535 & u) != (u >>> 16 ^ 65535)) {\n                t.msg = \"invalid stored block lengths\", r.mode = nr;\n                break;\n              }\n              if (r.length = 65535 & u, u = 0, l = 0, r.mode = tr, e === Ue) break t;\n            case tr:\n              r.mode = 16195;\n            case 16195:\n              if (d = r.length) {\n                if (d > a && (d = a), d > h && (d = h), 0 === d) break t;\n                n.set(i.subarray(s, s + d), o), a -= d, s += d, h -= d, o += d, r.length -= d;\n                break;\n              }\n              r.mode = We;\n              break;\n            case 16196:\n              for (; l < 14;) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if (r.nlen = 257 + (31 & u), u >>>= 5, l -= 5, r.ndist = 1 + (31 & u), u >>>= 5, l -= 5, r.ncode = 4 + (15 & u), u >>>= 4, l -= 4, r.nlen > 286 || r.ndist > 30) {\n                t.msg = \"too many length or distance symbols\", r.mode = nr;\n                break;\n              }\n              r.have = 0, r.mode = 16197;\n            case 16197:\n              for (; r.have < r.ncode;) {\n                for (; l < 3;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                r.lens[T[r.have++]] = 7 & u, u >>>= 3, l -= 3;\n              }\n              for (; r.have < 19;) r.lens[T[r.have++]] = 0;\n              if (r.lencode = r.lendyn, r.lenbits = 7, A = {\n                bits: r.lenbits\n              }, k = De(0, r.lens, 0, 19, r.lencode, 0, r.work, A), r.lenbits = A.bits, k) {\n                t.msg = \"invalid code lengths set\", r.mode = nr;\n                break;\n              }\n              r.have = 0, r.mode = 16198;\n            case 16198:\n              for (; r.have < r.nlen + r.ndist;) {\n                for (; g = (O = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, m = 65535 & O, !((v = O >>> 24) <= l);) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                if (m < 16) u >>>= v, l -= v, r.lens[r.have++] = m;else {\n                  if (16 === m) {\n                    for (S = v + 2; l < S;) {\n                      if (0 === a) break t;\n                      a--, u += i[s++] << l, l += 8;\n                    }\n                    if (u >>>= v, l -= v, 0 === r.have) {\n                      t.msg = \"invalid bit length repeat\", r.mode = nr;\n                      break;\n                    }\n                    x = r.lens[r.have - 1], d = 3 + (3 & u), u >>>= 2, l -= 2;\n                  } else if (17 === m) {\n                    for (S = v + 3; l < S;) {\n                      if (0 === a) break t;\n                      a--, u += i[s++] << l, l += 8;\n                    }\n                    l -= v, x = 0, d = 3 + (7 & (u >>>= v)), u >>>= 3, l -= 3;\n                  } else {\n                    for (S = v + 7; l < S;) {\n                      if (0 === a) break t;\n                      a--, u += i[s++] << l, l += 8;\n                    }\n                    l -= v, x = 0, d = 11 + (127 & (u >>>= v)), u >>>= 7, l -= 7;\n                  }\n                  if (r.have + d > r.nlen + r.ndist) {\n                    t.msg = \"invalid bit length repeat\", r.mode = nr;\n                    break;\n                  }\n                  for (; d--;) r.lens[r.have++] = x;\n                }\n              }\n              if (r.mode === nr) break;\n              if (0 === r.lens[256]) {\n                t.msg = \"invalid code -- missing end-of-block\", r.mode = nr;\n                break;\n              }\n              if (r.lenbits = 9, A = {\n                bits: r.lenbits\n              }, k = De(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, A), r.lenbits = A.bits, k) {\n                t.msg = \"invalid literal/lengths set\", r.mode = nr;\n                break;\n              }\n              if (r.distbits = 6, r.distcode = r.distdyn, A = {\n                bits: r.distbits\n              }, k = De(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, A), r.distbits = A.bits, k) {\n                t.msg = \"invalid distances set\", r.mode = nr;\n                break;\n              }\n              if (r.mode = er, e === Ue) break t;\n            case er:\n              r.mode = rr;\n            case rr:\n              if (a >= 6 && h >= 258) {\n                t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = a, r.hold = u, r.bits = l, Fe(t, c), o = t.next_out, n = t.output, h = t.avail_out, s = t.next_in, i = t.input, a = t.avail_in, u = r.hold, l = r.bits, r.mode === We && (r.back = -1);\n                break;\n              }\n              for (r.back = 0; g = (O = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, m = 65535 & O, !((v = O >>> 24) <= l);) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if (g && !(240 & g)) {\n                for (_ = v, w = g, b = m; g = (O = r.lencode[b + ((u & (1 << _ + w) - 1) >> _)]) >>> 16 & 255, m = 65535 & O, !(_ + (v = O >>> 24) <= l);) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                u >>>= _, l -= _, r.back += _;\n              }\n              if (u >>>= v, l -= v, r.back += v, r.length = m, 0 === g) {\n                r.mode = 16205;\n                break;\n              }\n              if (32 & g) {\n                r.back = -1, r.mode = We;\n                break;\n              }\n              if (64 & g) {\n                t.msg = \"invalid literal/length code\", r.mode = nr;\n                break;\n              }\n              r.extra = 15 & g, r.mode = 16201;\n            case 16201:\n              if (r.extra) {\n                for (S = r.extra; l < S;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                r.length += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;\n              }\n              r.was = r.length, r.mode = 16202;\n            case 16202:\n              for (; g = (O = r.distcode[u & (1 << r.distbits) - 1]) >>> 16 & 255, m = 65535 & O, !((v = O >>> 24) <= l);) {\n                if (0 === a) break t;\n                a--, u += i[s++] << l, l += 8;\n              }\n              if (!(240 & g)) {\n                for (_ = v, w = g, b = m; g = (O = r.distcode[b + ((u & (1 << _ + w) - 1) >> _)]) >>> 16 & 255, m = 65535 & O, !(_ + (v = O >>> 24) <= l);) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                u >>>= _, l -= _, r.back += _;\n              }\n              if (u >>>= v, l -= v, r.back += v, 64 & g) {\n                t.msg = \"invalid distance code\", r.mode = nr;\n                break;\n              }\n              r.offset = m, r.extra = 15 & g, r.mode = 16203;\n            case 16203:\n              if (r.extra) {\n                for (S = r.extra; l < S;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                r.offset += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;\n              }\n              if (r.offset > r.dmax) {\n                t.msg = \"invalid distance too far back\", r.mode = nr;\n                break;\n              }\n              r.mode = 16204;\n            case 16204:\n              if (0 === h) break t;\n              if (d = c - h, r.offset > d) {\n                if ((d = r.offset - d) > r.whave && r.sane) {\n                  t.msg = \"invalid distance too far back\", r.mode = nr;\n                  break;\n                }\n                d > r.wnext ? (d -= r.wnext, p = r.wsize - d) : p = r.wnext - d, d > r.length && (d = r.length), y = r.window;\n              } else y = n, p = o - r.offset, d = r.length;\n              d > h && (d = h), h -= d, r.length -= d;\n              do {\n                n[o++] = y[p++];\n              } while (--d);\n              0 === r.length && (r.mode = rr);\n              break;\n            case 16205:\n              if (0 === h) break t;\n              n[o++] = r.length, h--, r.mode = rr;\n              break;\n            case ir:\n              if (r.wrap) {\n                for (; l < 32;) {\n                  if (0 === a) break t;\n                  a--, u |= i[s++] << l, l += 8;\n                }\n                if (c -= h, t.total_out += c, r.total += c, 4 & r.wrap && c && (t.adler = r.check = r.flags ? ft(r.check, n, c, o - c) : ut(r.check, n, c, o - c)), c = h, 4 & r.wrap && (r.flags ? u : sr(u)) !== r.check) {\n                  t.msg = \"incorrect data check\", r.mode = nr;\n                  break;\n                }\n                u = 0, l = 0;\n              }\n              r.mode = 16207;\n            case 16207:\n              if (r.wrap && r.flags) {\n                for (; l < 32;) {\n                  if (0 === a) break t;\n                  a--, u += i[s++] << l, l += 8;\n                }\n                if (4 & r.wrap && u !== (4294967295 & r.total)) {\n                  t.msg = \"incorrect length check\", r.mode = nr;\n                  break;\n                }\n                u = 0, l = 0;\n              }\n              r.mode = 16208;\n            case 16208:\n              k = qe;\n              break t;\n            case nr:\n              k = He;\n              break t;\n            case 16210:\n              return $e;\n            default:\n              return Ve;\n          }\n          return t.next_out = o, t.avail_out = h, t.next_in = s, t.avail_in = a, r.hold = u, r.bits = l, (r.wsize || c !== t.avail_out && r.mode < nr && (r.mode < ir || e !== Me)) && vr(t, t.output, t.next_out, c - t.avail_out), f -= t.avail_in, c -= t.avail_out, t.total_in += f, t.total_out += c, r.total += c, 4 & r.wrap && c && (t.adler = r.check = r.flags ? ft(r.check, n, c, t.next_out - c) : ut(r.check, n, c, t.next_out - c)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === We ? 128 : 0) + (r.mode === er || r.mode === tr ? 256 : 0), (0 === f && 0 === c || e === Me) && k === Ze && (k = Ke), k;\n        },\n        inflateEnd: function (t) {\n          if (ur(t)) return Ve;\n          var e = t.state;\n          return e.window && (e.window = null), t.state = null, Ze;\n        },\n        inflateGetHeader: function (t, e) {\n          if (ur(t)) return Ve;\n          var r = t.state;\n          return 2 & r.wrap ? (r.head = e, e.done = !1, Ze) : Ve;\n        },\n        inflateSetDictionary: function (t, e) {\n          var r,\n            i = e.length;\n          return ur(t) || 0 !== (r = t.state).wrap && r.mode !== Ge ? Ve : r.mode === Ge && ut(1, e, i, 0) !== r.check ? He : vr(t, e, i, i) ? (r.mode = 16210, $e) : (r.havedict = 1, Ze);\n        },\n        inflateInfo: \"pako inflate (from Nodeca project)\"\n      },\n      mr = function () {\n        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = !1;\n      },\n      _r = Object.prototype.toString,\n      wr = dt.Z_NO_FLUSH,\n      br = dt.Z_FINISH,\n      xr = dt.Z_OK,\n      kr = dt.Z_STREAM_END,\n      Ar = dt.Z_NEED_DICT,\n      Sr = dt.Z_STREAM_ERROR,\n      Or = dt.Z_DATA_ERROR,\n      Er = dt.Z_MEM_ERROR;\n    function Tr(t) {\n      this.options = ye.assign({\n        chunkSize: 65536,\n        windowBits: 15,\n        to: \"\"\n      }, t || {});\n      var e = this.options;\n      e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (15 & e.windowBits || (e.windowBits |= 15)), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new we(), this.strm.avail_out = 0;\n      var r = gr.inflateInit2(this.strm, e.windowBits);\n      if (r !== xr) throw new Error(ct[r]);\n      if (this.header = new mr(), gr.inflateGetHeader(this.strm, this.header), e.dictionary && (\"string\" == typeof e.dictionary ? e.dictionary = _e.string2buf(e.dictionary) : \"[object ArrayBuffer]\" === _r.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = gr.inflateSetDictionary(this.strm, e.dictionary)) !== xr)) throw new Error(ct[r]);\n    }\n    function zr(t, e) {\n      var r = new Tr(e);\n      if (r.push(t), r.err) throw r.msg || ct[r.err];\n      return r.result;\n    }\n    Tr.prototype.push = function (t, e) {\n      var r,\n        i,\n        n,\n        s = this.strm,\n        o = this.options.chunkSize,\n        a = this.options.dictionary;\n      if (this.ended) return !1;\n      for (i = e === ~~e ? e : !0 === e ? br : wr, \"[object ArrayBuffer]\" === _r.call(t) ? s.input = new Uint8Array(t) : s.input = t, s.next_in = 0, s.avail_in = s.input.length;;) {\n        for (0 === s.avail_out && (s.output = new Uint8Array(o), s.next_out = 0, s.avail_out = o), (r = gr.inflate(s, i)) === Ar && a && ((r = gr.inflateSetDictionary(s, a)) === xr ? r = gr.inflate(s, i) : r === Or && (r = Ar)); s.avail_in > 0 && r === kr && s.state.wrap > 0 && 0 !== t[s.next_in];) gr.inflateReset(s), r = gr.inflate(s, i);\n        switch (r) {\n          case Sr:\n          case Or:\n          case Ar:\n          case Er:\n            return this.onEnd(r), this.ended = !0, !1;\n        }\n        if (n = s.avail_out, s.next_out && (0 === s.avail_out || r === kr)) if (\"string\" === this.options.to) {\n          var h = _e.utf8border(s.output, s.next_out),\n            u = s.next_out - h,\n            l = _e.buf2string(s.output, h);\n          s.next_out = u, s.avail_out = o - u, u && s.output.set(s.output.subarray(h, h + u), 0), this.onData(l);\n        } else this.onData(s.output.length === s.next_out ? s.output : s.output.subarray(0, s.next_out));\n        if (r !== xr || 0 !== n) {\n          if (r === kr) return r = gr.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, !0;\n          if (0 === s.avail_in) break;\n        }\n      }\n      return !0;\n    }, Tr.prototype.onData = function (t) {\n      this.chunks.push(t);\n    }, Tr.prototype.onEnd = function (t) {\n      t === xr && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = ye.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;\n    };\n    var Br = zr,\n      Ir = r(700),\n      Nr = JSON.parse('{\"nested\":{\"com\":{\"nested\":{\"opensource\":{\"nested\":{\"svga\":{\"options\":{\"objc_class_prefix\":\"SVGAProto\",\"java_package\":\"com.opensource.svgaplayer.proto\"},\"nested\":{\"MovieParams\":{\"fields\":{\"viewBoxWidth\":{\"type\":\"float\",\"id\":1},\"viewBoxHeight\":{\"type\":\"float\",\"id\":2},\"fps\":{\"type\":\"int32\",\"id\":3},\"frames\":{\"type\":\"int32\",\"id\":4}}},\"SpriteEntity\":{\"fields\":{\"imageKey\":{\"type\":\"string\",\"id\":1},\"frames\":{\"rule\":\"repeated\",\"type\":\"FrameEntity\",\"id\":2},\"matteKey\":{\"type\":\"string\",\"id\":3}}},\"AudioEntity\":{\"fields\":{\"audioKey\":{\"type\":\"string\",\"id\":1},\"startFrame\":{\"type\":\"int32\",\"id\":2},\"endFrame\":{\"type\":\"int32\",\"id\":3},\"startTime\":{\"type\":\"int32\",\"id\":4},\"totalTime\":{\"type\":\"int32\",\"id\":5}}},\"Layout\":{\"fields\":{\"x\":{\"type\":\"float\",\"id\":1},\"y\":{\"type\":\"float\",\"id\":2},\"width\":{\"type\":\"float\",\"id\":3},\"height\":{\"type\":\"float\",\"id\":4}}},\"Transform\":{\"fields\":{\"a\":{\"type\":\"float\",\"id\":1},\"b\":{\"type\":\"float\",\"id\":2},\"c\":{\"type\":\"float\",\"id\":3},\"d\":{\"type\":\"float\",\"id\":4},\"tx\":{\"type\":\"float\",\"id\":5},\"ty\":{\"type\":\"float\",\"id\":6}}},\"ShapeEntity\":{\"oneofs\":{\"args\":{\"oneof\":[\"shape\",\"rect\",\"ellipse\"]}},\"fields\":{\"type\":{\"type\":\"ShapeType\",\"id\":1},\"shape\":{\"type\":\"ShapeArgs\",\"id\":2},\"rect\":{\"type\":\"RectArgs\",\"id\":3},\"ellipse\":{\"type\":\"EllipseArgs\",\"id\":4},\"styles\":{\"type\":\"ShapeStyle\",\"id\":10},\"transform\":{\"type\":\"Transform\",\"id\":11}},\"nested\":{\"ShapeType\":{\"values\":{\"SHAPE\":0,\"RECT\":1,\"ELLIPSE\":2,\"KEEP\":3}},\"ShapeArgs\":{\"fields\":{\"d\":{\"type\":\"string\",\"id\":1}}},\"RectArgs\":{\"fields\":{\"x\":{\"type\":\"float\",\"id\":1},\"y\":{\"type\":\"float\",\"id\":2},\"width\":{\"type\":\"float\",\"id\":3},\"height\":{\"type\":\"float\",\"id\":4},\"cornerRadius\":{\"type\":\"float\",\"id\":5}}},\"EllipseArgs\":{\"fields\":{\"x\":{\"type\":\"float\",\"id\":1},\"y\":{\"type\":\"float\",\"id\":2},\"radiusX\":{\"type\":\"float\",\"id\":3},\"radiusY\":{\"type\":\"float\",\"id\":4}}},\"ShapeStyle\":{\"fields\":{\"fill\":{\"type\":\"RGBAColor\",\"id\":1},\"stroke\":{\"type\":\"RGBAColor\",\"id\":2},\"strokeWidth\":{\"type\":\"float\",\"id\":3},\"lineCap\":{\"type\":\"LineCap\",\"id\":4},\"lineJoin\":{\"type\":\"LineJoin\",\"id\":5},\"miterLimit\":{\"type\":\"float\",\"id\":6},\"lineDashI\":{\"type\":\"float\",\"id\":7},\"lineDashII\":{\"type\":\"float\",\"id\":8},\"lineDashIII\":{\"type\":\"float\",\"id\":9}},\"nested\":{\"RGBAColor\":{\"fields\":{\"r\":{\"type\":\"float\",\"id\":1},\"g\":{\"type\":\"float\",\"id\":2},\"b\":{\"type\":\"float\",\"id\":3},\"a\":{\"type\":\"float\",\"id\":4}}},\"LineCap\":{\"values\":{\"LineCap_BUTT\":0,\"LineCap_ROUND\":1,\"LineCap_SQUARE\":2}},\"LineJoin\":{\"values\":{\"LineJoin_MITER\":0,\"LineJoin_ROUND\":1,\"LineJoin_BEVEL\":2}}}}}},\"FrameEntity\":{\"fields\":{\"alpha\":{\"type\":\"float\",\"id\":1},\"layout\":{\"type\":\"Layout\",\"id\":2},\"transform\":{\"type\":\"Transform\",\"id\":3},\"clipPath\":{\"type\":\"string\",\"id\":4},\"shapes\":{\"rule\":\"repeated\",\"type\":\"ShapeEntity\",\"id\":5}}},\"MovieEntity\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1},\"params\":{\"type\":\"MovieParams\",\"id\":2},\"images\":{\"keyType\":\"string\",\"type\":\"bytes\",\"id\":3},\"sprites\":{\"rule\":\"repeated\",\"type\":\"SpriteEntity\",\"id\":4},\"audios\":{\"rule\":\"repeated\",\"type\":\"AudioEntity\",\"id\":5}}}}}}}}}}}'),\n      Fr = Ir.Root.fromJSON(Nr).lookupType(\"com.opensource.svga.MovieEntity\"),\n      jr = {},\n      Lr = function () {\n        return u(function t() {\n          o(this, t);\n        }, [{\n          key: \"load\",\n          value: (t = s(e().mark(function t(r) {\n            var i;\n            return e().wrap(function (t) {\n              for (;;) switch (t.prev = t.next) {\n                case 0:\n                  if (!jr[r]) {\n                    t.next = 7;\n                    break;\n                  }\n                  return t.next = 3, jr[r];\n                case 3:\n                  if (1 !== (i = t.sent).code) {\n                    t.next = 7;\n                    break;\n                  }\n                  return y(\"预加载命中\", r.substring(r.lastIndexOf(\"/\") + 1)), t.abrupt(\"return\", i.data);\n                case 7:\n                  if (0 !== r.indexOf(\"http://\") && 0 !== r.indexOf(\"https://\")) {\n                    t.next = 9;\n                    break;\n                  }\n                  return t.abrupt(\"return\", this.loadUrl(r));\n                case 9:\n                  return t.abrupt(\"return\", this.loadFile(r));\n                case 10:\n                case \"end\":\n                  return t.stop();\n              }\n            }, t, this);\n          })), function (e) {\n            return t.apply(this, arguments);\n          })\n        }, {\n          key: \"loadUrl\",\n          value: function (t) {\n            return new Promise(function (e, r) {\n              if (\"h5\" === _()) {\n                var i = new XMLHttpRequest();\n                i.open(\"GET\", t, !0), i.responseType = \"arraybuffer\", i.onloadend = function () {\n                  if (void 0 === i.response || 200 !== i.status && 304 !== i.status) r(new Error(\"XMLHttpRequest, \".concat(i.statusText)));else {\n                    var n = Br(i.response),\n                      s = Fr.decode(n);\n                    e(new A(s, t));\n                  }\n                }, i.send();\n              } else l().request({\n                url: t,\n                dataType: \"arraybuffer\",\n                responseType: \"arraybuffer\",\n                success: function (i) {\n                  try {\n                    var n = Br(i.data),\n                      s = Fr.decode(n);\n                    e(new A(s, t));\n                  } catch (t) {\n                    r(t);\n                  }\n                },\n                fail: function (t) {\n                  r(new Error(t.errMsg || \"load url failed\"));\n                }\n              });\n            });\n          }\n        }, {\n          key: \"loadFile\",\n          value: function (t) {\n            return new Promise(function (e, r) {\n              \"h5\" === _() ? r(new Error(\"暂不支持\")) : l().getFileSystemManager().readFile({\n                filePath: t,\n                success: function (i) {\n                  try {\n                    var n = Br(i.data),\n                      s = Fr.decode(n);\n                    e(new A(s, t));\n                  } catch (t) {\n                    r(t);\n                  }\n                },\n                fail: function (t) {\n                  r(new Error(t.errMsg || \"load file failed\"));\n                }\n              });\n            });\n          }\n        }], [{\n          key: \"preload\",\n          value: function (t) {\n            if (!t) return Promise.resolve({\n              code: 0,\n              msg: \"no preload url\"\n            });\n            if (jr[t]) return jr[t];\n            var e = new Promise(function (e) {\n              var r = Date.now(),\n                i = _();\n              \"h5\" === i ? e({\n                code: 0,\n                msg: \"platform unsupported\"\n              }) : l().request({\n                url: t,\n                dataType: \"alipay\" === i ? \"arraybuffer\" : \"其他\",\n                responseType: \"arraybuffer\",\n                success: function (i) {\n                  try {\n                    var n = Br(i.data),\n                      s = Fr.decode(n);\n                    y(\"预加载完成, 耗时: \".concat(Date.now() - r, \"ms\"), t.substring(t.lastIndexOf(\"/\") + 1)), e({\n                      code: 1,\n                      data: new A(s, t)\n                    });\n                  } catch (t) {\n                    y(\"预加载解析失败, 耗时: \".concat(Date.now() - r, \"ms\"), t), e({\n                      code: 0,\n                      msg: \"file parse failed\"\n                    });\n                  }\n                },\n                fail: function (t) {\n                  y(\"预加载失败, 耗时: \".concat(Date.now() - r, \"ms\"), t), e({\n                    code: 0,\n                    msg: \"file read failed\"\n                  });\n                }\n              });\n            });\n            return jr[t] = e, e;\n          }\n        }, {\n          key: \"unload\",\n          value: function (t) {\n            delete jr[t], jr[t] = void 0, y(\"释放预加载\", t.substring(t.lastIndexOf(\"/\") + 1));\n          }\n        }]);\n        var t;\n      }();\n    function Cr(t, e) {\n      var r = Object.keys(t);\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(t);\n        e && (i = i.filter(function (e) {\n          return Object.getOwnPropertyDescriptor(t, e).enumerable;\n        })), r.push.apply(r, i);\n      }\n      return r;\n    }\n    function Rr(t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var r = null != arguments[e] ? arguments[e] : {};\n        e % 2 ? Cr(Object(r), !0).forEach(function (e) {\n          f(t, e, r[e]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Cr(Object(r)).forEach(function (e) {\n          Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n        });\n      }\n      return t;\n    }\n    function Dr(t) {\n      return Dr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      }, Dr(t);\n    }\n    function Mr() {\n      try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      } catch (t) {}\n      return (Mr = function () {\n        return !!t;\n      })();\n    }\n    function Pr(e, r, i) {\n      return r = Dr(r), function (e, r) {\n        if (r && (\"object\" == t(r) || \"function\" == typeof r)) return r;\n        if (void 0 !== r) throw new TypeError(\"Derived constructors may only return object or undefined\");\n        return function (t) {\n          if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return t;\n        }(e);\n      }(e, Mr() ? Reflect.construct(r, i || [], Dr(e).constructor) : r.apply(e, i));\n    }\n    function Ur(t, e) {\n      return Ur = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n        return t.__proto__ = e, t;\n      }, Ur(t, e);\n    }\n    function Zr(t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), e && Ur(t, e);\n    }\n    var qr = function (t) {\n        function e(t, r, i, n, s, a) {\n          var h;\n          return o(this, e), f(h = Pr(this, e, [\"\", s, a]), \"_x\", void 0), f(h, \"_y\", void 0), f(h, \"_radiusX\", void 0), f(h, \"_radiusY\", void 0), f(h, \"_transform\", void 0), f(h, \"_styles\", void 0), h._x = t, h._y = r, h._radiusX = i, h._radiusY = n, h._transform = s, h._styles = a, h;\n        }\n        return Zr(e, t), u(e);\n      }(b),\n      Jr = function (t) {\n        function e(t, r, i, n, s, a, h) {\n          var u;\n          return o(this, e), f(u = Pr(this, e, [\"\", a, h]), \"_x\", void 0), f(u, \"_y\", void 0), f(u, \"_width\", void 0), f(u, \"_height\", void 0), f(u, \"_cornerRadius\", void 0), f(u, \"_transform\", void 0), f(u, \"_styles\", void 0), u._x = t, u._y = r, u._width = i, u._height = n, u._cornerRadius = s, u._transform = a, u._styles = h, u;\n        }\n        return Zr(e, t), u(e);\n      }(b),\n      Vr = function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6,\n          r = Math.pow(10, e);\n        return ~~(t * r) / r;\n      },\n      Hr = function (t) {\n        return ~~t;\n      },\n      $r = function () {\n        return u(function t(e, r, i) {\n          o(this, t), this.videoItem = e, this.width = r, this.height = i, f(this, \"canvas\", void 0), f(this, \"ctx\", void 0), f(this, \"_transform\", {\n            translateX: 0,\n            translateY: 0,\n            scale: 1\n          }), f(this, \"dpr\", \"h5\" === _() ? window.devicePixelRatio : l().getSystemInfoSync().pixelRatio), f(this, \"globalTransform\", void 0), f(this, \"_dynamicImage\", {}), f(this, \"_dynamicText\", {}), f(this, \"isMatteing\", !1), f(this, \"matteSprites\", {}), this.videoItem = e, this.canvas = function (t) {\n            if (\"undefined\" != typeof my && \"function\" == typeof my.createOffscreenCanvas) return my.createOffscreenCanvas({\n              width: t.width,\n              height: t.height\n            });\n            if (\"undefined\" != typeof tt && \"function\" == typeof has.createOffscreenCanvas) {\n              var e = has.createOffscreenCanvas();\n              return e.width = t.width, e.height = t.height, e;\n            }\n            if (\"undefined\" != typeof wx && \"function\" == typeof has.createOffscreenCanvas) return has.createOffscreenCanvas(t);\n            if (\"OffscreenCanvas\" in window) return new OffscreenCanvas(t.width, t.height);\n            throw new Error(\"暂不支持当前环境\");\n          }({\n            width: r,\n            height: i,\n            type: \"2d\"\n          }), this.ctx = this.canvas.getContext(\"2d\");\n        }, [{\n          key: \"transform\",\n          get: function () {\n            return this._transform;\n          },\n          set: function (t) {\n            this._transform = t;\n          }\n        }, {\n          key: \"clear\",\n          value: function () {\n            var t = this.ctx,\n              e = {\n                x: 0,\n                y: 0,\n                width: this.canvas.width,\n                height: this.canvas.height\n              };\n            t.clearRect(e.x, e.y, e.width, e.height), this.isMatteing = !1, this.matteSprites = {};\n          }\n        }, {\n          key: \"drawFrame\",\n          value: function (t) {\n            for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 1], r = this.ctx, i = this.isMatteing, n = this.matteSprites, s = this.videoItem.sprites, o = Hr(s.length * e[0]), a = Hr(s.length * e[1]); o < a; o++) {\n              var h,\n                u,\n                l = s[o];\n              if (-1 != (null === (h = s[0].imageKey) || void 0 === h ? void 0 : h.indexOf(\".matte\"))) {\n                if (-1 == (null === (u = l.imageKey) || void 0 === u ? void 0 : u.indexOf(\".matte\"))) {\n                  var f = s[o - 1];\n                  if (i && (!l.matteKey || 0 == l.matteKey.length || l.matteKey != f.matteKey)) {\n                    this.isMatteing = !1;\n                    var c = n[l.matteKey];\n                    r.globalCompositeOperation = \"destination-in\", this.drawSprite(c, t), r.globalCompositeOperation = \"source-over\", r.restore();\n                  }\n                  null == l.matteKey || null != f.matteKey && 0 != f.matteKey.length && f.matteKey == l.matteKey || (this.isMatteing = !0), this.drawSprite(l, t), i && o == s.length - 1 && (c = n.get(l.matteKey), r.globalCompositeOperation = \"destination-in\", this.drawSprite(c, t), r.globalCompositeOperation = \"source-over\", r.restore());\n                } else c[l.imageKey] = l;\n              } else this.drawSprite(l, t);\n            }\n          }\n        }, {\n          key: \"drawSprite\",\n          value: function (t, e) {\n            var r,\n              i,\n              n = this,\n              s = t.frames[e];\n            if (s && !(s.alpha < .05)) {\n              var o = this.ctx;\n              o.save(), this.globalTransform && o.transform(Vr(this.globalTransform.a), Vr(this.globalTransform.b), Vr(this.globalTransform.c), Vr(this.globalTransform.d), ~~this.globalTransform.tx, ~~this.globalTransform.ty), o.globalAlpha = s.alpha, o.transform(Vr(s.transform.a), Vr(s.transform.b), Vr(s.transform.c), Vr(s.transform.d), ~~s.transform.tx, ~~s.transform.ty);\n              var a = null === (r = t.imageKey) || void 0 === r ? void 0 : r.replace(\".matte\", \"\");\n              if (a) {\n                var h = null !== (i = this._dynamicImage[a]) && void 0 !== i ? i : this.videoItem.decodedImages[a];\n                if (void 0 !== s.maskPath && null !== s.maskPath && (s.maskPath._styles = void 0, this.drawBezier(s.maskPath), o.clip()), h) {\n                  var u = s.layout.width * this.transform.scale,\n                    l = s.layout.height * this.transform.scale,\n                    f = this.transform.translateX * this.dpr - (u - s.layout.width) / 2,\n                    c = this.transform.translateY * this.dpr - (l - s.layout.height) / 2;\n                  o.drawImage(h, 0, 0, h.width, h.height, f, c, u, l);\n                }\n                s.shapes && s.shapes.forEach(function (t) {\n                  var e = t.transform;\n                  \"shape\" === t.type && t.pathArgs && t.pathArgs.d && n.drawBezier(new b(t.pathArgs.d, e, t.styles)), \"ellipse\" === t.type && t.pathArgs && n.drawEllipse(new qr(parseFloat(t.pathArgs.x) || 0, parseFloat(t.pathArgs.y) || 0, parseFloat(t.pathArgs.radiusX) || 0, parseFloat(t.pathArgs.radiusY) || 0, e, t.styles)), \"rect\" === t.type && t.pathArgs && n.drawRect(new Jr(parseFloat(t.pathArgs.x) || 0, parseFloat(t.pathArgs.y) || 0, parseFloat(t.pathArgs.width) || 0, parseFloat(t.pathArgs.height) || 0, parseFloat(t.pathArgs.cornerRadius) || 0, e, t.styles));\n                });\n                var d = this._dynamicText[a];\n                if (void 0 !== d) {\n                  var p;\n                  o.font = \"\".concat(d.size, \"px \").concat(null !== (p = d.family) && void 0 !== p ? p : \"Arial\");\n                  var y = o.measureText(d.text).width;\n                  o.fillStyle = d.color;\n                  var v = void 0 !== d.offset && void 0 !== d.offset.x ? isNaN(d.offset.x) ? 0 : d.offset.x : 0,\n                    g = void 0 !== d.offset && void 0 !== d.offset.y ? isNaN(d.offset.y) ? 0 : d.offset.y : 0;\n                  o.fillText(d.text, (s.layout.width - y) / 2 + v, s.layout.height / 2 + g);\n                }\n                o.restore();\n              }\n            }\n          }\n        }, {\n          key: \"resetShapeStyles\",\n          value: function (t) {\n            var e = this.ctx,\n              r = t._styles;\n            r && (r && r.stroke ? e.strokeStyle = \"rgba(\".concat((255 * r.stroke[0]).toFixed(0), \", \").concat((255 * r.stroke[1]).toFixed(0), \", \").concat((255 * r.stroke[2]).toFixed(0), \", \").concat(r.stroke[3], \")\") : e.strokeStyle = \"transparent\", r && (e.lineWidth = r.strokeWidth || void 0, e.lineCap = r.lineCap || void 0, e.lineJoin = r.lineJoin || void 0, e.miterLimit = r.miterLimit || void 0), r && r.fill ? e.fillStyle = \"rgba(\".concat((255 * r.fill[0]).toFixed(0), \", \").concat((255 * r.fill[1]).toFixed(0), \", \").concat((255 * r.fill[2]).toFixed(0), \", \").concat(r.fill[3], \")\") : e.fillStyle = \"transparent\", r && r.lineDash && (e.lineDashOffset = r.lineDash[2], e.setLineDash([r.lineDash[0], r.lineDash[1]])));\n          }\n        }, {\n          key: \"drawBezier\",\n          value: function (t) {\n            var e = this,\n              r = this.ctx;\n            r.save(), this.resetShapeStyles(t), void 0 !== t._transform && null !== t._transform && r.transform(Vr(t._transform.a), Vr(t._transform.b), Vr(t._transform.c), Vr(t._transform.d), ~~t._transform.tx, ~~t._transform.ty);\n            var i = {\n              x: 0,\n              y: 0,\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 0\n            };\n            r.beginPath(), t._d.replace(/([a-zA-Z])/g, \"|||$1 \").replace(/,/g, \" \").split(\"|||\").forEach(function (t) {\n              if (0 != t.length) {\n                var r = t.substring(0, 1);\n                if (\"MLHVCSQRZmlhvcsqrz\".indexOf(r) >= 0) {\n                  var n = t.substring(1).trim().split(\" \");\n                  e.drawBezierElement(i, r, n);\n                }\n              }\n            }), t._styles && t._styles.fill && r.fill(), t._styles && t._styles.stroke && r.stroke(), r.restore();\n          }\n        }, {\n          key: \"drawBezierElement\",\n          value: function (t, e, r) {\n            var i = this.ctx;\n            switch (e) {\n              case \"M\":\n                t.x = Hr(r[0]), t.y = Hr(r[1]), i.moveTo(t.x, t.y);\n                break;\n              case \"m\":\n                t.x += Hr(r[0]), t.y += Hr(r[1]), i.moveTo(t.x, t.y);\n                break;\n              case \"L\":\n                t.x = Hr(r[0]), t.y = Hr(r[1]), i.lineTo(t.x, t.y);\n                break;\n              case \"l\":\n                t.x += Hr(r[0]), t.y += Hr(r[1]), i.lineTo(t.x, t.y);\n                break;\n              case \"H\":\n                t.x = Hr(r[0]), i.lineTo(t.x, t.y);\n                break;\n              case \"h\":\n                t.x += Hr(r[0]), i.lineTo(t.x, t.y);\n                break;\n              case \"V\":\n                t.y = Hr(r[0]), i.lineTo(t.x, t.y);\n                break;\n              case \"v\":\n                t.y += Hr(r[0]), i.lineTo(t.x, t.y);\n                break;\n              case \"C\":\n                t.x1 = Hr(r[0]), t.y1 = Hr(r[1]), t.x2 = Hr(r[2]), t.y2 = Hr(r[3]), t.x = Hr(r[4]), t.y = Hr(r[5]), i.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y);\n                break;\n              case \"c\":\n                t.x1 = t.x + Hr(r[0]), t.y1 = t.y + Hr(r[1]), t.x2 = t.x + Hr(r[2]), t.y2 = t.y + Hr(r[3]), t.x += Hr(r[4]), t.y += Hr(r[5]), i.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y);\n                break;\n              case \"S\":\n                t.x1 && t.y1 && t.x2 && t.y2 ? (t.x1 = t.x - t.x2 + t.x, t.y1 = t.y - t.y2 + t.y, t.x2 = Hr(r[0]), t.y2 = Hr(r[1]), t.x = Hr(r[2]), t.y = Hr(r[3]), i.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y)) : (t.x1 = Hr(r[0]), t.y1 = Hr(r[1]), t.x = Hr(r[2]), t.y = Hr(r[3]), i.quadraticCurveTo(t.x1, t.y1, t.x, t.y));\n                break;\n              case \"s\":\n                t.x1 && t.y1 && t.x2 && t.y2 ? (t.x1 = t.x - t.x2 + t.x, t.y1 = t.y - t.y2 + t.y, t.x2 = t.x + Hr(r[0]), t.y2 = t.y + Hr(r[1]), t.x += Hr(r[2]), t.y += Hr(r[3]), i.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y)) : (t.x1 = t.x + Hr(r[0]), t.y1 = t.y + Hr(r[1]), t.x += Hr(r[2]), t.y += Hr(r[3]), i.quadraticCurveTo(t.x1, t.y1, t.x, t.y));\n                break;\n              case \"Q\":\n                t.x1 = Hr(r[0]), t.y1 = Hr(r[1]), t.x = Hr(r[2]), t.y = Hr(r[3]), i.quadraticCurveTo(t.x1, t.y1, t.x, t.y);\n                break;\n              case \"q\":\n                t.x1 = t.x + Hr(r[0]), t.y1 = t.y + Hr(r[1]), t.x += Hr(r[2]), t.y += Hr(r[3]), i.quadraticCurveTo(t.x1, t.y1, t.x, t.y);\n                break;\n              case \"A\":\n              case \"a\":\n              default:\n                break;\n              case \"Z\":\n              case \"z\":\n                i.closePath();\n            }\n          }\n        }, {\n          key: \"drawEllipse\",\n          value: function (t) {\n            var e = this.ctx;\n            e.save(), this.resetShapeStyles(t), void 0 !== t._transform && null !== t._transform && e.transform(Vr(t._transform.a), Vr(t._transform.b), Vr(t._transform.c), Vr(t._transform.d), ~~t._transform.tx, ~~t._transform.ty);\n            var r = t._x - t._radiusX,\n              i = t._y - t._radiusY,\n              n = 2 * t._radiusX,\n              s = 2 * t._radiusY,\n              o = .5522848,\n              a = n / 2 * o,\n              h = s / 2 * o,\n              u = r + n,\n              l = i + s,\n              f = r + n / 2,\n              c = i + s / 2;\n            e.beginPath(), e.moveTo(r, c), e.bezierCurveTo(r, c - h, f - a, i, f, i), e.bezierCurveTo(f + a, i, u, c - h, u, c), e.bezierCurveTo(u, c + h, f + a, l, f, l), e.bezierCurveTo(f - a, l, r, c + h, r, c), t._styles && t._styles.fill && e.fill(), t._styles && t._styles.stroke && e.stroke(), e.restore();\n          }\n        }, {\n          key: \"drawRect\",\n          value: function (t) {\n            var e = this.ctx;\n            e.save(), this.resetShapeStyles(t), void 0 !== t._transform && null !== t._transform && e.transform(Vr(t._transform.a), Vr(t._transform.b), Vr(t._transform.c), Vr(t._transform.d), ~~t._transform.tx, ~~t._transform.ty);\n            var r = t._x,\n              i = t._y,\n              n = t._width,\n              s = t._height,\n              o = t._cornerRadius;\n            n < 2 * o && (o = n / 2), s < 2 * o && (o = s / 2), e.beginPath(), e.moveTo(r + o, i), e.arcTo(r + n, i, r + n, i + s, o), e.arcTo(r + n, i + s, r, i + s, o), e.arcTo(r, i + s, r, i, o), e.arcTo(r, i, r + n, i, o), e.closePath(), t._styles && t._styles.fill && e.fill(), t._styles && t._styles.stroke && e.stroke(), e.restore();\n          }\n        }, {\n          key: \"createImageData\",\n          value: function () {\n            return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n          }\n        }]);\n      }(),\n      Kr = function () {\n        function t() {\n          o(this, t), f(this, \"canvas\", void 0), f(this, \"startValue\", 0), f(this, \"endValue\", 0), f(this, \"duration\", 0), f(this, \"loops\", 1), f(this, \"fillRule\", 0), f(this, \"mRunning\", !1), f(this, \"mStartTime\", 0), f(this, \"mCurrentFrication\", 0), f(this, \"mReverse\", !1), f(this, \"requestId\", void 0), f(this, \"platform\", _()), f(this, \"onStart\", function () {}), f(this, \"onUpdate\", function (t) {}), f(this, \"onEnd\", function () {});\n        }\n        return u(t, [{\n          key: \"start\",\n          value: function (t) {\n            this.doStart(!1, t);\n          }\n        }, {\n          key: \"reverse\",\n          value: function (t) {\n            this.doStart(!0, t);\n          }\n        }, {\n          key: \"stop\",\n          value: function () {\n            this.doStop();\n          }\n        }, {\n          key: \"animatedValue\",\n          value: function () {\n            return (this.endValue - this.startValue) * this.mCurrentFrication + this.startValue;\n          }\n        }, {\n          key: \"doStart\",\n          value: function (e) {\n            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;\n            this.mReverse = e, this.mRunning = !0, this.mStartTime = t.currentTimeMillSecond(), r && (this.mStartTime -= e ? (1 - r / (this.endValue - this.startValue)) * this.duration : r / (this.endValue - this.startValue) * this.duration), this.mCurrentFrication = 0, this.onStart(), this.doFrame();\n          }\n        }, {\n          key: \"doStop\",\n          value: function () {\n            this.mRunning = !1, this.cancelAnimationFrame();\n          }\n        }, {\n          key: \"requestAnimationFrame\",\n          value: function (t) {\n            var e;\n            return \"h5\" === this.platform ? window.requestAnimationFrame(t) : null === (e = this.canvas) || void 0 === e ? void 0 : e.requestAnimationFrame(t);\n          }\n        }, {\n          key: \"cancelAnimationFrame\",\n          value: function () {\n            var t;\n            if (\"h5\" === this.platform) return window.cancelAnimationFrame(this.requestId);\n            null === (t = this.canvas) || void 0 === t || t.cancelAnimationFrame(this.requestId);\n          }\n        }, {\n          key: \"doFrame\",\n          value: function () {\n            var e = this;\n            this.requestId = this.requestAnimationFrame(function r() {\n              e.mRunning && (e.doDeltaTime(t.currentTimeMillSecond() - e.mStartTime), e.requestId = e.requestAnimationFrame(r));\n            });\n          }\n        }, {\n          key: \"doDeltaTime\",\n          value: function (t) {\n            var e = !1;\n            t >= this.duration * this.loops ? (this.mCurrentFrication = 1 === this.fillRule ? 0 : 1, this.mReverse && (this.mCurrentFrication = 1 - this.mCurrentFrication), this.mRunning = !1, e = !0) : (this.mCurrentFrication = t % this.duration / this.duration, this.mReverse && (this.mCurrentFrication = 1 - this.mCurrentFrication)), this.onUpdate(this.animatedValue()), !1 === this.mRunning && e && this.onEnd();\n          }\n        }]);\n      }();\n    f(Kr, \"currentTimeMillSecond\", function () {\n      return \"undefined\" == typeof performance ? Date.now() : performance.now();\n    });\n    var Xr = 0;\n    function Yr() {\n      if (\"h5\" === _()) return !1;\n      var t = l().getFileSystemManager(),\n        e = w();\n      try {\n        return t.accessSync(e), !0;\n      } catch (r) {\n        try {\n          return t.mkdirSync(e, !0), y(\"创建缓存目录\"), !0;\n        } catch (t) {\n          return y(\"创建缓存目录失败\", t), !1;\n        }\n      }\n    }\n    var Gr = function () {\n        return u(function t() {\n          o(this, t), f(this, \"canvas\", void 0), f(this, \"ctx\", void 0), f(this, \"platform\", _()), f(this, \"loops\", 0), f(this, \"clearsAfterStop\", !0), f(this, \"fillMode\", \"Forward\"), f(this, \"_videoItem\", void 0), f(this, \"_contentMode\", \"AspectFit\"), f(this, \"_renderer\", void 0), f(this, \"_animator\", void 0), f(this, \"_forwardAnimating\", !1), f(this, \"_currentFrame\", 0), f(this, \"_dynamicImage\", {}), f(this, \"_dynamicText\", {}), f(this, \"_onFinished\", void 0), f(this, \"_onFrame\", void 0), f(this, \"_onPercentage\", void 0);\n        }, [{\n          key: \"setCanvas\",\n          value: (i = s(e().mark(function t(r, i) {\n            var n = this;\n            return e().wrap(function (t) {\n              for (;;) switch (t.prev = t.next) {\n                case 0:\n                  return t.abrupt(\"return\", new Promise(function (t, e) {\n                    if (\"h5\" === n.platform) {\n                      var s = document.querySelector(r);\n                      n.canvas = s;\n                      var o = window.devicePixelRatio;\n                      n.canvas.width = s.clientWidth * o, n.canvas.height = s.clientHeight * o, n.ctx = s.getContext(\"2d\"), t(void 0);\n                    } else {\n                      var a = l(),\n                        h = a.createSelectorQuery();\n                      i && (h = h.in(i)), h.select(r).fields({\n                        node: !0,\n                        size: !0\n                      }).exec(function (r) {\n                        var i;\n                        if (n.canvas = null == r || null === (i = r[0]) || void 0 === i ? void 0 : i.node, n.canvas) {\n                          if (n.ctx = n.canvas.getContext(\"2d\"), n.ctx) {\n                            var s = a.getSystemInfoSync().pixelRatio;\n                            n.canvas.width = r[0].width * s, n.canvas.height = r[0].height * s, t(void 0);\n                          } else e(\"canvas context not found.\");\n                        } else e(\"canvas not found.\");\n                      });\n                    }\n                  }));\n                case 1:\n                case \"end\":\n                  return t.stop();\n              }\n            }, t);\n          })), function (t, e) {\n            return i.apply(this, arguments);\n          })\n        }, {\n          key: \"setVideoItem\",\n          value: (r = s(e().mark(function t(r, i) {\n            var n,\n              o,\n              a = this;\n            return e().wrap(function (t) {\n              for (;;) switch (t.prev = t.next) {\n                case 0:\n                  if (this.stopAnimation(!0), this._currentFrame = 0, this._videoItem = r || void 0, !r) {\n                    t.next = 16;\n                    break;\n                  }\n                  return Yr(), t.next = 7, Promise.all(Object.keys(r.spec.images).map(function () {\n                    var t = s(e().mark(function t(n) {\n                      var s;\n                      return e().wrap(function (t) {\n                        for (;;) switch (t.prev = t.next) {\n                          case 0:\n                            return t.prev = 0, t.next = 3, a.loadWXImage(r.spec.images[n], v(\"\".concat(r.src, \"/\").concat(n)), null == i ? void 0 : i.frameMode);\n                          case 3:\n                            return s = t.sent, t.abrupt(\"return\", {\n                              key: n,\n                              value: s\n                            });\n                          case 7:\n                            return t.prev = 7, t.t0 = t.catch(0), t.abrupt(\"return\", {\n                              key: n,\n                              value: void 0\n                            });\n                          case 10:\n                          case \"end\":\n                            return t.stop();\n                        }\n                      }, t, null, [[0, 7]]);\n                    }));\n                    return function (e) {\n                      return t.apply(this, arguments);\n                    };\n                  }()));\n                case 7:\n                  n = t.sent, delete r.spec.images, delete r.spec.sprites, o = {}, n.forEach(function (t) {\n                    o[t.key] = t.value;\n                  }), r.decodedImages = o, this._renderer = new $r(this._videoItem, this.canvas.width, this.canvas.height), t.next = 17;\n                  break;\n                case 16:\n                  this._renderer = void 0;\n                case 17:\n                  this.clear(), this._update();\n                case 19:\n                case \"end\":\n                  return t.stop();\n              }\n            }, t, this);\n          })), function (t, e) {\n            return r.apply(this, arguments);\n          })\n        }, {\n          key: \"loadWXImage\",\n          value: function (t, e, r) {\n            var i = this;\n            if (!this.canvas) throw new Error(\"no canvas\");\n            return new Promise(function (n, s) {\n              if (\"h5\" !== i.platform) {\n                var o = i.canvas.createImage();\n                if (o.onload = function () {\n                  n(o);\n                }, o.onerror = function () {\n                  s(new Error(\"image decoded fail.\"));\n                }, \"string\" != typeof t) switch (r) {\n                  case \"worker\":\n                  case \"wasm\":\n                  case \"base64\":\n                    o.src = \"data:image/png;base64,\".concat(g(t));\n                    break;\n                  default:\n                    var a = function (t) {\n                      t || y(\"frameName未指定\");\n                      var e = w();\n                      return \"\".concat(e, \"/\").concat(t || \"svga_temp_\".concat(++Xr), \".png\");\n                    }(e);\n                    (function (t, e) {\n                      return new Promise(function (r, i) {\n                        l().getFileSystemManager().writeFile({\n                          filePath: t,\n                          data: e,\n                          success: function () {\n                            r();\n                          },\n                          fail: function (t) {\n                            i(t);\n                          }\n                        });\n                      });\n                    })(a, t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)).then(function () {\n                      o.src = a;\n                    }).catch(function (e) {\n                      y(\"临时文件保存失败, 降级使用base64模式\", e), o.src = \"data:image/png;base64,\".concat(g(t));\n                    });\n                } else o.src = t;\n              } else if (\"string\" == typeof t) s(new Error(\"image decoded fail.\"));else {\n                var h = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);\n                n(createImageBitmap(new Blob([h])));\n              }\n            });\n          }\n        }, {\n          key: \"setContentMode\",\n          value: function (t) {\n            this._contentMode = t, this._update();\n          }\n        }, {\n          key: \"startAnimation\",\n          value: function () {\n            var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n            this.stopAnimation(!1), this._doStart(void 0, t, void 0);\n          }\n        }, {\n          key: \"startAnimationWithRange\",\n          value: function (t) {\n            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n            this.stopAnimation(!1), this._doStart(t, e, void 0);\n          }\n        }, {\n          key: \"pauseAnimation\",\n          value: function () {\n            this.stopAnimation(!1);\n          }\n        }, {\n          key: \"stopAnimation\",\n          value: function (t) {\n            this._forwardAnimating = !1, void 0 !== this._animator && this._animator.stop(), void 0 === t && (t = this.clearsAfterStop), t && this.clear();\n          }\n        }, {\n          key: \"clear\",\n          value: function () {\n            var t;\n            null === (t = this._renderer) || void 0 === t || t.clear();\n          }\n        }, {\n          key: \"stepToFrame\",\n          value: function (t) {\n            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n              r = this._videoItem;\n            r && (t >= r.frames || t < 0 || (this.pauseAnimation(), this._currentFrame = t, this._update(), e && this._doStart(void 0, !1, this._currentFrame)));\n          }\n        }, {\n          key: \"stepToPercentage\",\n          value: function (t) {\n            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n              r = this._videoItem;\n            if (r) {\n              var i = t * r.frames;\n              i >= r.frames && i > 0 && (i = r.frames - 1), this.stepToFrame(i, e);\n            }\n          }\n        }, {\n          key: \"setImage\",\n          value: (t = s(e().mark(function t(r, i) {\n            var n;\n            return e().wrap(function (t) {\n              for (;;) switch (t.prev = t.next) {\n                case 0:\n                  return Yr(), t.next = 3, this.loadWXImage(r, \"dynamic_frame_\".concat(i));\n                case 3:\n                  n = t.sent, this._dynamicImage[i] = n;\n                case 5:\n                case \"end\":\n                  return t.stop();\n              }\n            }, t, this);\n          })), function (e, r) {\n            return t.apply(this, arguments);\n          })\n        }, {\n          key: \"setText\",\n          value: function (t, e) {\n            this._dynamicText[e] = t;\n          }\n        }, {\n          key: \"clearDynamicObjects\",\n          value: function () {\n            this._dynamicImage = {}, this._dynamicText = {};\n          }\n        }, {\n          key: \"onFinished\",\n          value: function (t) {\n            this._onFinished = t;\n          }\n        }, {\n          key: \"onFrame\",\n          value: function (t) {\n            this._onFrame = t;\n          }\n        }, {\n          key: \"onPercentage\",\n          value: function (t) {\n            this._onPercentage = t;\n          }\n        }, {\n          key: \"_doStart\",\n          value: function (t) {\n            var e = this,\n              r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n              i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,\n              n = this._videoItem;\n            if (n) {\n              this._animator = new Kr(), this._animator.canvas = this.canvas;\n              var s = 1 / n.FPS * 1e3;\n              void 0 !== t ? (this._animator.startValue = Math.max(0, t.location), this._animator.endValue = Math.min(n.frames - 1, t.location + t.length), this._animator.duration = (this._animator.endValue - this._animator.startValue + 1) * s) : (this._animator.startValue = 0, this._animator.endValue = n.frames - 1, this._animator.duration = n.frames * s), this._animator.loops = this.loops <= 0 ? 1 / 0 : this.loops, this._animator.fillRule = \"Backward\" === this.fillMode ? 1 : 0, this._animator.onUpdate = function (t) {\n                e._currentFrame !== Math.floor(t) && (e._currentFrame = Math.floor(t), e._updateFrame(e._currentFrame + 1), e._update(), \"function\" == typeof e._onFrame && e._onFrame(e._currentFrame), \"function\" == typeof e._onPercentage && e._onPercentage((e._currentFrame + 1) / n.frames));\n              }, this._animator.onEnd = function () {\n                e._forwardAnimating = !1, !0 === e.clearsAfterStop && e.clear(), \"function\" == typeof e._onFinished && e._onFinished();\n              }, this._currentFrame = this._animator.startValue, this._updateFrame(this._currentFrame), this._updateFrame(this._currentFrame + 1), this._update(), !0 === r ? (this._animator.reverse(i), this._forwardAnimating = !1) : (this._animator.start(i), this._forwardAnimating = !0);\n            }\n          }\n        }, {\n          key: \"transform\",\n          value: function (t) {\n            if (this._renderer) {\n              var e = {};\n              t.translateToX ? e.translateX = t.translateToX : t.translateByX && (e.translateX = this._renderer.transform.translateX + t.translateByX), t.translateToY ? e.translateY = t.translateToY : t.translateByY && (e.translateY = this._renderer.transform.translateY + t.translateByY), t.scaleTo ? e.scale = Math.min(Math.max(t.scaleTo, .1), 5) : t.scaleBy && (e.scale = Math.min(Math.max(this._renderer.transform.scale + t.scaleBy, .1), 5)), this._renderer.transform = Rr(Rr({}, this._renderer.transform), e);\n            }\n          }\n        }, {\n          key: \"_resize\",\n          value: function () {\n            var t = this.ctx,\n              e = this._videoItem;\n            if (t && e) {\n              var r = 1,\n                i = 1,\n                n = 0,\n                s = 0,\n                o = this.canvas.width,\n                a = this.canvas.height,\n                h = e.videoSize;\n              if (\"Fill\" === this._contentMode) r = o / h.width, i = a / h.height;else if (\"AspectFit\" === this._contentMode || \"AspectFill\" === this._contentMode) {\n                var u = h.width / h.height,\n                  l = o / a;\n                u >= l && \"AspectFit\" === this._contentMode || u <= l && \"AspectFill\" === this._contentMode ? (r = i = o / h.width, s = (a - h.height * i) / 2) : (u < l && \"AspectFit\" === this._contentMode || u > l && \"AspectFill\" === this._contentMode) && (r = i = a / h.height, n = (o - h.width * r) / 2);\n              }\n              this._renderer && (this._renderer.globalTransform = {\n                a: r,\n                b: 0,\n                c: 0,\n                d: i,\n                tx: n,\n                ty: s\n              });\n            }\n          }\n        }, {\n          key: \"_updateFrame\",\n          value: function (t) {\n            this._resize(), this._renderer && (this._renderer.clear(), this._renderer._dynamicImage = this._dynamicImage, this._renderer._dynamicText = this._dynamicText, this._renderer.drawFrame(t < 0 ? 0 : t));\n          }\n        }, {\n          key: \"_update\",\n          value: function () {\n            if (this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this._renderer) {\n              var t,\n                e = this._renderer.createImageData();\n              e && (null === (t = this.ctx) || void 0 === t || t.putImageData(e, 0, 0));\n            }\n          }\n        }]);\n        var t, r, i;\n      }(),\n      Wr = function (t, e) {\n        var r = t,\n          i = ni[e],\n          n = null,\n          s = 0,\n          o = null,\n          a = [],\n          h = {},\n          u = function (t, e) {\n            n = function (t) {\n              for (var e = new Array(t), r = 0; r < t; r += 1) {\n                e[r] = new Array(t);\n                for (var i = 0; i < t; i += 1) e[r][i] = null;\n              }\n              return e;\n            }(s = 4 * r + 17), l(0, 0), l(s - 7, 0), l(0, s - 7), c(), f(), p(t, e), r >= 7 && d(t), null == o && (o = v(r, i, a)), y(o, e);\n          },\n          l = function (t, e) {\n            for (var r = -1; r <= 7; r += 1) if (!(t + r <= -1 || s <= t + r)) for (var i = -1; i <= 7; i += 1) e + i <= -1 || s <= e + i || (n[t + r][e + i] = r >= 0 && r <= 6 && (0 == i || 6 == i) || i >= 0 && i <= 6 && (0 == r || 6 == r) || r >= 2 && r <= 4 && i >= 2 && i <= 4);\n          },\n          f = function () {\n            for (var t = 8; t < s - 8; t += 1) null == n[t][6] && (n[t][6] = t % 2 == 0);\n            for (var e = 8; e < s - 8; e += 1) null == n[6][e] && (n[6][e] = e % 2 == 0);\n          },\n          c = function () {\n            for (var t = si.getPatternPosition(r), e = 0; e < t.length; e += 1) for (var i = 0; i < t.length; i += 1) {\n              var s = t[e],\n                o = t[i];\n              if (null == n[s][o]) for (var a = -2; a <= 2; a += 1) for (var h = -2; h <= 2; h += 1) n[s + a][o + h] = -2 == a || 2 == a || -2 == h || 2 == h || 0 == a && 0 == h;\n            }\n          },\n          d = function (t) {\n            for (var e = si.getBCHTypeNumber(r), i = 0; i < 18; i += 1) {\n              var o = !t && 1 == (e >> i & 1);\n              n[Math.floor(i / 3)][i % 3 + s - 8 - 3] = o;\n            }\n            for (i = 0; i < 18; i += 1) o = !t && 1 == (e >> i & 1), n[i % 3 + s - 8 - 3][Math.floor(i / 3)] = o;\n          },\n          p = function (t, e) {\n            for (var r = i << 3 | e, o = si.getBCHTypeInfo(r), a = 0; a < 15; a += 1) {\n              var h = !t && 1 == (o >> a & 1);\n              a < 6 ? n[a][8] = h : a < 8 ? n[a + 1][8] = h : n[s - 15 + a][8] = h;\n            }\n            for (a = 0; a < 15; a += 1) h = !t && 1 == (o >> a & 1), a < 8 ? n[8][s - a - 1] = h : a < 9 ? n[8][15 - a - 1 + 1] = h : n[8][15 - a - 1] = h;\n            n[s - 8][8] = !t;\n          },\n          y = function (t, e) {\n            for (var r = -1, i = s - 1, o = 7, a = 0, h = si.getMaskFunction(e), u = s - 1; u > 0; u -= 2) for (6 == u && (u -= 1);;) {\n              for (var l = 0; l < 2; l += 1) if (null == n[i][u - l]) {\n                var f = !1;\n                a < t.length && (f = 1 == (t[a] >>> o & 1)), h(i, u - l) && (f = !f), n[i][u - l] = f, -1 == (o -= 1) && (a += 1, o = 7);\n              }\n              if ((i += r) < 0 || s <= i) {\n                i -= r, r = -r;\n                break;\n              }\n            }\n          },\n          v = function (t, e, r) {\n            for (var i = hi.getRSBlocks(t, e), n = ui(), s = 0; s < r.length; s += 1) {\n              var o = r[s];\n              n.put(o.getMode(), 4), n.put(o.getLength(), si.getLengthInBits(o.getMode(), t)), o.write(n);\n            }\n            var a = 0;\n            for (s = 0; s < i.length; s += 1) a += i[s].dataCount;\n            if (n.getLengthInBits() > 8 * a) throw new Error(\"code length overflow. (\" + n.getLengthInBits() + \">\" + 8 * a + \")\");\n            for (n.getLengthInBits() + 4 <= 8 * a && n.put(0, 4); n.getLengthInBits() % 8 != 0;) n.putBit(!1);\n            for (; !(n.getLengthInBits() >= 8 * a || (n.put(236, 8), n.getLengthInBits() >= 8 * a));) n.put(17, 8);\n            return function (t, e) {\n              for (var r = 0, i = 0, n = 0, s = new Array(e.length), o = new Array(e.length), a = 0; a < e.length; a += 1) {\n                var h = e[a].dataCount,\n                  u = e[a].totalCount - h;\n                i = Math.max(i, h), n = Math.max(n, u), s[a] = new Array(h);\n                for (var l = 0; l < s[a].length; l += 1) s[a][l] = 255 & t.getBuffer()[l + r];\n                r += h;\n                var f = si.getErrorCorrectPolynomial(u),\n                  c = ai(s[a], f.getLength() - 1).mod(f);\n                for (o[a] = new Array(f.getLength() - 1), l = 0; l < o[a].length; l += 1) {\n                  var d = l + c.getLength() - o[a].length;\n                  o[a][l] = d >= 0 ? c.getAt(d) : 0;\n                }\n              }\n              var p = 0;\n              for (l = 0; l < e.length; l += 1) p += e[l].totalCount;\n              var y = new Array(p),\n                v = 0;\n              for (l = 0; l < i; l += 1) for (a = 0; a < e.length; a += 1) l < s[a].length && (y[v] = s[a][l], v += 1);\n              for (l = 0; l < n; l += 1) for (a = 0; a < e.length; a += 1) l < o[a].length && (y[v] = o[a][l], v += 1);\n              return y;\n            }(n, i);\n          };\n        return h.addData = function (t) {\n          var e = li(t);\n          a.push(e), o = null;\n        }, h.isDark = function (t, e) {\n          if (t < 0 || s <= t || e < 0 || s <= e) throw new Error(t + \",\" + e);\n          return n[t][e];\n        }, h.getModuleCount = function () {\n          return s;\n        }, h.make = function () {\n          u(!1, function () {\n            for (var t = 0, e = 0, r = 0; r < 8; r += 1) {\n              u(!0, r);\n              var i = si.getLostPoint(h);\n              (0 == r || t > i) && (t = i, e = r);\n            }\n            return e;\n          }());\n        }, h.createTableTag = function (t, e) {\n          t = t || 2;\n          var r = \"\";\n          r += '<table style=\"', r += \" border-width: 0px; border-style: none;\", r += \" border-collapse: collapse;\", r += \" padding: 0px; margin: \" + (e = void 0 === e ? 4 * t : e) + \"px;\", r += '\">', r += \"<tbody>\";\n          for (var i = 0; i < h.getModuleCount(); i += 1) {\n            r += \"<tr>\";\n            for (var n = 0; n < h.getModuleCount(); n += 1) r += '<td style=\"', r += \" border-width: 0px; border-style: none;\", r += \" border-collapse: collapse;\", r += \" padding: 0px; margin: 0px;\", r += \" width: \" + t + \"px;\", r += \" height: \" + t + \"px;\", r += \" background-color: \", r += h.isDark(i, n) ? \"#000000\" : \"#ffffff\", r += \";\", r += '\"/>';\n            r += \"</tr>\";\n          }\n          return (r += \"</tbody>\") + \"</table>\";\n        }, h.createImgTag = function (t, e, r, i, n) {\n          t = t || 2;\n          var s = e = void 0 === e ? 4 * t : e,\n            o = h.getModuleCount() * t + e;\n          return di(r, r, function (e, r) {\n            if (s <= e && e < o && s <= r && r < o) {\n              var i = Math.floor((e - s) / t),\n                n = Math.floor((r - s) / t);\n              return h.isDark(n, i) ? 0 : 1;\n            }\n            return 1;\n          }, i, n);\n        }, h;\n      };\n    Wr.stringToBytes = function (t) {\n      for (var e = [], r = 0; r < t.length; r += 1) {\n        var i = t.charCodeAt(r);\n        e.push(255 & i);\n      }\n      return e;\n    }, Wr.createStringToBytes = function (t, e) {\n      var r = function () {\n          for (var r = ci(t), i = function () {\n              var t = r.read();\n              if (-1 == t) throw new Error();\n              return t;\n            }, n = 0, s = {};;) {\n            var o = r.read();\n            if (-1 == o) break;\n            var a = i(),\n              h = i() << 8 | i();\n            s[String.fromCharCode(o << 8 | a)] = h, n += 1;\n          }\n          if (n != e) throw new Error(n + \" != \" + e);\n          return s;\n        }(),\n        i = \"?\".charCodeAt(0);\n      return function (t) {\n        for (var e = [], n = 0; n < t.length; n += 1) {\n          var s = t.charCodeAt(n);\n          if (s < 128) e.push(s);else {\n            var o = r[t.charAt(n)];\n            \"number\" == typeof o ? (255 & o) == o ? e.push(o) : (e.push(o >>> 8), e.push(255 & o)) : e.push(i);\n          }\n        }\n        return e;\n      };\n    };\n    var Qr,\n      ti,\n      ei,\n      ri,\n      ii,\n      ni = {\n        L: 1,\n        M: 0,\n        Q: 3,\n        H: 2\n      },\n      si = (Qr = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], ti = 1335, ei = 7973, ii = function (t) {\n        for (var e = 0; 0 != t;) e += 1, t >>>= 1;\n        return e;\n      }, (ri = {}).getBCHTypeInfo = function (t) {\n        for (var e = t << 10; ii(e) - ii(ti) >= 0;) e ^= ti << ii(e) - ii(ti);\n        return 21522 ^ (t << 10 | e);\n      }, ri.getBCHTypeNumber = function (t) {\n        for (var e = t << 12; ii(e) - ii(ei) >= 0;) e ^= ei << ii(e) - ii(ei);\n        return t << 12 | e;\n      }, ri.getPatternPosition = function (t) {\n        return Qr[t - 1];\n      }, ri.getMaskFunction = function (t) {\n        switch (t) {\n          case 0:\n            return function (t, e) {\n              return (t + e) % 2 == 0;\n            };\n          case 1:\n            return function (t) {\n              return t % 2 == 0;\n            };\n          case 2:\n            return function (t, e) {\n              return e % 3 == 0;\n            };\n          case 3:\n            return function (t, e) {\n              return (t + e) % 3 == 0;\n            };\n          case 4:\n            return function (t, e) {\n              return (Math.floor(t / 2) + Math.floor(e / 3)) % 2 == 0;\n            };\n          case 5:\n            return function (t, e) {\n              return t * e % 2 + t * e % 3 == 0;\n            };\n          case 6:\n            return function (t, e) {\n              return (t * e % 2 + t * e % 3) % 2 == 0;\n            };\n          case 7:\n            return function (t, e) {\n              return (t * e % 3 + (t + e) % 2) % 2 == 0;\n            };\n          default:\n            throw new Error(\"bad maskPattern:\" + t);\n        }\n      }, ri.getErrorCorrectPolynomial = function (t) {\n        for (var e = ai([1], 0), r = 0; r < t; r += 1) e = e.multiply(ai([1, oi.gexp(r)], 0));\n        return e;\n      }, ri.getLengthInBits = function (t, e) {\n        if (e >= 1 && e < 10) switch (t) {\n          case 1:\n            return 10;\n          case 2:\n            return 9;\n          case 4:\n          case 8:\n            return 8;\n          default:\n            throw new Error(\"mode:\" + t);\n        } else if (e < 27) switch (t) {\n          case 1:\n            return 12;\n          case 2:\n            return 11;\n          case 4:\n            return 16;\n          case 8:\n            return 10;\n          default:\n            throw new Error(\"mode:\" + t);\n        } else {\n          if (!(e < 41)) throw new Error(\"type:\" + e);\n          switch (t) {\n            case 1:\n              return 14;\n            case 2:\n              return 13;\n            case 4:\n              return 16;\n            case 8:\n              return 12;\n            default:\n              throw new Error(\"mode:\" + t);\n          }\n        }\n      }, ri.getLostPoint = function (t) {\n        for (var e = t.getModuleCount(), r = 0, i = 0; i < e; i += 1) for (var n = 0; n < e; n += 1) {\n          for (var s = 0, o = t.isDark(i, n), a = -1; a <= 1; a += 1) if (!(i + a < 0 || e <= i + a)) for (var h = -1; h <= 1; h += 1) n + h < 0 || e <= n + h || 0 == a && 0 == h || o == t.isDark(i + a, n + h) && (s += 1);\n          s > 5 && (r += 3 + s - 5);\n        }\n        for (i = 0; i < e - 1; i += 1) for (n = 0; n < e - 1; n += 1) {\n          var u = 0;\n          t.isDark(i, n) && (u += 1), t.isDark(i + 1, n) && (u += 1), t.isDark(i, n + 1) && (u += 1), t.isDark(i + 1, n + 1) && (u += 1), 0 != u && 4 != u || (r += 3);\n        }\n        for (i = 0; i < e; i += 1) for (n = 0; n < e - 6; n += 1) t.isDark(i, n) && !t.isDark(i, n + 1) && t.isDark(i, n + 2) && t.isDark(i, n + 3) && t.isDark(i, n + 4) && !t.isDark(i, n + 5) && t.isDark(i, n + 6) && (r += 40);\n        for (n = 0; n < e; n += 1) for (i = 0; i < e - 6; i += 1) t.isDark(i, n) && !t.isDark(i + 1, n) && t.isDark(i + 2, n) && t.isDark(i + 3, n) && t.isDark(i + 4, n) && !t.isDark(i + 5, n) && t.isDark(i + 6, n) && (r += 40);\n        var l = 0;\n        for (n = 0; n < e; n += 1) for (i = 0; i < e; i += 1) t.isDark(i, n) && (l += 1);\n        return r + Math.abs(100 * l / e / e - 50) / 5 * 10;\n      }, ri),\n      oi = function () {\n        for (var t = new Array(256), e = new Array(256), r = 0; r < 8; r += 1) t[r] = 1 << r;\n        for (r = 8; r < 256; r += 1) t[r] = t[r - 4] ^ t[r - 5] ^ t[r - 6] ^ t[r - 8];\n        for (r = 0; r < 255; r += 1) e[t[r]] = r;\n        return {\n          glog: function (t) {\n            if (t < 1) throw new Error(\"glog(\" + t + \")\");\n            return e[t];\n          },\n          gexp: function (e) {\n            for (; e < 0;) e += 255;\n            for (; e >= 256;) e -= 255;\n            return t[e];\n          }\n        };\n      }();\n    function ai(t, e) {\n      if (void 0 === t.length) throw new Error(t.length + \"/\" + e);\n      var r = function () {\n          for (var r = 0; r < t.length && 0 == t[r];) r += 1;\n          for (var i = new Array(t.length - r + e), n = 0; n < t.length - r; n += 1) i[n] = t[n + r];\n          return i;\n        }(),\n        i = {\n          getAt: function (t) {\n            return r[t];\n          },\n          getLength: function () {\n            return r.length;\n          },\n          multiply: function (t) {\n            for (var e = new Array(i.getLength() + t.getLength() - 1), r = 0; r < i.getLength(); r += 1) for (var n = 0; n < t.getLength(); n += 1) e[r + n] ^= oi.gexp(oi.glog(i.getAt(r)) + oi.glog(t.getAt(n)));\n            return ai(e, 0);\n          },\n          mod: function (t) {\n            if (i.getLength() - t.getLength() < 0) return i;\n            for (var e = oi.glog(i.getAt(0)) - oi.glog(t.getAt(0)), r = new Array(i.getLength()), n = 0; n < i.getLength(); n += 1) r[n] = i.getAt(n);\n            for (n = 0; n < t.getLength(); n += 1) r[n] ^= oi.gexp(oi.glog(t.getAt(n)) + e);\n            return ai(r, 0).mod(t);\n          }\n        };\n      return i;\n    }\n    var hi = function () {\n        var t = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],\n          e = function (t, e) {\n            var r = {};\n            return r.totalCount = t, r.dataCount = e, r;\n          },\n          r = {\n            getRSBlocks: function (r, i) {\n              var n = function (e, r) {\n                switch (r) {\n                  case ni.L:\n                    return t[4 * (e - 1) + 0];\n                  case ni.M:\n                    return t[4 * (e - 1) + 1];\n                  case ni.Q:\n                    return t[4 * (e - 1) + 2];\n                  case ni.H:\n                    return t[4 * (e - 1) + 3];\n                  default:\n                    return;\n                }\n              }(r, i);\n              if (void 0 === n) throw new Error(\"bad rs block @ typeNumber:\" + r + \"/errorCorrectLevel:\" + i);\n              for (var s = n.length / 3, o = [], a = 0; a < s; a += 1) for (var h = n[3 * a + 0], u = n[3 * a + 1], l = n[3 * a + 2], f = 0; f < h; f += 1) o.push(e(u, l));\n              return o;\n            }\n          };\n        return r;\n      }(),\n      ui = function () {\n        var t = [],\n          e = 0,\n          r = {\n            getBuffer: function () {\n              return t;\n            },\n            getAt: function (e) {\n              var r = Math.floor(e / 8);\n              return 1 == (t[r] >>> 7 - e % 8 & 1);\n            },\n            put: function (t, e) {\n              for (var i = 0; i < e; i += 1) r.putBit(1 == (t >>> e - i - 1 & 1));\n            },\n            getLengthInBits: function () {\n              return e;\n            },\n            putBit: function (r) {\n              var i = Math.floor(e / 8);\n              t.length <= i && t.push(0), r && (t[i] |= 128 >>> e % 8), e += 1;\n            }\n          };\n        return r;\n      },\n      li = function (t) {\n        for (var e = t, r = [], i = {}, n = 0, s = e.length; n < s; n++) {\n          var o = [],\n            a = e.charCodeAt(n);\n          a > 65536 ? (o[0] = 240 | (1835008 & a) >>> 18, o[1] = 128 | (258048 & a) >>> 12, o[2] = 128 | (4032 & a) >>> 6, o[3] = 128 | 63 & a) : a > 2048 ? (o[0] = 224 | (61440 & a) >>> 12, o[1] = 128 | (4032 & a) >>> 6, o[2] = 128 | 63 & a) : a > 128 ? (o[0] = 192 | (1984 & a) >>> 6, o[1] = 128 | 63 & a) : o[0] = a, r.push(o);\n        }\n        (r = Array.prototype.concat.apply([], r)).length != e.length && (r.unshift(191), r.unshift(187), r.unshift(239));\n        var h = r;\n        return i.getMode = function () {\n          return 4;\n        }, i.getLength = function () {\n          return h.length;\n        }, i.write = function (t) {\n          for (var e = 0; e < h.length; e += 1) t.put(h[e], 8);\n        }, i;\n      },\n      fi = function () {\n        var t = [],\n          e = {\n            writeByte: function (e) {\n              t.push(255 & e);\n            },\n            writeShort: function (t) {\n              e.writeByte(t), e.writeByte(t >>> 8);\n            },\n            writeBytes: function (t, r, i) {\n              r = r || 0, i = i || t.length;\n              for (var n = 0; n < i; n += 1) e.writeByte(t[n + r]);\n            },\n            writeString: function (t) {\n              for (var r = 0; r < t.length; r += 1) e.writeByte(t.charCodeAt(r));\n            },\n            toByteArray: function () {\n              return t;\n            },\n            toString: function () {\n              var e = \"\";\n              e += \"[\";\n              for (var r = 0; r < t.length; r += 1) r > 0 && (e += \",\"), e += t[r];\n              return e + \"]\";\n            }\n          };\n        return e;\n      },\n      ci = function (t) {\n        var e = t,\n          r = 0,\n          i = 0,\n          n = 0,\n          s = {\n            read: function () {\n              for (; n < 8;) {\n                if (r >= e.length) {\n                  if (0 == n) return -1;\n                  throw new Error(\"unexpected end of file./\" + n);\n                }\n                var t = e.charAt(r);\n                if (r += 1, \"=\" == t) return n = 0, -1;\n                t.match(/^\\s$/) || (i = i << 6 | o(t.charCodeAt(0)), n += 6);\n              }\n              var s = i >>> n - 8 & 255;\n              return n -= 8, s;\n            }\n          },\n          o = function (t) {\n            if (t >= 65 && t <= 90) return t - 65;\n            if (t >= 97 && t <= 122) return t - 97 + 26;\n            if (t >= 48 && t <= 57) return t - 48 + 52;\n            if (43 == t) return 62;\n            if (47 == t) return 63;\n            throw new Error(\"c:\" + t);\n          };\n        return s;\n      },\n      di = function (t, e, r, i, n) {\n        for (var s = function (t, e) {\n            var r = t,\n              i = e,\n              n = new Array(t * e),\n              s = {\n                setPixel: function (t, e, i) {\n                  n[e * r + t] = i;\n                },\n                write: function (t) {\n                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"#000000\",\n                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"#ffffff\";\n                  t.writeString(\"GIF87a\"), t.writeShort(r), t.writeShort(i), t.writeByte(128), t.writeByte(0), t.writeByte(0);\n                  var s = e.split(\"\");\n                  t.writeByte(parseInt(\"\".concat(s[1]).concat(s[2]), 16)), t.writeByte(parseInt(\"\".concat(s[3]).concat(s[4]), 16)), t.writeByte(parseInt(\"\".concat(s[5]).concat(s[6]), 16));\n                  var a = n.split(\"\");\n                  t.writeByte(parseInt(\"\".concat(a[1]).concat(a[2]), 16)), t.writeByte(parseInt(\"\".concat(a[3]).concat(a[4]), 16)), t.writeByte(parseInt(\"\".concat(a[5]).concat(a[6]), 16)), t.writeString(\",\"), t.writeShort(0), t.writeShort(0), t.writeShort(r), t.writeShort(i), t.writeByte(0);\n                  var h = o(2);\n                  t.writeByte(2);\n                  for (var u = 0; h.length - u > 255;) t.writeByte(255), t.writeBytes(h, u, 255), u += 255;\n                  t.writeByte(h.length - u), t.writeBytes(h, u, h.length - u), t.writeByte(0), t.writeString(\";\");\n                }\n              },\n              o = function (t) {\n                for (var e = 1 << t, r = 1 + (1 << t), i = t + 1, s = a(), o = 0; o < e; o += 1) s.add(String.fromCharCode(o));\n                s.add(String.fromCharCode(e)), s.add(String.fromCharCode(r));\n                var h,\n                  u,\n                  l,\n                  f = fi(),\n                  c = (h = f, u = 0, l = 0, {\n                    write: function (t, e) {\n                      if (t >>> e != 0) throw new Error(\"length over\");\n                      for (; u + e >= 8;) h.writeByte(255 & (t << u | l)), e -= 8 - u, t >>>= 8 - u, l = 0, u = 0;\n                      l |= t << u, u += e;\n                    },\n                    flush: function () {\n                      u > 0 && h.writeByte(l);\n                    }\n                  });\n                c.write(e, i);\n                var d = 0,\n                  p = String.fromCharCode(n[d]);\n                for (d += 1; d < n.length;) {\n                  var y = String.fromCharCode(n[d]);\n                  d += 1, s.contains(p + y) ? p += y : (c.write(s.indexOf(p), i), s.size() < 4095 && (s.size() == 1 << i && (i += 1), s.add(p + y)), p = y);\n                }\n                return c.write(s.indexOf(p), i), c.write(r, i), c.flush(), f.toByteArray();\n              },\n              a = function () {\n                var t = {},\n                  e = 0,\n                  r = {\n                    add: function (i) {\n                      if (r.contains(i)) throw new Error(\"dup key:\" + i);\n                      t[i] = e, e += 1;\n                    },\n                    size: function () {\n                      return e;\n                    },\n                    indexOf: function (e) {\n                      return t[e];\n                    },\n                    contains: function (e) {\n                      return void 0 !== t[e];\n                    }\n                  };\n                return r;\n              };\n            return s;\n          }(t, e), o = 0; o < e; o += 1) for (var a = 0; a < t; a += 1) s.setPixel(a, o, r(a, o));\n        var h = fi();\n        s.write(h, i, n);\n        for (var u = function () {\n            var t = 0,\n              e = 0,\n              r = 0,\n              i = \"\",\n              n = {},\n              s = function (t) {\n                i += String.fromCharCode(o(63 & t));\n              },\n              o = function (t) {\n                if (t < 0) ;else {\n                  if (t < 26) return 65 + t;\n                  if (t < 52) return t - 26 + 97;\n                  if (t < 62) return t - 52 + 48;\n                  if (62 == t) return 43;\n                  if (63 == t) return 47;\n                }\n                throw new Error(\"n:\" + t);\n              };\n            return n.writeByte = function (i) {\n              for (t = t << 8 | 255 & i, e += 8, r += 1; e >= 6;) s(t >>> e - 6), e -= 6;\n            }, n.flush = function () {\n              if (e > 0 && (s(t << 6 - e), t = 0, e = 0), r % 3 != 0) for (var n = 3 - r % 3, o = 0; o < n; o += 1) i += \"=\";\n            }, n.toString = function () {\n              return i;\n            }, n;\n          }(), l = h.toByteArray(), f = 0; f < l.length; f += 1) u.writeByte(l[f]);\n        u.flush();\n        var c = \"\";\n        return (c += \"data:image/gif;base64,\") + u;\n      },\n      pi = 0;\n    function yi(t, e, r) {\n      var i;\n      try {\n        (i = Wr(r, e)).addData(t), i.make();\n      } catch (i) {\n        if (r >= 40) throw new Error(\"Text too long to encode\");\n        return yi(t, e, r + 1);\n      }\n      return i;\n    }\n    var vi = function () {\n      function r(t, e, i) {\n        switch (o(this, r), f(this, \"platform\", void 0), f(this, \"size\", void 0), f(this, \"dpi\", 1), f(this, \"context\", void 0), f(this, \"canvas\", void 0), f(this, \"cachedImages\", {}), this.platform = _(), this.dpi = i || this.dpi, this.size = {\n          width: t || 300,\n          height: e || 300\n        }, this.platform) {\n          case \"weapp\":\n            this.canvas = has.createOffscreenCanvas({\n              type: \"2d\",\n              width: this.size.width * this.dpi,\n              height: this.size.height * this.dpi\n            }), this.context = this.canvas.getContext(\"2d\");\n            break;\n          case \"alipay\":\n            this.canvas = my.createOffscreenCanvas({\n              type: \"2d\",\n              width: this.size.width * this.dpi,\n              height: this.size.height * this.dpi\n            }), this.context = this.canvas.getContext(\"2d\");\n            break;\n          case \"tt\":\n            this.canvas = has.createOffscreenCanvas({\n              type: \"2d\",\n              width: this.size.width * this.dpi,\n              height: this.size.height * this.dpi\n            }), this.context = this.canvas.getContext(\"2d\");\n            break;\n          case \"h5\":\n            this.canvas = new OffscreenCanvas(this.size.width * this.dpi, this.size.height * this.dpi), this.context = this.canvas.getContext(\"2d\");\n            break;\n          default:\n            y(\"[painter]不支持当前平台\", this.platform);\n        }\n      }\n      return u(r, [{\n        key: \"calcBound\",\n        value: function (e) {\n          var r,\n            i,\n            n = this.calcBoundSize(e.width, this.size.width) || 0,\n            s = this.calcBoundSize(e.height, this.size.height) || 0,\n            o = this.calcBoundSize(e.left, this.size.width),\n            a = this.calcBoundSize(e.right, this.size.width),\n            h = this.calcBoundSize(e.top, this.size.height),\n            u = this.calcBoundSize(e.bottom, this.size.height),\n            l = Math.max(0, Math.min(n, s)),\n            f = this.calcBoundSize(\"object\" === t(e.radius) ? e.radius.tl : e.radius, l) || 0;\n          f = Math.min(l / 2, Math.max(f, 0));\n          var c = this.calcBoundSize(\"object\" === t(e.radius) ? e.radius.tr : e.radius, l) || 0;\n          c = Math.min(l / 2, Math.max(c, 0));\n          var d = this.calcBoundSize(\"object\" === t(e.radius) ? e.radius.bl : e.radius, l) || 0;\n          d = Math.min(l / 2, Math.max(d, 0));\n          var p = this.calcBoundSize(\"object\" === t(e.radius) ? e.radius.br : e.radius, l) || 0;\n          return p = Math.min(l / 2, Math.max(p, 0)), r = void 0 !== o ? void 0 !== a ? o + (this.size.width - o - a - n) / 2 : o : void 0 !== a ? this.size.width - a - n : 0, i = void 0 !== h ? void 0 !== u ? h + (this.size.height - h - u - s) / 2 : h : void 0 !== u ? this.size.height - u - s : 0, {\n            x: r * this.dpi,\n            y: i * this.dpi,\n            width: n * this.dpi,\n            height: s * this.dpi,\n            radiusTL: f * this.dpi,\n            radiusTR: c * this.dpi,\n            radiusBL: d * this.dpi,\n            radiusBR: p * this.dpi\n          };\n        }\n      }, {\n        key: \"calcBoundSize\",\n        value: function (t, e) {\n          return \"string\" == typeof t ? /[\\d\\.]+%$/.test(t) ? e * Number(t.substring(0, t.length - 1)) / 100 : 0 : t;\n        }\n      }, {\n        key: \"drawImage\",\n        value: (d = s(e().mark(function t(r, i) {\n          var n, s, o, a, h, u, l, f;\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return this.context.save(), t.next = 3, this.loadImage(r);\n              case 3:\n                n = t.sent, s = n.width, o = n.height, a = n.width, h = n.height, u = this.calcBoundSize(i.width, this.size.width), (l = this.calcBoundSize(i.height, this.size.height)) ? u ? (a = u, h = l) : (a = n.width * l / n.height, h = l) : u ? (a = u, h = n.height * u / n.width) : (a = n.width, h = n.height), f = this.calcBound(Rr(Rr({}, i), {}, {\n                  width: a,\n                  height: h\n                })), this.drawRect(f), this.context.clip(), this.context.drawImage(n.data, 0, 0, s, o, f.x, f.y, f.width, f.height), this.context.restore();\n              case 13:\n              case \"end\":\n                return t.stop();\n            }\n          }, t, this);\n        })), function (t, e) {\n          return d.apply(this, arguments);\n        })\n      }, {\n        key: \"drawText\",\n        value: (c = s(e().mark(function t(r, i, n) {\n          var s, o, a, h;\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return this.context.save(), s = this.calcBound(i), this.context.fillStyle = (null == n ? void 0 : n.color) || \"#000000\", o = ((null == n ? void 0 : n.fontSize) || 16) * this.dpi, this.context.font = \"\".concat((null == n ? void 0 : n.fontWeight) || \"normal\", \" \").concat(o, \"px \").concat((null == n ? void 0 : n.fontFamily) || \"sans-serif\"), this.context.textBaseline = \"top\", this.context.textAlign = (null == n ? void 0 : n.textAlign) || \"start\", a = this.context.measureText(r), h = a.width, i.width ? this.context.fillText(r, s.x, s.y, s.width) : this.context.fillText(r, s.x, s.y), this.context.restore(), t.abrupt(\"return\", {\n                  width: i.width ? s.width : h,\n                  height: o\n                });\n              case 11:\n              case \"end\":\n                return t.stop();\n            }\n          }, t, this);\n        })), function (t, e, r) {\n          return c.apply(this, arguments);\n        })\n      }, {\n        key: \"drawQrCode\",\n        value: (h = s(e().mark(function t(r, i, n) {\n          var s, o, a, h, u, l, f, c, d, p, y;\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                for (this.context.save(), s = \"string\" == typeof r ? yi(r, n.level, 4) : r, o = s.getModuleCount(), a = Math.ceil(n.size / o), h = a * o + 2 * n.margin, u = this.calcBound(Rr(Rr({}, i), {}, {\n                  width: h,\n                  height: h\n                })), l = n.margin * this.dpi, f = a * this.dpi, this.context.fillStyle = n.bgColor, this.context.fillRect(u.x, u.y, u.x + u.width, u.y + u.height), c = 0; c < s.getModuleCount(); c++) for (d = 0; d < s.getModuleCount(); d++) this.context.fillStyle = s.isDark(c, d) ? n.fgColor : n.bgColor, p = Math.ceil((d + 1) * f) - Math.floor(d * f), y = Math.ceil((c + 1) * f) - Math.floor(c * f), this.context.fillRect(u.x + Math.round(d * f) + l, u.y + Math.round(c * f) + l, p, y);\n                return this.context.restore(), t.abrupt(\"return\", {\n                  width: u.width,\n                  height: u.height\n                });\n              case 13:\n              case \"end\":\n                return t.stop();\n            }\n          }, t, this);\n        })), function (t, e, r) {\n          return h.apply(this, arguments);\n        })\n      }, {\n        key: \"drawColor\",\n        value: (a = s(e().mark(function t(r, i) {\n          var n;\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                this.context.save(), n = this.calcBound(Rr(Rr({}, i), {}, {\n                  width: i.width || 100,\n                  height: i.height || 100\n                })), this.drawRect(n), this.context.fillStyle = r, this.context.fill(), this.context.restore();\n              case 6:\n              case \"end\":\n                return t.stop();\n            }\n          }, t, this);\n        })), function (t, e) {\n          return a.apply(this, arguments);\n        })\n      }, {\n        key: \"loadImage\",\n        value: function (t) {\n          var e = this;\n          return new Promise(function (r, i) {\n            if (\"h5\" === e.platform) {\n              var n = document.createElement(\"img\");\n              n.crossOrigin = \"anonymous\", n.onload = function () {\n                r({\n                  width: n.naturalWidth,\n                  height: n.naturalHeight,\n                  data: n\n                });\n              }, n.onerror = function () {\n                i(\"加载失败\");\n              }, n.src = t;\n            } else {\n              var s = e.canvas.createImage();\n              e.cachedImages[t] ? (s.src = t, y(\"[painter]cache image matched\", t), r({\n                width: e.cachedImages[t].width,\n                height: e.cachedImages[t].height,\n                data: s\n              })) : (s.onload = function () {\n                e.cachedImages[t] = s, r({\n                  width: s.width,\n                  height: s.height,\n                  data: s\n                });\n              }, s.onerror = function () {\n                i(\"加载失败\");\n              }, s.src = t.startsWith(\"data:image/\") ? t : t.includes(\"?\") ? \"\".concat(t, \"&t=\").concat(Date.now()) : \"\".concat(t, \"?t=\").concat(Date.now()));\n            }\n          });\n        }\n      }, {\n        key: \"drawRect\",\n        value: function (t) {\n          this.context.beginPath(), this.context.moveTo(t.x + t.radiusTL, t.y), this.context.lineTo(t.x + t.width - t.radiusTR, t.y), this.context.arcTo(t.x + t.width, t.y, t.x + t.width, t.y + t.radiusTR, t.radiusTR), this.context.lineTo(t.x + t.width, t.y + t.height - t.radiusBR), this.context.arcTo(t.x + t.width, t.y + t.height, t.x + t.width - t.radiusBR, t.y + t.height, t.radiusBR), this.context.lineTo(t.x + t.radiusBL, t.y + t.height), this.context.arcTo(t.x, t.y + t.height, t.x, t.y + t.height - t.radiusBL, t.radiusBL), this.context.lineTo(t.x, t.y + t.radiusTL), this.context.arcTo(t.x, t.y, t.x + t.radiusTL, t.y, t.radiusTL), this.context.closePath();\n        }\n      }, {\n        key: \"drawCustom\",\n        value: (n = s(e().mark(function t(r) {\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return this.context.save(), t.next = 3, r(this.context);\n              case 3:\n                this.context.restore();\n              case 4:\n              case \"end\":\n                return t.stop();\n            }\n          }, t, this);\n        })), function (t) {\n          return n.apply(this, arguments);\n        })\n      }, {\n        key: \"output\",\n        value: function (t) {\n          var e = this;\n          return new Promise(function (i, n) {\n            switch (e.platform) {\n              case \"h5\":\n                e.canvas.convertToBlob({\n                  type: \"image/png\",\n                  quality: 1\n                }).then(function (t) {\n                  var e = new FileReader();\n                  e.onload = function () {\n                    var t = e.result;\n                    i({\n                      src: t,\n                      hash: \"\"\n                    });\n                  }, e.onerror = n, e.readAsDataURL(t);\n                }).catch(n);\n                break;\n              case \"alipay\":\n                var s = e.context.canvas.toDataURL(\"image/png\");\n                if (\"file\" === t) {\n                  Yr();\n                  var o = l(),\n                    a = o.getFileSystemManager(),\n                    h = \"\".concat(w(), \"/painter_image_\").concat(++pi, \".png\");\n                  o.downloadFile({\n                    url: s,\n                    success: function (t) {\n                      a.saveFile({\n                        filePath: h,\n                        tempFilePath: t.tempFilePath,\n                        success: function () {\n                          r.getHash(h, \"file\").then(function (t) {\n                            i({\n                              src: h,\n                              hash: t\n                            });\n                          }).catch(function (t) {\n                            console.warn(\"[svga/painter]hash failed\", t), i({\n                              src: h,\n                              hash: \"\"\n                            });\n                          });\n                        },\n                        fail: function (t) {\n                          n(new Error(t.errMsg || \"output failed(1)\"));\n                        }\n                      });\n                    },\n                    fail: function (t) {\n                      n(new Error(t.errMsg || \"output failed(0)\"));\n                    }\n                  });\n                } else i({\n                  src: s,\n                  hash: v(s)\n                });\n                break;\n              case \"weapp\":\n              case \"tt\":\n                var u = e.context.canvas.toDataURL(\"image/png\");\n                if (\"file\" === t) {\n                  Yr();\n                  var f = l().getFileSystemManager(),\n                    c = \"\".concat(w(), \"/painter_image_\").concat(++pi, \".png\");\n                  f.writeFile({\n                    filePath: c,\n                    encoding: \"base64\",\n                    data: u.substring(22),\n                    success: function () {\n                      r.getHash(c, \"file\").then(function (t) {\n                        i({\n                          src: c,\n                          hash: t\n                        });\n                      }).catch(function (t) {\n                        console.warn(\"[svga/painter]hash failed\", t), i({\n                          src: c,\n                          hash: \"\"\n                        });\n                      });\n                    },\n                    fail: function (t) {\n                      n(new Error(t.errMsg || \"output failed\"));\n                    }\n                  });\n                } else i({\n                  src: u,\n                  hash: v(u)\n                });\n                break;\n              default:\n                n(new Error(\"暂不支持当前平台\"));\n            }\n          });\n        }\n      }], [{\n        key: \"getHash\",\n        value: function (t, e) {\n          return new Promise(function (r, i) {\n            \"base64\" !== e ? l().getFileSystemManager().getFileInfo({\n              filePath: t,\n              digestAlgorithm: \"md5\",\n              success: function (t) {\n                r(t.digest);\n              },\n              fail: function (t) {\n                i(t.errMsg || \"unknown error\");\n              }\n            }) : r(v(t));\n          });\n        }\n      }, {\n        key: \"qrcode\",\n        value: (i = s(e().mark(function t(i, n) {\n          var s, o, a, h, u, l, f, c, d, p;\n          return e().wrap(function (t) {\n            for (;;) switch (t.prev = t.next) {\n              case 0:\n                return s = (null == n ? void 0 : n.level) || \"M\", o = yi(i, s, 4), a = o.getModuleCount(), h = (null == n ? void 0 : n.size) || 300, u = Math.ceil(h / a), l = u * a, f = \"number\" == typeof (null == n ? void 0 : n.margin) ? n.margin : \"string\" == typeof (null == n ? void 0 : n.margin) && n.margin.endsWith(\"t\") ? u * (Number(n.margin.substring(0, n.margin.length - 1)) || 0) : u, d = new r(c = l + 2 * f, c, 1), t.next = 11, d.drawQrCode(i, {}, {\n                  size: l,\n                  margin: f,\n                  level: s,\n                  bgColor: (null == n ? void 0 : n.bgColor) || \"#ffffff\",\n                  fgColor: (null == n ? void 0 : n.fgColor) || \"#000000\"\n                });\n              case 11:\n                return t.next = 13, d.output();\n              case 13:\n                return p = t.sent, t.abrupt(\"return\", p);\n              case 15:\n              case \"end\":\n                return t.stop();\n            }\n          }, t);\n        })), function (t, e) {\n          return i.apply(this, arguments);\n        })\n      }]);\n      var i, n, a, h, c, d;\n    }();\n    const gi = {\n      init: function (t) {\n        return s(e().mark(function r() {\n          return e().wrap(function (e) {\n            for (;;) switch (e.prev = e.next) {\n              case 0:\n                return m(t), e.next = 3, \"h5\" === _() ? Promise.resolve(!1) : new Promise(function (t) {\n                  var e = l().getFileSystemManager(),\n                    r = w();\n                  e.access({\n                    path: r,\n                    success: function () {\n                      try {\n                        e.rmdirSync(r, !0), t(!0);\n                      } catch (e) {\n                        y(\"info\", \"[svga]清理缓存目录失败\", e), t(!1);\n                      }\n                    },\n                    fail: function () {\n                      t(!0);\n                    }\n                  });\n                });\n              case 3:\n                y(\"inited\", t);\n              case 4:\n              case \"end\":\n                return e.stop();\n            }\n          }, r);\n        }))();\n      },\n      md5: function (t) {\n        return d.hashStr(t);\n      },\n      Player: Gr,\n      Parser: Lr,\n      Painter: vi\n    };\n  })(), i;\n})());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9zdmdhLTJkZmlyZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi91dGlscy9zdmdhLTJkZmlyZS5qcz9lYjk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiEgRm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSBzdmdhLmpzLkxJQ0VOU0UudHh0ICovXG4vLyDmmoLkuI3mlK/mjIFhcGkgaGFzLmFycmF5QnVmZmVyVG9CYXNlNjQgVE9ETy8vIOaaguS4jeaUr+aMgWFwaSBoYXMuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzIFRPRE9cbi8vIOaaguS4jeaUr+aMgWFwaSBoYXMuYXJyYXlCdWZmZXJUb0Jhc2U2NCBUT0RPLy8g5pqC5LiN5pSv5oyBYXBpIGhhcy5jcmVhdGVPZmZzY3JlZW5DYW52YXMgVE9ET1xuIWZ1bmN0aW9uICh0LCBlKSB7XG4gIFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSBlKCkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtdLCBlKSA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgPyBleHBvcnRzLiRzdmdhID0gZSgpIDogdC4kc3ZnYSA9IGUoKTtcbn0oc2VsZiwgKCkgPT4gKCgpID0+IHtcbiAgdmFyIHQgPSB7XG4gICAgICA3MDA6ICh0LCBlLCByKSA9PiB7XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgICB0LmNvbnZlcnRlci5fY29uZmlndXJlKCksIHQuZGVjb2Rlci5fY29uZmlndXJlKCksIHQuRmllbGQuX2NvbmZpZ3VyZSgpLCB0Lk1hcEZpZWxkLl9jb25maWd1cmUoKSwgdC5NZXNzYWdlLl9jb25maWd1cmUoKSwgdC5OYW1lc3BhY2UuX2NvbmZpZ3VyZSgpLCB0Lk1ldGhvZC5fY29uZmlndXJlKCksIHQuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlKCksIHQuT25lT2YuX2NvbmZpZ3VyZSgpLCB0LnBhcnNlLl9jb25maWd1cmUoKSwgdC5SZWFkZXIuX2NvbmZpZ3VyZSgpLCB0LlJvb3QuX2NvbmZpZ3VyZSgpLCB0LlNlcnZpY2UuX2NvbmZpZ3VyZSgpLCB0LnZlcmlmaWVyLl9jb25maWd1cmUoKSwgdC5UeXBlLl9jb25maWd1cmUoKSwgdC50eXBlcy5fY29uZmlndXJlKCksIHQud3JhcHBlcnMuX2NvbmZpZ3VyZSgpLCB0LldyaXRlci5fY29uZmlndXJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0LmJ1aWxkID0gXCJtaW5pbWFsXCIsIHQuV3JpdGVyID0gcig0NDMpLCB0LlJlYWRlciA9IHIoNzk1KSwgdC51dGlsID0gcig5MTYpLCB0LnJwYyA9IHIoMTUzKSwgdC5yb290cyA9IHIoNTg3KSwgdC52ZXJpZmllciA9IHIoMTIyKSwgdC50b2tlbml6ZSA9IHIoOTQxKSwgdC5wYXJzZSA9IHIoMTIxKSwgdC5jb21tb24gPSByKDQ1MyksIHQuUmVmbGVjdGlvbk9iamVjdCA9IHIoNzE5KSwgdC5OYW1lc3BhY2UgPSByKDYyNSksIHQuUm9vdCA9IHIoNTcyKSwgdC5FbnVtID0gcig0MjEpLCB0LlR5cGUgPSByKDI0KSwgdC5GaWVsZCA9IHIoMjM4KSwgdC5PbmVPZiA9IHIoODAzKSwgdC5NYXBGaWVsZCA9IHIoNzE4KSwgdC5TZXJ2aWNlID0gcig2NzMpLCB0Lk1ldGhvZCA9IHIoNDkzKSwgdC5jb252ZXJ0ZXIgPSByKDk1NCksIHQuZGVjb2RlciA9IHIoOTEwKSwgdC5NZXNzYWdlID0gcig4NTMpLCB0LndyYXBwZXJzID0gcig0MzIpLCB0LnR5cGVzID0gcig0NzEpLCB0LnV0aWwgPSByKDkxNiksIHQuY29uZmlndXJlID0gZSwgdC5sb2FkID0gZnVuY3Rpb24gKGUsIHIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIgPyAoaSA9IHIsIHIgPSBuZXcgdC5Sb290KCkpIDogciB8fCAociA9IG5ldyB0LlJvb3QoKSksIHIubG9hZChlLCBpKTtcbiAgICAgICAgICB9LCB0LmxvYWRTeW5jID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByIHx8IChyID0gbmV3IHQuUm9vdCgpKSwgci5sb2FkU3luYyhlKTtcbiAgICAgICAgICB9LCB0LnBhcnNlRnJvbVBiU3RyaW5nID0gZnVuY3Rpb24gKGUsIHIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIgPyAoaSA9IHIsIHIgPSBuZXcgdC5Sb290KCkpIDogciB8fCAociA9IG5ldyB0LlJvb3QoKSksIHIucGFyc2VGcm9tUGJTdHJpbmcoZSwgaSk7XG4gICAgICAgICAgfSwgZSgpLCBhcmd1bWVudHMgJiYgYXJndW1lbnRzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSByZXR1cm4gdm9pZCAobi5leHBvcnRzID0gdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KCk7XG4gICAgICB9LFxuICAgICAgNzcwOiB0ID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0LmV4cG9ydHMgPSBlLCBlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLl9saXN0ZW5lcnNbdF0gfHwgKHRoaXMuX2xpc3RlbmVyc1t0XSA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICBmbjogZSxcbiAgICAgICAgICAgIGN0eDogciB8fCB0aGlzXG4gICAgICAgICAgfSksIHRoaXM7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdCkgdGhpcy5fbGlzdGVuZXJzID0ge307ZWxzZSBpZiAodm9pZCAwID09PSBlKSB0aGlzLl9saXN0ZW5lcnNbdF0gPSBbXTtlbHNlIGZvciAodmFyIHIgPSB0aGlzLl9saXN0ZW5lcnNbdF0sIGkgPSAwOyBpIDwgci5sZW5ndGg7KSByW2ldLmZuID09PSBlID8gci5zcGxpY2UoaSwgMSkgOiArK2k7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gW10sIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspIHIucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZS5sZW5ndGg7KSBlW2ldLmZuLmFwcGx5KGVbaSsrXS5jdHgsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAzNDc6IHQgPT4ge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCBpID0gMCwgbiA9IDIsIHMgPSAhMDsgbiA8IGFyZ3VtZW50cy5sZW5ndGg7KSByW2krK10gPSBhcmd1bWVudHNbbisrXTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKG4sIG8pIHtcbiAgICAgICAgICAgIHJbaV0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBpZiAocykgaWYgKHMgPSAhMSwgdCkgbyh0KTtlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSwgciA9IDA7IHIgPCBlLmxlbmd0aDspIGVbcisrXSA9IGFyZ3VtZW50c1tyXTtcbiAgICAgICAgICAgICAgICBuLmFwcGx5KG51bGwsIGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdC5hcHBseShlIHx8IG51bGwsIHIpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICBzICYmIChzID0gITEsIG8odCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDIwMzogdCA9PiB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgIHZhciBlID0gdC5leHBvcnRzO1xuICAgICAgICBlLmxlbmd0aCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWUpIHJldHVybiAwO1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyAtLWUgJSA0ID4gMSAmJiBcIj1cIiA9PT0gdC5jaGFyQXQoZSk7KSArK3I7XG4gICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgzICogdC5sZW5ndGgpIC8gNCAtIHI7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHIgPSBuZXcgQXJyYXkoNjQpLCBpID0gbmV3IEFycmF5KDEyMyksIG4gPSAwOyBuIDwgNjQ7KSBpW3Jbbl0gPSBuIDwgMjYgPyBuICsgNjUgOiBuIDwgNTIgPyBuICsgNzEgOiBuIDwgNjIgPyBuIC0gNCA6IG4gLSA1OSB8IDQzXSA9IG4rKztcbiAgICAgICAgZS5lbmNvZGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIGZvciAodmFyIG4sIHMgPSBudWxsLCBvID0gW10sIGEgPSAwLCBoID0gMDsgZSA8IGk7KSB7XG4gICAgICAgICAgICB2YXIgdSA9IHRbZSsrXTtcbiAgICAgICAgICAgIHN3aXRjaCAoaCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb1thKytdID0gclt1ID4+IDJdLCBuID0gKDMgJiB1KSA8PCA0LCBoID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG9bYSsrXSA9IHJbbiB8IHUgPj4gNF0sIG4gPSAoMTUgJiB1KSA8PCAyLCBoID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG9bYSsrXSA9IHJbbiB8IHUgPj4gNl0sIG9bYSsrXSA9IHJbNjMgJiB1XSwgaCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID4gODE5MSAmJiAoKHMgfHwgKHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIG8pKSwgYSA9IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaCAmJiAob1thKytdID0gcltuXSwgb1thKytdID0gNjEsIDEgPT09IGggJiYgKG9bYSsrXSA9IDYxKSksIHMgPyAoYSAmJiBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIG8uc2xpY2UoMCwgYSkpKSwgcy5qb2luKFwiXCIpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBvLnNsaWNlKDAsIGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHMgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcbiAgICAgICAgZS5kZWNvZGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGZvciAodmFyIG4sIG8gPSByLCBhID0gMCwgaCA9IDA7IGggPCB0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciB1ID0gdC5jaGFyQ29kZUF0KGgrKyk7XG4gICAgICAgICAgICBpZiAoNjEgPT09IHUgJiYgYSA+IDEpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gKHUgPSBpW3VdKSkgdGhyb3cgRXJyb3Iocyk7XG4gICAgICAgICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG4gPSB1LCBhID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGVbcisrXSA9IG4gPDwgMiB8ICg0OCAmIHUpID4+IDQsIG4gPSB1LCBhID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVbcisrXSA9ICgxNSAmIG4pIDw8IDQgfCAoNjAgJiB1KSA+PiAyLCBuID0gdSwgYSA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBlW3IrK10gPSAoMyAmIG4pIDw8IDYgfCB1LCBhID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IGEpIHRocm93IEVycm9yKHMpO1xuICAgICAgICAgIHJldHVybiByIC0gbztcbiAgICAgICAgfSwgZS50ZXN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QodCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNDUzOiB0ID0+IHtcbiAgICAgICAgdC5leHBvcnRzID0gaTtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgciA9IC9cXC98XFwuLztcbiAgICAgICAgZnVuY3Rpb24gaSh0LCBlKSB7XG4gICAgICAgICAgci50ZXN0KHQpIHx8ICh0ID0gXCJnb29nbGUvcHJvdG9idWYvXCIgKyB0ICsgXCIucHJvdG9cIiwgZSA9IHtcbiAgICAgICAgICAgIG5lc3RlZDoge1xuICAgICAgICAgICAgICBnb29nbGU6IHtcbiAgICAgICAgICAgICAgICBuZXN0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgIHByb3RvYnVmOiB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZDogZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBpW3RdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBpKFwiYW55XCIsIHtcbiAgICAgICAgICBBbnk6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICB0eXBlX3VybDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksIGkoXCJkdXJhdGlvblwiLCB7XG4gICAgICAgICAgRHVyYXRpb246IGUgPSB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgc2Vjb25kczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW5vczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaShcInRpbWVzdGFtcFwiLCB7XG4gICAgICAgICAgVGltZXN0YW1wOiBlXG4gICAgICAgIH0pLCBpKFwiZW1wdHlcIiwge1xuICAgICAgICAgIEVtcHR5OiB7XG4gICAgICAgICAgICBmaWVsZHM6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaShcInN0cnVjdFwiLCB7XG4gICAgICAgICAgU3RydWN0OiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgVmFsdWU6IHtcbiAgICAgICAgICAgIG9uZW9mczoge1xuICAgICAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICAgICAgb25lb2Y6IFtcIm51bGxWYWx1ZVwiLCBcIm51bWJlclZhbHVlXCIsIFwic3RyaW5nVmFsdWVcIiwgXCJib29sVmFsdWVcIiwgXCJzdHJ1Y3RWYWx1ZVwiLCBcImxpc3RWYWx1ZVwiXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgIG51bGxWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbnVtYmVyVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogM1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib29sVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBpZDogNFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU3RydWN0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGlzdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogNlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBOdWxsVmFsdWU6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBOVUxMX1ZBTFVFOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBMaXN0VmFsdWU6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBpKFwid3JhcHBlcnNcIiwge1xuICAgICAgICAgIERvdWJsZVZhbHVlOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIEZsb2F0VmFsdWU6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBJbnQ2NFZhbHVlOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgVUludDY0VmFsdWU6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgSW50MzJWYWx1ZToge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFVJbnQzMlZhbHVlOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIEJvb2xWYWx1ZToge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgU3RyaW5nVmFsdWU6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgQnl0ZXNWYWx1ZToge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBpKFwiZmllbGRfbWFza1wiLCB7XG4gICAgICAgICAgRmllbGRNYXNrOiB7XG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgaS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpW3RdIHx8IG51bGw7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgOTU0OiAodCwgZSwgcikgPT4ge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSByKDUzNSkuZGVmYXVsdCxcbiAgICAgICAgICBvID0gdC5leHBvcnRzO1xuICAgICAgICBmdW5jdGlvbiBhKHQsIGUsIHIsIG8pIHtcbiAgICAgICAgICB2YXIgYSA9IG8ubSxcbiAgICAgICAgICAgIGggPSBvLmQsXG4gICAgICAgICAgICB1ID0gby50eXBlcyxcbiAgICAgICAgICAgIGwgPSBvLmtzaSxcbiAgICAgICAgICAgIGYgPSB2b2lkIDAgIT09IGw7XG4gICAgICAgICAgaWYgKHQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgICAgICBpZiAodC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSBmID8gaFtyXVtsXSA6IGhbcl0sIGQgPSB0LnJlc29sdmVkVHlwZS52YWx1ZXMsIHAgPSBPYmplY3Qua2V5cyhkKSwgeSA9IDA7IHkgPCBwLmxlbmd0aDsgeSsrKSBpZiAoISh0LnJlcGVhdGVkICYmIGRbcFt5XV0gPT09IHQudHlwZURlZmF1bHQgfHwgcFt5XSAhPSBjICYmIGRbcFt5XV0gIT0gYykpIHtcbiAgICAgICAgICAgICAgICBmID8gYVtyXVtsXSA9IGRbcFt5XV0gOiBhW3JdID0gZFtwW3ldXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHMoZiA/IGhbcl1bbF0gOiBoW3JdKSkgdGhyb3cgVHlwZUVycm9yKHQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBmID8gYVtyXVtsXSA9IHVbZV0uZnJvbU9iamVjdChoW3JdW2xdKSA6IGFbcl0gPSB1W2VdLmZyb21PYmplY3QoaFtyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2ID0gITE7XG4gICAgICAgICAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgICAgIGYgPyBhW3JdW2xdID0gTnVtYmVyKGhbcl1bbF0pIDogYVtyXSA9IE51bWJlcihoW3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICAgICAgICAgIGYgPyBhW3JdW2xdID0gaFtyXVtsXSA+Pj4gMCA6IGFbcl0gPSBoW3JdID4+PiAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjpcbiAgICAgICAgICAgICAgICBmID8gYVtyXVtsXSA9IDAgfCBoW3JdW2xdIDogYVtyXSA9IDAgfCBoW3JdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgdiA9ICEwO1xuICAgICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjpcbiAgICAgICAgICAgICAgICBuLkxvbmcgPyBmID8gYVtyXVtsXSA9IG4uTG9uZy5mcm9tVmFsdWUoaFtyXVtsXSkudW5zaWduZWQgPSB2IDogYVtyXSA9IG4uTG9uZy5mcm9tVmFsdWUoaFtyXSkudW5zaWduZWQgPSB2IDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgKGYgPyBoW3JdW2xdIDogaFtyXSkgPyBmID8gYVtyXVtsXSA9IHBhcnNlSW50KGhbcl1bbF0sIDEwKSA6IGFbcl0gPSBwYXJzZUludChoW3JdLCAxMCkgOiBcIm51bWJlclwiID09IHR5cGVvZiAoZiA/IGhbcl1bbF0gOiBoW3JdKSA/IGYgPyBhW3JdW2xdID0gaFtyXVtsXSA6IGFbcl0gPSBoW3JdIDogXCJvYmplY3RcIiA9PT0gcyhmID8gaFtyXVtsXSA6IGhbcl0pICYmIChmID8gYVtyXVtsXSA9IG5ldyBuLkxvbmdCaXRzKGhbcl1bbF0ubG93ID4+PiAwLCBoW3JdW2xdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHYpIDogYVtyXSA9IG5ldyBuLkxvbmdCaXRzKGhbcl0ubG93ID4+PiAwLCBoW3JdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHYpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgKGYgPyBoW3JdW2xdIDogaFtyXSkgPyBmID8gbi5iYXNlNjQuZGVjb2RlKGhbcl1bbF0sIGFbcl1bbF0gPSBuLm5ld0J1ZmZlcihuLmJhc2U2NC5sZW5ndGgoaFtyXVtsXSkpLCAwKSA6IG4uYmFzZTY0LmRlY29kZShoW3JdLCBhW3JdID0gbi5uZXdCdWZmZXIobi5iYXNlNjQubGVuZ3RoKGhbcl0pKSwgMCkgOiAoZiA/IGhbcl1bbF0gOiBoW3JdKS5sZW5ndGggJiYgKGYgPyBhW3JdW2xdID0gaFtyXVtsXSA6IGFbcl0gPSBoW3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGYgPyBhW3JdW2xdID0gU3RyaW5nKGhbcl1bbF0pIDogYVtyXSA9IFN0cmluZyhoW3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICBmID8gYVtyXVtsXSA9IEJvb2xlYW4oaFtyXVtsXSkgOiBhW3JdID0gQm9vbGVhbihoW3JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaCh0LCBlLCByLCBzKSB7XG4gICAgICAgICAgdmFyIG8gPSBzLm0sXG4gICAgICAgICAgICBhID0gcy5kLFxuICAgICAgICAgICAgaCA9IHMudHlwZXMsXG4gICAgICAgICAgICB1ID0gcy5rc2ksXG4gICAgICAgICAgICBsID0gcy5vLFxuICAgICAgICAgICAgZiA9IHZvaWQgMCAhPT0gdTtcbiAgICAgICAgICBpZiAodC5yZXNvbHZlZFR5cGUpIHQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgaSA/IGYgPyBhW3JdW3VdID0gbC5lbnVtcyA9PT0gU3RyaW5nID8gaFtlXS52YWx1ZXNbb1tyXVt1XV0gOiBvW3JdW3VdIDogYVtyXSA9IGwuZW51bXMgPT09IFN0cmluZyA/IGhbZV0udmFsdWVzW29bcl1dIDogb1tyXSA6IGYgPyBhW3JdW3VdID0gaFtlXS50b09iamVjdChvW3JdW3VdLCBsKSA6IGFbcl0gPSBoW2VdLnRvT2JqZWN0KG9bcl0sIGwpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGMgPSAhMTtcbiAgICAgICAgICAgIHN3aXRjaCAodC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICAgICAgZiA/IGFbcl1bdV0gPSBsLmpzb24gJiYgIWlzRmluaXRlKG9bcl1bdV0pID8gU3RyaW5nKG9bcl1bdV0pIDogb1tyXVt1XSA6IGFbcl0gPSBsLmpzb24gJiYgIWlzRmluaXRlKG9bcl0pID8gU3RyaW5nKG9bcl0pIDogb1tyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGMgPSAhMDtcbiAgICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6XG4gICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2Ygb1tyXVt1XSA/IGYgPyBhW3JdW3VdID0gbC5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG9bcl1bdV0pIDogb1tyXVt1XSA6IGFbcl0gPSBsLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcob1tyXSkgOiBvW3JdIDogZiA/IGFbcl1bdV0gPSBsLmxvbmdzID09PSBTdHJpbmcgPyBuLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob1tyXVt1XSkgOiBsLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgbi5Mb25nQml0cyhvW3JdW3VdLmxvdyA+Pj4gMCwgb1tyXVt1XS5oaWdoID4+PiAwKS50b051bWJlcihjKSA6IG9bcl1bdV0gOiBhW3JdID0gbC5sb25ncyA9PT0gU3RyaW5nID8gbi5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9bcl0pIDogbC5sb25ncyA9PT0gTnVtYmVyID8gbmV3IG4uTG9uZ0JpdHMob1tyXS5sb3cgPj4+IDAsIG9bcl0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoYykgOiBvW3JdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICBmID8gYVtyXVt1XSA9IGwuYnl0ZXMgPT09IFN0cmluZyA/IG4uYmFzZTY0LmVuY29kZShvW3JdW3VdLCAwLCBvW3JdW3VdLmxlbmd0aCkgOiBsLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9bcl1bdV0pIDogb1tyXVt1XSA6IGFbcl0gPSBsLmJ5dGVzID09PSBTdHJpbmcgPyBuLmJhc2U2NC5lbmNvZGUob1tyXSwgMCwgb1tyXS5sZW5ndGgpIDogbC5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvW3JdKSA6IG9bcl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZiA/IGFbcl1bdV0gPSBvW3JdW3VdIDogYVtyXSA9IG9bcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG8uX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpID0gcig0MjEpLCBuID0gcig5MTYpO1xuICAgICAgICB9LCBvLmZyb21PYmplY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdC5maWVsZHNBcnJheTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIHRoaXMuY3RvcikgcmV0dXJuIHI7XG4gICAgICAgICAgICAgIGlmICghZS5sZW5ndGgpIHJldHVybiBuZXcgdGhpcy5jdG9yKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIG8gPSBuZXcgdGhpcy5jdG9yKCksIGggPSAwOyBoIDwgZS5sZW5ndGg7ICsraCkge1xuICAgICAgICAgICAgICAgIHZhciB1LFxuICAgICAgICAgICAgICAgICAgbCA9IGVbaF0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgICAgICAgZiA9IGwubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobC5tYXApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyW2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBzKHJbZl0pKSB0aHJvdyBUeXBlRXJyb3IobC5mdWxsTmFtZSArIFwiOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG9bZl0gPSB7fTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBjID0gT2JqZWN0LmtleXMocltmXSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgYy5sZW5ndGg7ICsrdSkgYShsLCBoLCBmLCBuLm1lcmdlKG4uY29weSh0KSwge1xuICAgICAgICAgICAgICAgICAgICBtOiBvLFxuICAgICAgICAgICAgICAgICAgICBkOiByLFxuICAgICAgICAgICAgICAgICAgICBrc2k6IGNbdV1cbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGwucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyW2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyW2ZdKSkgdGhyb3cgVHlwZUVycm9yKGwuZnVsbE5hbWUgKyBcIjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAob1tmXSA9IFtdLCB1ID0gMDsgdSA8IHJbZl0ubGVuZ3RoOyArK3UpIGEobCwgaCwgZiwgbi5tZXJnZShuLmNvcHkodCksIHtcbiAgICAgICAgICAgICAgICAgICAgICBtOiBvLFxuICAgICAgICAgICAgICAgICAgICAgIGQ6IHIsXG4gICAgICAgICAgICAgICAgICAgICAga3NpOiB1XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgKGwucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgaSB8fCBudWxsICE9IHJbZl0pICYmIGEobCwgaCwgZiwgbi5tZXJnZShuLmNvcHkodCksIHtcbiAgICAgICAgICAgICAgICAgIG06IG8sXG4gICAgICAgICAgICAgICAgICBkOiByXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBvLnRvT2JqZWN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHQuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KG4uY29tcGFyZUZpZWxkc0J5SWQpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID8gZnVuY3Rpb24gKHMsIG8pIHtcbiAgICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGEsIHUsIGwgPSB7fSwgZiA9IFtdLCBjID0gW10sIGQgPSBbXSwgcCA9IDA7IHAgPCBlLmxlbmd0aDsgKytwKSBlW3BdLnBhcnRPZiB8fCAoZVtwXS5yZXNvbHZlKCkucmVwZWF0ZWQgPyBmIDogZVtwXS5tYXAgPyBjIDogZCkucHVzaChlW3BdKTtcbiAgICAgICAgICAgICAgaWYgKGYubGVuZ3RoICYmIChvLmFycmF5cyB8fCBvLmRlZmF1bHRzKSkgZm9yIChwID0gMDsgcCA8IGYubGVuZ3RoOyArK3ApIGxbZltwXS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICBpZiAoYy5sZW5ndGggJiYgKG8ub2JqZWN0cyB8fCBvLmRlZmF1bHRzKSkgZm9yIChwID0gMDsgcCA8IGMubGVuZ3RoOyArK3ApIGxbY1twXS5uYW1lXSA9IHt9O1xuICAgICAgICAgICAgICBpZiAoZC5sZW5ndGggJiYgby5kZWZhdWx0cykgZm9yIChwID0gMDsgcCA8IGQubGVuZ3RoOyArK3ApIGlmICh1ID0gKGEgPSBkW3BdKS5uYW1lLCBhLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIGkpIGxbdV0gPSBvLmVudW1zID0gU3RyaW5nID8gYS5yZXNvbHZlZFR5cGUudmFsdWVzQnlJZFthLnR5cGVEZWZhdWx0XSA6IGEudHlwZURlZmF1bHQ7ZWxzZSBpZiAoYS5sb25nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4uTG9uZykge1xuICAgICAgICAgICAgICAgICAgdmFyIHkgPSBuZXcgbi5Mb25nKGEudHlwZURlZmF1bHQubG93LCBhLnR5cGVEZWZhdWx0LmhpZ2gsIGEudHlwZURlZmF1bHQudW5zaWduZWQpO1xuICAgICAgICAgICAgICAgICAgbFt1XSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IHkudG9TdHJpbmcoKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IHkudG9OdW1iZXIoKSA6IHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGxbdV0gPSBvLmxvbmdzID09PSBTdHJpbmcgPyBhLnR5cGVEZWZhdWx0LnRvU3RyaW5nKCkgOiBhLnR5cGVEZWZhdWx0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBhLmJ5dGVzID8gbFt1XSA9IG8uYnl0ZXMgPT09IFN0cmluZyA/IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBhLnR5cGVEZWZhdWx0KSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEudHlwZURlZmF1bHQpLmpvaW4oXCIqLi4qXCIpLnNwbGl0KFwiKi4uKlwiKSA6IGxbdV0gPSBhLnR5cGVEZWZhdWx0O1xuICAgICAgICAgICAgICB2YXIgdiA9ICExO1xuICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgZS5sZW5ndGg7ICsrcCkge1xuICAgICAgICAgICAgICAgIHUgPSAoYSA9IGVbcF0pLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGcsXG4gICAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgICAgXyA9IHQuX2ZpZWxkc0FycmF5LmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgaWYgKGEubWFwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodiB8fCAodiA9ICEwKSwgc1t1XSAmJiAoZyA9IE9iamVjdC5rZXlzKHNbdV0pLmxlbmd0aCkpIGZvciAobFt1XSA9IHt9LCBtID0gMDsgbSA8IGcubGVuZ3RoOyArK20pIGgoYSwgXywgdSwgbi5tZXJnZShuLmNvcHkociksIHtcbiAgICAgICAgICAgICAgICAgICAgbTogcyxcbiAgICAgICAgICAgICAgICAgICAgZDogbCxcbiAgICAgICAgICAgICAgICAgICAga3NpOiBnW21dLFxuICAgICAgICAgICAgICAgICAgICBvXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc1t1XSAmJiBzW3VdLmxlbmd0aCkgZm9yIChsW3VdID0gW10sIG0gPSAwOyBtIDwgc1t1XS5sZW5ndGg7ICsrbSkgaChhLCBfLCB1LCBuLm1lcmdlKG4uY29weShyKSwge1xuICAgICAgICAgICAgICAgICAgICBtOiBzLFxuICAgICAgICAgICAgICAgICAgICBkOiBsLFxuICAgICAgICAgICAgICAgICAgICBrc2k6IG0sXG4gICAgICAgICAgICAgICAgICAgIG9cbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgbnVsbCAhPSBzW3VdICYmIHMuaGFzT3duUHJvcGVydHkodSkgJiYgaChhLCBfLCB1LCBuLm1lcmdlKG4uY29weShyKSwge1xuICAgICAgICAgICAgICAgICAgbTogcyxcbiAgICAgICAgICAgICAgICAgIGQ6IGwsXG4gICAgICAgICAgICAgICAgICBvXG4gICAgICAgICAgICAgICAgfSkpLCBhLnBhcnRPZiAmJiBvLm9uZW9mcyAmJiAobFthLnBhcnRPZi5uYW1lXSA9IHUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDkxMDogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICBzLFxuICAgICAgICAgIG8gPSByKDUzNSkuZGVmYXVsdDtcbiAgICAgICAgZnVuY3Rpb24gYSh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwibWlzc2luZyByZXF1aXJlZCAnXCIgKyB0Lm5hbWUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoKHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciByID0gZS5SZWFkZXIsXG4gICAgICAgICAgICAgIGggPSBlLnR5cGVzLFxuICAgICAgICAgICAgICB1ID0gZS51dGlsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBsKSB7XG4gICAgICAgICAgICAgIGUgaW5zdGFuY2VvZiByIHx8IChlID0gci5jcmVhdGUoZSkpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBmLCBjID0gdm9pZCAwID09PSBsID8gZS5sZW4gOiBlLnBvcyArIGwsIGQgPSBuZXcgdGhpcy5jdG9yKCk7IGUucG9zIDwgYzspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGUudWludDMyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHQuZ3JvdXAgJiYgNCA9PSAoNyAmIHApKSBicmVhaztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gcCA+Pj4gMywgdiA9IDAsIGcgPSAhMTsgdiA8IHQuZmllbGRzQXJyYXkubGVuZ3RoOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtID0gdC5fZmllbGRzQXJyYXlbdl0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgICAgICAgICBfID0gbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB3ID0gbS5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBpID8gXCJpbnQzMlwiIDogbS50eXBlO1xuICAgICAgICAgICAgICAgICAgaWYgKHkgPT0gbS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZyA9ICEwLCBtLm1hcCkgZS5za2lwKCkucG9zKyssIGRbX10gPT09IHUuZW1wdHlPYmplY3QgJiYgKGRbX10gPSB7fSksIGYgPSBlW20ua2V5VHlwZV0oKSwgZS5wb3MrKywgbi5sb25nW20ua2V5VHlwZV0sIG51bGwgPT0gbi5iYXNpY1t3XSA/IGRbX11bXCJvYmplY3RcIiA9PT0gbyhmKSA/IHUubG9uZ1RvSGFzaChmKSA6IGZdID0gaFt2XS5kZWNvZGUoZSwgZS51aW50MzIoKSkgOiBkW19dW1wib2JqZWN0XCIgPT09IG8oZikgPyB1LmxvbmdUb0hhc2goZikgOiBmXSA9IGVbd10oKTtlbHNlIGlmIChtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRbX10gJiYgZFtfXS5sZW5ndGggfHwgKGRbX10gPSBbXSksIG51bGwgIT0gbi5wYWNrZWRbd10gJiYgMiA9PSAoNyAmIHApKSBmb3IgKHZhciBiID0gZS51aW50MzIoKSArIGUucG9zOyBlLnBvcyA8IGI7KSBkW19dLnB1c2goZVt3XSgpKTtlbHNlIG51bGwgPT0gbi5iYXNpY1t3XSA/IG0ucmVzb2x2ZWRUeXBlLmdyb3VwID8gZFtfXS5wdXNoKGhbdl0uZGVjb2RlKGUpKSA6IGRbX10ucHVzaChoW3ZdLmRlY29kZShlLCBlLnVpbnQzMigpKSkgOiBkW19dLnB1c2goZVt3XSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIG51bGwgPT0gbi5iYXNpY1t3XSA/IG0ucmVzb2x2ZWRUeXBlLmdyb3VwID8gZFtfXSA9IGhbdl0uZGVjb2RlKGUpIDogZFtfXSA9IGhbdl0uZGVjb2RlKGUsIGUudWludDMyKCkpIDogZFtfXSA9IGVbd10oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGcgfHwgKGNvbnNvbGUubG9nKFwidFwiLCBwKSwgZS5za2lwVHlwZSg3ICYgcCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCB0Ll9maWVsZHNBcnJheS5sZW5ndGg7ICsrdikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdC5fZmllbGRzQXJyYXlbdl07XG4gICAgICAgICAgICAgICAgaWYgKHgucmVxdWlyZWQgJiYgIWQuaGFzT3duUHJvcGVydHkoeC5uYW1lKSkgdGhyb3cgcy5Qcm90b2NvbEVycm9yKGEoeCksIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdC5leHBvcnRzID0gaCwgaC5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkgPSByKDQyMSksIG4gPSByKDQ3MSksIHMgPSByKDkxNik7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNDIxOiAodCwgZSwgcikgPT4ge1xuICAgICAgICB2YXIgaSA9IHIoNTM1KS5kZWZhdWx0O1xuICAgICAgICB0LmV4cG9ydHMgPSBvO1xuICAgICAgICB2YXIgbiA9IHIoNzE5KTtcbiAgICAgICAgKChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IG8pLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xuICAgICAgICB2YXIgcyA9IHIoNjI1KTtcbiAgICAgICAgZnVuY3Rpb24gbyh0LCBlLCByLCBzLCBvKSB7XG4gICAgICAgICAgaWYgKG4uY2FsbCh0aGlzLCB0LCByKSwgZSAmJiBcIm9iamVjdFwiICE9PSBpKGUpKSB0aHJvdyBUeXBlRXJyb3IoXCJ2YWx1ZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVzQnlJZCA9IHt9LCB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNCeUlkKSwgdGhpcy5jb21tZW50ID0gcywgdGhpcy5jb21tZW50cyA9IG8gfHwge30sIHRoaXMucmVzZXJ2ZWQgPSB2b2lkIDAsIGUpIGZvciAodmFyIGEgPSBPYmplY3Qua2V5cyhlKSwgaCA9IDA7IGggPCBhLmxlbmd0aDsgKytoKSBcIm51bWJlclwiID09IHR5cGVvZiBlW2FbaF1dICYmICh0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbYVtoXV0gPSBlW2FbaF1dXSA9IGFbaF0pO1xuICAgICAgICB9XG4gICAgICAgIG8uZnJvbUpTT04gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gbmV3IG8odCwgZS52YWx1ZXMsIGUub3B0aW9ucywgZS5jb21tZW50LCBlLmNvbW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gci5yZXNlcnZlZCA9IGUucmVzZXJ2ZWQsIHI7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSAhIXQgJiYgQm9vbGVhbih0LmtlZXBDb21tZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1wib3B0aW9uc1wiLCB0aGlzLm9wdGlvbnMsIFwidmFsdWVzXCIsIHRoaXMudmFsdWVzLCBcInJlc2VydmVkXCIsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdm9pZCAwLCBcImNvbW1lbnRcIiwgZSA/IHRoaXMuY29tbWVudCA6IHZvaWQgMCwgXCJjb21tZW50c1wiLCBlID8gdGhpcy5jb21tZW50cyA6IHZvaWQgMF0pO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyh0KSkgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoZSkpIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSB0aGlzLnZhbHVlc1t0XSkgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyB0ICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKGUpKSB0aHJvdyBFcnJvcihcImlkIFwiICsgZSArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUodCkpIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyB0ICsgXCInIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdGhpcy52YWx1ZXNCeUlkW2VdKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmFsbG93X2FsaWFzKSB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIGUgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNbdF0gPSBlO1xuICAgICAgICAgIH0gZWxzZSB0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbdF0gPSBlXSA9IHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHNbdF0gPSByIHx8IG51bGwsIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHQpKSB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLnZhbHVlc1t0XTtcbiAgICAgICAgICBpZiAobnVsbCA9PSBlKSB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgdCArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xuICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy52YWx1ZXNCeUlkW2VdLCBkZWxldGUgdGhpcy52YWx1ZXNbdF0sIGRlbGV0ZSB0aGlzLmNvbW1lbnRzW3RdLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBzLmlzUmVzZXJ2ZWRJZCh0aGlzLnJlc2VydmVkLCB0KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBzLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIHQpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDIzODogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdmFyIGkgPSByKDUzNSkuZGVmYXVsdDtcbiAgICAgICAgdC5leHBvcnRzID0gbDtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgcyxcbiAgICAgICAgICBvLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgaCA9IHIoNzE5KTtcbiAgICAgICAgKChsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoaC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGwpLmNsYXNzTmFtZSA9IFwiRmllbGRcIjtcbiAgICAgICAgdmFyIHUgPSAvXnJlcXVpcmVkfG9wdGlvbmFsfHJlcGVhdGVkJC87XG4gICAgICAgIGZ1bmN0aW9uIGwodCwgZSwgciwgaSwgbiwgYSwgbCkge1xuICAgICAgICAgIGlmIChvLmlzT2JqZWN0KGkpID8gKGwgPSBuLCBhID0gaSwgaSA9IG4gPSB2b2lkIDApIDogby5pc09iamVjdChuKSAmJiAobCA9IGEsIGEgPSBuLCBuID0gdm9pZCAwKSwgaC5jYWxsKHRoaXMsIHQsIGEpLCAhby5pc0ludGVnZXIoZSkgfHwgZSA8IDApIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcbiAgICAgICAgICBpZiAoIW8uaXNTdHJpbmcocikpIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBpICYmICF1LnRlc3QoaSA9IGkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSkgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbiAmJiAhby5pc1N0cmluZyhuKSkgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgdGhpcy5ydWxlID0gaSAmJiBcIm9wdGlvbmFsXCIgIT09IGkgPyBpIDogdm9pZCAwLCB0aGlzLnR5cGUgPSByLCB0aGlzLmlkID0gZSwgdGhpcy5leHRlbmQgPSBuIHx8IHZvaWQgMCwgdGhpcy5yZXF1aXJlZCA9IFwicmVxdWlyZWRcIiA9PT0gaSwgdGhpcy5vcHRpb25hbCA9ICF0aGlzLnJlcXVpcmVkLCB0aGlzLnJlcGVhdGVkID0gXCJyZXBlYXRlZFwiID09PSBpLCB0aGlzLm1hcCA9ICExLCB0aGlzLm1lc3NhZ2UgPSBudWxsLCB0aGlzLnBhcnRPZiA9IG51bGwsIHRoaXMudHlwZURlZmF1bHQgPSBudWxsLCB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGwsIHRoaXMubG9uZyA9ICEhby5Mb25nICYmIHZvaWQgMCAhPT0gcy5sb25nW3JdLCB0aGlzLmJ5dGVzID0gXCJieXRlc1wiID09PSByLCB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGwsIHRoaXMuZXh0ZW5zaW9uRmllbGQgPSBudWxsLCB0aGlzLmRlY2xhcmluZ0ZpZWxkID0gbnVsbCwgdGhpcy5fcGFja2VkID0gbnVsbCwgdGhpcy5jb21tZW50ID0gbDtcbiAgICAgICAgfVxuICAgICAgICBsLmZyb21KU09OID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGwodCwgZS5pZCwgZS50eXBlLCBlLnJ1bGUsIGUuZXh0ZW5kLCBlLm9wdGlvbnMsIGUuY29tbWVudCk7XG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLnByb3RvdHlwZSwgXCJwYWNrZWRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IHRoaXMuX3BhY2tlZCAmJiAodGhpcy5fcGFja2VkID0gITEgIT09IHRoaXMuZ2V0T3B0aW9uKFwicGFja2VkXCIpKSwgdGhpcy5fcGFja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGwucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgcmV0dXJuIFwicGFja2VkXCIgPT09IHQgJiYgKHRoaXMuX3BhY2tlZCA9IG51bGwpLCBoLnByb3RvdHlwZS5zZXRPcHRpb24uY2FsbCh0aGlzLCB0LCBlLCByKTtcbiAgICAgICAgfSwgbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9ICEhdCAmJiBCb29sZWFuKHQua2VlcENvbW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gby50b09iamVjdChbXCJydWxlXCIsIFwib3B0aW9uYWxcIiAhPT0gdGhpcy5ydWxlICYmIHRoaXMucnVsZSB8fCB2b2lkIDAsIFwidHlwZVwiLCB0aGlzLnR5cGUsIFwiaWRcIiwgdGhpcy5pZCwgXCJleHRlbmRcIiwgdGhpcy5leHRlbmQsIFwib3B0aW9uc1wiLCB0aGlzLm9wdGlvbnMsIFwiY29tbWVudFwiLCBlID8gdGhpcy5jb21tZW50IDogdm9pZCAwXSk7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09ICh0aGlzLnR5cGVEZWZhdWx0ID0gcy5kZWZhdWx0c1t0aGlzLnR5cGVdKSAmJiAodGhpcy5yZXNvbHZlZFR5cGUgPSAodGhpcy5kZWNsYXJpbmdGaWVsZCA/IHRoaXMuZGVjbGFyaW5nRmllbGQucGFyZW50IDogdGhpcy5wYXJlbnQpLmxvb2t1cFR5cGVPckVudW0odGhpcy50eXBlKSwgdGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBhID8gdGhpcy50eXBlRGVmYXVsdCA9IG51bGwgOiB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW09iamVjdC5rZXlzKHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlcylbMF1dKSwgdGhpcy5vcHRpb25zICYmIG51bGwgIT0gdGhpcy5vcHRpb25zLmRlZmF1bHQgJiYgKHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdCwgdGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBuICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgJiYgKHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF0pKSwgdGhpcy5vcHRpb25zICYmICghMCAhPT0gdGhpcy5vcHRpb25zLnBhY2tlZCAmJiAodm9pZCAwID09PSB0aGlzLm9wdGlvbnMucGFja2VkIHx8ICF0aGlzLnJlc29sdmVkVHlwZSB8fCB0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIG4pIHx8IGRlbGV0ZSB0aGlzLm9wdGlvbnMucGFja2VkLCBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmxlbmd0aCB8fCAodGhpcy5vcHRpb25zID0gdm9pZCAwKSksIHRoaXMubG9uZykgdGhpcy50eXBlRGVmYXVsdCA9IG8uTG9uZy5mcm9tTnVtYmVyKHRoaXMudHlwZURlZmF1bHQsIFwidVwiID09PSB0aGlzLnR5cGUuY2hhckF0KDApKSwgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKHRoaXMudHlwZURlZmF1bHQpO2Vsc2UgaWYgKHRoaXMuYnl0ZXMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCkge1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBvLnV0Zjgud3JpdGUodGhpcy50eXBlRGVmYXVsdCwgdCA9IG8ubmV3QnVmZmVyKG8udXRmOC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKSwgdGhpcy50eXBlRGVmYXVsdCA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm1hcCA/IHRoaXMuZGVmYXVsdFZhbHVlID0gby5lbXB0eU9iamVjdCA6IHRoaXMucmVwZWF0ZWQgPyB0aGlzLmRlZmF1bHRWYWx1ZSA9IG8uZW1wdHlBcnJheSA6IHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy50eXBlRGVmYXVsdCwgdGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBhICYmICh0aGlzLnBhcmVudC5jdG9yLnByb3RvdHlwZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWUpLCBoLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIGwuZCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPSBvLmRlY29yYXRlVHlwZShlKS5uYW1lIDogZSAmJiBcIm9iamVjdFwiID09PSBpKGUpICYmIChlID0gby5kZWNvcmF0ZUVudW0oZSkubmFtZSksIGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgICAgICAgICBvLmRlY29yYXRlVHlwZShpLmNvbnN0cnVjdG9yKS5hZGQobmV3IGwocywgdCwgZSwgciwge1xuICAgICAgICAgICAgICBkZWZhdWx0OiBuXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgbC5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEgPSByKDI0KSwgbiA9IHIoNDIxKSwgcyA9IHIoNDcxKSwgbyA9IHIoOTE2KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICA2MjA6IHQgPT4ge1xuICAgICAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgRmxvYXQzMkFycmF5ID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRmxvYXQzMkFycmF5KFstMF0pLFxuICAgICAgICAgICAgICByID0gbmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIpLFxuICAgICAgICAgICAgICBpID0gMTI4ID09PSByWzNdO1xuICAgICAgICAgICAgZnVuY3Rpb24gbih0LCBpLCBuKSB7XG4gICAgICAgICAgICAgIGVbMF0gPSB0LCBpW25dID0gclswXSwgaVtuICsgMV0gPSByWzFdLCBpW24gKyAyXSA9IHJbMl0sIGlbbiArIDNdID0gclszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHModCwgaSwgbikge1xuICAgICAgICAgICAgICBlWzBdID0gdCwgaVtuXSA9IHJbM10sIGlbbiArIDFdID0gclsyXSwgaVtuICsgMl0gPSByWzFdLCBpW24gKyAzXSA9IHJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvKHQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJbMF0gPSB0W2ldLCByWzFdID0gdFtpICsgMV0sIHJbMl0gPSB0W2kgKyAyXSwgclszXSA9IHRbaSArIDNdLCBlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYSh0LCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByWzNdID0gdFtpXSwgclsyXSA9IHRbaSArIDFdLCByWzFdID0gdFtpICsgMl0sIHJbMF0gPSB0W2kgKyAzXSwgZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQud3JpdGVGbG9hdExFID0gaSA/IG4gOiBzLCB0LndyaXRlRmxvYXRCRSA9IGkgPyBzIDogbiwgdC5yZWFkRmxvYXRMRSA9IGkgPyBvIDogYSwgdC5yZWFkRmxvYXRCRSA9IGkgPyBhIDogbztcbiAgICAgICAgICB9KCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlKHQsIGUsIHIsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBlIDwgMCA/IDEgOiAwO1xuICAgICAgICAgICAgICBpZiAobiAmJiAoZSA9IC1lKSwgMCA9PT0gZSkgdCgxIC8gZSA+IDAgPyAwIDogMjE0NzQ4MzY0OCwgciwgaSk7ZWxzZSBpZiAoaXNOYU4oZSkpIHQoMjE0MzI4OTM0NCwgciwgaSk7ZWxzZSBpZiAoZSA+IDM0MDI4MjM0NjYzODUyODg2ZTIyKSB0KChuIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIHIsIGkpO2Vsc2UgaWYgKGUgPCAxMTc1NDk0MzUwODIyMjg3NWUtNTQpIHQoKG4gPDwgMzEgfCBNYXRoLnJvdW5kKGUgLyAxNDAxMjk4NDY0MzI0ODE3ZS02MCkpID4+PiAwLCByLCBpKTtlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGguZmxvb3IoTWF0aC5sb2coZSkgLyBNYXRoLkxOMik7XG4gICAgICAgICAgICAgICAgdCgobiA8PCAzMSB8IHMgKyAxMjcgPDwgMjMgfCA4Mzg4NjA3ICYgTWF0aC5yb3VuZChlICogTWF0aC5wb3coMiwgLXMpICogODM4ODYwOCkpID4+PiAwLCByLCBpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbyh0LCBlLCByKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gdChlLCByKSxcbiAgICAgICAgICAgICAgICBuID0gMiAqIChpID4+IDMxKSArIDEsXG4gICAgICAgICAgICAgICAgcyA9IGkgPj4+IDIzICYgMjU1LFxuICAgICAgICAgICAgICAgIG8gPSA4Mzg4NjA3ICYgaTtcbiAgICAgICAgICAgICAgcmV0dXJuIDI1NSA9PT0gcyA/IG8gPyBOYU4gOiBuICogKDEgLyAwKSA6IDAgPT09IHMgPyAxNDAxMjk4NDY0MzI0ODE3ZS02MCAqIG4gKiBvIDogbiAqIE1hdGgucG93KDIsIHMgLSAxNTApICogKG8gKyA4Mzg4NjA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQud3JpdGVGbG9hdExFID0gZS5iaW5kKG51bGwsIHIpLCB0LndyaXRlRmxvYXRCRSA9IGUuYmluZChudWxsLCBpKSwgdC5yZWFkRmxvYXRMRSA9IG8uYmluZChudWxsLCBuKSwgdC5yZWFkRmxvYXRCRSA9IG8uYmluZChudWxsLCBzKTtcbiAgICAgICAgICB9KCksIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEZsb2F0NjRBcnJheSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcbiAgICAgICAgICAgICAgciA9IG5ldyBVaW50OEFycmF5KGUuYnVmZmVyKSxcbiAgICAgICAgICAgICAgaSA9IDEyOCA9PT0gcls3XTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG4odCwgaSwgbikge1xuICAgICAgICAgICAgICBlWzBdID0gdCwgaVtuXSA9IHJbMF0sIGlbbiArIDFdID0gclsxXSwgaVtuICsgMl0gPSByWzJdLCBpW24gKyAzXSA9IHJbM10sIGlbbiArIDRdID0gcls0XSwgaVtuICsgNV0gPSByWzVdLCBpW24gKyA2XSA9IHJbNl0sIGlbbiArIDddID0gcls3XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHModCwgaSwgbikge1xuICAgICAgICAgICAgICBlWzBdID0gdCwgaVtuXSA9IHJbN10sIGlbbiArIDFdID0gcls2XSwgaVtuICsgMl0gPSByWzVdLCBpW24gKyAzXSA9IHJbNF0sIGlbbiArIDRdID0gclszXSwgaVtuICsgNV0gPSByWzJdLCBpW24gKyA2XSA9IHJbMV0sIGlbbiArIDddID0gclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG8odCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gclswXSA9IHRbaV0sIHJbMV0gPSB0W2kgKyAxXSwgclsyXSA9IHRbaSArIDJdLCByWzNdID0gdFtpICsgM10sIHJbNF0gPSB0W2kgKyA0XSwgcls1XSA9IHRbaSArIDVdLCByWzZdID0gdFtpICsgNl0sIHJbN10gPSB0W2kgKyA3XSwgZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGEodCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gcls3XSA9IHRbaV0sIHJbNl0gPSB0W2kgKyAxXSwgcls1XSA9IHRbaSArIDJdLCByWzRdID0gdFtpICsgM10sIHJbM10gPSB0W2kgKyA0XSwgclsyXSA9IHRbaSArIDVdLCByWzFdID0gdFtpICsgNl0sIHJbMF0gPSB0W2kgKyA3XSwgZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQud3JpdGVEb3VibGVMRSA9IGkgPyBuIDogcywgdC53cml0ZURvdWJsZUJFID0gaSA/IHMgOiBuLCB0LnJlYWREb3VibGVMRSA9IGkgPyBvIDogYSwgdC5yZWFkRG91YmxlQkUgPSBpID8gYSA6IG87XG4gICAgICAgICAgfSgpIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZSh0LCBlLCByLCBpLCBuLCBzKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gaSA8IDAgPyAxIDogMDtcbiAgICAgICAgICAgICAgaWYgKG8gJiYgKGkgPSAtaSksIDAgPT09IGkpIHQoMCwgbiwgcyArIGUpLCB0KDEgLyBpID4gMCA/IDAgOiAyMTQ3NDgzNjQ4LCBuLCBzICsgcik7ZWxzZSBpZiAoaXNOYU4oaSkpIHQoMCwgbiwgcyArIGUpLCB0KDIxNDY5NTkzNjAsIG4sIHMgKyByKTtlbHNlIGlmIChpID4gMTc5NzY5MzEzNDg2MjMxNTdlMjkyKSB0KDAsIG4sIHMgKyBlKSwgdCgobyA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBuLCBzICsgcik7ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMjI1MDczODU4NTA3MjAxNGUtMzI0KSB0KChhID0gaSAvIDVlLTMyNCkgPj4+IDAsIG4sIHMgKyBlKSwgdCgobyA8PCAzMSB8IGEgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgbiwgcyArIHIpO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKE1hdGgubG9nKGkpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgICAgICAgMTAyNCA9PT0gaCAmJiAoaCA9IDEwMjMpLCB0KDQ1MDM1OTk2MjczNzA0OTYgKiAoYSA9IGkgKiBNYXRoLnBvdygyLCAtaCkpID4+PiAwLCBuLCBzICsgZSksIHQoKG8gPDwgMzEgfCBoICsgMTAyMyA8PCAyMCB8IDEwNDg1NzYgKiBhICYgMTA0ODU3NSkgPj4+IDAsIG4sIHMgKyByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG8odCwgZSwgciwgaSwgbikge1xuICAgICAgICAgICAgICB2YXIgcyA9IHQoaSwgbiArIGUpLFxuICAgICAgICAgICAgICAgIG8gPSB0KGksIG4gKyByKSxcbiAgICAgICAgICAgICAgICBhID0gMiAqIChvID4+IDMxKSArIDEsXG4gICAgICAgICAgICAgICAgaCA9IG8gPj4+IDIwICYgMjA0NyxcbiAgICAgICAgICAgICAgICB1ID0gNDI5NDk2NzI5NiAqICgxMDQ4NTc1ICYgbykgKyBzO1xuICAgICAgICAgICAgICByZXR1cm4gMjA0NyA9PT0gaCA/IHUgPyBOYU4gOiBhICogKDEgLyAwKSA6IDAgPT09IGggPyA1ZS0zMjQgKiBhICogdSA6IGEgKiBNYXRoLnBvdygyLCBoIC0gMTA3NSkgKiAodSArIDQ1MDM1OTk2MjczNzA0OTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC53cml0ZURvdWJsZUxFID0gZS5iaW5kKG51bGwsIHIsIDAsIDQpLCB0LndyaXRlRG91YmxlQkUgPSBlLmJpbmQobnVsbCwgaSwgNCwgMCksIHQucmVhZERvdWJsZUxFID0gby5iaW5kKG51bGwsIG4sIDAsIDQpLCB0LnJlYWREb3VibGVCRSA9IG8uYmluZChudWxsLCBzLCA0LCAwKTtcbiAgICAgICAgICB9KCksIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcih0LCBlLCByKSB7XG4gICAgICAgICAgZVtyXSA9IDI1NSAmIHQsIGVbciArIDFdID0gdCA+Pj4gOCAmIDI1NSwgZVtyICsgMl0gPSB0ID4+PiAxNiAmIDI1NSwgZVtyICsgM10gPSB0ID4+PiAyNDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpKHQsIGUsIHIpIHtcbiAgICAgICAgICBlW3JdID0gdCA+Pj4gMjQsIGVbciArIDFdID0gdCA+Pj4gMTYgJiAyNTUsIGVbciArIDJdID0gdCA+Pj4gOCAmIDI1NSwgZVtyICsgM10gPSAyNTUgJiB0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG4odCwgZSkge1xuICAgICAgICAgIHJldHVybiAodFtlXSB8IHRbZSArIDFdIDw8IDggfCB0W2UgKyAyXSA8PCAxNiB8IHRbZSArIDNdIDw8IDI0KSA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gKHRbZV0gPDwgMjQgfCB0W2UgKyAxXSA8PCAxNiB8IHRbZSArIDJdIDw8IDggfCB0W2UgKyAzXSkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgdC5leHBvcnRzID0gZShlKTtcbiAgICAgIH0sXG4gICAgICA0NzA6IHQgPT4ge1xuICAgICAgICB0LmV4cG9ydHMgPSByO1xuICAgICAgICB2YXIgZSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMV0pKSwge30pLmV4cG9ydHM7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICAgIGZ1bmN0aW9uIHIodCwgZSwgcikge1xuICAgICAgICAgIHRoaXMubG93ID0gMCB8IHQsIHRoaXMuaGlnaCA9IDAgfCBlLCB0aGlzLnVuc2lnbmVkID0gISFyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGkodCkge1xuICAgICAgICAgIHJldHVybiAhMCA9PT0gKHQgJiYgdC5fX2lzTG9uZ19fKTtcbiAgICAgICAgfVxuICAgICAgICByLnByb3RvdHlwZS5fX2lzTG9uZ19fLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XG4gICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgIH0pLCByLmlzTG9uZyA9IGk7XG4gICAgICAgIHZhciBuID0ge30sXG4gICAgICAgICAgcyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBvKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciwgaSwgbztcbiAgICAgICAgICByZXR1cm4gZSA/IChvID0gMCA8PSAodCA+Pj49IDApICYmIHQgPCAyNTYpICYmIChpID0gc1t0XSkgPyBpIDogKHIgPSBoKHQsICgwIHwgdCkgPCAwID8gLTEgOiAwLCAhMCksIG8gJiYgKHNbdF0gPSByKSwgcikgOiAobyA9IC0xMjggPD0gKHQgfD0gMCkgJiYgdCA8IDEyOCkgJiYgKGkgPSBuW3RdKSA/IGkgOiAociA9IGgodCwgdCA8IDAgPyAtMSA6IDAsICExKSwgbyAmJiAoblt0XSA9IHIpLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhKHQsIGUpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odCkpIHJldHVybiBlID8gZyA6IHY7XG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmICh0IDwgMCkgcmV0dXJuIGc7XG4gICAgICAgICAgICBpZiAodCA+PSBkKSByZXR1cm4geDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHQgPD0gLXApIHJldHVybiBrO1xuICAgICAgICAgICAgaWYgKHQgKyAxID49IHApIHJldHVybiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdCA8IDAgPyBhKC10LCBlKS5uZWcoKSA6IGgodCAlIGMgfCAwLCB0IC8gYyB8IDAsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGgodCwgZSwgaSkge1xuICAgICAgICAgIHJldHVybiBuZXcgcih0LCBlLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByLmZyb21JbnQgPSBvLCByLmZyb21OdW1iZXIgPSBhLCByLmZyb21CaXRzID0gaDtcbiAgICAgICAgdmFyIHUgPSBNYXRoLnBvdztcbiAgICAgICAgZnVuY3Rpb24gbCh0LCBlLCByKSB7XG4gICAgICAgICAgaWYgKDAgPT09IHQubGVuZ3RoKSB0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICBpZiAoXCJOYU5cIiA9PT0gdCB8fCBcIkluZmluaXR5XCIgPT09IHQgfHwgXCIrSW5maW5pdHlcIiA9PT0gdCB8fCBcIi1JbmZpbml0eVwiID09PSB0KSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgZSA/IChyID0gZSwgZSA9ICExKSA6IGUgPSAhIWUsIChyID0gciB8fCAxMCkgPCAyIHx8IDM2IDwgcikgdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIGlmICgoaSA9IHQuaW5kZXhPZihcIi1cIikpID4gMCkgdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7XG4gICAgICAgICAgaWYgKDAgPT09IGkpIHJldHVybiBsKHQuc3Vic3RyaW5nKDEpLCBlLCByKS5uZWcoKTtcbiAgICAgICAgICBmb3IgKHZhciBuID0gYSh1KHIsIDgpKSwgcyA9IHYsIG8gPSAwOyBvIDwgdC5sZW5ndGg7IG8gKz0gOCkge1xuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1pbig4LCB0Lmxlbmd0aCAtIG8pLFxuICAgICAgICAgICAgICBmID0gcGFyc2VJbnQodC5zdWJzdHJpbmcobywgbyArIGgpLCByKTtcbiAgICAgICAgICAgIGlmIChoIDwgOCkge1xuICAgICAgICAgICAgICB2YXIgYyA9IGEodShyLCBoKSk7XG4gICAgICAgICAgICAgIHMgPSBzLm11bChjKS5hZGQoYShmKSk7XG4gICAgICAgICAgICB9IGVsc2UgcyA9IChzID0gcy5tdWwobikpLmFkZChhKGYpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHMudW5zaWduZWQgPSBlLCBzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGYodCwgZSkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gYSh0LCBlKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBsKHQsIGUpIDogaCh0LmxvdywgdC5oaWdoLCBcImJvb2xlYW5cIiA9PSB0eXBlb2YgZSA/IGUgOiB0LnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByLmZyb21TdHJpbmcgPSBsLCByLmZyb21WYWx1ZSA9IGY7XG4gICAgICAgIHZhciBjID0gNDI5NDk2NzI5NixcbiAgICAgICAgICBkID0gYyAqIGMsXG4gICAgICAgICAgcCA9IGQgLyAyLFxuICAgICAgICAgIHkgPSBvKDEgPDwgMjQpLFxuICAgICAgICAgIHYgPSBvKDApO1xuICAgICAgICByLlpFUk8gPSB2O1xuICAgICAgICB2YXIgZyA9IG8oMCwgITApO1xuICAgICAgICByLlVaRVJPID0gZztcbiAgICAgICAgdmFyIG0gPSBvKDEpO1xuICAgICAgICByLk9ORSA9IG07XG4gICAgICAgIHZhciBfID0gbygxLCAhMCk7XG4gICAgICAgIHIuVU9ORSA9IF87XG4gICAgICAgIHZhciB3ID0gbygtMSk7XG4gICAgICAgIHIuTkVHX09ORSA9IHc7XG4gICAgICAgIHZhciBiID0gaCgtMSwgMjE0NzQ4MzY0NywgITEpO1xuICAgICAgICByLk1BWF9WQUxVRSA9IGI7XG4gICAgICAgIHZhciB4ID0gaCgtMSwgLTEsICEwKTtcbiAgICAgICAgci5NQVhfVU5TSUdORURfVkFMVUUgPSB4O1xuICAgICAgICB2YXIgayA9IGgoMCwgLTIxNDc0ODM2NDgsICExKTtcbiAgICAgICAgci5NSU5fVkFMVUUgPSBrO1xuICAgICAgICB2YXIgQSA9IHIucHJvdG90eXBlO1xuICAgICAgICBBLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgICAgICAgfSwgQS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/ICh0aGlzLmhpZ2ggPj4+IDApICogYyArICh0aGlzLmxvdyA+Pj4gMCkgOiB0aGlzLmhpZ2ggKiBjICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICAgICAgfSwgQS50b1N0cmluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCh0ID0gdCB8fCAxMCkgPCAyIHx8IDM2IDwgdCkgdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO1xuICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gXCIwXCI7XG4gICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShrKSkge1xuICAgICAgICAgICAgICB2YXIgZSA9IGEodCksXG4gICAgICAgICAgICAgICAgciA9IHRoaXMuZGl2KGUpLFxuICAgICAgICAgICAgICAgIGkgPSByLm11bChlKS5zdWIodGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiByLnRvU3RyaW5nKHQpICsgaS50b0ludCgpLnRvU3RyaW5nKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiLVwiICsgdGhpcy5uZWcoKS50b1N0cmluZyh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgbiA9IGEodSh0LCA2KSwgdGhpcy51bnNpZ25lZCksIHMgPSB0aGlzLCBvID0gXCJcIjs7KSB7XG4gICAgICAgICAgICB2YXIgaCA9IHMuZGl2KG4pLFxuICAgICAgICAgICAgICBsID0gKHMuc3ViKGgubXVsKG4pKS50b0ludCgpID4+PiAwKS50b1N0cmluZyh0KTtcbiAgICAgICAgICAgIGlmICgocyA9IGgpLmlzWmVybygpKSByZXR1cm4gbCArIG87XG4gICAgICAgICAgICBmb3IgKDsgbC5sZW5ndGggPCA2OykgbCA9IFwiMFwiICsgbDtcbiAgICAgICAgICAgIG8gPSBcIlwiICsgbCArIG87XG4gICAgICAgICAgfVxuICAgICAgICB9LCBBLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgICAgIH0sIEEuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgICAgICB9LCBBLmdldExvd0JpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG93O1xuICAgICAgICB9LCBBLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gICAgICAgIH0sIEEuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLmVxKGspID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMCAhPSB0aGlzLmhpZ2ggPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdywgZSA9IDMxOyBlID4gMCAmJiAhKHQgJiAxIDw8IGUpOyBlLS0pO1xuICAgICAgICAgIHJldHVybiAwICE9IHRoaXMuaGlnaCA/IGUgKyAzMyA6IGUgKyAxO1xuICAgICAgICB9LCBBLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMCA9PT0gdGhpcy5oaWdoICYmIDAgPT09IHRoaXMubG93O1xuICAgICAgICB9LCBBLmVxeiA9IEEuaXNaZXJvLCBBLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG4gICAgICAgIH0sIEEuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgICAgICAgfSwgQS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gISgxICYgfnRoaXMubG93KTtcbiAgICAgICAgfSwgQS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEoMSAmIHRoaXMubG93KTtcbiAgICAgICAgfSwgQS5lcXVhbHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpKHQpIHx8ICh0ID0gZih0KSksICh0aGlzLnVuc2lnbmVkID09PSB0LnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+Pj4gMzEgIT0gMSB8fCB0LmhpZ2ggPj4+IDMxICE9IDEpICYmIHRoaXMuaGlnaCA9PT0gdC5oaWdoICYmIHRoaXMubG93ID09PSB0LmxvdztcbiAgICAgICAgfSwgQS5lcSA9IEEuZXF1YWxzLCBBLm5vdEVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLmVxKHQpO1xuICAgICAgICB9LCBBLm5lcSA9IEEubm90RXF1YWxzLCBBLm5lID0gQS5ub3RFcXVhbHMsIEEubGVzc1RoYW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXAodCkgPCAwO1xuICAgICAgICB9LCBBLmx0ID0gQS5sZXNzVGhhbiwgQS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXAodCkgPD0gMDtcbiAgICAgICAgfSwgQS5sdGUgPSBBLmxlc3NUaGFuT3JFcXVhbCwgQS5sZSA9IEEubGVzc1RoYW5PckVxdWFsLCBBLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wKHQpID4gMDtcbiAgICAgICAgfSwgQS5ndCA9IEEuZ3JlYXRlclRoYW4sIEEuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wKHQpID49IDA7XG4gICAgICAgIH0sIEEuZ3RlID0gQS5ncmVhdGVyVGhhbk9yRXF1YWwsIEEuZ2UgPSBBLmdyZWF0ZXJUaGFuT3JFcXVhbCwgQS5jb21wYXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoaSh0KSB8fCAodCA9IGYodCkpLCB0aGlzLmVxKHQpKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgICAgICAgICAgciA9IHQuaXNOZWdhdGl2ZSgpO1xuICAgICAgICAgIHJldHVybiBlICYmICFyID8gLTEgOiAhZSAmJiByID8gMSA6IHRoaXMudW5zaWduZWQgPyB0LmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHwgdC5oaWdoID09PSB0aGlzLmhpZ2ggJiYgdC5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMSA6IHRoaXMuc3ViKHQpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICAgICAgfSwgQS5jb21wID0gQS5jb21wYXJlLCBBLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShrKSA/IGsgOiB0aGlzLm5vdCgpLmFkZChtKTtcbiAgICAgICAgfSwgQS5uZWcgPSBBLm5lZ2F0ZSwgQS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGkodCkgfHwgKHQgPSBmKHQpKTtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuaGlnaCA+Pj4gMTYsXG4gICAgICAgICAgICByID0gNjU1MzUgJiB0aGlzLmhpZ2gsXG4gICAgICAgICAgICBuID0gdGhpcy5sb3cgPj4+IDE2LFxuICAgICAgICAgICAgcyA9IDY1NTM1ICYgdGhpcy5sb3csXG4gICAgICAgICAgICBvID0gdC5oaWdoID4+PiAxNixcbiAgICAgICAgICAgIGEgPSA2NTUzNSAmIHQuaGlnaCxcbiAgICAgICAgICAgIHUgPSB0LmxvdyA+Pj4gMTYsXG4gICAgICAgICAgICBsID0gMCxcbiAgICAgICAgICAgIGMgPSAwLFxuICAgICAgICAgICAgZCA9IDAsXG4gICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICByZXR1cm4gZCArPSAocCArPSBzICsgKDY1NTM1ICYgdC5sb3cpKSA+Pj4gMTYsIGMgKz0gKGQgKz0gbiArIHUpID4+PiAxNiwgbCArPSAoYyArPSByICsgYSkgPj4+IDE2LCBsICs9IGUgKyBvLCBoKChkICY9IDY1NTM1KSA8PCAxNiB8IChwICY9IDY1NTM1KSwgKGwgJj0gNjU1MzUpIDw8IDE2IHwgKGMgJj0gNjU1MzUpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfSwgQS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkodCkgfHwgKHQgPSBmKHQpKSwgdGhpcy5hZGQodC5uZWcoKSk7XG4gICAgICAgIH0sIEEuc3ViID0gQS5zdWJ0cmFjdCwgQS5tdWx0aXBseSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpKHQpIHx8ICh0ID0gZih0KSksIGUpIHJldHVybiBoKGUubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIHQubG93LCB0LmhpZ2gpLCBlLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgIGlmICh0LmlzWmVybygpKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAodGhpcy5lcShrKSkgcmV0dXJuIHQuaXNPZGQoKSA/IGsgOiB2O1xuICAgICAgICAgIGlmICh0LmVxKGspKSByZXR1cm4gdGhpcy5pc09kZCgpID8gayA6IHY7XG4gICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdC5pc05lZ2F0aXZlKCkgPyB0aGlzLm5lZygpLm11bCh0Lm5lZygpKSA6IHRoaXMubmVnKCkubXVsKHQpLm5lZygpO1xuICAgICAgICAgIGlmICh0LmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubXVsKHQubmVnKCkpLm5lZygpO1xuICAgICAgICAgIGlmICh0aGlzLmx0KHkpICYmIHQubHQoeSkpIHJldHVybiBhKHRoaXMudG9OdW1iZXIoKSAqIHQudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLmhpZ2ggPj4+IDE2LFxuICAgICAgICAgICAgbiA9IDY1NTM1ICYgdGhpcy5oaWdoLFxuICAgICAgICAgICAgcyA9IHRoaXMubG93ID4+PiAxNixcbiAgICAgICAgICAgIG8gPSA2NTUzNSAmIHRoaXMubG93LFxuICAgICAgICAgICAgdSA9IHQuaGlnaCA+Pj4gMTYsXG4gICAgICAgICAgICBsID0gNjU1MzUgJiB0LmhpZ2gsXG4gICAgICAgICAgICBjID0gdC5sb3cgPj4+IDE2LFxuICAgICAgICAgICAgZCA9IDY1NTM1ICYgdC5sb3csXG4gICAgICAgICAgICBwID0gMCxcbiAgICAgICAgICAgIGcgPSAwLFxuICAgICAgICAgICAgbSA9IDAsXG4gICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICByZXR1cm4gbSArPSAoXyArPSBvICogZCkgPj4+IDE2LCBnICs9IChtICs9IHMgKiBkKSA+Pj4gMTYsIG0gJj0gNjU1MzUsIGcgKz0gKG0gKz0gbyAqIGMpID4+PiAxNiwgcCArPSAoZyArPSBuICogZCkgPj4+IDE2LCBnICY9IDY1NTM1LCBwICs9IChnICs9IHMgKiBjKSA+Pj4gMTYsIGcgJj0gNjU1MzUsIHAgKz0gKGcgKz0gbyAqIGwpID4+PiAxNiwgcCArPSByICogZCArIG4gKiBjICsgcyAqIGwgKyBvICogdSwgaCgobSAmPSA2NTUzNSkgPDwgMTYgfCAoXyAmPSA2NTUzNSksIChwICY9IDY1NTM1KSA8PCAxNiB8IChnICY9IDY1NTM1KSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH0sIEEubXVsID0gQS5tdWx0aXBseSwgQS5kaXZpZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChpKHQpIHx8ICh0ID0gZih0KSksIHQuaXNaZXJvKCkpIHRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTtcbiAgICAgICAgICB2YXIgciwgbiwgcztcbiAgICAgICAgICBpZiAoZSkgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgLTIxNDc0ODM2NDggIT09IHRoaXMuaGlnaCB8fCAtMSAhPT0gdC5sb3cgfHwgLTEgIT09IHQuaGlnaCA/IGgoKHRoaXMudW5zaWduZWQgPyBlLmRpdl91IDogZS5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgdC5sb3csIHQuaGlnaCksIGUuZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCkgOiB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IGcgOiB2O1xuICAgICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodC51bnNpZ25lZCB8fCAodCA9IHQudG9VbnNpZ25lZCgpKSwgdC5ndCh0aGlzKSkgcmV0dXJuIGc7XG4gICAgICAgICAgICBpZiAodC5ndCh0aGlzLnNocnUoMSkpKSByZXR1cm4gXztcbiAgICAgICAgICAgIHMgPSBnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcShrKSkgcmV0dXJuIHQuZXEobSkgfHwgdC5lcSh3KSA/IGsgOiB0LmVxKGspID8gbSA6IChyID0gdGhpcy5zaHIoMSkuZGl2KHQpLnNobCgxKSkuZXEodikgPyB0LmlzTmVnYXRpdmUoKSA/IG0gOiB3IDogKG4gPSB0aGlzLnN1Yih0Lm11bChyKSksIHMgPSByLmFkZChuLmRpdih0KSkpO1xuICAgICAgICAgICAgaWYgKHQuZXEoaykpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gZyA6IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHJldHVybiB0LmlzTmVnYXRpdmUoKSA/IHRoaXMubmVnKCkuZGl2KHQubmVnKCkpIDogdGhpcy5uZWcoKS5kaXYodCkubmVnKCk7XG4gICAgICAgICAgICBpZiAodC5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLmRpdih0Lm5lZygpKS5uZWcoKTtcbiAgICAgICAgICAgIHMgPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKG4gPSB0aGlzOyBuLmd0ZSh0KTspIHtcbiAgICAgICAgICAgIHIgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKG4udG9OdW1iZXIoKSAvIHQudG9OdW1iZXIoKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgbyA9IE1hdGguY2VpbChNYXRoLmxvZyhyKSAvIE1hdGguTE4yKSwgbCA9IG8gPD0gNDggPyAxIDogdSgyLCBvIC0gNDgpLCBjID0gYShyKSwgZCA9IGMubXVsKHQpOyBkLmlzTmVnYXRpdmUoKSB8fCBkLmd0KG4pOykgZCA9IChjID0gYShyIC09IGwsIHRoaXMudW5zaWduZWQpKS5tdWwodCk7XG4gICAgICAgICAgICBjLmlzWmVybygpICYmIChjID0gbSksIHMgPSBzLmFkZChjKSwgbiA9IG4uc3ViKGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSwgQS5kaXYgPSBBLmRpdmlkZSwgQS5tb2R1bG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpKHQpIHx8ICh0ID0gZih0KSksIGUgPyBoKCh0aGlzLnVuc2lnbmVkID8gZS5yZW1fdSA6IGUucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIHQubG93LCB0LmhpZ2gpLCBlLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpIDogdGhpcy5zdWIodGhpcy5kaXYodCkubXVsKHQpKTtcbiAgICAgICAgfSwgQS5tb2QgPSBBLm1vZHVsbywgQS5yZW0gPSBBLm1vZHVsbywgQS5ub3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGgofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfSwgQS5hbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpKHQpIHx8ICh0ID0gZih0KSksIGgodGhpcy5sb3cgJiB0LmxvdywgdGhpcy5oaWdoICYgdC5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfSwgQS5vciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkodCkgfHwgKHQgPSBmKHQpKSwgaCh0aGlzLmxvdyB8IHQubG93LCB0aGlzLmhpZ2ggfCB0LmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9LCBBLnhvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkodCkgfHwgKHQgPSBmKHQpKSwgaCh0aGlzLmxvdyBeIHQubG93LCB0aGlzLmhpZ2ggXiB0LmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9LCBBLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkodCkgJiYgKHQgPSB0LnRvSW50KCkpLCAwID09ICh0ICY9IDYzKSA/IHRoaXMgOiB0IDwgMzIgPyBoKHRoaXMubG93IDw8IHQsIHRoaXMuaGlnaCA8PCB0IHwgdGhpcy5sb3cgPj4+IDMyIC0gdCwgdGhpcy51bnNpZ25lZCkgOiBoKDAsIHRoaXMubG93IDw8IHQgLSAzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH0sIEEuc2hsID0gQS5zaGlmdExlZnQsIEEuc2hpZnRSaWdodCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGkodCkgJiYgKHQgPSB0LnRvSW50KCkpLCAwID09ICh0ICY9IDYzKSA/IHRoaXMgOiB0IDwgMzIgPyBoKHRoaXMubG93ID4+PiB0IHwgdGhpcy5oaWdoIDw8IDMyIC0gdCwgdGhpcy5oaWdoID4+IHQsIHRoaXMudW5zaWduZWQpIDogaCh0aGlzLmhpZ2ggPj4gdCAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH0sIEEuc2hyID0gQS5zaGlmdFJpZ2h0LCBBLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKGkodCkgJiYgKHQgPSB0LnRvSW50KCkpLCAwID09ICh0ICY9IDYzKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmhpZ2g7XG4gICAgICAgICAgcmV0dXJuIHQgPCAzMiA/IGgodGhpcy5sb3cgPj4+IHQgfCBlIDw8IDMyIC0gdCwgZSA+Pj4gdCwgdGhpcy51bnNpZ25lZCkgOiBoKDMyID09PSB0ID8gZSA6IGUgPj4+IHQgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH0sIEEuc2hydSA9IEEuc2hpZnRSaWdodFVuc2lnbmVkLCBBLnNocl91ID0gQS5zaGlmdFJpZ2h0VW5zaWduZWQsIEEudG9TaWduZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBoKHRoaXMubG93LCB0aGlzLmhpZ2gsICExKSA6IHRoaXM7XG4gICAgICAgIH0sIEEudG9VbnNpZ25lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMgOiBoKHRoaXMubG93LCB0aGlzLmhpZ2gsICEwKTtcbiAgICAgICAgfSwgQS50b0J5dGVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xuICAgICAgICB9LCBBLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuaGlnaCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmxvdztcbiAgICAgICAgICByZXR1cm4gWzI1NSAmIGUsIGUgPj4+IDggJiAyNTUsIGUgPj4+IDE2ICYgMjU1LCBlID4+PiAyNCwgMjU1ICYgdCwgdCA+Pj4gOCAmIDI1NSwgdCA+Pj4gMTYgJiAyNTUsIHQgPj4+IDI0XTtcbiAgICAgICAgfSwgQS50b0J5dGVzQkUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmhpZ2gsXG4gICAgICAgICAgICBlID0gdGhpcy5sb3c7XG4gICAgICAgICAgcmV0dXJuIFt0ID4+PiAyNCwgdCA+Pj4gMTYgJiAyNTUsIHQgPj4+IDggJiAyNTUsIDI1NSAmIHQsIGUgPj4+IDI0LCBlID4+PiAxNiAmIDI1NSwgZSA+Pj4gOCAmIDI1NSwgMjU1ICYgZV07XG4gICAgICAgIH0sIHIuZnJvbUJ5dGVzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gaSA/IHIuZnJvbUJ5dGVzTEUodCwgZSkgOiByLmZyb21CeXRlc0JFKHQsIGUpO1xuICAgICAgICB9LCByLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHIodFswXSB8IHRbMV0gPDwgOCB8IHRbMl0gPDwgMTYgfCB0WzNdIDw8IDI0LCB0WzRdIHwgdFs1XSA8PCA4IHwgdFs2XSA8PCAxNiB8IHRbN10gPDwgMjQsIGUpO1xuICAgICAgICB9LCByLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHIodFs0XSA8PCAyNCB8IHRbNV0gPDwgMTYgfCB0WzZdIDw8IDggfCB0WzddLCB0WzBdIDw8IDI0IHwgdFsxXSA8PCAxNiB8IHRbMl0gPDwgOCB8IHRbM10sIGUpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDIxODogdCA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGUodCwgZSkge1xuICAgICAgICAgIHRoaXMubG8gPSB0ID4+PiAwLCB0aGlzLmhpID0gZSA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICB0LmV4cG9ydHMgPSBlO1xuICAgICAgICB2YXIgciA9IGUuemVybyA9IG5ldyBlKDAsIDApO1xuICAgICAgICByLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LCByLnp6RW5jb2RlID0gci56ekRlY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgci5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpID0gZS56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG4gICAgICAgIGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKDAgPT09IHQpIHJldHVybiByO1xuICAgICAgICAgIHZhciBpID0gdCA8IDA7XG4gICAgICAgICAgaSAmJiAodCA9IC10KTtcbiAgICAgICAgICB2YXIgbiA9IHQgPj4+IDAsXG4gICAgICAgICAgICBzID0gKHQgLSBuKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgKHMgPSB+cyA+Pj4gMCwgbiA9IH5uID4+PiAwLCArK24gPiA0Mjk0OTY3Mjk1ICYmIChuID0gMCwgKytzID4gNDI5NDk2NzI5NSAmJiAocyA9IDApKSksIG5ldyBlKG4sIHMpO1xuICAgICAgICB9LCBlLmZyb20gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gZS5mcm9tTnVtYmVyKHQpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCB8fCB0IGluc3RhbmNlb2YgU3RyaW5nID8gZS5mcm9tTnVtYmVyKHBhcnNlSW50KHQsIDEwKSkgOiB0LmxvdyB8fCB0LmhpZ2ggPyBuZXcgZSh0LmxvdyA+Pj4gMCwgdC5oaWdoID4+PiAwKSA6IHI7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoIXQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgICAgIHZhciBlID0gMSArIH50aGlzLmxvID4+PiAwLFxuICAgICAgICAgICAgICByID0gfnRoaXMuaGkgPj4+IDA7XG4gICAgICAgICAgICByZXR1cm4gZSB8fCAociA9IHIgKyAxID4+PiAwKSwgLShlICsgNDI5NDk2NzI5NiAqIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5sbyArIDQyOTQ5NjcyOTYgKiB0aGlzLmhpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb3c6IDAgfCB0aGlzLmxvLFxuICAgICAgICAgICAgaGlnaDogMCB8IHRoaXMuaGksXG4gICAgICAgICAgICB1bnNpZ25lZDogQm9vbGVhbih0KVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBuID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuICAgICAgICBlLmZyb21IYXNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA9PT0gaSA/IHIgOiBuZXcgZSgobi5jYWxsKHQsIDApIHwgbi5jYWxsKHQsIDEpIDw8IDggfCBuLmNhbGwodCwgMikgPDwgMTYgfCBuLmNhbGwodCwgMykgPDwgMjQpID4+PiAwLCAobi5jYWxsKHQsIDQpIHwgbi5jYWxsKHQsIDUpIDw8IDggfCBuLmNhbGwodCwgNikgPDwgMTYgfCBuLmNhbGwodCwgNykgPDwgMjQpID4+PiAwKTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmIHRoaXMubG8sIHRoaXMubG8gPj4+IDggJiAyNTUsIHRoaXMubG8gPj4+IDE2ICYgMjU1LCB0aGlzLmxvID4+PiAyNCwgMjU1ICYgdGhpcy5oaSwgdGhpcy5oaSA+Pj4gOCAmIDI1NSwgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsIHRoaXMuaGkgPj4+IDI0KTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmhpID4+IDMxO1xuICAgICAgICAgIHJldHVybiB0aGlzLmhpID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiB0KSA+Pj4gMCwgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEgXiB0KSA+Pj4gMCwgdGhpcztcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSAtKDEgJiB0aGlzLmxvKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gdCkgPj4+IDAsIHRoaXMuaGkgPSAodGhpcy5oaSA+Pj4gMSBeIHQpID4+PiAwLCB0aGlzO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmxvLFxuICAgICAgICAgICAgZSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgICAgICByID0gdGhpcy5oaSA+Pj4gMjQ7XG4gICAgICAgICAgcmV0dXJuIDAgPT09IHIgPyAwID09PSBlID8gdCA8IDE2Mzg0ID8gdCA8IDEyOCA/IDEgOiAyIDogdCA8IDIwOTcxNTIgPyAzIDogNCA6IGUgPCAxNjM4NCA/IGUgPCAxMjggPyA1IDogNiA6IGUgPCAyMDk3MTUyID8gNyA6IDggOiByIDwgMTI4ID8gOSA6IDEwO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDcxODogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdmFyIGkgPSByKDUzNSkuZGVmYXVsdDtcbiAgICAgICAgdC5leHBvcnRzID0gYTtcbiAgICAgICAgdmFyIG4sXG4gICAgICAgICAgcyxcbiAgICAgICAgICBvID0gcigyMzgpO1xuICAgICAgICBmdW5jdGlvbiBhKHQsIGUsIHIsIGksIG4sIGEpIHtcbiAgICAgICAgICBpZiAoby5jYWxsKHRoaXMsIHQsIGUsIGksIHZvaWQgMCwgdm9pZCAwLCBuLCBhKSwgIXMuaXNTdHJpbmcocikpIHRocm93IFR5cGVFcnJvcihcImtleVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICB0aGlzLmtleVR5cGUgPSByLCB0aGlzLnJlc29sdmVkS2V5VHlwZSA9IG51bGwsIHRoaXMubWFwID0gITA7XG4gICAgICAgIH1cbiAgICAgICAgKChhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoby5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGEpLmNsYXNzTmFtZSA9IFwiTWFwRmllbGRcIiwgYS5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBhKHQsIGUuaWQsIGUua2V5VHlwZSwgZS50eXBlLCBlLm9wdGlvbnMsIGUuY29tbWVudCk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSAhIXQgJiYgQm9vbGVhbih0LmtlZXBDb21tZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHMudG9PYmplY3QoW1wia2V5VHlwZVwiLCB0aGlzLmtleVR5cGUsIFwidHlwZVwiLCB0aGlzLnR5cGUsIFwiaWRcIiwgdGhpcy5pZCwgXCJleHRlbmRcIiwgdGhpcy5leHRlbmQsIFwib3B0aW9uc1wiLCB0aGlzLm9wdGlvbnMsIFwiY29tbWVudFwiLCBlID8gdGhpcy5jb21tZW50IDogdm9pZCAwXSk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IG4ubWFwS2V5W3RoaXMua2V5VHlwZV0pIHRocm93IEVycm9yKFwiaW52YWxpZCBrZXkgdHlwZTogXCIgKyB0aGlzLmtleVR5cGUpO1xuICAgICAgICAgIHJldHVybiBvLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIGEuZCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciA/IHIgPSBzLmRlY29yYXRlVHlwZShyKS5uYW1lIDogciAmJiBcIm9iamVjdFwiID09PSBpKHIpICYmIChyID0gcy5kZWNvcmF0ZUVudW0ocikubmFtZSksIGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgICBzLmRlY29yYXRlVHlwZShpLmNvbnN0cnVjdG9yKS5hZGQobmV3IGEobiwgdCwgZSwgcikpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGEuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBuID0gcig0NzEpLCBzID0gcig5MTYpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDg1MzogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICAgIGlmICh0KSBmb3IgKHZhciBlID0gT2JqZWN0LmtleXModCksIHIgPSAwOyByIDwgZS5sZW5ndGg7ICsrcikgdGhpc1tlW3JdXSA9IHRbZVtyXV07XG4gICAgICAgIH1cbiAgICAgICAgdC5leHBvcnRzID0gbiwgbi5jcmVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiR0eXBlLmNyZWF0ZSh0KTtcbiAgICAgICAgfSwgbi5lbmNvZGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gMSA9PSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy4kdHlwZS5lbmNvZGUoYXJndW1lbnRzWzBdKSA6IHRoaXMuJHR5cGUuZW5jb2RlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHRoaXMuJHR5cGUuZW5jb2RlKHRoaXMpO1xuICAgICAgICB9LCBuLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlRGVsaW1pdGVkKHQsIGUpO1xuICAgICAgICB9LCBuLmRlY29kZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlKHQpO1xuICAgICAgICB9LCBuLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlRGVsaW1pdGVkKHQpO1xuICAgICAgICB9LCBuLnZlcmlmeSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHR5cGUudmVyaWZ5KHQpO1xuICAgICAgICB9LCBuLmZyb21PYmplY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiR0eXBlLmZyb21PYmplY3QodCk7XG4gICAgICAgIH0sIG4udG9PYmplY3QgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0ID0gdCB8fCB0aGlzLCB0aGlzLiR0eXBlLnRvT2JqZWN0KHQsIGUpO1xuICAgICAgICB9LCBuLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QodGhpcywgaS50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfSwgbi5zZXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIG5bdF0gPSBlO1xuICAgICAgICB9LCBuLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5bdF07XG4gICAgICAgIH0sIG4uX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpID0gcig5MTYpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDQ5MzogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdC5leHBvcnRzID0gcztcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgbiA9IHIoNzE5KTtcbiAgICAgICAgZnVuY3Rpb24gcyh0LCBlLCByLCBzLCBvLCBhLCBoLCB1KSB7XG4gICAgICAgICAgaWYgKGkuaXNPYmplY3QobykgPyAoaCA9IG8sIG8gPSBhID0gdm9pZCAwKSA6IGkuaXNPYmplY3QoYSkgJiYgKGggPSBhLCBhID0gdm9pZCAwKSwgdm9pZCAwICE9PSBlICYmICFpLmlzU3RyaW5nKGUpKSB0aHJvdyBUeXBlRXJyb3IoXCJ0eXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgaWYgKCFpLmlzU3RyaW5nKHIpKSB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgIGlmICghaS5pc1N0cmluZyhzKSkgdGhyb3cgVHlwZUVycm9yKFwicmVzcG9uc2VUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgbi5jYWxsKHRoaXMsIHQsIGgpLCB0aGlzLnR5cGUgPSBlIHx8IFwicnBjXCIsIHRoaXMucmVxdWVzdFR5cGUgPSByLCB0aGlzLnJlcXVlc3RTdHJlYW0gPSAhIW8gfHwgdm9pZCAwLCB0aGlzLnJlc3BvbnNlVHlwZSA9IHMsIHRoaXMucmVzcG9uc2VTdHJlYW0gPSAhIWEgfHwgdm9pZCAwLCB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsLCB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbCwgdGhpcy5jb21tZW50ID0gdTtcbiAgICAgICAgfVxuICAgICAgICAoKHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gcykuY2xhc3NOYW1lID0gXCJNZXRob2RcIiwgcy5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBzKHQsIGUudHlwZSwgZS5yZXF1ZXN0VHlwZSwgZS5yZXNwb25zZVR5cGUsIGUucmVxdWVzdFN0cmVhbSwgZS5yZXNwb25zZVN0cmVhbSwgZS5vcHRpb25zLCBlLmNvbW1lbnQpO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gISF0ICYmIEJvb2xlYW4odC5rZWVwQ29tbWVudHMpO1xuICAgICAgICAgIHJldHVybiBpLnRvT2JqZWN0KFtcInR5cGVcIiwgXCJycGNcIiAhPT0gdGhpcy50eXBlICYmIHRoaXMudHlwZSB8fCB2b2lkIDAsIFwicmVxdWVzdFR5cGVcIiwgdGhpcy5yZXF1ZXN0VHlwZSwgXCJyZXF1ZXN0U3RyZWFtXCIsIHRoaXMucmVxdWVzdFN0cmVhbSwgXCJyZXNwb25zZVR5cGVcIiwgdGhpcy5yZXNwb25zZVR5cGUsIFwicmVzcG9uc2VTdHJlYW1cIiwgdGhpcy5yZXNwb25zZVN0cmVhbSwgXCJvcHRpb25zXCIsIHRoaXMub3B0aW9ucywgXCJjb21tZW50XCIsIGUgPyB0aGlzLmNvbW1lbnQgOiB2b2lkIDBdKTtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZCA/IHRoaXMgOiAodGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gdGhpcy5wYXJlbnQubG9va3VwVHlwZSh0aGlzLnJlcXVlc3RUeXBlKSwgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpLCBuLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcykpO1xuICAgICAgICB9LCBzLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaSA9IHIoOTE2KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICA2MjU6ICh0LCBlLCByKSA9PiB7XG4gICAgICAgIHQuZXhwb3J0cyA9IGw7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyxcbiAgICAgICAgICBvLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgaCA9IHIoNzE5KTtcbiAgICAgICAgZnVuY3Rpb24gdSh0LCBlKSB7XG4gICAgICAgICAgaWYgKHQgJiYgdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSB7fSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKytpKSByW3RbaV0ubmFtZV0gPSB0W2ldLnRvSlNPTihlKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsKHQsIGUpIHtcbiAgICAgICAgICBoLmNhbGwodGhpcywgdCwgZSksIHRoaXMubmVzdGVkID0gdm9pZCAwLCB0aGlzLl9uZXN0ZWRBcnJheSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZih0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuX25lc3RlZEFycmF5ID0gbnVsbCwgdDtcbiAgICAgICAgfVxuICAgICAgICAoKGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShoLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbCkuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIiwgbC5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKHQsIGUub3B0aW9ucykuYWRkSlNPTihlLm5lc3RlZCk7XG4gICAgICAgIH0sIGwuYXJyYXlUb0pTT04gPSB1LCBsLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKHQpIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHRbcl0gJiYgdFtyXVswXSA8PSBlICYmIHRbcl1bMV0gPj0gZSkgcmV0dXJuICEwO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgbC5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKHQpIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgaWYgKHRbcl0gPT09IGUpIHJldHVybiAhMDtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLnByb3RvdHlwZSwgXCJuZXN0ZWRBcnJheVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmVzdGVkQXJyYXkgfHwgKHRoaXMuX25lc3RlZEFycmF5ID0gcy50b0FycmF5KHRoaXMubmVzdGVkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gcy50b09iamVjdChbXCJvcHRpb25zXCIsIHRoaXMub3B0aW9ucywgXCJuZXN0ZWRcIiwgdSh0aGlzLm5lc3RlZEFycmF5LCB0KV0pO1xuICAgICAgICB9LCBsLnByb3RvdHlwZS5hZGRKU09OID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCkgZm9yICh2YXIgZSwgciA9IE9iamVjdC5rZXlzKHQpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyArK3MpIGUgPSB0W3Jbc11dLCB0aGlzLmFkZCgodm9pZCAwICE9PSBlLmZpZWxkcyA/IG8uZnJvbUpTT04gOiB2b2lkIDAgIT09IGUudmFsdWVzID8gaS5mcm9tSlNPTiA6IHZvaWQgMCAhPT0gZS5tZXRob2RzID8gYS5mcm9tSlNPTiA6IHZvaWQgMCAhPT0gZS5pZCA/IG4uZnJvbUpTT04gOiBsLmZyb21KU09OKShyW3NdLCBlKSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW3RdIHx8IG51bGw7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmdldEVudW0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFt0XSBpbnN0YW5jZW9mIGkpIHJldHVybiB0aGlzLm5lc3RlZFt0XS52YWx1ZXM7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIGVudW06IFwiICsgdCk7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIG4gJiYgdm9pZCAwICE9PSB0LmV4dGVuZCB8fCB0IGluc3RhbmNlb2YgbyB8fCB0IGluc3RhbmNlb2YgaSB8fCB0IGluc3RhbmNlb2YgYSB8fCB0IGluc3RhbmNlb2YgbCkpIHRocm93IFR5cGVFcnJvcihcIm9iamVjdCBtdXN0IGJlIGEgdmFsaWQgbmVzdGVkIG9iamVjdFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5uZXN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nZXQodC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBsICYmIHQgaW5zdGFuY2VvZiBsKSB8fCBlIGluc3RhbmNlb2YgbyB8fCBlIGluc3RhbmNlb2YgYSkgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyB0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgciA9IGUubmVzdGVkQXJyYXksIHMgPSAwOyBzIDwgci5sZW5ndGg7ICsrcykgdC5hZGQocltzXSk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGUpLCB0aGlzLm5lc3RlZCB8fCAodGhpcy5uZXN0ZWQgPSB7fSksIHQuc2V0T3B0aW9ucyhlLm9wdGlvbnMsICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZXN0ZWRbdC5uYW1lXSA9IHQsIHQub25BZGQodGhpcyksIGYodGhpcyk7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIGgpKSB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XG4gICAgICAgICAgaWYgKHQucGFyZW50ICE9PSB0aGlzKSB0aHJvdyBFcnJvcih0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLm5lc3RlZFt0Lm5hbWVdLCBPYmplY3Qua2V5cyh0aGlzLm5lc3RlZCkubGVuZ3RoIHx8ICh0aGlzLm5lc3RlZCA9IHZvaWQgMCksIHQub25SZW1vdmUodGhpcyksIGYodGhpcyk7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKHMuaXNTdHJpbmcodCkpIHQgPSB0LnNwbGl0KFwiLlwiKTtlbHNlIGlmICghQXJyYXkuaXNBcnJheSh0KSkgdGhyb3cgVHlwZUVycm9yKFwiaWxsZWdhbCBwYXRoXCIpO1xuICAgICAgICAgIGlmICh0ICYmIHQubGVuZ3RoICYmIFwiXCIgPT09IHRbMF0pIHRocm93IEVycm9yKFwicGF0aCBtdXN0IGJlIHJlbGF0aXZlXCIpO1xuICAgICAgICAgIGZvciAodmFyIHIgPSB0aGlzOyB0Lmxlbmd0aCA+IDA7KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHQuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyLm5lc3RlZCAmJiByLm5lc3RlZFtpXSkge1xuICAgICAgICAgICAgICBpZiAoISgociA9IHIubmVzdGVkW2ldKSBpbnN0YW5jZW9mIGwpKSB0aHJvdyBFcnJvcihcInBhdGggY29uZmxpY3RzIHdpdGggbm9uLW5hbWVzcGFjZSBvYmplY3RzXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHIuYWRkKHIgPSBuZXcgbChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlICYmIHIuYWRkSlNPTihlKSwgcjtcbiAgICAgICAgfSwgbC5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy5uZXN0ZWRBcnJheSwgZSA9IDA7IGUgPCB0Lmxlbmd0aDspIHRbZV0gaW5zdGFuY2VvZiBsID8gdFtlKytdLnJlc29sdmVBbGwoKSA6IHRbZSsrXS5yZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZSgpO1xuICAgICAgICB9LCBsLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgZSA/IChyID0gZSwgZSA9IHZvaWQgMCkgOiBlICYmICFBcnJheS5pc0FycmF5KGUpICYmIChlID0gW2VdKSwgcy5pc1N0cmluZyh0KSAmJiB0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKFwiLlwiID09PSB0KSByZXR1cm4gdGhpcy5yb290O1xuICAgICAgICAgICAgdCA9IHQuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXQubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgICAgICBpZiAoXCJcIiA9PT0gdFswXSkgcmV0dXJuIHRoaXMucm9vdC5sb29rdXAodC5zbGljZSgxKSwgZSk7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmdldCh0WzBdKTtcbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgaWYgKDEgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICghZSB8fCBlLmluZGV4T2YoaS5jb25zdHJ1Y3RvcikgPiAtMSkgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgaW5zdGFuY2VvZiBsICYmIChpID0gaS5sb29rdXAodC5zbGljZSgxKSwgZSwgITApKSkgcmV0dXJuIGk7XG4gICAgICAgICAgfSBlbHNlIGZvciAodmFyIG4gPSAwOyBuIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsrbikgaWYgKHRoaXMuX25lc3RlZEFycmF5W25dIGluc3RhbmNlb2YgbCAmJiAoaSA9IHRoaXMuX25lc3RlZEFycmF5W25dLmxvb2t1cCh0LCBlLCAhMCkpKSByZXR1cm4gaTtcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gdGhpcy5wYXJlbnQgfHwgciA/IG51bGwgOiB0aGlzLnBhcmVudC5sb29rdXAodCwgZSk7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmxvb2t1cFR5cGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5sb29rdXAodCwgW29dKTtcbiAgICAgICAgICBpZiAoIWUpIHRocm93IEVycm9yKFwibm8gc3VjaCB0eXBlOiBcIiArIHQpO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LCBsLnByb3RvdHlwZS5sb29rdXBFbnVtID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMubG9va3VwKHQsIFtpXSk7XG4gICAgICAgICAgaWYgKCFlKSB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggRW51bSAnXCIgKyB0ICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIGwucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5sb29rdXAodCwgW28sIGldKTtcbiAgICAgICAgICBpZiAoIWUpIHRocm93IEVycm9yKFwibm8gc3VjaCBUeXBlIG9yIEVudW0gJ1wiICsgdCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LCBsLnByb3RvdHlwZS5sb29rdXBTZXJ2aWNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMubG9va3VwKHQsIFthXSk7XG4gICAgICAgICAgaWYgKCFlKSB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggU2VydmljZSAnXCIgKyB0ICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIGwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpID0gcig0MjEpLCBuID0gcigyMzgpLCBzID0gcig5MTYpLCBvID0gcigyNCksIGEgPSByKDY3Myk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNzE5OiAodCwgZSwgcikgPT4ge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICB2YXIgaSwgbjtcbiAgICAgICAgZnVuY3Rpb24gcyh0LCBlKSB7XG4gICAgICAgICAgaWYgKCFpLmlzU3RyaW5nKHQpKSB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgICAgaWYgKGUgJiYgIWkuaXNPYmplY3QoZSkpIHRocm93IFR5cGVFcnJvcihcIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gZSwgdGhpcy5uYW1lID0gdCwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLnJlc29sdmVkID0gITEsIHRoaXMuY29tbWVudCA9IG51bGwsIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHQuZXhwb3J0cyA9IHMsIHMuY2xhc3NOYW1lID0gXCJSZWZsZWN0aW9uT2JqZWN0XCIsIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMucHJvdG90eXBlLCB7XG4gICAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHQgPSB0aGlzOyBudWxsICE9PSB0LnBhcmVudDspIHQgPSB0LnBhcmVudDtcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdWxsTmFtZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHQgPSBbdGhpcy5uYW1lXSwgZSA9IHRoaXMucGFyZW50OyBlOykgdC51bnNoaWZ0KGUubmFtZSksIGUgPSBlLnBhcmVudDtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuam9pbihcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCAhPT0gdCAmJiB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyksIHRoaXMucGFyZW50ID0gdCwgdGhpcy5yZXNvbHZlZCA9ICExO1xuICAgICAgICAgIHZhciBlID0gdC5yb290O1xuICAgICAgICAgIGUgaW5zdGFuY2VvZiBuICYmIGUuX2hhbmRsZUFkZCh0aGlzKTtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdC5yb290O1xuICAgICAgICAgIGUgaW5zdGFuY2VvZiBuICYmIGUuX2hhbmRsZVJlbW92ZSh0aGlzKSwgdGhpcy5wYXJlbnQgPSBudWxsLCB0aGlzLnJlc29sdmVkID0gITE7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yb290IGluc3RhbmNlb2YgbiAmJiAodGhpcy5yZXNvbHZlZCA9ICEwKSwgdGhpcztcbiAgICAgICAgfSwgcy5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zKSByZXR1cm4gdGhpcy5vcHRpb25zW3RdO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiByICYmIHRoaXMub3B0aW9ucyAmJiB2b2lkIDAgIT09IHRoaXMub3B0aW9uc1t0XSB8fCAoKHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pKVt0XSA9IGUpLCB0aGlzO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBpZiAodCkgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKHQpLCBpID0gMDsgaSA8IHIubGVuZ3RoOyArK2kpIHRoaXMuc2V0T3B0aW9uKHJbaV0sIHRbcltpXV0sIGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lLFxuICAgICAgICAgICAgZSA9IHRoaXMuZnVsbE5hbWU7XG4gICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID8gdCArIFwiIFwiICsgZSA6IHQ7XG4gICAgICAgIH0sIHMuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgbiA9IHIoNTcyKSwgaSA9IHIoOTE2KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICA4MDM6ICh0LCBlLCByKSA9PiB7XG4gICAgICAgIHQuZXhwb3J0cyA9IG87XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyA9IHIoNzE5KTtcbiAgICAgICAgZnVuY3Rpb24gbyh0LCBlLCByLCBpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkgfHwgKHIgPSBlLCBlID0gdm9pZCAwKSwgcy5jYWxsKHRoaXMsIHQsIHIpLCB2b2lkIDAgIT09IGUgJiYgIUFycmF5LmlzQXJyYXkoZSkpIHRocm93IFR5cGVFcnJvcihcImZpZWxkTmFtZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgICB0aGlzLm9uZW9mID0gZSB8fCBbXSwgdGhpcy5maWVsZHNBcnJheSA9IFtdLCB0aGlzLmNvbW1lbnQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGEodCkge1xuICAgICAgICAgIGlmICh0LnBhcmVudCkgZm9yICh2YXIgZSA9IDA7IGUgPCB0LmZpZWxkc0FycmF5Lmxlbmd0aDsgKytlKSB0LmZpZWxkc0FycmF5W2VdLnBhcmVudCB8fCB0LnBhcmVudC5hZGQodC5maWVsZHNBcnJheVtlXSk7XG4gICAgICAgIH1cbiAgICAgICAgKChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocy5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IG8pLmNsYXNzTmFtZSA9IFwiT25lT2ZcIiwgby5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBvKHQsIGUub25lb2YsIGUub3B0aW9ucywgZS5jb21tZW50KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9ICEhdCAmJiBCb29sZWFuKHQua2VlcENvbW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gbi50b09iamVjdChbXCJvcHRpb25zXCIsIHRoaXMub3B0aW9ucywgXCJvbmVvZlwiLCB0aGlzLm9uZW9mLCBcImNvbW1lbnRcIiwgZSA/IHRoaXMuY29tbWVudCA6IHZvaWQgMF0pO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBpKSkgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuICAgICAgICAgIHJldHVybiB0LnBhcmVudCAmJiB0LnBhcmVudCAhPT0gdGhpcy5wYXJlbnQgJiYgdC5wYXJlbnQucmVtb3ZlKHQpLCB0aGlzLm9uZW9mLnB1c2godC5uYW1lKSwgdGhpcy5maWVsZHNBcnJheS5wdXNoKHQpLCB0LnBhcnRPZiA9IHRoaXMsIGEodGhpcyksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIGkpKSB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmZpZWxkc0FycmF5LmluZGV4T2YodCk7XG4gICAgICAgICAgaWYgKGUgPCAwKSB0aHJvdyBFcnJvcih0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzQXJyYXkuc3BsaWNlKGUsIDEpLCAoZSA9IHRoaXMub25lb2YuaW5kZXhPZih0Lm5hbWUpKSA+IC0xICYmIHRoaXMub25lb2Yuc3BsaWNlKGUsIDEpLCB0LnBhcnRPZiA9IG51bGwsIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBzLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5vbmVvZi5sZW5ndGg7ICsrZSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0LmdldCh0aGlzLm9uZW9mW2VdKTtcbiAgICAgICAgICAgIHIgJiYgIXIucGFydE9mICYmIChyLnBhcnRPZiA9IHRoaXMsIHRoaXMuZmllbGRzQXJyYXkucHVzaChyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEodGhpcyk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlLCByID0gMDsgciA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK3IpIChlID0gdGhpcy5maWVsZHNBcnJheVtyXSkucGFyZW50ICYmIGUucGFyZW50LnJlbW92ZShlKTtcbiAgICAgICAgICBzLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIHQpO1xuICAgICAgICB9LCBvLmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSwgZSA9IDA7IGUgPCBhcmd1bWVudHMubGVuZ3RoOykgdFtlXSA9IGFyZ3VtZW50c1tlKytdO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgbi5kZWNvcmF0ZVR5cGUoZS5jb25zdHJ1Y3RvcikuYWRkKG5ldyBvKHIsIHQpKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICAgICAgICAgICAgZ2V0OiBuLm9uZU9mR2V0dGVyKHQpLFxuICAgICAgICAgICAgICBzZXQ6IG4ub25lT2ZTZXR0ZXIodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIG8uX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpID0gcigyMzgpLCBuID0gcig5MTYpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDEyMTogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdmFyIGksIG4sIHMsIG8sIGEsIGgsIHUsIGwsIGYsIGMsIGQ7XG4gICAgICAgIHQuZXhwb3J0cyA9IEEsIEEuZmlsZW5hbWUgPSBudWxsLCBBLmRlZmF1bHRzID0ge1xuICAgICAgICAgIGtlZXBDYXNlOiAhMVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcCA9IC9eWzEtOV1bMC05XSokLyxcbiAgICAgICAgICB5ID0gL14tP1sxLTldWzAtOV0qJC8sXG4gICAgICAgICAgdiA9IC9eMFt4XVswLTlhLWZBLUZdKyQvLFxuICAgICAgICAgIGcgPSAvXi0/MFt4XVswLTlhLWZBLUZdKyQvLFxuICAgICAgICAgIG0gPSAvXjBbMC03XSskLyxcbiAgICAgICAgICBfID0gL14tPzBbMC03XSskLyxcbiAgICAgICAgICB3ID0gL14oPyFbZUVdKVswLTldKig/OlxcLlswLTldKik/KD86W2VFXVsrLV0/WzAtOV0rKT8kLyxcbiAgICAgICAgICBiID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXG4gICAgICAgICAgeCA9IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKyQvLFxuICAgICAgICAgIGsgPSAvXig/OlxcLlthLXpBLVpdW2EtekEtWl8wLTldKikrJC87XG4gICAgICAgIGZ1bmN0aW9uIEEodCwgZSwgcikge1xuICAgICAgICAgIGUgaW5zdGFuY2VvZiBuIHx8IChyID0gZSwgZSA9IG5ldyBuKCkpLCByIHx8IChyID0gQS5kZWZhdWx0cyk7XG4gICAgICAgICAgdmFyIFMsXG4gICAgICAgICAgICBPLFxuICAgICAgICAgICAgRSxcbiAgICAgICAgICAgIFQsXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgQiA9IGkodCwgci5hbHRlcm5hdGVDb21tZW50TW9kZSB8fCAhMSksXG4gICAgICAgICAgICBJID0gQi5uZXh0LFxuICAgICAgICAgICAgTiA9IEIucHVzaCxcbiAgICAgICAgICAgIEYgPSBCLnBlZWssXG4gICAgICAgICAgICBqID0gQi5za2lwLFxuICAgICAgICAgICAgTCA9IEIuY21udCxcbiAgICAgICAgICAgIEMgPSAhMCxcbiAgICAgICAgICAgIFIgPSAhMSxcbiAgICAgICAgICAgIEQgPSBlLFxuICAgICAgICAgICAgTSA9IHIua2VlcENhc2UgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0gOiBkLmNhbWVsQ2FzZTtcbiAgICAgICAgICBmdW5jdGlvbiBQKHQsIGUsIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0gQS5maWxlbmFtZTtcbiAgICAgICAgICAgIHJldHVybiByIHx8IChBLmZpbGVuYW1lID0gbnVsbCksIEVycm9yKFwiaWxsZWdhbCBcIiArIChlIHx8IFwidG9rZW5cIikgKyBcIiAnXCIgKyB0ICsgXCInIChcIiArIChpID8gaSArIFwiLCBcIiA6IFwiXCIpICsgXCJsaW5lIFwiICsgQi5saW5lICsgXCIpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBVKCkge1xuICAgICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICAgIGUgPSBbXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaWYgKCdcIicgIT09ICh0ID0gSSgpKSAmJiBcIidcIiAhPT0gdCkgdGhyb3cgUCh0KTtcbiAgICAgICAgICAgICAgZS5wdXNoKEkoKSksIGoodCksIHQgPSBGKCk7XG4gICAgICAgICAgICB9IHdoaWxlICgnXCInID09PSB0IHx8IFwiJ1wiID09PSB0KTtcbiAgICAgICAgICAgIHJldHVybiBlLmpvaW4oXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFoodCkge1xuICAgICAgICAgICAgdmFyIGUgPSBJKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgIHJldHVybiBOKGUpLCBVKCk7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJUUlVFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIkZBTFNFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAxO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoXCItXCIgPT09IHQuY2hhckF0KDApICYmIChyID0gLTEsIHQgPSB0LnN1YnN0cmluZygxKSksIHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJJTkZcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJJbmZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgKiAoMSAvIDApO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm5hblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIk5BTlwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIk5hblwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwLnRlc3QodCkpIHJldHVybiByICogcGFyc2VJbnQodCwgMTApO1xuICAgICAgICAgICAgICAgIGlmICh2LnRlc3QodCkpIHJldHVybiByICogcGFyc2VJbnQodCwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChtLnRlc3QodCkpIHJldHVybiByICogcGFyc2VJbnQodCwgOCk7XG4gICAgICAgICAgICAgICAgaWYgKHcudGVzdCh0KSkgcmV0dXJuIHIgKiBwYXJzZUZsb2F0KHQpO1xuICAgICAgICAgICAgICAgIHRocm93IFAodCwgXCJudW1iZXJcIiwgITApO1xuICAgICAgICAgICAgICB9KGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgICBpZiAodCAmJiB4LnRlc3QoZSkpIHJldHVybiBlO1xuICAgICAgICAgICAgICB0aHJvdyBQKGUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHEodCwgZSkge1xuICAgICAgICAgICAgdmFyIHIsIGk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICFlIHx8ICdcIicgIT09IChyID0gRigpKSAmJiBcIidcIiAhPT0gciA/IHQucHVzaChbaSA9IEooSSgpKSwgaihcInRvXCIsICEwKSA/IEooSSgpKSA6IGldKSA6IHQucHVzaChVKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAoaihcIixcIiwgITApKTtcbiAgICAgICAgICAgIGooXCI7XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBKKHQsIGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJNQVhcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIk1heFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MzY4NzA5MTE7XG4gICAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUgJiYgXCItXCIgPT09IHQuY2hhckF0KDApKSB0aHJvdyBQKHQsIFwiaWRcIik7XG4gICAgICAgICAgICBpZiAoeS50ZXN0KHQpKSByZXR1cm4gcGFyc2VJbnQodCwgMTApO1xuICAgICAgICAgICAgaWYgKGcudGVzdCh0KSkgcmV0dXJuIHBhcnNlSW50KHQsIDE2KTtcbiAgICAgICAgICAgIGlmIChfLnRlc3QodCkpIHJldHVybiBwYXJzZUludCh0LCA4KTtcbiAgICAgICAgICAgIHRocm93IFAodCwgXCJpZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVigpIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IFMpIHRocm93IFAoXCJwYWNrYWdlXCIpO1xuICAgICAgICAgICAgaWYgKFMgPSBJKCksICF4LnRlc3QoUykpIHRocm93IFAoUywgXCJuYW1lXCIpO1xuICAgICAgICAgICAgRCA9IEQuZGVmaW5lKFMpLCBqKFwiO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSCgpIHtcbiAgICAgICAgICAgIHZhciB0LFxuICAgICAgICAgICAgICBlID0gRigpO1xuICAgICAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ3ZWFrXCI6XG4gICAgICAgICAgICAgICAgdCA9IEUgfHwgKEUgPSBbXSksIEkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgICAgICAgICAgIEkoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0ID0gTyB8fCAoTyA9IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUgPSBVKCksIGooXCI7XCIpLCB0LnB1c2goZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uICQoKSB7XG4gICAgICAgICAgICBpZiAoaihcIj1cIiksIFQgPSBVKCksICEoUiA9IFwicHJvdG8zXCIgPT09IFQpICYmIFwicHJvdG8yXCIgIT09IFQpIHRocm93IFAoVCwgXCJzeW50YXhcIik7XG4gICAgICAgICAgICBqKFwiO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gSyh0LCBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBHKHQsIGUpLCBqKFwiO1wiKSwgITA7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWIudGVzdChlID0gSSgpKSkgdGhyb3cgUChlLCBcInR5cGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHMoZSk7XG4gICAgICAgICAgICAgICAgICBYKHIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSyhyLCB0KSkgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGooXCI8XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IEkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYy5tYXBLZXlbZV0pIHRocm93IFAoZSwgXCJ0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBqKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBJKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgheC50ZXN0KHIpKSB0aHJvdyBQKHIsIFwidHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaihcIj5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gSSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWIudGVzdChpKSkgdGhyb3cgUChpLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGooXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyBhKE0oaSksIEooSSgpKSwgZSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFgobiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvcHRpb25cIiAhPT0gdCkgdGhyb3cgUCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHKG4sIHQpLCBqKFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0KG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgdC5hZGQobik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBZKHIsIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiLnRlc3QoZSA9IEkoKSkpIHRocm93IFAoZSwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBoKE0oZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBYKHIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25cIiA9PT0gdCA/IChHKHIsIHQpLCBqKFwiO1wiKSkgOiAoTih0KSwgWShyLCBcIm9wdGlvbmFsXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQuYWRkKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShyLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlbnNpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBxKHIuZXh0ZW5zaW9ucyB8fCAoci5leHRlbnNpb25zID0gW10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcShyLnJlc2VydmVkIHx8IChyLnJlc2VydmVkID0gW10pLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFSIHx8ICF4LnRlc3QodCkpIHRocm93IFAodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBOKHQpLCBZKHIsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCB0LmFkZChyKTtcbiAgICAgICAgICAgICAgICB9KHQsIGUpLCAhMDtcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghYi50ZXN0KGUgPSBJKCkpKSB0aHJvdyBQKGUsIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHUoZSk7XG4gICAgICAgICAgICAgICAgICBYKHIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIEcociwgdCksIGooXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBxKHIucmVzZXJ2ZWQgfHwgKHIucmVzZXJ2ZWQgPSBbXSksICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiLnRlc3QoZSkpIHRocm93IFAoZSwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBqKFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBKKEkoKSwgITApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWChpLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9wdGlvblwiICE9PSB0KSB0aHJvdyBQKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcoaSwgdCksIGooXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB0LmFkZChlLCByLCBpLmNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShyLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIHQuYWRkKHIpO1xuICAgICAgICAgICAgICAgIH0odCwgZSksICEwO1xuICAgICAgICAgICAgICBjYXNlIFwic2VydmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFiLnRlc3QoZSA9IEkoKSkpIHRocm93IFAoZSwgXCJzZXJ2aWNlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBsKGUpO1xuICAgICAgICAgICAgICAgICAgWChyLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUsociwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJycGNcIiAhPT0gdCkgdGhyb3cgUCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYi50ZXN0KGUgPSBJKCkpKSB0aHJvdyBQKGUsIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqKFwiKFwiKSwgaihcInN0cmVhbVwiLCAhMCkgJiYgKG4gPSAhMCksICF4LnRlc3QoZSA9IEkoKSkpIHRocm93IFAoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGUsIGooXCIpXCIpLCBqKFwicmV0dXJuc1wiKSwgaihcIihcIiksIGooXCJzdHJlYW1cIiwgITApICYmIChvID0gITApLCAheC50ZXN0KGUgPSBJKCkpKSB0aHJvdyBQKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGUsIGooXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBuZXcgZihhLCByLCBpLCBzLCBuLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFgoaCwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib3B0aW9uXCIgIT09IHQpIHRocm93IFAodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIEcoaCwgdCksIGooXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHQuYWRkKGgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0ociwgdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLCB0LmFkZChyKTtcbiAgICAgICAgICAgICAgICB9KHQsIGUpLCAhMDtcbiAgICAgICAgICAgICAgY2FzZSBcImV4dGVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCF4LnRlc3QoZSA9IEkoKSkpIHRocm93IFAoZSwgXCJyZWZlcmVuY2VcIik7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IGU7XG4gICAgICAgICAgICAgICAgICBYKG51bGwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgWSh0LCBlLCByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVIgfHwgIXgudGVzdChlKSkgdGhyb3cgUChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE4oZSksIFkodCwgXCJvcHRpb25hbFwiLCByKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSh0LCBlKSwgITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFgodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBCLmxpbmU7XG4gICAgICAgICAgICBpZiAodCAmJiAodC5jb21tZW50ID0gTCgpLCB0LmZpbGVuYW1lID0gQS5maWxlbmFtZSksIGooXCJ7XCIsICEwKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuOyBcIn1cIiAhPT0gKG4gPSBJKCkpOykgZShuKTtcbiAgICAgICAgICAgICAgaihcIjtcIiwgITApO1xuICAgICAgICAgICAgfSBlbHNlIHIgJiYgcigpLCBqKFwiO1wiKSwgdCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB0LmNvbW1lbnQgJiYgKHQuY29tbWVudCA9IEwoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBZKHQsIGUsIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0gSSgpO1xuICAgICAgICAgICAgaWYgKFwiZ3JvdXBcIiAhPT0gaSkge1xuICAgICAgICAgICAgICBpZiAoIXgudGVzdChpKSkgdGhyb3cgUChpLCBcInR5cGVcIik7XG4gICAgICAgICAgICAgIHZhciBuID0gSSgpO1xuICAgICAgICAgICAgICBpZiAoIWIudGVzdChuKSkgdGhyb3cgUChuLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgIG4gPSBNKG4pLCBqKFwiPVwiKTtcbiAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgbyhuLCBKKEkoKSksIGksIGUsIHIpO1xuICAgICAgICAgICAgICBYKGEsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwib3B0aW9uXCIgIT09IHQpIHRocm93IFAodCk7XG4gICAgICAgICAgICAgICAgRyhhLCB0KSwgaihcIjtcIik7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0dChhKTtcbiAgICAgICAgICAgICAgfSksIHQuYWRkKGEpLCBSIHx8ICFhLnJlcGVhdGVkIHx8IHZvaWQgMCA9PT0gYy5wYWNrZWRbaV0gJiYgdm9pZCAwICE9PSBjLmJhc2ljW2ldIHx8IGEuc2V0T3B0aW9uKFwicGFja2VkXCIsICExLCAhMCk7XG4gICAgICAgICAgICB9IGVsc2UgIWZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIHZhciByID0gSSgpO1xuICAgICAgICAgICAgICBpZiAoIWIudGVzdChyKSkgdGhyb3cgUChyLCBcIm5hbWVcIik7XG4gICAgICAgICAgICAgIHZhciBpID0gZC5sY0ZpcnN0KHIpO1xuICAgICAgICAgICAgICByID09PSBpICYmIChyID0gZC51Y0ZpcnN0KHIpKSwgaihcIj1cIik7XG4gICAgICAgICAgICAgIHZhciBuID0gSihJKCkpLFxuICAgICAgICAgICAgICAgIGEgPSBuZXcgcyhyKTtcbiAgICAgICAgICAgICAgYS5ncm91cCA9ICEwO1xuICAgICAgICAgICAgICB2YXIgaCA9IG5ldyBvKGksIG4sIHIsIGUpO1xuICAgICAgICAgICAgICBoLmZpbGVuYW1lID0gQS5maWxlbmFtZSwgWChhLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBHKGEsIHQpLCBqKFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIFkoYSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLCB0LmFkZChhKS5hZGQoaCk7XG4gICAgICAgICAgICB9KHQsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBHKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciByID0gaihcIihcIiwgITApO1xuICAgICAgICAgICAgaWYgKCF4LnRlc3QoZSA9IEkoKSkpIHRocm93IFAoZSwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgdmFyIGkgPSBlO1xuICAgICAgICAgICAgciAmJiAoaihcIilcIiksIGkgPSBcIihcIiArIGkgKyBcIilcIiwgZSA9IEYoKSwgay50ZXN0KGUpICYmIChpICs9IGUsIEkoKSkpLCBqKFwiPVwiKSwgVyh0LCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gVyh0LCBlKSB7XG4gICAgICAgICAgICBpZiAoaihcIntcIiwgITApKSBkbyB7XG4gICAgICAgICAgICAgIGlmICghYi50ZXN0KHogPSBJKCkpKSB0aHJvdyBQKHosIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgXCJ7XCIgPT09IEYoKSA/IFcodCwgZSArIFwiLlwiICsgeikgOiAoaihcIjpcIiksIFwie1wiID09PSBGKCkgPyBXKHQsIGUgKyBcIi5cIiArIHopIDogUSh0LCBlICsgXCIuXCIgKyB6LCBaKCEwKSkpO1xuICAgICAgICAgICAgfSB3aGlsZSAoIWooXCJ9XCIsICEwKSk7ZWxzZSBRKHQsIGUsIFooITApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gUSh0LCBlLCByKSB7XG4gICAgICAgICAgICB0LnNldE9wdGlvbiAmJiB0LnNldE9wdGlvbihlLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdHQodCkge1xuICAgICAgICAgICAgaWYgKGooXCJbXCIsICEwKSkge1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgRyh0LCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoaihcIixcIiwgITApKTtcbiAgICAgICAgICAgICAgaihcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IG51bGwgIT09ICh6ID0gSSgpKTspIHN3aXRjaCAoeikge1xuICAgICAgICAgICAgY2FzZSBcInBhY2thZ2VcIjpcbiAgICAgICAgICAgICAgaWYgKCFDKSB0aHJvdyBQKHopO1xuICAgICAgICAgICAgICBWKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImltcG9ydFwiOlxuICAgICAgICAgICAgICBpZiAoIUMpIHRocm93IFAoeik7XG4gICAgICAgICAgICAgIEgoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG4gICAgICAgICAgICAgIGlmICghQykgdGhyb3cgUCh6KTtcbiAgICAgICAgICAgICAgJCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgaWYgKCFDKSB0aHJvdyBQKHopO1xuICAgICAgICAgICAgICBHKEQsIHopLCBqKFwiO1wiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoSyhELCB6KSkge1xuICAgICAgICAgICAgICAgIEMgPSAhMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBQKHopO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gQS5maWxlbmFtZSA9IG51bGwsIHtcbiAgICAgICAgICAgIHBhY2thZ2U6IFMsXG4gICAgICAgICAgICBpbXBvcnRzOiBPLFxuICAgICAgICAgICAgd2Vha0ltcG9ydHM6IEUsXG4gICAgICAgICAgICBzeW50YXg6IFQsXG4gICAgICAgICAgICByb290OiBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBBLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaSA9IHIoOTQxKSwgbiA9IHIoNTcyKSwgcyA9IHIoMjQpLCBvID0gcigyMzgpLCBhID0gcig3MTgpLCBoID0gcig4MDMpLCB1ID0gcig0MjEpLCBsID0gcig2NzMpLCBmID0gcig0OTMpLCBjID0gcig0NzEpLCBkID0gcig5MTYpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDkxNTogdCA9PiB7XG4gICAgICAgIHZhciBlID0gdC5leHBvcnRzLFxuICAgICAgICAgIHIgPSBlLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIC9eKD86XFwvfFxcdys6KS8udGVzdCh0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGkgPSBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9ICh0ID0gdC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKS5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKSkuc3BsaXQoXCIvXCIpLFxuICAgICAgICAgICAgICBpID0gcih0KSxcbiAgICAgICAgICAgICAgbiA9IFwiXCI7XG4gICAgICAgICAgICBpICYmIChuID0gZS5zaGlmdCgpICsgXCIvXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBlLmxlbmd0aDspIFwiLi5cIiA9PT0gZVtzXSA/IHMgPiAwICYmIFwiLi5cIiAhPT0gZVtzIC0gMV0gPyBlLnNwbGljZSgtLXMsIDIpIDogaSA/IGUuc3BsaWNlKHMsIDEpIDogKytzIDogXCIuXCIgPT09IGVbc10gPyBlLnNwbGljZShzLCAxKSA6ICsrcztcbiAgICAgICAgICAgIHJldHVybiBuICsgZS5qb2luKFwiL1wiKTtcbiAgICAgICAgICB9O1xuICAgICAgICBlLnJlc29sdmUgPSBmdW5jdGlvbiAodCwgZSwgbikge1xuICAgICAgICAgIHJldHVybiBuIHx8IChlID0gaShlKSksIHIoZSkgPyBlIDogKG4gfHwgKHQgPSBpKHQpKSwgKHQgPSB0LnJlcGxhY2UoLyg/OlxcL3xeKVteL10rJC8sIFwiXCIpKS5sZW5ndGggPyBpKHQgKyBcIi9cIiArIGUpIDogZSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgMjY2OiB0ID0+IHtcbiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICB2YXIgaSA9IHIgfHwgODE5MixcbiAgICAgICAgICAgIG4gPSBpID4+PiAxLFxuICAgICAgICAgICAgcyA9IG51bGwsXG4gICAgICAgICAgICBvID0gaTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIGlmIChyIDwgMSB8fCByID4gbikgcmV0dXJuIHQocik7XG4gICAgICAgICAgICBvICsgciA+IGkgJiYgKHMgPSB0KGkpLCBvID0gMCk7XG4gICAgICAgICAgICB2YXIgYSA9IGUuY2FsbChzLCBvLCBvICs9IHIpO1xuICAgICAgICAgICAgcmV0dXJuIDcgJiBvICYmIChvID0gMSArICg3IHwgbykpLCBhO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNzk1OiAodCwgZSwgcikgPT4ge1xuICAgICAgICB0LmV4cG9ydHMgPSBhO1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSByKDkxNik7XG4gICAgICAgIGZ1bmN0aW9uIG8odCwgZSkge1xuICAgICAgICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHQucG9zICsgXCIgKyBcIiArIChlIHx8IDEpICsgXCIgPiBcIiArIHQubGVuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhKHQpIHtcbiAgICAgICAgICB0aGlzLmJ1ZiA9IHQsIHRoaXMucG9zID0gMCwgdGhpcy5sZW4gPSB0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCxcbiAgICAgICAgICB1ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgVWludDhBcnJheSA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIG5ldyBhKHQpO1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEFycmF5QnVmZmVyICYmIHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIG5ldyBhKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIG5ldyBhKHQpO1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBsKCkge1xuICAgICAgICAgIHZhciB0ID0gbmV3IGkoMCwgMCksXG4gICAgICAgICAgICBlID0gMDtcbiAgICAgICAgICBpZiAoISh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkpIHtcbiAgICAgICAgICAgIGZvciAoOyBlIDwgMzsgKytlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbikgdGhyb3cgbyh0aGlzKTtcbiAgICAgICAgICAgICAgaWYgKHQubG8gPSAodC5sbyB8ICgxMjcgJiB0aGlzLmJ1Zlt0aGlzLnBvc10pIDw8IDcgKiBlKSA+Pj4gMCwgdGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQubG8gPSAodC5sbyB8ICgxMjcgJiB0aGlzLmJ1Zlt0aGlzLnBvcysrXSkgPDwgNyAqIGUpID4+PiAwLCB0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgZSA8IDQ7ICsrZSkgaWYgKHQubG8gPSAodC5sbyB8ICgxMjcgJiB0aGlzLmJ1Zlt0aGlzLnBvc10pIDw8IDcgKiBlKSA+Pj4gMCwgdGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh0LmxvID0gKHQubG8gfCAoMTI3ICYgdGhpcy5idWZbdGhpcy5wb3NdKSA8PCAyOCkgPj4+IDAsIHQuaGkgPSAodC5oaSB8ICgxMjcgJiB0aGlzLmJ1Zlt0aGlzLnBvc10pID4+IDQpID4+PiAwLCB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKGUgPSAwLCB0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkge1xuICAgICAgICAgICAgZm9yICg7IGUgPCA1OyArK2UpIGlmICh0LmhpID0gKHQuaGkgfCAoMTI3ICYgdGhpcy5idWZbdGhpcy5wb3NdKSA8PCA3ICogZSArIDMpID4+PiAwLCB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHQ7XG4gICAgICAgICAgfSBlbHNlIGZvciAoOyBlIDwgNTsgKytlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pIHRocm93IG8odGhpcyk7XG4gICAgICAgICAgICBpZiAodC5oaSA9ICh0LmhpIHwgKDEyNyAmIHRoaXMuYnVmW3RoaXMucG9zXSkgPDwgNyAqIGUgKyAzKSA+Pj4gMCwgdGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGYodCwgZSkge1xuICAgICAgICAgIHJldHVybiAodFtlIC0gNF0gfCB0W2UgLSAzXSA8PCA4IHwgdFtlIC0gMl0gPDwgMTYgfCB0W2UgLSAxXSA8PCAyNCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pIHRocm93IG8odGhpcywgOCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBpKGYodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCBmKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgYS5jcmVhdGUgPSBzLkJ1ZmZlciA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIChhLmNyZWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gcy5CdWZmZXIuaXNCdWZmZXIodCkgPyBuZXcgKHZvaWQgMCkodCkgOiB1KHQpO1xuICAgICAgICAgIH0pKHQpO1xuICAgICAgICB9IDogdSwgYS5wcm90b3R5cGUuX3NsaWNlID0gcy5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgcy5BcnJheS5wcm90b3R5cGUuc2xpY2UsIGEucHJvdG90eXBlLnVpbnQzMiA9IChoID0gNDI5NDk2NzI5NSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChoID0gKDEyNyAmIHRoaXMuYnVmW3RoaXMucG9zXSkgPj4+IDAsIHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gaDtcbiAgICAgICAgICBpZiAoaCA9IChoIHwgKDEyNyAmIHRoaXMuYnVmW3RoaXMucG9zXSkgPDwgNykgPj4+IDAsIHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gaDtcbiAgICAgICAgICBpZiAoaCA9IChoIHwgKDEyNyAmIHRoaXMuYnVmW3RoaXMucG9zXSkgPDwgMTQpID4+PiAwLCB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIGg7XG4gICAgICAgICAgaWYgKGggPSAoaCB8ICgxMjcgJiB0aGlzLmJ1Zlt0aGlzLnBvc10pIDw8IDIxKSA+Pj4gMCwgdGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiBoO1xuICAgICAgICAgIGlmIChoID0gKGggfCAoMTUgJiB0aGlzLmJ1Zlt0aGlzLnBvc10pIDw8IDI4KSA+Pj4gMCwgdGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiBoO1xuICAgICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikgdGhyb3cgdGhpcy5wb3MgPSB0aGlzLmxlbiwgbyh0aGlzLCAxMCk7XG4gICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgIH0pLCBhLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMCB8IHRoaXMudWludDMyKCk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMudWludDMyKCk7XG4gICAgICAgICAgcmV0dXJuIHQgPj4+IDEgXiAtKDEgJiB0KTtcbiAgICAgICAgfSwgYS5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMCAhPT0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgfSwgYS5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pIHRocm93IG8odGhpcywgNCk7XG4gICAgICAgICAgcmV0dXJuIGYodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xuICAgICAgICB9LCBhLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pIHRocm93IG8odGhpcywgNCk7XG4gICAgICAgICAgcmV0dXJuIDAgfCBmKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbiAgICAgICAgfSwgYS5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKSB0aHJvdyBvKHRoaXMsIDQpO1xuICAgICAgICAgIHZhciB0ID0gcy5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA0LCB0O1xuICAgICAgICB9LCBhLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKSB0aHJvdyBvKHRoaXMsIDQpO1xuICAgICAgICAgIHZhciB0ID0gcy5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgICAgfSwgYS5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICAgICAgZSA9IHRoaXMucG9zLFxuICAgICAgICAgICAgciA9IHRoaXMucG9zICsgdDtcbiAgICAgICAgICBpZiAociA+IHRoaXMubGVuKSB0aHJvdyBvKHRoaXMsIHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvcyArPSB0LCBBcnJheS5pc0FycmF5KHRoaXMuYnVmKSA/IHRoaXMuYnVmLnNsaWNlKGUsIHIpIDogZSA9PT0gciA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKSA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIGUsIHIpO1xuICAgICAgICB9LCBhLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmJ5dGVzKCk7XG4gICAgICAgICAgcmV0dXJuIG4ucmVhZCh0LCAwLCB0Lmxlbmd0aCk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgKyB0ID4gdGhpcy5sZW4pIHRocm93IG8odGhpcywgdCk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0O1xuICAgICAgICAgIH0gZWxzZSBkbyB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pIHRocm93IG8odGhpcyk7XG4gICAgICAgICAgfSB3aGlsZSAoMTI4ICYgdGhpcy5idWZbdGhpcy5wb3MrK10pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCBhLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZm9yICg7IDQgIT0gKHQgPSA3ICYgdGhpcy51aW50MzIoKSk7KSB0aGlzLnNraXBUeXBlKHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB0ICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgYS5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkgPSByKDIxOCksIG4gPSByKDE4Nyk7XG4gICAgICAgICAgdmFyIHQgPSBzLkxvbmcgPyBcInRvTG9uZ1wiIDogXCJ0b051bWJlclwiO1xuICAgICAgICAgIHMubWVyZ2UoYS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGludDY0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsLmNhbGwodGhpcylbdF0oITEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbC5jYWxsKHRoaXMpW3RdKCEwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGwuY2FsbCh0aGlzKS56ekRlY29kZSgpW3RdKCExKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjLmNhbGwodGhpcylbdF0oITApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjLmNhbGwodGhpcylbdF0oITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDU3MjogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdmFyIGkgPSByKDUzNSkuZGVmYXVsdDtcbiAgICAgICAgdC5leHBvcnRzID0gYztcbiAgICAgICAgdmFyIG4gPSByKDYyNSk7XG4gICAgICAgICgoYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBjKS5jbGFzc05hbWUgPSBcIlJvb3RcIjtcbiAgICAgICAgdmFyIHMsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGggPSByKDIzOCksXG4gICAgICAgICAgdSA9IHIoNDIxKSxcbiAgICAgICAgICBsID0gcig4MDMpLFxuICAgICAgICAgIGYgPSByKDkxNik7XG4gICAgICAgIGZ1bmN0aW9uIGModCkge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBcIlwiLCB0KSwgdGhpcy5kZWZlcnJlZCA9IFtdLCB0aGlzLmZpbGVzID0gW10sIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkKCkge31cbiAgICAgICAgYy5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gSlNPTi5wYXJzZSh0KSA6IHQsIGUgfHwgKGUgPSBuZXcgYygpKSwgdC5vcHRpb25zICYmIGUuc2V0T3B0aW9ucyh0Lm9wdGlvbnMpLCBlLmFkZEpTT04odC5uZXN0ZWQpO1xuICAgICAgICB9LCBjLnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IGYucGF0aC5yZXNvbHZlLCBjLnByb3RvdHlwZS5wYXJzZUZyb21QYlN0cmluZyA9IGZ1bmN0aW9uIHQoZSwgciwgbikge1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgciAmJiAobiA9IHIsIHIgPSB2b2lkIDApO1xuICAgICAgICAgIHZhciBzID0gdGhpcztcbiAgICAgICAgICBpZiAoIW4pIHJldHVybiBmLmFzUHJvbWlzZSh0LCBzLCBlLCByKTtcbiAgICAgICAgICB2YXIgaCA9IG51bGw7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIGggPSBKU09OLnBhcnNlKGUpO2Vsc2Uge1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IGkoZSkpIHJldHVybiB2b2lkIGNvbnNvbGUubG9nKFwicGLmoLzlvI/ovazljJblpLHotKVcIik7XG4gICAgICAgICAgICBoID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdSh0LCBlKSB7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICB2YXIgciA9IG47XG4gICAgICAgICAgICAgIG4gPSBudWxsLCByKHQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBsKHQsIGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChmLmlzU3RyaW5nKGUpICYmIFwie1wiID09PSBlLmNoYXJBdCgwKSAmJiAoZSA9IEpTT04ucGFyc2UoZSkpLCBmLmlzU3RyaW5nKGUpKSB7XG4gICAgICAgICAgICAgICAgby5maWxlbmFtZSA9IHQ7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICBuID0gbyhlLCBzLCByKSxcbiAgICAgICAgICAgICAgICAgIGEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChuLmltcG9ydHMpIGZvciAoOyBhIDwgbi5pbXBvcnRzLmxlbmd0aDsgKythKSBjKGkgPSBuLmltcG9ydHNbYV0pO1xuICAgICAgICAgICAgICAgIGlmIChuLndlYWtJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgbi53ZWFrSW1wb3J0cy5sZW5ndGg7ICsrYSkgaSA9IG4ud2Vha0ltcG9ydHNbYV07XG4gICAgICAgICAgICAgICAgICBjKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHMuc2V0T3B0aW9ucyhlLm9wdGlvbnMpLmFkZEpTT04oZS5uZXN0ZWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICB1KHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdShudWxsLCBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYyh0KSB7XG4gICAgICAgICAgICBzLm5hbWVzLmluZGV4T2YodCkgPiAtMSB8fCAocy5uYW1lcy5wdXNoKHQpLCB0IGluIGEgJiYgbCh0LCBhW3RdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGwoaC5uYW1lLCBoLnBiSnNvblN0cik7XG4gICAgICAgIH0sIGMucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiB0KGUsIHIsIGkpIHtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIgJiYgKGkgPSByLCByID0gdm9pZCAwKTtcbiAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFpKSByZXR1cm4gZi5hc1Byb21pc2UodCwgbiwgZSwgcik7XG4gICAgICAgICAgdmFyIHMgPSBpID09PSBkO1xuICAgICAgICAgIGZ1bmN0aW9uIGgodCwgZSkge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBpO1xuICAgICAgICAgICAgICBpZiAoaSA9IG51bGwsIHMpIHRocm93IHQ7XG4gICAgICAgICAgICAgIHIodCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHUodCwgZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGYuaXNTdHJpbmcoZSkgJiYgXCJ7XCIgPT09IGUuY2hhckF0KDApICYmIChlID0gSlNPTi5wYXJzZShlKSksIGYuaXNTdHJpbmcoZSkpIHtcbiAgICAgICAgICAgICAgICBvLmZpbGVuYW1lID0gdDtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgIGEgPSBvKGUsIG4sIHIpLFxuICAgICAgICAgICAgICAgICAgdSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW1wb3J0cykgZm9yICg7IHUgPCBhLmltcG9ydHMubGVuZ3RoOyArK3UpIChpID0gbi5yZXNvbHZlUGF0aCh0LCBhLmltcG9ydHNbdV0pKSAmJiBsKGkpO1xuICAgICAgICAgICAgICAgIGlmIChhLndlYWtJbXBvcnRzKSBmb3IgKHUgPSAwOyB1IDwgYS53ZWFrSW1wb3J0cy5sZW5ndGg7ICsrdSkgKGkgPSBuLnJlc29sdmVQYXRoKHQsIGEud2Vha0ltcG9ydHNbdV0pKSAmJiBsKGksICEwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIG4uc2V0T3B0aW9ucyhlLm9wdGlvbnMpLmFkZEpTT04oZS5uZXN0ZWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICBoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyB8fCBjIHx8IGgobnVsbCwgbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGwodCwgZSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0Lmxhc3RJbmRleE9mKFwiZ29vZ2xlL3Byb3RvYnVmL1wiKTtcbiAgICAgICAgICAgIGlmIChyID4gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSB0LnN1YnN0cmluZyhyKTtcbiAgICAgICAgICAgICAgbyBpbiBhICYmICh0ID0gbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShuLmZpbGVzLmluZGV4T2YodCkgPiAtMSkpIGlmIChuLmZpbGVzLnB1c2godCksIHQgaW4gYSkgcyA/IHUodCwgYVt0XSkgOiAoKytjLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLS1jLCB1KHQsIGFbdF0pO1xuICAgICAgICAgICAgfSkpO2Vsc2UgaWYgKHMpIHtcbiAgICAgICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbCA9IGYuZnMucmVhZEZpbGVTeW5jKHQpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIChlIHx8IGgodCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHUodCwgbCk7XG4gICAgICAgICAgICB9IGVsc2UgKytjLCBmLmZldGNoKHQsIGZ1bmN0aW9uIChyLCBzKSB7XG4gICAgICAgICAgICAgIC0tYywgaSAmJiAociA/IGUgPyBjIHx8IGgobnVsbCwgbikgOiBoKHIpIDogdSh0LCBzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgIGYuaXNTdHJpbmcoZSkgJiYgKGUgPSBbZV0pO1xuICAgICAgICAgIGZvciAodmFyIHAsIHkgPSAwOyB5IDwgZS5sZW5ndGg7ICsreSkgKHAgPSBuLnJlc29sdmVQYXRoKFwiXCIsIGVbeV0pKSAmJiBsKHApO1xuICAgICAgICAgIGlmIChzKSByZXR1cm4gbjtcbiAgICAgICAgICBjIHx8IGgobnVsbCwgbik7XG4gICAgICAgIH0sIGMucHJvdG90eXBlLmxvYWRTeW5jID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBpZiAoIWYuaXNOb2RlKSB0aHJvdyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZCh0LCBlLCBkKTtcbiAgICAgICAgfSwgYy5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWZlcnJlZC5sZW5ndGgpIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIGV4dGVuc2lvbnM6IFwiICsgdGhpcy5kZWZlcnJlZC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIidleHRlbmQgXCIgKyB0LmV4dGVuZCArIFwiJyBpbiBcIiArIHQucGFyZW50LmZ1bGxOYW1lO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgcmV0dXJuIG4ucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAgPSAvXltBLVpdLztcbiAgICAgICAgZnVuY3Rpb24geSh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLnBhcmVudC5sb29rdXAoZS5leHRlbmQpO1xuICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG5ldyBoKGUuZnVsbE5hbWUsIGUuaWQsIGUudHlwZSwgZS5ydWxlLCB2b2lkIDAsIGUub3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gaS5kZWNsYXJpbmdGaWVsZCA9IGUsIGUuZXh0ZW5zaW9uRmllbGQgPSBpLCByLmFkZChpKSwgITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICBjLnByb3RvdHlwZS5faGFuZGxlQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGgpIHZvaWQgMCA9PT0gdC5leHRlbmQgfHwgdC5leHRlbnNpb25GaWVsZCB8fCB5KDAsIHQpIHx8IHRoaXMuZGVmZXJyZWQucHVzaCh0KTtlbHNlIGlmICh0IGluc3RhbmNlb2YgdSkgcC50ZXN0KHQubmFtZSkgJiYgKHQucGFyZW50W3QubmFtZV0gPSB0LnZhbHVlcyk7ZWxzZSBpZiAoISh0IGluc3RhbmNlb2YgbCkpIHtcbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgcykgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmRlZmVycmVkLmxlbmd0aDspIHkoMCwgdGhpcy5kZWZlcnJlZFtlXSkgPyB0aGlzLmRlZmVycmVkLnNwbGljZShlLCAxKSA6ICsrZTtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsrcikgdGhpcy5faGFuZGxlQWRkKHQuX25lc3RlZEFycmF5W3JdKTtcbiAgICAgICAgICAgIHAudGVzdCh0Lm5hbWUpICYmICh0LnBhcmVudFt0Lm5hbWVdID0gdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjLnByb3RvdHlwZS5faGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGgpIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHQuZXh0ZW5kKSBpZiAodC5leHRlbnNpb25GaWVsZCkgdC5leHRlbnNpb25GaWVsZC5wYXJlbnQucmVtb3ZlKHQuZXh0ZW5zaW9uRmllbGQpLCB0LmV4dGVuc2lvbkZpZWxkID0gbnVsbDtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmRlZmVycmVkLmluZGV4T2YodCk7XG4gICAgICAgICAgICAgIGUgPiAtMSAmJiB0aGlzLmRlZmVycmVkLnNwbGljZShlLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiB1KSBwLnRlc3QodC5uYW1lKSAmJiBkZWxldGUgdC5wYXJlbnRbdC5uYW1lXTtlbHNlIGlmICh0IGluc3RhbmNlb2Ygbikge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytyKSB0aGlzLl9oYW5kbGVSZW1vdmUodC5fbmVzdGVkQXJyYXlbcl0pO1xuICAgICAgICAgICAgcC50ZXN0KHQubmFtZSkgJiYgZGVsZXRlIHQucGFyZW50W3QubmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcyA9IHIoMjQpLCBvID0gcigxMjEpLCBhID0gcig0NTMpLCBoID0gcigyMzgpLCB1ID0gcig0MjEpLCBsID0gcig4MDMpLCBmID0gcig5MTYpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDU4NzogdCA9PiB7XG4gICAgICAgIHQuZXhwb3J0cyA9IHt9O1xuICAgICAgfSxcbiAgICAgIDE1MzogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdC5leHBvcnRzID0gbjtcbiAgICAgICAgdmFyIGkgPSByKDkxNik7XG4gICAgICAgIGZ1bmN0aW9uIG4odCwgZSwgcikge1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIGkuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyksIHRoaXMucnBjSW1wbCA9IHQsIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4oZSksIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHIpO1xuICAgICAgICB9XG4gICAgICAgIChuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoaS5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBuLCBuLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gdChlLCByLCBuLCBzLCBvKSB7XG4gICAgICAgICAgaWYgKCFzKSB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICBpZiAoIW8pIHJldHVybiBpLmFzUHJvbWlzZSh0LCBhLCBlLCByLCBuLCBzKTtcbiAgICAgICAgICBpZiAoYS5ycGNJbXBsKSB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGEucnBjSW1wbChlLCByW2EucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShzKS5maW5pc2goKSwgZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgICAgICAgICAgaWYgKHQpIHJldHVybiBhLmVtaXQoXCJlcnJvclwiLCB0LCBlKSwgbyh0KTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyIGluc3RhbmNlb2YgbikpIHRyeSB7XG4gICAgICAgICAgICAgICAgICByID0gblthLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhLmVtaXQoXCJlcnJvclwiLCB0LCBlKSwgbyh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZW1pdChcImRhdGFcIiwgciwgZSksIG8obnVsbCwgcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYS5lbmQoITApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuZW1pdChcImVycm9yXCIsIHQsIGUpLCB2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBvKHQpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbyhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LCBuLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJwY0ltcGwgJiYgKHQgfHwgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpLCB0aGlzLnJwY0ltcGwgPSBudWxsLCB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCkpLCB0aGlzO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDY3MzogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdC5leHBvcnRzID0gYTtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICBzLFxuICAgICAgICAgIG8gPSByKDYyNSk7XG4gICAgICAgIGZ1bmN0aW9uIGEodCwgZSkge1xuICAgICAgICAgIG8uY2FsbCh0aGlzLCB0LCBlKSwgdGhpcy5tZXRob2RzID0ge30sIHRoaXMuX21ldGhvZHNBcnJheSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuX21ldGhvZHNBcnJheSA9IG51bGwsIHQ7XG4gICAgICAgIH1cbiAgICAgICAgKChhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoby5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGEpLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiLCBhLmZyb21KU09OID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IG5ldyBhKHQsIGUub3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGUubWV0aG9kcykgZm9yICh2YXIgbiA9IE9iamVjdC5rZXlzKGUubWV0aG9kcyksIHMgPSAwOyBzIDwgbi5sZW5ndGg7ICsrcykgci5hZGQoaS5mcm9tSlNPTihuW3NdLCBlLm1ldGhvZHNbbltzXV0pKTtcbiAgICAgICAgICByZXR1cm4gZS5uZXN0ZWQgJiYgci5hZGRKU09OKGUubmVzdGVkKSwgci5jb21tZW50ID0gZS5jb21tZW50LCByO1xuICAgICAgICB9LCBhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gby5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgdCksXG4gICAgICAgICAgICByID0gISF0ICYmIEJvb2xlYW4odC5rZWVwQ29tbWVudHMpO1xuICAgICAgICAgIHJldHVybiBuLnRvT2JqZWN0KFtcIm9wdGlvbnNcIiwgZSAmJiBlLm9wdGlvbnMgfHwgdm9pZCAwLCBcIm1ldGhvZHNcIiwgby5hcnJheVRvSlNPTih0aGlzLm1ldGhvZHNBcnJheSwgdCkgfHwge30sIFwibmVzdGVkXCIsIGUgJiYgZS5uZXN0ZWQgfHwgdm9pZCAwLCBcImNvbW1lbnRcIiwgciA/IHRoaXMuY29tbWVudCA6IHZvaWQgMF0pO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsIFwibWV0aG9kc0FycmF5XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXRob2RzQXJyYXkgfHwgKHRoaXMuX21ldGhvZHNBcnJheSA9IG4udG9BcnJheSh0aGlzLm1ldGhvZHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ldGhvZHNbdF0gfHwgby5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgdCk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMubWV0aG9kc0FycmF5LCBlID0gMDsgZSA8IHQubGVuZ3RoOyArK2UpIHRbZV0ucmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybiBvLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0KHQubmFtZSkpIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBpID8gKHRoaXMubWV0aG9kc1t0Lm5hbWVdID0gdCwgdC5wYXJlbnQgPSB0aGlzLCBoKHRoaXMpKSA6IG8ucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICB9LCBhLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgaSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0aG9kc1t0Lm5hbWVdICE9PSB0KSB0aHJvdyBFcnJvcih0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMubWV0aG9kc1t0Lm5hbWVdLCB0LnBhcmVudCA9IG51bGwsIGgodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfSwgYS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpLCBvID0gbmV3IHMuU2VydmljZSh0LCBlLCByKSwgYSA9IDA7IGEgPCB0aGlzLm1ldGhvZHNBcnJheS5sZW5ndGg7ICsrYSkge1xuICAgICAgICAgICAgdmFyIGggPSBuLmxjRmlyc3QoKGkgPSB0aGlzLl9tZXRob2RzQXJyYXlbYV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcbiAgICAgICAgICAgIG9baF0gPSBuLmNvZGVnZW4oW1wiclwiLCBcImNcIl0sIG4uaXNSZXNlcnZlZChoKSA/IGggKyBcIl9cIiA6IGgpKFwicmV0dXJuIHRoaXMucnBjQ2FsbChtLHEscyxyLGMpXCIpKHtcbiAgICAgICAgICAgICAgbTogaSxcbiAgICAgICAgICAgICAgcTogaS5yZXNvbHZlZFJlcXVlc3RUeXBlLmN0b3IsXG4gICAgICAgICAgICAgIHM6IGkucmVzb2x2ZWRSZXNwb25zZVR5cGUuY3RvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9LCBhLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaSA9IHIoNDkzKSwgbiA9IHIoOTE2KSwgcyA9IHIoMTUzKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICA5NDE6IHQgPT4ge1xuICAgICAgICB0LmV4cG9ydHMgPSBmO1xuICAgICAgICB2YXIgZSA9IC9bXFxze309OzpbXFxdLCdcIigpPD5dL2csXG4gICAgICAgICAgciA9IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXG4gICAgICAgICAgaSA9IC8oPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZyxcbiAgICAgICAgICBuID0gL14gKlsqL10rICovLFxuICAgICAgICAgIHMgPSAvXlxccypcXCo/XFwvKi8sXG4gICAgICAgICAgbyA9IC9cXG4vZyxcbiAgICAgICAgICBhID0gL1xccy8sXG4gICAgICAgICAgaCA9IC9cXFxcKC4/KS9nLFxuICAgICAgICAgIHUgPSB7XG4gICAgICAgICAgICAwOiBcIlxcMFwiLFxuICAgICAgICAgICAgcjogXCJcXHJcIixcbiAgICAgICAgICAgIG46IFwiXFxuXCIsXG4gICAgICAgICAgICB0OiBcIlxcdFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbCh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQucmVwbGFjZShoLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdVtlXSB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGYodCwgaCkge1xuICAgICAgICAgIHQgPSB0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIHUgPSAwLFxuICAgICAgICAgICAgZiA9IHQubGVuZ3RoLFxuICAgICAgICAgICAgYyA9IDEsXG4gICAgICAgICAgICBkID0gbnVsbCxcbiAgICAgICAgICAgIHAgPSBudWxsLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICB2ID0gITEsXG4gICAgICAgICAgICBnID0gW10sXG4gICAgICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgICBmdW5jdGlvbiBfKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcihcImlsbGVnYWwgXCIgKyB0ICsgXCIgKGxpbmUgXCIgKyBjICsgXCIpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB3KGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmNoYXJBdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gYihlLCByKSB7XG4gICAgICAgICAgICBkID0gdC5jaGFyQXQoZSsrKSwgeSA9IGMsIHYgPSAhMTtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICBhID0gZSAtIChoID8gMiA6IDMpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAoLS1hIDwgMCB8fCBcIlxcblwiID09PSAoaSA9IHQuY2hhckF0KGEpKSkge1xuICAgICAgICAgICAgICAgIHYgPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoXCIgXCIgPT09IGkgfHwgXCJcXHRcIiA9PT0gaSk7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gdC5zdWJzdHJpbmcoZSwgcikuc3BsaXQobyksIGwgPSAwOyBsIDwgdS5sZW5ndGg7ICsrbCkgdVtsXSA9IHVbbF0ucmVwbGFjZShoID8gcyA6IG4sIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIHAgPSB1LmpvaW4oXCJcXG5cIikudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB4KGUpIHtcbiAgICAgICAgICAgIHZhciByID0gayhlKSxcbiAgICAgICAgICAgICAgaSA9IHQuc3Vic3RyaW5nKGUsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIC9eXFxzKlxcL3sxLDJ9Ly50ZXN0KGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBrKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSB0OyBlIDwgZiAmJiBcIlxcblwiICE9PSB3KGUpOykgZSsrO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIEEoKSB7XG4gICAgICAgICAgICBpZiAoZy5sZW5ndGggPiAwKSByZXR1cm4gZy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKG0pIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gXCInXCIgPT09IG0gPyBpIDogcjtcbiAgICAgICAgICAgICAgZS5sYXN0SW5kZXggPSB1IC0gMTtcbiAgICAgICAgICAgICAgdmFyIG4gPSBlLmV4ZWModCk7XG4gICAgICAgICAgICAgIGlmICghbikgdGhyb3cgXyhcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHUgPSBlLmxhc3RJbmRleCwgUyhtKSwgbSA9IG51bGwsIGwoblsxXSk7XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICB2YXIgbiwgcywgbywgZCwgcDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaWYgKHUgPT09IGYpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICBmb3IgKG4gPSAhMTsgYS50ZXN0KG8gPSB3KHUpKTspIGlmIChcIlxcblwiID09PSBvICYmICsrYywgKyt1ID09PSBmKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKFwiL1wiID09PSB3KHUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrdSA9PT0gZikgdGhyb3cgXyhcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgaWYgKFwiL1wiID09PSB3KHUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCA9IHUsIHAgPSAhMSwgeCh1KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHAgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHUgPSBrKHUpKSA9PT0gZikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB1Kys7XG4gICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoeCh1KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1ID0gTWF0aC5taW4oZiwgayh1KSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwICYmIGIoZCwgdSksIGMrKywgbiA9ICEwO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gXCIvXCIgPT09IHcoZCA9IHUgKyAxKTsgXCJcXG5cIiAhPT0gdygrK3UpOykgaWYgKHUgPT09IGYpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICArK3UsIHAgJiYgYihkLCB1IC0gMSksICsrYywgbiA9ICEwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXCIqXCIgIT09IChvID0gdyh1KSkpIHJldHVybiBcIi9cIjtcbiAgICAgICAgICAgICAgICAgIGQgPSB1ICsgMSwgcCA9IGggfHwgXCIqXCIgPT09IHcoZCk7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIlxcblwiID09PSBvICYmICsrYywgKyt1ID09PSBmKSB0aHJvdyBfKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IG8sIG8gPSB3KHUpO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoXCIqXCIgIT09IHMgfHwgXCIvXCIgIT09IG8pO1xuICAgICAgICAgICAgICAgICAgKyt1LCBwICYmIGIoZCwgdSAtIDIpLCBuID0gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChuKTtcbiAgICAgICAgICAgIHZhciB5ID0gdTtcbiAgICAgICAgICAgIGlmIChlLmxhc3RJbmRleCA9IDAsICFlLnRlc3Qodyh5KyspKSkgZm9yICg7IHkgPCBmICYmICFlLnRlc3Qodyh5KSk7KSArK3k7XG4gICAgICAgICAgICB2YXIgdiA9IHQuc3Vic3RyaW5nKHUsIHUgPSB5KTtcbiAgICAgICAgICAgIHJldHVybiAnXCInICE9PSB2ICYmIFwiJ1wiICE9PSB2IHx8IChtID0gdiksIHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIFModCkge1xuICAgICAgICAgICAgZy5wdXNoKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBPKCkge1xuICAgICAgICAgICAgaWYgKCFnLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdCA9IEEoKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICBTKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgbmV4dDogQSxcbiAgICAgICAgICAgIHBlZWs6IE8sXG4gICAgICAgICAgICBwdXNoOiBTLFxuICAgICAgICAgICAgc2tpcDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBPKCk7XG4gICAgICAgICAgICAgIGlmIChyID09PSB0KSByZXR1cm4gQSgpLCAhMDtcbiAgICAgICAgICAgICAgaWYgKCFlKSB0aHJvdyBfKFwidG9rZW4gJ1wiICsgciArIFwiJywgJ1wiICsgdCArIFwiJyBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNtbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHZhciBlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCA/IHkgPT09IGMgLSAxICYmIChoIHx8IFwiKlwiID09PSBkIHx8IHYpICYmIChlID0gcCkgOiAoeSA8IHQgJiYgTygpLCB5ICE9PSB0IHx8IHYgfHwgIWggJiYgXCIvXCIgIT09IGQgfHwgKGUgPSBwKSksIGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgXCJsaW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmLnVuZXNjYXBlID0gbDtcbiAgICAgIH0sXG4gICAgICAyNDogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdC5leHBvcnRzID0gdjtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICBzLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgYSxcbiAgICAgICAgICBoLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIHkgPSByKDYyNSk7XG4gICAgICAgIGZ1bmN0aW9uIHYodCwgZSkge1xuICAgICAgICAgIHkuY2FsbCh0aGlzLCB0LCBlKSwgdGhpcy5maWVsZHMgPSB7fSwgdGhpcy5vbmVvZnMgPSB2b2lkIDAsIHRoaXMuZXh0ZW5zaW9ucyA9IHZvaWQgMCwgdGhpcy5yZXNlcnZlZCA9IHZvaWQgMCwgdGhpcy5ncm91cCA9IHZvaWQgMCwgdGhpcy5fZmllbGRzQnlJZCA9IG51bGwsIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbCwgdGhpcy5fb25lb2ZzQXJyYXkgPSBudWxsLCB0aGlzLl9jdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5fZmllbGRzQnlJZCA9IHQuX2ZpZWxkc0FycmF5ID0gdC5fb25lb2ZzQXJyYXkgPSBudWxsLCBkZWxldGUgdC5lbmNvZGUsIGRlbGV0ZSB0LmRlY29kZSwgZGVsZXRlIHQudmVyaWZ5LCB0O1xuICAgICAgICB9XG4gICAgICAgICgodi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHkucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSB2KS5jbGFzc05hbWUgPSBcIlR5cGVcIiwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModi5wcm90b3R5cGUsIHtcbiAgICAgICAgICBmaWVsZHNCeUlkOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQpIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGUgPSAwOyBlIDwgdC5sZW5ndGg7ICsrZSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5maWVsZHNbdFtlXV0sXG4gICAgICAgICAgICAgICAgICBpID0gci5pZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZFtpXSkgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkW2ldID0gcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpZWxkc0FycmF5OiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0FycmF5IHx8ICh0aGlzLl9maWVsZHNBcnJheSA9IGgudG9BcnJheSh0aGlzLmZpZWxkcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25lb2ZzQXJyYXk6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lb2ZzQXJyYXkgfHwgKHRoaXMuX29uZW9mc0FycmF5ID0gaC50b0FycmF5KHRoaXMub25lb2ZzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdG9yOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0b3IgfHwgKHRoaXMuY3RvciA9IHYuZ2VuZXJhdGVDb25zdHJ1Y3Rvcih0aGlzKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB2YXIgZSA9IHQucHJvdG90eXBlO1xuICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgcyB8fCAoKHQucHJvdG90eXBlID0gbmV3IHMoKSkuY29uc3RydWN0b3IgPSB0LCBoLm1lcmdlKHQucHJvdG90eXBlLCBlKSksIHQuJHR5cGUgPSB0LnByb3RvdHlwZS4kdHlwZSA9IHRoaXMsIGgubWVyZ2UodCwgcywgITApLCBoLm1lcmdlKHQucHJvdG90eXBlLCBzLCAhMCksIHRoaXMuX2N0b3IgPSB0O1xuICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK3IpIHRoaXMuX2ZpZWxkc0FycmF5W3JdLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuX29uZW9mc0FycmF5W3JdLnJlc29sdmUoKS5uYW1lLFxuICAgICAgICAgICAgICAgICAgbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSB7fSwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSBlW3Rbcl1dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0LmluZGV4T2YocikgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlW3JdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKytpKSB0W2ldICE9PSByICYmIGRlbGV0ZSB0aGlzW3RbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gT2JqZWN0LmtleXModGhpcyksIHIgPSB0Lmxlbmd0aCAtIDE7IHIgPiAtMTsgLS1yKSBpZiAoMSA9PT0gZVt0W3JdXSAmJiB2b2lkIDAgIT09IHRoaXNbdFtyXV0gJiYgbnVsbCAhPT0gdGhpc1t0W3JdXSkgcmV0dXJuIHRbcl07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSh0aGlzLl9vbmVvZnNBcnJheVtyXS5vbmVvZik7XG4gICAgICAgICAgICAgICAgaVtuXSA9IHtcbiAgICAgICAgICAgICAgICAgIGdldDogby5nZXR0ZXIsXG4gICAgICAgICAgICAgICAgICBzZXQ6IG8uc2V0dGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQucHJvdG90eXBlLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB2LmdlbmVyYXRlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgciwgaSA9IDA7IGkgPCB0LmZpZWxkc0FycmF5Lmxlbmd0aDsgaSsrKSAociA9IHQuX2ZpZWxkc0FycmF5W2ldKS5tYXAgPyB0aGlzW3IubmFtZV0gPSB7fSA6IHIucmVwZWF0ZWQgJiYgKHRoaXNbci5uYW1lXSA9IFtdKTtcbiAgICAgICAgICAgIGlmIChlKSBmb3IgKHZhciBuID0gT2JqZWN0LmtleXMoZSksIHMgPSAwOyBzIDwgbi5sZW5ndGg7ICsrcykgbnVsbCAhPSBlW25bc11dICYmICh0aGlzW25bc11dID0gZVtuW3NdXSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdi5mcm9tSlNPTiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBuZXcgdih0LCBlLm9wdGlvbnMpO1xuICAgICAgICAgIHIuZXh0ZW5zaW9ucyA9IGUuZXh0ZW5zaW9ucywgci5yZXNlcnZlZCA9IGUucmVzZXJ2ZWQ7XG4gICAgICAgICAgZm9yICh2YXIgcyA9IE9iamVjdC5rZXlzKGUuZmllbGRzKSwgYSA9IDA7IGEgPCBzLmxlbmd0aDsgKythKSByLmFkZCgodm9pZCAwICE9PSBlLmZpZWxkc1tzW2FdXS5rZXlUeXBlID8gcC5mcm9tSlNPTiA6IG4uZnJvbUpTT04pKHNbYV0sIGUuZmllbGRzW3NbYV1dKSk7XG4gICAgICAgICAgaWYgKGUub25lb2ZzKSBmb3IgKHMgPSBPYmplY3Qua2V5cyhlLm9uZW9mcyksIGEgPSAwOyBhIDwgcy5sZW5ndGg7ICsrYSkgci5hZGQoby5mcm9tSlNPTihzW2FdLCBlLm9uZW9mc1tzW2FdXSkpO1xuICAgICAgICAgIGlmIChlLm5lc3RlZCkgZm9yIChzID0gT2JqZWN0LmtleXMoZS5uZXN0ZWQpLCBhID0gMDsgYSA8IHMubGVuZ3RoOyArK2EpIHtcbiAgICAgICAgICAgIHZhciBoID0gZS5uZXN0ZWRbc1thXV07XG4gICAgICAgICAgICByLmFkZCgodm9pZCAwICE9PSBoLmlkID8gbi5mcm9tSlNPTiA6IHZvaWQgMCAhPT0gaC5maWVsZHMgPyB2LmZyb21KU09OIDogdm9pZCAwICE9PSBoLnZhbHVlcyA/IGkuZnJvbUpTT04gOiB2b2lkIDAgIT09IGgubWV0aG9kcyA/IGYuZnJvbUpTT04gOiB5LmZyb21KU09OKShzW2FdLCBoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlLmV4dGVuc2lvbnMgJiYgZS5leHRlbnNpb25zLmxlbmd0aCAmJiAoci5leHRlbnNpb25zID0gZS5leHRlbnNpb25zKSwgZS5yZXNlcnZlZCAmJiBlLnJlc2VydmVkLmxlbmd0aCAmJiAoci5yZXNlcnZlZCA9IGUucmVzZXJ2ZWQpLCBlLmdyb3VwICYmIChyLmdyb3VwID0gITApLCBlLmNvbW1lbnQgJiYgKHIuY29tbWVudCA9IGUuY29tbWVudCksIHI7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB5LnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0KSxcbiAgICAgICAgICAgIHIgPSAhIXQgJiYgQm9vbGVhbih0LmtlZXBDb21tZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGUgJiYgZS5vcHRpb25zIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIG9uZW9mczogeS5hcnJheVRvSlNPTih0aGlzLm9uZW9mc0FycmF5LCB0KSxcbiAgICAgICAgICAgIGZpZWxkczogeS5hcnJheVRvSlNPTih0aGlzLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gIXQuZGVjbGFyaW5nRmllbGQ7XG4gICAgICAgICAgICB9KSwgdCkgfHwge30sXG4gICAgICAgICAgICBleHRlbnNpb25zOiB0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCA/IHRoaXMuZXh0ZW5zaW9ucyA6IHZvaWQgMCxcbiAgICAgICAgICAgIHJlc2VydmVkOiB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHZvaWQgMCxcbiAgICAgICAgICAgIGdyb3VwOiB0aGlzLmdyb3VwIHx8IHZvaWQgMCxcbiAgICAgICAgICAgIG5lc3RlZDogZSAmJiBlLm5lc3RlZCB8fCB2b2lkIDAsXG4gICAgICAgICAgICBjb21tZW50OiByID8gdGhpcy5jb21tZW50IDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy5maWVsZHNBcnJheSwgZSA9IDA7IGUgPCB0Lmxlbmd0aDspIHRbZSsrXS5yZXNvbHZlKCk7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLm9uZW9mc0FycmF5O1xuICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCByLmxlbmd0aDspIHJbZSsrXS5yZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuIHkucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZHNbdF0gfHwgdGhpcy5vbmVvZnMgJiYgdGhpcy5vbmVvZnNbdF0gfHwgdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbdF0gfHwgbnVsbDtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXQodC5uYW1lKSkgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyB0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIG4gJiYgdm9pZCAwID09PSB0LmV4dGVuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQgJiYgdGhpcy5fZmllbGRzQnlJZFt0LmlkXSkgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyB0LmlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZCh0LmlkKSkgdGhyb3cgRXJyb3IoXCJpZCBcIiArIHQuaWQgKyBcIiBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUodC5uYW1lKSkgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIHQubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHQucGFyZW50ICYmIHQucGFyZW50LnJlbW92ZSh0KSwgdGhpcy5maWVsZHNbdC5uYW1lXSA9IHQsIHQubWVzc2FnZSA9IHRoaXMsIHQub25BZGQodGhpcyksIGcodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgbyA/ICh0aGlzLm9uZW9mcyB8fCAodGhpcy5vbmVvZnMgPSB7fSksIHRoaXMub25lb2ZzW3QubmFtZV0gPSB0LCB0Lm9uQWRkKHRoaXMpLCBnKHRoaXMpKSA6IHkucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICB9LCB2LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgbiAmJiB2b2lkIDAgPT09IHQuZXh0ZW5kKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmllbGRzIHx8IHRoaXMuZmllbGRzW3QubmFtZV0gIT09IHQpIHRocm93IEVycm9yKHQgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5maWVsZHNbdC5uYW1lXSwgdC5wYXJlbnQgPSBudWxsLCB0Lm9uUmVtb3ZlKHRoaXMpLCBnKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIG8pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vbmVvZnMgfHwgdGhpcy5vbmVvZnNbdC5uYW1lXSAhPT0gdCkgdGhyb3cgRXJyb3IodCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLm9uZW9mc1t0Lm5hbWVdLCB0LnBhcmVudCA9IG51bGwsIHQub25SZW1vdmUodGhpcyksIGcodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB5LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4geS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgdCk7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4geS5pc1Jlc2VydmVkTmFtZSh0aGlzLnJlc2VydmVkLCB0KTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcih0KTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMuZnVsbE5hbWUsIGUgPSBbXSwgciA9IDA7IHIgPCB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytyKSBlLnB1c2godGhpcy5fZmllbGRzQXJyYXlbcl0ucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgdGhpcy5kZWNvZGUgPSBsKHRoaXMpKHtcbiAgICAgICAgICAgIFJlYWRlcjogYSxcbiAgICAgICAgICAgIHR5cGVzOiBlLFxuICAgICAgICAgICAgdXRpbDogaFxuICAgICAgICAgIH0pLCB0aGlzLnZlcmlmeSA9IHUodGhpcykoe1xuICAgICAgICAgICAgdHlwZXM6IGUsXG4gICAgICAgICAgICB1dGlsOiBoXG4gICAgICAgICAgfSksIHRoaXMuZnJvbU9iamVjdCA9IGQuZnJvbU9iamVjdCh0aGlzKSh7XG4gICAgICAgICAgICB0eXBlczogZSxcbiAgICAgICAgICAgIHV0aWw6IGhcbiAgICAgICAgICB9KSwgdGhpcy50b09iamVjdCA9IGQudG9PYmplY3QodGhpcykoe1xuICAgICAgICAgICAgdHlwZXM6IGUsXG4gICAgICAgICAgICB1dGlsOiBoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGkgPSBjW3RdO1xuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgICBuLmZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QsIHRoaXMuZnJvbU9iamVjdCA9IGkuZnJvbU9iamVjdC5iaW5kKG4pLCBuLnRvT2JqZWN0ID0gdGhpcy50b09iamVjdCwgdGhpcy50b09iamVjdCA9IGkudG9PYmplY3QuYmluZChuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUodCwgZSk7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHQsIGUgJiYgZS5sZW4gPyBlLmZvcmsoKSA6IGUpLmxkZWxpbSgpO1xuICAgICAgICB9LCB2LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHVwKCkuZGVjb2RlKHQsIGUpO1xuICAgICAgICB9LCB2LnByb3RvdHlwZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IGluc3RhbmNlb2YgYSB8fCAodCA9IGEuY3JlYXRlKHQpKSwgdGhpcy5kZWNvZGUodCwgdC51aW50MzIoKSk7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXAoKS52ZXJpZnkodCk7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHVwKCkuZnJvbU9iamVjdCh0KTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHVwKCkudG9PYmplY3QodCwgZSk7XG4gICAgICAgIH0sIHYuZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBoLmRlY29yYXRlVHlwZShlLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB2Ll9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaSA9IHIoNDIxKSwgbiA9IHIoMjM4KSwgcyA9IHIoODUzKSwgbyA9IHIoODAzKSwgcig0NDMpLCBhID0gcig3OTUpLCBoID0gcig5MTYpLCB1ID0gcigxMjIpLCBsID0gcig5MTApLCBmID0gcig2NzMpLCBjID0gcig0MzIpLCBkID0gcig5NTQpLCBwID0gcig3MTgpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDQ3MTogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgdmFyIGkgPSB0LmV4cG9ydHMsXG4gICAgICAgICAgbiA9IHIoOTE2KSxcbiAgICAgICAgICBzID0gW1wiZG91YmxlXCIsIFwiZmxvYXRcIiwgXCJpbnQzMlwiLCBcInVpbnQzMlwiLCBcInNpbnQzMlwiLCBcImZpeGVkMzJcIiwgXCJzZml4ZWQzMlwiLCBcImludDY0XCIsIFwidWludDY0XCIsIFwic2ludDY0XCIsIFwiZml4ZWQ2NFwiLCBcInNmaXhlZDY0XCIsIFwiYm9vbFwiLCBcInN0cmluZ1wiLCBcImJ5dGVzXCJdO1xuICAgICAgICBmdW5jdGlvbiBvKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgICBpID0ge307XG4gICAgICAgICAgZm9yIChlIHw9IDA7IHIgPCB0Lmxlbmd0aDspIGlbc1tyICsgZV1dID0gdFtyKytdO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGkuYmFzaWMgPSBvKFsxLCA1LCAwLCAwLCAwLCA1LCA1LCAwLCAwLCAwLCAxLCAxLCAwLCAyLCAyXSksIGkuZGVmYXVsdHMgPSBvKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAhMSwgXCJcIiwgbi5lbXB0eUFycmF5LCBudWxsXSksIGkubG9uZyA9IG8oWzAsIDAsIDAsIDEsIDFdLCA3KSwgaS5tYXBLZXkgPSBvKFswLCAwLCAwLCA1LCA1LCAwLCAwLCAwLCAxLCAxLCAwLCAyXSwgMiksIGkucGFja2VkID0gbyhbMSwgNSwgMCwgMCwgMCwgNSwgNSwgMCwgMCwgMCwgMSwgMSwgMF0pLCBpLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbiA9IHIoOTE2KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICAxODc6IHQgPT4ge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICB2YXIgZSA9IHQuZXhwb3J0cztcbiAgICAgICAgZS5sZW5ndGggPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gMCwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKytpKSAociA9IHQuY2hhckNvZGVBdChpKSkgPCAxMjggPyBlICs9IDEgOiByIDwgMjA0OCA/IGUgKz0gMiA6IDU1Mjk2ID09ICg2NDUxMiAmIHIpICYmIDU2MzIwID09ICg2NDUxMiAmIHQuY2hhckNvZGVBdChpICsgMSkpID8gKCsraSwgZSArPSA0KSA6IGUgKz0gMztcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSwgZS5yZWFkID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBpZiAociAtIGUgPCAxKSByZXR1cm4gXCJcIjtcbiAgICAgICAgICBmb3IgKHZhciBpLCBuID0gbnVsbCwgcyA9IFtdLCBvID0gMDsgZSA8IHI7KSAoaSA9IHRbZSsrXSkgPCAxMjggPyBzW28rK10gPSBpIDogaSA+IDE5MSAmJiBpIDwgMjI0ID8gc1tvKytdID0gKDMxICYgaSkgPDwgNiB8IDYzICYgdFtlKytdIDogaSA+IDIzOSAmJiBpIDwgMzY1ID8gKGkgPSAoKDcgJiBpKSA8PCAxOCB8ICg2MyAmIHRbZSsrXSkgPDwgMTIgfCAoNjMgJiB0W2UrK10pIDw8IDYgfCA2MyAmIHRbZSsrXSkgLSA2NTUzNiwgc1tvKytdID0gNTUyOTYgKyAoaSA+PiAxMCksIHNbbysrXSA9IDU2MzIwICsgKDEwMjMgJiBpKSkgOiBzW28rK10gPSAoMTUgJiBpKSA8PCAxMiB8ICg2MyAmIHRbZSsrXSkgPDwgNiB8IDYzICYgdFtlKytdLCBvID4gODE5MSAmJiAoKG4gfHwgKG4gPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHMpKSwgbyA9IDApO1xuICAgICAgICAgIHJldHVybiBuID8gKG8gJiYgbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBzLnNsaWNlKDAsIG8pKSksIG4uam9pbihcIlwiKSkgOiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgcy5zbGljZSgwLCBvKSk7XG4gICAgICAgIH0sIGUud3JpdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGZvciAodmFyIGksIG4sIHMgPSByLCBvID0gMDsgbyA8IHQubGVuZ3RoOyArK28pIChpID0gdC5jaGFyQ29kZUF0KG8pKSA8IDEyOCA/IGVbcisrXSA9IGkgOiBpIDwgMjA0OCA/IChlW3IrK10gPSBpID4+IDYgfCAxOTIsIGVbcisrXSA9IDYzICYgaSB8IDEyOCkgOiA1NTI5NiA9PSAoNjQ1MTIgJiBpKSAmJiA1NjMyMCA9PSAoNjQ1MTIgJiAobiA9IHQuY2hhckNvZGVBdChvICsgMSkpKSA/IChpID0gNjU1MzYgKyAoKDEwMjMgJiBpKSA8PCAxMCkgKyAoMTAyMyAmIG4pLCArK28sIGVbcisrXSA9IGkgPj4gMTggfCAyNDAsIGVbcisrXSA9IGkgPj4gMTIgJiA2MyB8IDEyOCwgZVtyKytdID0gaSA+PiA2ICYgNjMgfCAxMjgsIGVbcisrXSA9IDYzICYgaSB8IDEyOCkgOiAoZVtyKytdID0gaSA+PiAxMiB8IDIyNCwgZVtyKytdID0gaSA+PiA2ICYgNjMgfCAxMjgsIGVbcisrXSA9IDYzICYgaSB8IDEyOCk7XG4gICAgICAgICAgcmV0dXJuIHIgLSBzO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIDkxNjogKHQsIGUsIHIpID0+IHtcbiAgICAgICAgdmFyIGkgPSByKDUzNSkuZGVmYXVsdCxcbiAgICAgICAgICBuID0gdC5leHBvcnRzLFxuICAgICAgICAgIHMgPSByKDU4Nyk7XG4gICAgICAgIG4uTG9uZ0JpdHMgPSByKDIxOCksIG4uTG9uZyA9IHIoNDcwKSwgbi5wb29sID0gcigyNjYpLCBuLmZsb2F0ID0gcig2MjApLCBuLmFzUHJvbWlzZSA9IHIoMzQ3KSwgbi5FdmVudEVtaXR0ZXIgPSByKDc3MCksIG4ucGF0aCA9IHIoOTE1KSwgbi5iYXNlNjQgPSByKDIwMyksIG4udXRmOCA9IHIoMTg3KSwgbi5jb21wYXJlRmllbGRzQnlJZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQuaWQgLSBlLmlkO1xuICAgICAgICB9LCBuLnRvQXJyYXkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlID0gT2JqZWN0LmtleXModCksIHIgPSBuZXcgQXJyYXkoZS5sZW5ndGgpLCBpID0gMDsgaSA8IGUubGVuZ3RoOykgcltpXSA9IHRbZVtpKytdXTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIG4udG9PYmplY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSB7fSwgciA9IDA7IHIgPCB0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBpID0gdFtyKytdLFxuICAgICAgICAgICAgICBuID0gdFtyKytdO1xuICAgICAgICAgICAgdm9pZCAwICE9PSBuICYmIChlW2ldID0gbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LCBuLmlzU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCB8fCB0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgICAgICB9LCBuLmlzUmVzZXJ2ZWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAvXig/OmRvfGlmfGlufGZvcnxsZXR8bmV3fHRyeXx2YXJ8Y2FzZXxlbHNlfGVudW18ZXZhbHxmYWxzZXxudWxsfHRoaXN8dHJ1ZXx2b2lkfHdpdGh8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGV4cG9ydHxpbXBvcnR8cHVibGljfHJldHVybnxzdGF0aWN8c3dpdGNofHR5cGVvZnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258YXJndW1lbnRzfGludGVyZmFjZXxwcm90ZWN0ZWR8aW1wbGVtZW50c3xpbnN0YW5jZW9mKSQvLnRlc3QodCk7XG4gICAgICAgIH0sIG4uaXNPYmplY3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICYmIFwib2JqZWN0XCIgPT09IGkodCk7XG4gICAgICAgIH0sIG4uQXJyYXkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBVaW50OEFycmF5ID8gVWludDhBcnJheSA6IEFycmF5LCBuLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlID0ge30sIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgZVt0W3JdXSA9IDE7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzKSwgciA9IHQubGVuZ3RoIC0gMTsgciA+IC0xOyAtLXIpIGlmICgxID09PSBlW3Rbcl1dICYmIHZvaWQgMCAhPT0gdGhpc1t0W3JdXSAmJiBudWxsICE9PSB0aGlzW3Rbcl1dKSByZXR1cm4gdFtyXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBuLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgdFtyXSAhPT0gZSAmJiBkZWxldGUgdGhpc1t0W3JdXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBuLm1lcmdlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gT2JqZWN0LmtleXMoZSksIG4gPSAwOyBuIDwgaS5sZW5ndGg7ICsrbikgdm9pZCAwICE9PSB0W2lbbl1dICYmIHIgfHwgKHRbaVtuXV0gPSBlW2lbbl1dKTtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSwgbi5kZWNvcmF0ZVR5cGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGlmICh0LiR0eXBlKSByZXR1cm4gZSAmJiB0LiR0eXBlLm5hbWUgIT09IGUgJiYgKG4uZGVjb3JhdGVSb290LnJlbW92ZSh0LiR0eXBlKSwgdC4kdHlwZS5uYW1lID0gZSwgbi5kZWNvcmF0ZVJvb3QuYWRkKHQuJHR5cGUpKSwgdC4kdHlwZTtcbiAgICAgICAgICBUeXBlIHx8IChUeXBlID0gcigyNCkpO1xuICAgICAgICAgIHZhciBpID0gbmV3IFR5cGUoZSB8fCB0Lm5hbWUpO1xuICAgICAgICAgIHJldHVybiBuLmRlY29yYXRlUm9vdC5hZGQoaSksIGkuY3RvciA9IHQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIiR0eXBlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITFcbiAgICAgICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLCBcIiR0eXBlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITFcbiAgICAgICAgICB9KSwgaTtcbiAgICAgICAgfSwgbi5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogW10sIG4uZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fSwgbi5sb25nVG9IYXNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCA/IG4uTG9uZ0JpdHMuZnJvbSh0KS50b0hhc2goKSA6IG4uTG9uZ0JpdHMuemVyb0hhc2g7XG4gICAgICAgIH0sIG4uY29weSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gaSh0KSkgcmV0dXJuIHQ7XG4gICAgICAgICAgdmFyIGUgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciByIGluIHQpIGVbcl0gPSB0W3JdO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LCBuLmRlZXBDb3B5ID0gZnVuY3Rpb24gdChlKSB7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gaShlKSkgcmV0dXJuIGU7XG4gICAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIGUpIHJbbl0gPSB0KGVbbl0pO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LCBuLlByb3RvY29sRXJyb3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGUodCwgcikge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGUpKSByZXR1cm4gbmV3IGUodCwgcik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGUpIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIlxuICAgICAgICAgICAgfSksIHIgJiYgbWVyZ2UodGhpcywgcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgfSwgZTtcbiAgICAgICAgfSwgbi50b0pTT05PcHRpb25zID0ge1xuICAgICAgICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgICAgICBieXRlczogU3RyaW5nLFxuICAgICAgICAgIGpzb246ICEwXG4gICAgICAgIH0sIG4uQnVmZmVyID0gbnVsbCwgbi5uZXdCdWZmZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ID8gbmV3IG4uQXJyYXkodCkgOiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBVaW50OEFycmF5ID8gdCA6IG5ldyBVaW50OEFycmF5KHQpO1xuICAgICAgICB9LCBuLnN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGkgPSBbXTtcbiAgICAgICAgICBlID0gdC5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlOyBuKyspIChyID0gdC5jaGFyQ29kZUF0KG4pKSA+PSA2NTUzNiAmJiByIDw9IDExMTQxMTEgPyAoaS5wdXNoKHIgPj4gMTggJiA3IHwgMjQwKSwgaS5wdXNoKHIgPj4gMTIgJiA2MyB8IDEyOCksIGkucHVzaChyID4+IDYgJiA2MyB8IDEyOCksIGkucHVzaCg2MyAmIHIgfCAxMjgpKSA6IHIgPj0gMjA0OCAmJiByIDw9IDY1NTM1ID8gKGkucHVzaChyID4+IDEyICYgMTUgfCAyMjQpLCBpLnB1c2gociA+PiA2ICYgNjMgfCAxMjgpLCBpLnB1c2goNjMgJiByIHwgMTI4KSkgOiByID49IDEyOCAmJiByIDw9IDIwNDcgPyAoaS5wdXNoKHIgPj4gNiAmIDMxIHwgMTkyKSwgaS5wdXNoKDYzICYgciB8IDEyOCkpIDogaS5wdXNoKDI1NSAmIHIpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9LCBuLmJ5dGVUb1N0cmluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHJldHVybiB0O1xuICAgICAgICAgIGZvciAodmFyIGUgPSBcIlwiLCByID0gdCwgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJbaV0udG9TdHJpbmcoMiksXG4gICAgICAgICAgICAgIHMgPSBuLm1hdGNoKC9eMSs/KD89MCkvKTtcbiAgICAgICAgICAgIGlmIChzICYmIDggPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IHNbMF0ubGVuZ3RoLCBhID0gcltpXS50b1N0cmluZygyKS5zbGljZSg3IC0gbyksIGggPSAxOyBoIDwgbzsgaCsrKSBhICs9IHJbaCArIGldLnRvU3RyaW5nKDIpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYSwgMikpLCBpICs9IG8gLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIG4uaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIGlzRmluaXRlKHQpICYmIE1hdGguZmxvb3IodCkgPT09IHQ7XG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImRlY29yYXRlUm9vdFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5kZWNvcmF0ZWQgfHwgKHMuZGVjb3JhdGVkID0gbmV3IChyKDU3MikpKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgMTIyOiAodCwgZSwgcikgPT4ge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSByKDUzNSkuZGVmYXVsdDtcbiAgICAgICAgZnVuY3Rpb24gbyh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQubmFtZSArIFwiOiBcIiArIGUgKyAodC5yZXBlYXRlZCAmJiBcImFycmF5XCIgIT09IGUgPyBcIltdXCIgOiB0Lm1hcCAmJiBcIm9iamVjdFwiICE9PSBlID8gXCJ7azpcIiArIHQua2V5VHlwZSArIFwifVwiIDogXCJcIikgKyBcIiBleHBlY3RlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGEodCwgZSwgciwgcykge1xuICAgICAgICAgIHZhciBhID0gcy50eXBlcztcbiAgICAgICAgICBpZiAodC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0LnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIGkpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHQucmVzb2x2ZWRUeXBlLnZhbHVlcykuaW5kZXhPZihyKSA8IDApIHJldHVybiBvKHQsIFwiZW51bSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBoID0gYVtlXS52ZXJpZnkocik7XG4gICAgICAgICAgICAgIGlmIChoKSByZXR1cm4gdC5uYW1lICsgXCIuXCIgKyBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6XG4gICAgICAgICAgICAgIGlmICghbi5pc0ludGVnZXIocikpIHJldHVybiBvKHQsIFwiaW50ZWdlclwiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjpcbiAgICAgICAgICAgICAgaWYgKCEobi5pc0ludGVnZXIocikgfHwgciAmJiBuLmlzSW50ZWdlcihyLmxvdykgJiYgbi5pc0ludGVnZXIoci5oaWdoKSkpIHJldHVybiBvKHQsIFwiaW50ZWdlcnxMb25nXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgcmV0dXJuIG8odCwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgaWYgKFwiYm9vbGVhblwiICE9IHR5cGVvZiByKSByZXR1cm4gbyh0LCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICBpZiAoIW4uaXNTdHJpbmcocikpIHJldHVybiBvKHQsIFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICBpZiAoIShyICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIHIubGVuZ3RoIHx8IG4uaXNTdHJpbmcocikpKSByZXR1cm4gbyh0LCBcImJ1ZmZlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaCh0LCBlKSB7XG4gICAgICAgICAgc3dpdGNoICh0LmtleVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkMzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOlxuICAgICAgICAgICAgICBpZiAoIW4ua2V5MzJSZS50ZXN0KGUpKSByZXR1cm4gbyh0LCBcImludGVnZXIga2V5XCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOlxuICAgICAgICAgICAgICBpZiAoIW4ua2V5NjRSZS50ZXN0KGUpKSByZXR1cm4gbyh0LCBcImludGVnZXJ8TG9uZyBrZXlcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgaWYgKCFuLmtleTJSZS50ZXN0KGUpKSByZXR1cm4gbyh0LCBcImJvb2xlYW4ga2V5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1KHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHMocikgfHwgbnVsbCA9PT0gcikgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIHZhciB1LFxuICAgICAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICAgICAgdC5vbmVvZnNBcnJheS5sZW5ndGggJiYgKHUgPSB7fSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGYgPSAwOyBmIDwgdC5maWVsZHNBcnJheS5sZW5ndGg7ICsrZikge1xuICAgICAgICAgICAgICAgIHZhciBjLFxuICAgICAgICAgICAgICAgICAgZCA9IHQuX2ZpZWxkc0FycmF5W2ZdLnJlc29sdmUoKSxcbiAgICAgICAgICAgICAgICAgIHAgPSByW2QubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFkLm9wdGlvbmFsIHx8IG51bGwgIT0gcCAmJiByLmhhc093blByb3BlcnR5KGQubmFtZSkpIGlmIChkLm1hcCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFuLmlzT2JqZWN0KHApKSByZXR1cm4gbyhkLCBcIm9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICAgIHZhciB5ID0gT2JqZWN0LmtleXMocCk7XG4gICAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgeS5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGgoZCwgeVtjXSkpIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9IGEoZCwgZiwgcFt5W2NdXSwgZSkpIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHApKSByZXR1cm4gbyhkLCBcImFycmF5XCIpO1xuICAgICAgICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IHAubGVuZ3RoOyArK2MpIGlmIChpID0gYShkLCBmLCBwW2NdLCBlKSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkLnBhcnRPZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGQucGFydE9mLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBsW2QucGFydE9mLm5hbWVdICYmIDEgPT09IHVbdl0pIHJldHVybiBkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgICAgICB1W3ZdID0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpID0gYShkLCBmLCBwLCBlKSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdC5leHBvcnRzID0gdSwgdS5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkgPSByKDQyMSksIG4gPSByKDkxNik7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNDMyOiAodCwgZSwgcikgPT4ge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuID0gZTtcbiAgICAgICAgbltcIi5nb29nbGUucHJvdG9idWYuQW55XCJdID0ge1xuICAgICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAodCAmJiB0W1wiQHR5cGVcIl0pIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmxvb2t1cCh0W1wiQHR5cGVcIl0pO1xuICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gXCIuXCIgPT09IHRbXCJAdHlwZVwiXS5jaGFyQXQoMCkgPyB0W1wiQHR5cGVcIl0uc3Vic3RyKDEpIDogdFtcIkB0eXBlXCJdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlX3VybDogXCIvXCIgKyByLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGUuZW5jb2RlKGUuZnJvbU9iamVjdCh0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU9iamVjdCh0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5qc29uICYmIHQudHlwZV91cmwgJiYgdC52YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgciA9IHQudHlwZV91cmwuc3Vic3RyaW5nKHQudHlwZV91cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSksXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMubG9va3VwKHIpO1xuICAgICAgICAgICAgICBuICYmICh0ID0gbi5kZWNvZGUodC52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEodCBpbnN0YW5jZW9mIHRoaXMuY3RvcikgJiYgdCBpbnN0YW5jZW9mIGkpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSB0LiR0eXBlLnRvT2JqZWN0KHQsIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gc1tcIkB0eXBlXCJdID0gdC4kdHlwZS5mdWxsTmFtZSwgcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHQsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbi5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkgPSByKDg1Myk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgNDQzOiAodCwgZSwgcikgPT4ge1xuICAgICAgICB0LmV4cG9ydHMgPSB1O1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuID0gcig5MTYpLFxuICAgICAgICAgIHMgPSByKDE4Nyk7XG4gICAgICAgIGZ1bmN0aW9uIG8odCwgZSwgcikge1xuICAgICAgICAgIHRoaXMuZm4gPSB0LCB0aGlzLmxlbiA9IGUsIHRoaXMubmV4dCA9IHZvaWQgMCwgdGhpcy52YWwgPSByO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGEoKSB7fVxuICAgICAgICBmdW5jdGlvbiBoKHQpIHtcbiAgICAgICAgICB0aGlzLmhlYWQgPSB0LmhlYWQsIHRoaXMudGFpbCA9IHQudGFpbCwgdGhpcy5sZW4gPSB0LmxlbiwgdGhpcy5uZXh0ID0gdC5zdGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgICB0aGlzLmxlbiA9IDAsIHRoaXMuaGVhZCA9IG5ldyBvKGEsIDAsIDApLCB0aGlzLnRhaWwgPSB0aGlzLmhlYWQsIHRoaXMuc3RhdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsKHQsIGUsIHIpIHtcbiAgICAgICAgICBlW3JdID0gMjU1ICYgdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmKHQsIGUpIHtcbiAgICAgICAgICB0aGlzLmxlbiA9IHQsIHRoaXMubmV4dCA9IHZvaWQgMCwgdGhpcy52YWwgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGModCwgZSwgcikge1xuICAgICAgICAgIGZvciAoOyB0LmhpOykgZVtyKytdID0gMTI3ICYgdC5sbyB8IDEyOCwgdC5sbyA9ICh0LmxvID4+PiA3IHwgdC5oaSA8PCAyNSkgPj4+IDAsIHQuaGkgPj4+PSA3O1xuICAgICAgICAgIGZvciAoOyB0LmxvID4gMTI3OykgZVtyKytdID0gMTI3ICYgdC5sbyB8IDEyOCwgdC5sbyA9IHQubG8gPj4+IDc7XG4gICAgICAgICAgZVtyKytdID0gdC5sbztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkKHQsIGUsIHIpIHtcbiAgICAgICAgICBlW3JdID0gMjU1ICYgdCwgZVtyICsgMV0gPSB0ID4+PiA4ICYgMjU1LCBlW3IgKyAyXSA9IHQgPj4+IDE2ICYgMjU1LCBlW3IgKyAzXSA9IHQgPj4+IDI0O1xuICAgICAgICB9XG4gICAgICAgIHUuY3JlYXRlID0gbi5CdWZmZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICh1LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKHZvaWQgMCkoKTtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdSgpO1xuICAgICAgICB9LCB1LmFsbG9jID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG4uQXJyYXkodCk7XG4gICAgICAgIH0sIG4uQXJyYXkgIT09IEFycmF5ICYmICh1LmFsbG9jID0gbi5wb29sKHUuYWxsb2MsIG4uQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KSksIHUucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgbyh0LCBlLCByKSwgdGhpcy5sZW4gKz0gZSwgdGhpcztcbiAgICAgICAgfSwgZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG8ucHJvdG90eXBlKSwgZi5wcm90b3R5cGUuZm4gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGZvciAoOyB0ID4gMTI3OykgZVtyKytdID0gMTI3ICYgdCB8IDEyOCwgdCA+Pj49IDc7XG4gICAgICAgICAgZVtyXSA9IHQ7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBmKCh0ID4+Pj0gMCkgPCAxMjggPyAxIDogdCA8IDE2Mzg0ID8gMiA6IHQgPCAyMDk3MTUyID8gMyA6IHQgPCAyNjg0MzU0NTYgPyA0IDogNSwgdCkpLmxlbiwgdGhpcztcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0IDwgMCA/IHRoaXMuX3B1c2goYywgMTAsIGkuZnJvbU51bWJlcih0KSkgOiB0aGlzLnVpbnQzMih0KTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoKHQgPDwgMSBeIHQgPj4gMzEpID4+PiAwKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IGkuZnJvbSh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaChjLCBlLmxlbmd0aCgpLCBlKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuaW50NjQgPSB1LnByb3RvdHlwZS51aW50NjQsIHUucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSBpLmZyb20odCkuenpFbmNvZGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaChjLCBlLmxlbmd0aCgpLCBlKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2gobCwgMSwgdCA/IDEgOiAwKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2goZCwgNCwgdCA+Pj4gMCk7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLnNmaXhlZDMyID0gdS5wcm90b3R5cGUuZml4ZWQzMiwgdS5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSBpLmZyb20odCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2goZCwgNCwgZS5sbykuX3B1c2goZCwgNCwgZS5oaSk7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLnNmaXhlZDY0ID0gdS5wcm90b3R5cGUuZml4ZWQ2NCwgdS5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoKG4uZmxvYXQud3JpdGVGbG9hdExFLCA0LCB0KTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaChuLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcCA9IG4uQXJyYXkucHJvdG90eXBlLnNldCA/IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZS5zZXQodCwgcik7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7ICsraSkgZVtyICsgaV0gPSB0W2ldO1xuICAgICAgICB9O1xuICAgICAgICB1LnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICBpZiAoIWUpIHJldHVybiB0aGlzLl9wdXNoKGwsIDEsIDApO1xuICAgICAgICAgIGlmIChuLmlzU3RyaW5nKHQpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHUuYWxsb2MoZSA9IHMubGVuZ3RoKHQpKTtcbiAgICAgICAgICAgIHMud3JpdGUodCwgciwgMCksIHQgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy51aW50MzIoZSkuX3B1c2gocCwgZSwgdCk7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSBzLmxlbmd0aCh0KTtcbiAgICAgICAgICByZXR1cm4gZSA/IHRoaXMudWludDMyKGUpLl9wdXNoKHMud3JpdGUsIGUsIHQpIDogdGhpcy5fcHVzaChsLCAxLCAwKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXMgPSBuZXcgaCh0aGlzKSwgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IG8oYSwgMCwgMCksIHRoaXMubGVuID0gMCwgdGhpcztcbiAgICAgICAgfSwgdS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzID8gKHRoaXMuaGVhZCA9IHRoaXMuc3RhdGVzLmhlYWQsIHRoaXMudGFpbCA9IHRoaXMuc3RhdGVzLnRhaWwsIHRoaXMubGVuID0gdGhpcy5zdGF0ZXMubGVuLCB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQpIDogKHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBvKGEsIDAsIDApLCB0aGlzLmxlbiA9IDApLCB0aGlzO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmhlYWQsXG4gICAgICAgICAgICBlID0gdGhpcy50YWlsLFxuICAgICAgICAgICAgciA9IHRoaXMubGVuO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCkudWludDMyKHIpLCByICYmICh0aGlzLnRhaWwubmV4dCA9IHQubmV4dCwgdGhpcy50YWlsID0gZSwgdGhpcy5sZW4gKz0gciksIHRoaXM7XG4gICAgICAgIH0sIHUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gdGhpcy5oZWFkLm5leHQsIGUgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSwgciA9IDA7IHQ7KSB0LmZuKHQudmFsLCBlLCByKSwgciArPSB0LmxlbiwgdCA9IHQubmV4dDtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSwgdS5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkgPSByKDIxOCksIHIoMjAzKSwgcyA9IHIoMTg3KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICA1MzU6IHQgPT4ge1xuICAgICAgICBmdW5jdGlvbiBlKHIpIHtcbiAgICAgICAgICByZXR1cm4gdC5leHBvcnRzID0gZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHQ7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiB0LmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgdCAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgdDtcbiAgICAgICAgICB9LCB0LmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCB0LmV4cG9ydHMuZGVmYXVsdCA9IHQuZXhwb3J0cywgZShyKTtcbiAgICAgICAgfVxuICAgICAgICB0LmV4cG9ydHMgPSBlLCB0LmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCB0LmV4cG9ydHMuZGVmYXVsdCA9IHQuZXhwb3J0cztcbiAgICAgIH1cbiAgICB9LFxuICAgIGUgPSB7fTtcbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgdmFyIG4gPSBlW2ldO1xuICAgIGlmICh2b2lkIDAgIT09IG4pIHJldHVybiBuLmV4cG9ydHM7XG4gICAgdmFyIHMgPSBlW2ldID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIHJldHVybiB0W2ldKHMsIHMuZXhwb3J0cywgciksIHMuZXhwb3J0cztcbiAgfVxuICByLmQgPSAodCwgZSkgPT4ge1xuICAgIGZvciAodmFyIGkgaW4gZSkgci5vKGUsIGkpICYmICFyLm8odCwgaSkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGksIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBlW2ldXG4gICAgfSk7XG4gIH0sIHIubyA9ICh0LCBlKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgZSksIHIuciA9IHQgPT4ge1xuICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogITBcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGkgPSB7fTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiB0KGUpIHtcbiAgICAgIHJldHVybiB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0O1xuICAgICAgfSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0O1xuICAgICAgfSwgdChlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgIGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfTtcbiAgICAgIHZhciByLFxuICAgICAgICBpID0ge30sXG4gICAgICAgIG4gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBzID0gbi5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHRbZV0gPSByLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBhID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICAgICAgaCA9IGEuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgICAgIHUgPSBhLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIixcbiAgICAgICAgbCA9IGEudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gICAgICBmdW5jdGlvbiBmKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7XG4gICAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgfSksIHRbZV07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBmKHt9LCBcIlwiKTtcbiAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgZiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHRbZV0gPSByO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYyh0LCBlLCByLCBpKSB7XG4gICAgICAgIHZhciBuID0gZSAmJiBlLnByb3RvdHlwZSBpbnN0YW5jZW9mIF8gPyBlIDogXyxcbiAgICAgICAgICBzID0gT2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSksXG4gICAgICAgICAgYSA9IG5ldyBOKGkgfHwgW10pO1xuICAgICAgICByZXR1cm4gbyhzLCBcIl9pbnZva2VcIiwge1xuICAgICAgICAgIHZhbHVlOiBUKHQsIHIsIGEpXG4gICAgICAgIH0pLCBzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZCh0LCBlLCByKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBhcmc6IHQuY2FsbChlLCByKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICAgICAgYXJnOiB0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaS53cmFwID0gYztcbiAgICAgIHZhciBwID0gXCJzdXNwZW5kZWRTdGFydFwiLFxuICAgICAgICB5ID0gXCJzdXNwZW5kZWRZaWVsZFwiLFxuICAgICAgICB2ID0gXCJleGVjdXRpbmdcIixcbiAgICAgICAgZyA9IFwiY29tcGxldGVkXCIsXG4gICAgICAgIG0gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIF8oKSB7fVxuICAgICAgZnVuY3Rpb24gdygpIHt9XG4gICAgICBmdW5jdGlvbiBiKCkge31cbiAgICAgIHZhciB4ID0ge307XG4gICAgICBmKHgsIGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICAgIHZhciBrID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBBID0gayAmJiBrKGsoRihbXSkpKTtcbiAgICAgIEEgJiYgQSAhPT0gbiAmJiBzLmNhbGwoQSwgaCkgJiYgKHggPSBBKTtcbiAgICAgIHZhciBTID0gYi5wcm90b3R5cGUgPSBfLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoeCk7XG4gICAgICBmdW5jdGlvbiBPKHQpIHtcbiAgICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBmKHQsIGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKGUsIHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEUoZSwgcikge1xuICAgICAgICBmdW5jdGlvbiBpKG4sIG8sIGEsIGgpIHtcbiAgICAgICAgICB2YXIgdSA9IGQoZVtuXSwgZSwgbyk7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiAhPT0gdS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgbCA9IHUuYXJnLFxuICAgICAgICAgICAgICBmID0gbC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmICYmIFwib2JqZWN0XCIgPT0gdChmKSAmJiBzLmNhbGwoZiwgXCJfX2F3YWl0XCIpID8gci5yZXNvbHZlKGYuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBpKFwibmV4dFwiLCB0LCBhLCBoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGkoXCJ0aHJvd1wiLCB0LCBhLCBoKTtcbiAgICAgICAgICAgIH0pIDogci5yZXNvbHZlKGYpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgbC52YWx1ZSA9IHQsIGEobCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gaShcInRocm93XCIsIHQsIGEsIGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGgodS5hcmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuO1xuICAgICAgICBvKHRoaXMsIFwiX2ludm9rZVwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBzKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IHIoZnVuY3Rpb24gKHIsIG4pIHtcbiAgICAgICAgICAgICAgICBpKHQsIGUsIHIsIG4pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuID0gbiA/IG4udGhlbihzLCBzKSA6IHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVCh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBuID0gcDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvKSB7XG4gICAgICAgICAgaWYgKG4gPT09IHYpIHRocm93IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICBpZiAobiA9PT0gZykge1xuICAgICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcykgdGhyb3cgbztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiByLFxuICAgICAgICAgICAgICBkb25lOiAhMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpLm1ldGhvZCA9IHMsIGkuYXJnID0gbzs7KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGkuZGVsZWdhdGU7XG4gICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IHooYSwgaSk7XG4gICAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGggPT09IG0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IGkubWV0aG9kKSBpLnNlbnQgPSBpLl9zZW50ID0gaS5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBpLm1ldGhvZCkge1xuICAgICAgICAgICAgICBpZiAobiA9PT0gcCkgdGhyb3cgbiA9IGcsIGkuYXJnO1xuICAgICAgICAgICAgICBpLmRpc3BhdGNoRXhjZXB0aW9uKGkuYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBpLm1ldGhvZCAmJiBpLmFicnVwdChcInJldHVyblwiLCBpLmFyZyk7XG4gICAgICAgICAgICBuID0gdjtcbiAgICAgICAgICAgIHZhciB1ID0gZCh0LCBlLCBpKTtcbiAgICAgICAgICAgIGlmIChcIm5vcm1hbFwiID09PSB1LnR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG4gPSBpLmRvbmUgPyBnIDogeSwgdS5hcmcgPT09IG0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1LmFyZyxcbiAgICAgICAgICAgICAgICBkb25lOiBpLmRvbmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFwidGhyb3dcIiA9PT0gdS50eXBlICYmIChuID0gZywgaS5tZXRob2QgPSBcInRocm93XCIsIGkuYXJnID0gdS5hcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHoodCwgZSkge1xuICAgICAgICB2YXIgaSA9IGUubWV0aG9kLFxuICAgICAgICAgIG4gPSB0Lml0ZXJhdG9yW2ldO1xuICAgICAgICBpZiAobiA9PT0gcikgcmV0dXJuIGUuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IGkgJiYgdC5pdGVyYXRvci5yZXR1cm4gJiYgKGUubWV0aG9kID0gXCJyZXR1cm5cIiwgZS5hcmcgPSByLCB6KHQsIGUpLCBcInRocm93XCIgPT09IGUubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBpICYmIChlLm1ldGhvZCA9IFwidGhyb3dcIiwgZS5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBpICsgXCInIG1ldGhvZFwiKSksIG07XG4gICAgICAgIHZhciBzID0gZChuLCB0Lml0ZXJhdG9yLCBlLmFyZyk7XG4gICAgICAgIGlmIChcInRocm93XCIgPT09IHMudHlwZSkgcmV0dXJuIGUubWV0aG9kID0gXCJ0aHJvd1wiLCBlLmFyZyA9IHMuYXJnLCBlLmRlbGVnYXRlID0gbnVsbCwgbTtcbiAgICAgICAgdmFyIG8gPSBzLmFyZztcbiAgICAgICAgcmV0dXJuIG8gPyBvLmRvbmUgPyAoZVt0LnJlc3VsdE5hbWVdID0gby52YWx1ZSwgZS5uZXh0ID0gdC5uZXh0TG9jLCBcInJldHVyblwiICE9PSBlLm1ldGhvZCAmJiAoZS5tZXRob2QgPSBcIm5leHRcIiwgZS5hcmcgPSByKSwgZS5kZWxlZ2F0ZSA9IG51bGwsIG0pIDogbyA6IChlLm1ldGhvZCA9IFwidGhyb3dcIiwgZS5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGUuZGVsZWdhdGUgPSBudWxsLCBtKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEIodCkge1xuICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICB0cnlMb2M6IHRbMF1cbiAgICAgICAgfTtcbiAgICAgICAgMSBpbiB0ICYmIChlLmNhdGNoTG9jID0gdFsxXSksIDIgaW4gdCAmJiAoZS5maW5hbGx5TG9jID0gdFsyXSwgZS5hZnRlckxvYyA9IHRbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEkodCkge1xuICAgICAgICB2YXIgZSA9IHQuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgICAgZS50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIGUuYXJnLCB0LmNvbXBsZXRpb24gPSBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTih0KSB7XG4gICAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgICAgICB9XSwgdC5mb3JFYWNoKEIsIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEYoZSkge1xuICAgICAgICBpZiAoZSB8fCBcIlwiID09PSBlKSB7XG4gICAgICAgICAgdmFyIGkgPSBlW2hdO1xuICAgICAgICAgIGlmIChpKSByZXR1cm4gaS5jYWxsKGUpO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUubmV4dCkgcmV0dXJuIGU7XG4gICAgICAgICAgaWYgKCFpc05hTihlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciBuID0gLTEsXG4gICAgICAgICAgICAgIG8gPSBmdW5jdGlvbiB0KCkge1xuICAgICAgICAgICAgICAgIGZvciAoOyArK24gPCBlLmxlbmd0aDspIGlmIChzLmNhbGwoZSwgbikpIHJldHVybiB0LnZhbHVlID0gZVtuXSwgdC5kb25lID0gITEsIHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQudmFsdWUgPSByLCB0LmRvbmUgPSAhMCwgdDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBvLm5leHQgPSBvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHQoZSkgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdy5wcm90b3R5cGUgPSBiLCBvKFMsIFwiY29uc3RydWN0b3JcIiwge1xuICAgICAgICB2YWx1ZTogYixcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIG8oYiwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIHZhbHVlOiB3LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KSwgdy5kaXNwbGF5TmFtZSA9IGYoYiwgbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgaS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuICEhZSAmJiAoZSA9PT0gdyB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpO1xuICAgICAgfSwgaS5tYXJrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBiKSA6ICh0Ll9fcHJvdG9fXyA9IGIsIGYodCwgbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTKSwgdDtcbiAgICAgIH0sIGkuYXdyYXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9fYXdhaXQ6IHRcbiAgICAgICAgfTtcbiAgICAgIH0sIE8oRS5wcm90b3R5cGUpLCBmKEUucHJvdG90eXBlLCB1LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSksIGkuQXN5bmNJdGVyYXRvciA9IEUsIGkuYXN5bmMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgcykge1xuICAgICAgICB2b2lkIDAgPT09IHMgJiYgKHMgPSBQcm9taXNlKTtcbiAgICAgICAgdmFyIG8gPSBuZXcgRShjKHQsIGUsIHIsIG4pLCBzKTtcbiAgICAgICAgcmV0dXJuIGkuaXNHZW5lcmF0b3JGdW5jdGlvbihlKSA/IG8gOiBvLm5leHQoKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuZG9uZSA/IHQudmFsdWUgOiBvLm5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBPKFMpLCBmKFMsIGwsIFwiR2VuZXJhdG9yXCIpLCBmKFMsIGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KSwgZihTLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgICB9KSwgaS5rZXlzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBPYmplY3QodCksXG4gICAgICAgICAgciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIGUpIHIucHVzaChpKTtcbiAgICAgICAgcmV0dXJuIHIucmV2ZXJzZSgpLCBmdW5jdGlvbiB0KCkge1xuICAgICAgICAgIGZvciAoOyByLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBpID0gci5wb3AoKTtcbiAgICAgICAgICAgIGlmIChpIGluIGUpIHJldHVybiB0LnZhbHVlID0gaSwgdC5kb25lID0gITEsIHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0LmRvbmUgPSAhMCwgdDtcbiAgICAgICAgfTtcbiAgICAgIH0sIGkudmFsdWVzID0gRiwgTi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBOLFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHIsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSByLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChJKSwgIXQpIGZvciAodmFyIGUgaW4gdGhpcykgXCJ0XCIgPT09IGUuY2hhckF0KDApICYmIHMuY2FsbCh0aGlzLCBlKSAmJiAhaXNOYU4oK2Uuc2xpY2UoMSkpICYmICh0aGlzW2VdID0gcik7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgdDtcbiAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgZnVuY3Rpb24gaShpLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50eXBlID0gXCJ0aHJvd1wiLCBhLmFyZyA9IHQsIGUubmV4dCA9IGksIG4gJiYgKGUubWV0aG9kID0gXCJuZXh0XCIsIGUuYXJnID0gciksICEhbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgbiA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbbl0sXG4gICAgICAgICAgICAgIGEgPSBvLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoXCJyb290XCIgPT09IG8udHJ5TG9jKSByZXR1cm4gaShcImVuZFwiKTtcbiAgICAgICAgICAgIGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBzLmNhbGwobywgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgICAgICB1ID0gcy5jYWxsKG8sIFwiZmluYWxseUxvY1wiKTtcbiAgICAgICAgICAgICAgaWYgKGggJiYgdSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBvLmNhdGNoTG9jKSByZXR1cm4gaShvLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgcmV0dXJuIGkoby5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG8uY2F0Y2hMb2MpIHJldHVybiBpKG8uY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXUpIHRocm93IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG8uZmluYWxseUxvYykgcmV0dXJuIGkoby5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJydXB0OiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy50cnlFbnRyaWVzW3JdO1xuICAgICAgICAgICAgaWYgKGkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBzLmNhbGwoaSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICB2YXIgbiA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuICYmIChcImJyZWFrXCIgPT09IHQgfHwgXCJjb250aW51ZVwiID09PSB0KSAmJiBuLnRyeUxvYyA8PSBlICYmIGUgPD0gbi5maW5hbGx5TG9jICYmIChuID0gbnVsbCk7XG4gICAgICAgICAgdmFyIG8gPSBuID8gbi5jb21wbGV0aW9uIDoge307XG4gICAgICAgICAgcmV0dXJuIG8udHlwZSA9IHQsIG8uYXJnID0gZSwgbiA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBuLmZpbmFsbHlMb2MsIG0pIDogdGhpcy5jb21wbGV0ZShvKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZztcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiID09PSB0LnR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0LnR5cGUgPyB0aGlzLm5leHQgPSB0LmFyZyA6IFwicmV0dXJuXCIgPT09IHQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gdC50eXBlICYmIGUgJiYgKHRoaXMubmV4dCA9IGUpLCBtO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgICBpZiAoci5maW5hbGx5TG9jID09PSB0KSByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCBJKHIpLCBtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2F0Y2g6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgICBpZiAoci50cnlMb2MgPT09IHQpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSByLmNvbXBsZXRpb247XG4gICAgICAgICAgICAgIGlmIChcInRocm93XCIgPT09IGkudHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gaS5hcmc7XG4gICAgICAgICAgICAgICAgSShyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICBpdGVyYXRvcjogRih0KSxcbiAgICAgICAgICAgIHJlc3VsdE5hbWU6IGUsXG4gICAgICAgICAgICBuZXh0TG9jOiBpXG4gICAgICAgICAgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHIpLCBtO1xuICAgICAgICB9XG4gICAgICB9LCBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKHQsIGUsIHIsIGksIG4sIHMsIG8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhID0gdFtzXShvKSxcbiAgICAgICAgICBoID0gYS52YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgcih0KTtcbiAgICAgIH1cbiAgICAgIGEuZG9uZSA/IGUoaCkgOiBQcm9taXNlLnJlc29sdmUoaCkudGhlbihpLCBuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcyh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgciA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgICAgICAgdmFyIG8gPSB0LmFwcGx5KGUsIHIpO1xuICAgICAgICAgIGZ1bmN0aW9uIGEodCkge1xuICAgICAgICAgICAgbihvLCBpLCBzLCBhLCBoLCBcIm5leHRcIiwgdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGgodCkge1xuICAgICAgICAgICAgbihvLCBpLCBzLCBhLCBoLCBcInRocm93XCIsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhKHZvaWQgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbyh0LCBlKSB7XG4gICAgICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgdmFyIHIgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0KGUpIHx8ICFlKSByZXR1cm4gZTtcbiAgICAgICAgdmFyIGkgPSBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGkpIHtcbiAgICAgICAgICB2YXIgbiA9IGkuY2FsbChlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0KG4pKSByZXR1cm4gbjtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhlKTtcbiAgICAgIH0oZSk7XG4gICAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0KHIpID8gciA6IHIgKyBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgaSA9IGVbcl07XG4gICAgICAgIGkuZW51bWVyYWJsZSA9IGkuZW51bWVyYWJsZSB8fCAhMSwgaS5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGkgJiYgKGkud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBhKGkua2V5KSwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUodCwgZSwgcikge1xuICAgICAgcmV0dXJuIGUgJiYgaCh0LnByb3RvdHlwZSwgZSksIHIgJiYgaCh0LCByKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgICAgd3JpdGFibGU6ICExXG4gICAgICB9KSwgdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBteSkgcmV0dXJuIG15O1xuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHR0KSByZXR1cm4gdHQ7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd3gpIHJldHVybiB3eDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIuaaguS4jeaUr+aMgeW9k+WJjeeOr+Wig1wiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZih0LCBlLCByKSB7XG4gICAgICByZXR1cm4gKGUgPSBhKGUpKSBpbiB0ID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICB3cml0YWJsZTogITBcbiAgICAgIH0pIDogdFtlXSA9IHIsIHQ7XG4gICAgfVxuICAgIHZhciBjO1xuICAgIHIucihpKSwgci5kKGksIHtcbiAgICAgIGRlZmF1bHQ6ICgpID0+IGdpXG4gICAgfSk7XG4gICAgdmFyIGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICBvKHRoaXMsIHQpLCBmKHRoaXMsIFwiX2RhdGFMZW5ndGhcIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9idWZmZXJMZW5ndGhcIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9zdGF0ZVwiLCBuZXcgSW50MzJBcnJheSg0KSksIGYodGhpcywgXCJfYnVmZmVyXCIsIG5ldyBBcnJheUJ1ZmZlcig2OCkpLCBmKHRoaXMsIFwiX2J1ZmZlcjhcIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9idWZmZXIzMlwiLCB2b2lkIDApLCB0aGlzLl9idWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCAwLCA2OCksIHRoaXMuX2J1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2J1ZmZlciwgMCwgMTcpLCB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdSh0LCBbe1xuICAgICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUxlbmd0aCA9IDAsIHRoaXMuX2J1ZmZlckxlbmd0aCA9IDAsIHRoaXMuX3N0YXRlLnNldCh0LnN0YXRlSWRlbnRpdHkpLCB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJhcHBlbmRTdHJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbiA9IHRoaXMuX2J1ZmZlcjgsXG4gICAgICAgICAgICBzID0gdGhpcy5fYnVmZmVyMzIsXG4gICAgICAgICAgICBvID0gdGhpcy5fYnVmZmVyTGVuZ3RoO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKHIgPSBlLmNoYXJDb2RlQXQoaSkpIDwgMTI4KSBuW28rK10gPSByO2Vsc2UgaWYgKHIgPCAyMDQ4KSBuW28rK10gPSAxOTIgKyAociA+Pj4gNiksIG5bbysrXSA9IDYzICYgciB8IDEyODtlbHNlIGlmIChyIDwgNTUyOTYgfHwgciA+IDU2MzE5KSBuW28rK10gPSAyMjQgKyAociA+Pj4gMTIpLCBuW28rK10gPSByID4+PiA2ICYgNjMgfCAxMjgsIG5bbysrXSA9IDYzICYgciB8IDEyODtlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKChyID0gMTAyNCAqIChyIC0gNTUyOTYpICsgKGUuY2hhckNvZGVBdCgrK2kpIC0gNTYzMjApICsgNjU1MzYpID4gMTExNDExMSkgdGhyb3cgbmV3IEVycm9yKFwiVW5pY29kZSBzdGFuZGFyZCBzdXBwb3J0cyBjb2RlIHBvaW50cyB1cCB0byBVKzEwRkZGRlwiKTtcbiAgICAgICAgICAgICAgbltvKytdID0gMjQwICsgKHIgPj4+IDE4KSwgbltvKytdID0gciA+Pj4gMTIgJiA2MyB8IDEyOCwgbltvKytdID0gciA+Pj4gNiAmIDYzIHwgMTI4LCBuW28rK10gPSA2MyAmIHIgfCAxMjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvID49IDY0ICYmICh0aGlzLl9kYXRhTGVuZ3RoICs9IDY0LCB0Ll9tZDVjeWNsZSh0aGlzLl9zdGF0ZSwgcyksIG8gLT0gNjQsIHNbMF0gPSBzWzE2XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJMZW5ndGggPSBvLCB0aGlzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJhcHBlbmRBc2NpaVN0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciByLCBpID0gdGhpcy5fYnVmZmVyOCwgbiA9IHRoaXMuX2J1ZmZlcjMyLCBzID0gdGhpcy5fYnVmZmVyTGVuZ3RoLCBvID0gMDs7KSB7XG4gICAgICAgICAgICBmb3IgKHIgPSBNYXRoLm1pbihlLmxlbmd0aCAtIG8sIDY0IC0gcyk7IHItLTspIGlbcysrXSA9IGUuY2hhckNvZGVBdChvKyspO1xuICAgICAgICAgICAgaWYgKHMgPCA2NCkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IDY0LCB0Ll9tZDVjeWNsZSh0aGlzLl9zdGF0ZSwgbiksIHMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyTGVuZ3RoID0gcywgdGhpcztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiYXBwZW5kQnl0ZUFycmF5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGZvciAodmFyIHIsIGkgPSB0aGlzLl9idWZmZXI4LCBuID0gdGhpcy5fYnVmZmVyMzIsIHMgPSB0aGlzLl9idWZmZXJMZW5ndGgsIG8gPSAwOzspIHtcbiAgICAgICAgICAgIGZvciAociA9IE1hdGgubWluKGUubGVuZ3RoIC0gbywgNjQgLSBzKTsgci0tOykgaVtzKytdID0gZVtvKytdO1xuICAgICAgICAgICAgaWYgKHMgPCA2NCkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IDY0LCB0Ll9tZDVjeWNsZSh0aGlzLl9zdGF0ZSwgbiksIHMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyTGVuZ3RoID0gcywgdGhpcztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0U3RhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gdC5fc3RhdGU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1ZmZlcjogU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0Ll9idWZmZXI4KSxcbiAgICAgICAgICAgIGJ1ZmxlbjogdC5fYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgbGVuZ3RoOiB0Ll9kYXRhTGVuZ3RoLFxuICAgICAgICAgICAgc3RhdGU6IFtlWzBdLCBlWzFdLCBlWzJdLCBlWzNdXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgciA9IHQuYnVmZmVyLFxuICAgICAgICAgICAgaSA9IHQuc3RhdGUsXG4gICAgICAgICAgICBuID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgZm9yICh0aGlzLl9kYXRhTGVuZ3RoID0gdC5sZW5ndGgsIHRoaXMuX2J1ZmZlckxlbmd0aCA9IHQuYnVmbGVuLCBuWzBdID0gaVswXSwgblsxXSA9IGlbMV0sIG5bMl0gPSBpWzJdLCBuWzNdID0gaVszXSwgZSA9IDA7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB0aGlzLl9idWZmZXI4W2VdID0gci5jaGFyQ29kZUF0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBpID0gdGhpcy5fYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgbiA9IHRoaXMuX2J1ZmZlcjgsXG4gICAgICAgICAgICBzID0gdGhpcy5fYnVmZmVyMzIsXG4gICAgICAgICAgICBvID0gMSArIChpID4+IDIpO1xuICAgICAgICAgIGlmICh0aGlzLl9kYXRhTGVuZ3RoICs9IGksIG5baV0gPSAxMjgsIG5baSArIDFdID0gbltpICsgMl0gPSBuW2kgKyAzXSA9IDAsIHMuc2V0KHQuYnVmZmVyMzJJZGVudGl0eS5zdWJhcnJheShvKSwgbyksIGkgPiA1NSAmJiAodC5fbWQ1Y3ljbGUodGhpcy5fc3RhdGUsIHMpLCBzLnNldCh0LmJ1ZmZlcjMySWRlbnRpdHkpKSwgKGUgPSA4ICogdGhpcy5fZGF0YUxlbmd0aCkgPD0gNDI5NDk2NzI5NSkgc1sxNF0gPSBlO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGEgPSBlLnRvU3RyaW5nKDE2KS5tYXRjaCgvKC4qPykoLnswLDh9KSQvKTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBhKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KGFbMl0sIDE2KSxcbiAgICAgICAgICAgICAgdSA9IHBhcnNlSW50KGFbMV0sIDE2KSB8fCAwO1xuICAgICAgICAgICAgc1sxNF0gPSBoLCBzWzE1XSA9IHU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0Ll9tZDVjeWNsZSh0aGlzLl9zdGF0ZSwgcyksIHIgPyB0aGlzLl9zdGF0ZSA6IHQuX2hleCh0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1dLCBbe1xuICAgICAgICBrZXk6IFwiaGFzaFN0clwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbmVQYXNzSGFzaGVyLnN0YXJ0KCkuYXBwZW5kU3RyKHQpLmVuZChlKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzaEFzY2lpU3RyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdO1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uZVBhc3NIYXNoZXIuc3RhcnQoKS5hcHBlbmRBc2NpaVN0cih0KS5lbmQoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9oZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBvID0gdC5oZXhDaGFycyxcbiAgICAgICAgICAgIGEgPSB0LmhleE91dDtcbiAgICAgICAgICBmb3IgKHMgPSAwOyBzIDwgNDsgcyArPSAxKSBmb3IgKGkgPSA4ICogcywgciA9IGVbc10sIG4gPSAwOyBuIDwgODsgbiArPSAyKSBhW2kgKyAxICsgbl0gPSBvLmNoYXJBdCgxNSAmIHIpLCByID4+Pj0gNCwgYVtpICsgMCArIG5dID0gby5jaGFyQXQoMTUgJiByKSwgciA+Pj49IDQ7XG4gICAgICAgICAgcmV0dXJuIGEuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiX21kNWN5Y2xlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gdFswXSxcbiAgICAgICAgICAgIGkgPSB0WzFdLFxuICAgICAgICAgICAgbiA9IHRbMl0sXG4gICAgICAgICAgICBzID0gdFszXTtcbiAgICAgICAgICBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpICYgbiB8IH5pICYgcykgKyBlWzBdIC0gNjgwODc2OTM2IHwgMCkgPDwgNyB8IHIgPj4+IDI1KSArIGkgfCAwKSAmIGkgfCB+ciAmIG4pICsgZVsxXSAtIDM4OTU2NDU4NiB8IDApIDw8IDEyIHwgcyA+Pj4gMjApICsgciB8IDApICYgciB8IH5zICYgaSkgKyBlWzJdICsgNjA2MTA1ODE5IHwgMCkgPDwgMTcgfCBuID4+PiAxNSkgKyBzIHwgMCkgJiBzIHwgfm4gJiByKSArIGVbM10gLSAxMDQ0NTI1MzMwIHwgMCkgPDwgMjIgfCBpID4+PiAxMCkgKyBuIHwgMCwgaSA9ICgoaSArPSAoKG4gPSAoKG4gKz0gKChzID0gKChzICs9ICgociA9ICgociArPSAoaSAmIG4gfCB+aSAmIHMpICsgZVs0XSAtIDE3NjQxODg5NyB8IDApIDw8IDcgfCByID4+PiAyNSkgKyBpIHwgMCkgJiBpIHwgfnIgJiBuKSArIGVbNV0gKyAxMjAwMDgwNDI2IHwgMCkgPDwgMTIgfCBzID4+PiAyMCkgKyByIHwgMCkgJiByIHwgfnMgJiBpKSArIGVbNl0gLSAxNDczMjMxMzQxIHwgMCkgPDwgMTcgfCBuID4+PiAxNSkgKyBzIHwgMCkgJiBzIHwgfm4gJiByKSArIGVbN10gLSA0NTcwNTk4MyB8IDApIDw8IDIyIHwgaSA+Pj4gMTApICsgbiB8IDAsIGkgPSAoKGkgKz0gKChuID0gKChuICs9ICgocyA9ICgocyArPSAoKHIgPSAoKHIgKz0gKGkgJiBuIHwgfmkgJiBzKSArIGVbOF0gKyAxNzcwMDM1NDE2IHwgMCkgPDwgNyB8IHIgPj4+IDI1KSArIGkgfCAwKSAmIGkgfCB+ciAmIG4pICsgZVs5XSAtIDE5NTg0MTQ0MTcgfCAwKSA8PCAxMiB8IHMgPj4+IDIwKSArIHIgfCAwKSAmIHIgfCB+cyAmIGkpICsgZVsxMF0gLSA0MjA2MyB8IDApIDw8IDE3IHwgbiA+Pj4gMTUpICsgcyB8IDApICYgcyB8IH5uICYgcikgKyBlWzExXSAtIDE5OTA0MDQxNjIgfCAwKSA8PCAyMiB8IGkgPj4+IDEwKSArIG4gfCAwLCBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpICYgbiB8IH5pICYgcykgKyBlWzEyXSArIDE4MDQ2MDM2ODIgfCAwKSA8PCA3IHwgciA+Pj4gMjUpICsgaSB8IDApICYgaSB8IH5yICYgbikgKyBlWzEzXSAtIDQwMzQxMTAxIHwgMCkgPDwgMTIgfCBzID4+PiAyMCkgKyByIHwgMCkgJiByIHwgfnMgJiBpKSArIGVbMTRdIC0gMTUwMjAwMjI5MCB8IDApIDw8IDE3IHwgbiA+Pj4gMTUpICsgcyB8IDApICYgcyB8IH5uICYgcikgKyBlWzE1XSArIDEyMzY1MzUzMjkgfCAwKSA8PCAyMiB8IGkgPj4+IDEwKSArIG4gfCAwLCBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpICYgcyB8IG4gJiB+cykgKyBlWzFdIC0gMTY1Nzk2NTEwIHwgMCkgPDwgNSB8IHIgPj4+IDI3KSArIGkgfCAwKSAmIG4gfCBpICYgfm4pICsgZVs2XSAtIDEwNjk1MDE2MzIgfCAwKSA8PCA5IHwgcyA+Pj4gMjMpICsgciB8IDApICYgaSB8IHIgJiB+aSkgKyBlWzExXSArIDY0MzcxNzcxMyB8IDApIDw8IDE0IHwgbiA+Pj4gMTgpICsgcyB8IDApICYgciB8IHMgJiB+cikgKyBlWzBdIC0gMzczODk3MzAyIHwgMCkgPDwgMjAgfCBpID4+PiAxMikgKyBuIHwgMCwgaSA9ICgoaSArPSAoKG4gPSAoKG4gKz0gKChzID0gKChzICs9ICgociA9ICgociArPSAoaSAmIHMgfCBuICYgfnMpICsgZVs1XSAtIDcwMTU1ODY5MSB8IDApIDw8IDUgfCByID4+PiAyNykgKyBpIHwgMCkgJiBuIHwgaSAmIH5uKSArIGVbMTBdICsgMzgwMTYwODMgfCAwKSA8PCA5IHwgcyA+Pj4gMjMpICsgciB8IDApICYgaSB8IHIgJiB+aSkgKyBlWzE1XSAtIDY2MDQ3ODMzNSB8IDApIDw8IDE0IHwgbiA+Pj4gMTgpICsgcyB8IDApICYgciB8IHMgJiB+cikgKyBlWzRdIC0gNDA1NTM3ODQ4IHwgMCkgPDwgMjAgfCBpID4+PiAxMikgKyBuIHwgMCwgaSA9ICgoaSArPSAoKG4gPSAoKG4gKz0gKChzID0gKChzICs9ICgociA9ICgociArPSAoaSAmIHMgfCBuICYgfnMpICsgZVs5XSArIDU2ODQ0NjQzOCB8IDApIDw8IDUgfCByID4+PiAyNykgKyBpIHwgMCkgJiBuIHwgaSAmIH5uKSArIGVbMTRdIC0gMTAxOTgwMzY5MCB8IDApIDw8IDkgfCBzID4+PiAyMykgKyByIHwgMCkgJiBpIHwgciAmIH5pKSArIGVbM10gLSAxODczNjM5NjEgfCAwKSA8PCAxNCB8IG4gPj4+IDE4KSArIHMgfCAwKSAmIHIgfCBzICYgfnIpICsgZVs4XSArIDExNjM1MzE1MDEgfCAwKSA8PCAyMCB8IGkgPj4+IDEyKSArIG4gfCAwLCBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpICYgcyB8IG4gJiB+cykgKyBlWzEzXSAtIDE0NDQ2ODE0NjcgfCAwKSA8PCA1IHwgciA+Pj4gMjcpICsgaSB8IDApICYgbiB8IGkgJiB+bikgKyBlWzJdIC0gNTE0MDM3ODQgfCAwKSA8PCA5IHwgcyA+Pj4gMjMpICsgciB8IDApICYgaSB8IHIgJiB+aSkgKyBlWzddICsgMTczNTMyODQ3MyB8IDApIDw8IDE0IHwgbiA+Pj4gMTgpICsgcyB8IDApICYgciB8IHMgJiB+cikgKyBlWzEyXSAtIDE5MjY2MDc3MzQgfCAwKSA8PCAyMCB8IGkgPj4+IDEyKSArIG4gfCAwLCBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpIF4gbiBeIHMpICsgZVs1XSAtIDM3ODU1OCB8IDApIDw8IDQgfCByID4+PiAyOCkgKyBpIHwgMCkgXiBpIF4gbikgKyBlWzhdIC0gMjAyMjU3NDQ2MyB8IDApIDw8IDExIHwgcyA+Pj4gMjEpICsgciB8IDApIF4gciBeIGkpICsgZVsxMV0gKyAxODM5MDMwNTYyIHwgMCkgPDwgMTYgfCBuID4+PiAxNikgKyBzIHwgMCkgXiBzIF4gcikgKyBlWzE0XSAtIDM1MzA5NTU2IHwgMCkgPDwgMjMgfCBpID4+PiA5KSArIG4gfCAwLCBpID0gKChpICs9ICgobiA9ICgobiArPSAoKHMgPSAoKHMgKz0gKChyID0gKChyICs9IChpIF4gbiBeIHMpICsgZVsxXSAtIDE1MzA5OTIwNjAgfCAwKSA8PCA0IHwgciA+Pj4gMjgpICsgaSB8IDApIF4gaSBeIG4pICsgZVs0XSArIDEyNzI4OTMzNTMgfCAwKSA8PCAxMSB8IHMgPj4+IDIxKSArIHIgfCAwKSBeIHIgXiBpKSArIGVbN10gLSAxNTU0OTc2MzIgfCAwKSA8PCAxNiB8IG4gPj4+IDE2KSArIHMgfCAwKSBeIHMgXiByKSArIGVbMTBdIC0gMTA5NDczMDY0MCB8IDApIDw8IDIzIHwgaSA+Pj4gOSkgKyBuIHwgMCwgaSA9ICgoaSArPSAoKG4gPSAoKG4gKz0gKChzID0gKChzICs9ICgociA9ICgociArPSAoaSBeIG4gXiBzKSArIGVbMTNdICsgNjgxMjc5MTc0IHwgMCkgPDwgNCB8IHIgPj4+IDI4KSArIGkgfCAwKSBeIGkgXiBuKSArIGVbMF0gLSAzNTg1MzcyMjIgfCAwKSA8PCAxMSB8IHMgPj4+IDIxKSArIHIgfCAwKSBeIHIgXiBpKSArIGVbM10gLSA3MjI1MjE5NzkgfCAwKSA8PCAxNiB8IG4gPj4+IDE2KSArIHMgfCAwKSBeIHMgXiByKSArIGVbNl0gKyA3NjAyOTE4OSB8IDApIDw8IDIzIHwgaSA+Pj4gOSkgKyBuIHwgMCwgaSA9ICgoaSArPSAoKG4gPSAoKG4gKz0gKChzID0gKChzICs9ICgociA9ICgociArPSAoaSBeIG4gXiBzKSArIGVbOV0gLSA2NDAzNjQ0ODcgfCAwKSA8PCA0IHwgciA+Pj4gMjgpICsgaSB8IDApIF4gaSBeIG4pICsgZVsxMl0gLSA0MjE4MTU4MzUgfCAwKSA8PCAxMSB8IHMgPj4+IDIxKSArIHIgfCAwKSBeIHIgXiBpKSArIGVbMTVdICsgNTMwNzQyNTIwIHwgMCkgPDwgMTYgfCBuID4+PiAxNikgKyBzIHwgMCkgXiBzIF4gcikgKyBlWzJdIC0gOTk1MzM4NjUxIHwgMCkgPDwgMjMgfCBpID4+PiA5KSArIG4gfCAwLCBpID0gKChpICs9ICgocyA9ICgocyArPSAoaSBeICgociA9ICgociArPSAobiBeIChpIHwgfnMpKSArIGVbMF0gLSAxOTg2MzA4NDQgfCAwKSA8PCA2IHwgciA+Pj4gMjYpICsgaSB8IDApIHwgfm4pKSArIGVbN10gKyAxMTI2ODkxNDE1IHwgMCkgPDwgMTAgfCBzID4+PiAyMikgKyByIHwgMCkgXiAoKG4gPSAoKG4gKz0gKHIgXiAocyB8IH5pKSkgKyBlWzE0XSAtIDE0MTYzNTQ5MDUgfCAwKSA8PCAxNSB8IG4gPj4+IDE3KSArIHMgfCAwKSB8IH5yKSkgKyBlWzVdIC0gNTc0MzQwNTUgfCAwKSA8PCAyMSB8IGkgPj4+IDExKSArIG4gfCAwLCBpID0gKChpICs9ICgocyA9ICgocyArPSAoaSBeICgociA9ICgociArPSAobiBeIChpIHwgfnMpKSArIGVbMTJdICsgMTcwMDQ4NTU3MSB8IDApIDw8IDYgfCByID4+PiAyNikgKyBpIHwgMCkgfCB+bikpICsgZVszXSAtIDE4OTQ5ODY2MDYgfCAwKSA8PCAxMCB8IHMgPj4+IDIyKSArIHIgfCAwKSBeICgobiA9ICgobiArPSAociBeIChzIHwgfmkpKSArIGVbMTBdIC0gMTA1MTUyMyB8IDApIDw8IDE1IHwgbiA+Pj4gMTcpICsgcyB8IDApIHwgfnIpKSArIGVbMV0gLSAyMDU0OTIyNzk5IHwgMCkgPDwgMjEgfCBpID4+PiAxMSkgKyBuIHwgMCwgaSA9ICgoaSArPSAoKHMgPSAoKHMgKz0gKGkgXiAoKHIgPSAoKHIgKz0gKG4gXiAoaSB8IH5zKSkgKyBlWzhdICsgMTg3MzMxMzM1OSB8IDApIDw8IDYgfCByID4+PiAyNikgKyBpIHwgMCkgfCB+bikpICsgZVsxNV0gLSAzMDYxMTc0NCB8IDApIDw8IDEwIHwgcyA+Pj4gMjIpICsgciB8IDApIF4gKChuID0gKChuICs9IChyIF4gKHMgfCB+aSkpICsgZVs2XSAtIDE1NjAxOTgzODAgfCAwKSA8PCAxNSB8IG4gPj4+IDE3KSArIHMgfCAwKSB8IH5yKSkgKyBlWzEzXSArIDEzMDkxNTE2NDkgfCAwKSA8PCAyMSB8IGkgPj4+IDExKSArIG4gfCAwLCBpID0gKChpICs9ICgocyA9ICgocyArPSAoaSBeICgociA9ICgociArPSAobiBeIChpIHwgfnMpKSArIGVbNF0gLSAxNDU1MjMwNzAgfCAwKSA8PCA2IHwgciA+Pj4gMjYpICsgaSB8IDApIHwgfm4pKSArIGVbMTFdIC0gMTEyMDIxMDM3OSB8IDApIDw8IDEwIHwgcyA+Pj4gMjIpICsgciB8IDApIF4gKChuID0gKChuICs9IChyIF4gKHMgfCB+aSkpICsgZVsyXSArIDcxODc4NzI1OSB8IDApIDw8IDE1IHwgbiA+Pj4gMTcpICsgcyB8IDApIHwgfnIpKSArIGVbOV0gLSAzNDM0ODU1NTEgfCAwKSA8PCAyMSB8IGkgPj4+IDExKSArIG4gfCAwLCB0WzBdID0gciArIHRbMF0gfCAwLCB0WzFdID0gaSArIHRbMV0gfCAwLCB0WzJdID0gbiArIHRbMl0gfCAwLCB0WzNdID0gcyArIHRbM10gfCAwO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgfSgpO1xuICAgIGMgPSBkLCBmKGQsIFwic3RhdGVJZGVudGl0eVwiLCBuZXcgSW50MzJBcnJheShbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgLTE3MzI1ODQxOTQsIDI3MTczMzg3OF0pKSwgZihkLCBcImJ1ZmZlcjMySWRlbnRpdHlcIiwgbmV3IEludDMyQXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSksIGYoZCwgXCJoZXhDaGFyc1wiLCBcIjAxMjM0NTY3ODlhYmNkZWZcIiksIGYoZCwgXCJoZXhPdXRcIiwgW10pLCBmKGQsIFwib25lUGFzc0hhc2hlclwiLCBuZXcgYygpKSwgXCI1ZDQxNDAyYWJjNGIyYTc2Yjk3MTlkOTExMDE3YzU5MlwiICE9PSBkLmhhc2hTdHIoXCJoZWxsb1wiKSAmJiBjb25zb2xlLmVycm9yKFwiTWQ1IHNlbGYgdGVzdCBmYWlsZWQuXCIpO1xuICAgIHZhciBwID0gXCJcIjtcbiAgICBmdW5jdGlvbiB5KHQpIHtcbiAgICAgIGZvciAodmFyIGUsIHIgPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbiA9IDE7IG4gPCByOyBuKyspIGlbbiAtIDFdID0gYXJndW1lbnRzW25dO1xuICAgICAgKGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoZSwgW1wiW3N2Z2FdXCIuY29uY2F0KHQpXS5jb25jYXQoaSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KHQpIHtcbiAgICAgIHJldHVybiBkLmhhc2hTdHIodCkgfHwgdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZyh0KSB7XG4gICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgY2FzZSBcIndlYXBwXCI6XG4gICAgICAgICAgcmV0dXJuIGhhcy5hcnJheUJ1ZmZlclRvQmFzZTY0KHQpO1xuICAgICAgICBjYXNlIFwiYWxpcGF5XCI6XG4gICAgICAgICAgcmV0dXJuIG15LmFycmF5QnVmZmVyVG9CYXNlNjQodCk7XG4gICAgICAgIGNhc2UgXCJ0dFwiOlxuICAgICAgICAgIHJldHVybiBoYXMuYXJyYXlCdWZmZXJUb0Jhc2U2NCh0KTtcbiAgICAgICAgY2FzZSBcImg1XCI6XG4gICAgICAgICAgZm9yICh2YXIgZSA9IFwiXCIsIHIgPSB0LmJ5dGVMZW5ndGgsIGkgPSAwOyBpIDwgcjsgaSsrKSBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodFtpXSk7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIuaaguS4jeaUr+aMgeW9k+WJjeeOr+Wig1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbSh0KSB7XG4gICAgICBwID0gdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gXygpIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3KCkge1xuICAgICAgdmFyIHQgPSBsKCk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodC5lbnYuVVNFUl9EQVRBX1BBVEgsIFwiL3N2Z2FfY2FjaGVcIik7XG4gICAgfVxuICAgIHZhciBiID0gdShmdW5jdGlvbiB0KGUsIHIsIGkpIHtcbiAgICAgICAgbyh0aGlzLCB0KSwgdGhpcy5kID0gZSwgdGhpcy50cmFuc2Zvcm0gPSByLCB0aGlzLnN0eWxlcyA9IGksIGYodGhpcywgXCJfZFwiLCB2b2lkIDApLCBmKHRoaXMsIFwiX3RyYW5zZm9ybVwiLCB2b2lkIDApLCBmKHRoaXMsIFwiX3N0eWxlc1wiLCB2b2lkIDApLCBmKHRoaXMsIFwiX3NoYXBlXCIsIHZvaWQgMCksIHRoaXMuX2QgPSBlLCB0aGlzLl90cmFuc2Zvcm0gPSByLCB0aGlzLl9zdHlsZXMgPSBpO1xuICAgICAgfSksXG4gICAgICB4ID0gdShmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgbyh0aGlzLCB0KSwgZih0aGlzLCBcImFscGhhXCIsIDApLCBmKHRoaXMsIFwidHJhbnNmb3JtXCIsIHtcbiAgICAgICAgICBhOiAxLFxuICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgYzogMCxcbiAgICAgICAgICBkOiAxLFxuICAgICAgICAgIHR4OiAwLFxuICAgICAgICAgIHR5OiAwXG4gICAgICAgIH0pLCBmKHRoaXMsIFwibGF5b3V0XCIsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pLCBmKHRoaXMsIFwibnhcIiwgMCksIGYodGhpcywgXCJueVwiLCAwKSwgZih0aGlzLCBcIm1hc2tQYXRoXCIsIHZvaWQgMCksIGYodGhpcywgXCJzaGFwZXNcIiwgW10pLCB0aGlzLmFscGhhID0gcGFyc2VGbG9hdChlLmFscGhhKSB8fCAwLCBlLmxheW91dCAmJiAodGhpcy5sYXlvdXQueCA9IHBhcnNlRmxvYXQoZS5sYXlvdXQueCkgfHwgMCwgdGhpcy5sYXlvdXQueSA9IHBhcnNlRmxvYXQoZS5sYXlvdXQueSkgfHwgMCwgdGhpcy5sYXlvdXQud2lkdGggPSBwYXJzZUZsb2F0KGUubGF5b3V0LndpZHRoKSB8fCAwLCB0aGlzLmxheW91dC5oZWlnaHQgPSBwYXJzZUZsb2F0KGUubGF5b3V0LmhlaWdodCkgfHwgMCksIGUudHJhbnNmb3JtICYmICh0aGlzLnRyYW5zZm9ybS5hID0gcGFyc2VGbG9hdChlLnRyYW5zZm9ybS5hKSB8fCAxLCB0aGlzLnRyYW5zZm9ybS5iID0gcGFyc2VGbG9hdChlLnRyYW5zZm9ybS5iKSB8fCAwLCB0aGlzLnRyYW5zZm9ybS5jID0gcGFyc2VGbG9hdChlLnRyYW5zZm9ybS5jKSB8fCAwLCB0aGlzLnRyYW5zZm9ybS5kID0gcGFyc2VGbG9hdChlLnRyYW5zZm9ybS5kKSB8fCAxLCB0aGlzLnRyYW5zZm9ybS50eCA9IHBhcnNlRmxvYXQoZS50cmFuc2Zvcm0udHgpIHx8IDAsIHRoaXMudHJhbnNmb3JtLnR5ID0gcGFyc2VGbG9hdChlLnRyYW5zZm9ybS50eSkgfHwgMCksIGUuY2xpcFBhdGggJiYgZS5jbGlwUGF0aC5sZW5ndGggPiAwICYmICh0aGlzLm1hc2tQYXRoID0gbmV3IGIoZS5jbGlwUGF0aCwgdm9pZCAwLCB7XG4gICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCJcbiAgICAgICAgfSkpLCBlLnNoYXBlcyAmJiAoZS5zaGFwZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBlLnNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgc3dpdGNoICh0LnBhdGhBcmdzID0gdC5hcmdzLCB0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdC50eXBlID0gXCJzaGFwZVwiLCB0LnBhdGhBcmdzID0gdC5zaGFwZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHQudHlwZSA9IFwicmVjdFwiLCB0LnBhdGhBcmdzID0gdC5yZWN0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdC50eXBlID0gXCJlbGxpcHNlXCIsIHQucGF0aEFyZ3MgPSB0LmVsbGlwc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB0LnR5cGUgPSBcImtlZXBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQuc3R5bGVzKSB7XG4gICAgICAgICAgICB0LnN0eWxlcy5maWxsICYmIChcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5maWxsLnIgJiYgKHQuc3R5bGVzLmZpbGxbMF0gPSB0LnN0eWxlcy5maWxsLnIpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5maWxsLmcgJiYgKHQuc3R5bGVzLmZpbGxbMV0gPSB0LnN0eWxlcy5maWxsLmcpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5maWxsLmIgJiYgKHQuc3R5bGVzLmZpbGxbMl0gPSB0LnN0eWxlcy5maWxsLmIpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5maWxsLmEgJiYgKHQuc3R5bGVzLmZpbGxbM10gPSB0LnN0eWxlcy5maWxsLmEpKSwgdC5zdHlsZXMuc3Ryb2tlICYmIChcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5zdHJva2UuciAmJiAodC5zdHlsZXMuc3Ryb2tlWzBdID0gdC5zdHlsZXMuc3Ryb2tlLnIpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5zdHJva2UuZyAmJiAodC5zdHlsZXMuc3Ryb2tlWzFdID0gdC5zdHlsZXMuc3Ryb2tlLmcpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5zdHJva2UuYiAmJiAodC5zdHlsZXMuc3Ryb2tlWzJdID0gdC5zdHlsZXMuc3Ryb2tlLmIpLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnN0eWxlcy5zdHJva2UuYSAmJiAodC5zdHlsZXMuc3Ryb2tlWzNdID0gdC5zdHlsZXMuc3Ryb2tlLmEpKTtcbiAgICAgICAgICAgIHZhciBlID0gdC5zdHlsZXMubGluZURhc2ggfHwgW107XG4gICAgICAgICAgICBzd2l0Y2ggKHQuc3R5bGVzLmxpbmVEYXNoSSA+IDAgJiYgZS5wdXNoKHQuc3R5bGVzLmxpbmVEYXNoSSksIHQuc3R5bGVzLmxpbmVEYXNoSUkgPiAwICYmIChlLmxlbmd0aCA8IDEgJiYgZS5wdXNoKDApLCBlLnB1c2godC5zdHlsZXMubGluZURhc2hJSSksIGUucHVzaCgwKSksIHQuc3R5bGVzLmxpbmVEYXNoSUlJID4gMCAmJiAoZS5sZW5ndGggPCAyICYmIChlLnB1c2goMCksIGUucHVzaCgwKSksIGVbMl0gPSB0LnN0eWxlcy5saW5lRGFzaElJSSksIHQuc3R5bGVzLmxpbmVEYXNoID0gZSwgdC5zdHlsZXMubGluZUpvaW4pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHQuc3R5bGVzLmxpbmVKb2luID0gXCJtaXRlclwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdC5zdHlsZXMubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0LnN0eWxlcy5saW5lSm9pbiA9IFwiYmV2ZWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodC5zdHlsZXMubGluZUNhcCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdC5zdHlsZXMubGluZUNhcCA9IFwiYnV0dFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdC5zdHlsZXMubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHQuc3R5bGVzLmxpbmVDYXAgPSBcInNxdWFyZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksIGUuc2hhcGVzWzBdICYmIFwia2VlcFwiID09PSBlLnNoYXBlc1swXS50eXBlID8gdGhpcy5zaGFwZXMgPSB0Lmxhc3RTaGFwZXMgOiAodGhpcy5zaGFwZXMgPSBlLnNoYXBlcywgdC5sYXN0U2hhcGVzID0gZS5zaGFwZXMpKTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnRyYW5zZm9ybS5hICogdGhpcy5sYXlvdXQueCArIHRoaXMudHJhbnNmb3JtLmMgKiB0aGlzLmxheW91dC55ICsgdGhpcy50cmFuc2Zvcm0udHgsXG4gICAgICAgICAgaSA9IHRoaXMudHJhbnNmb3JtLmEgKiAodGhpcy5sYXlvdXQueCArIHRoaXMubGF5b3V0LndpZHRoKSArIHRoaXMudHJhbnNmb3JtLmMgKiB0aGlzLmxheW91dC55ICsgdGhpcy50cmFuc2Zvcm0udHgsXG4gICAgICAgICAgbiA9IHRoaXMudHJhbnNmb3JtLmEgKiB0aGlzLmxheW91dC54ICsgdGhpcy50cmFuc2Zvcm0uYyAqICh0aGlzLmxheW91dC55ICsgdGhpcy5sYXlvdXQuaGVpZ2h0KSArIHRoaXMudHJhbnNmb3JtLnR4LFxuICAgICAgICAgIHMgPSB0aGlzLnRyYW5zZm9ybS5hICogKHRoaXMubGF5b3V0LnggKyB0aGlzLmxheW91dC53aWR0aCkgKyB0aGlzLnRyYW5zZm9ybS5jICogKHRoaXMubGF5b3V0LnkgKyB0aGlzLmxheW91dC5oZWlnaHQpICsgdGhpcy50cmFuc2Zvcm0udHgsXG4gICAgICAgICAgYSA9IHRoaXMudHJhbnNmb3JtLmIgKiB0aGlzLmxheW91dC54ICsgdGhpcy50cmFuc2Zvcm0uZCAqIHRoaXMubGF5b3V0LnkgKyB0aGlzLnRyYW5zZm9ybS50eSxcbiAgICAgICAgICBoID0gdGhpcy50cmFuc2Zvcm0uYiAqICh0aGlzLmxheW91dC54ICsgdGhpcy5sYXlvdXQud2lkdGgpICsgdGhpcy50cmFuc2Zvcm0uZCAqIHRoaXMubGF5b3V0LnkgKyB0aGlzLnRyYW5zZm9ybS50eSxcbiAgICAgICAgICB1ID0gdGhpcy50cmFuc2Zvcm0uYiAqIHRoaXMubGF5b3V0LnggKyB0aGlzLnRyYW5zZm9ybS5kICogKHRoaXMubGF5b3V0LnkgKyB0aGlzLmxheW91dC5oZWlnaHQpICsgdGhpcy50cmFuc2Zvcm0udHksXG4gICAgICAgICAgbCA9IHRoaXMudHJhbnNmb3JtLmIgKiAodGhpcy5sYXlvdXQueCArIHRoaXMubGF5b3V0LndpZHRoKSArIHRoaXMudHJhbnNmb3JtLmQgKiAodGhpcy5sYXlvdXQueSArIHRoaXMubGF5b3V0LmhlaWdodCkgKyB0aGlzLnRyYW5zZm9ybS50eTtcbiAgICAgICAgdGhpcy5ueCA9IE1hdGgubWluKE1hdGgubWluKG4sIHMpLCBNYXRoLm1pbihyLCBpKSksIHRoaXMubnkgPSBNYXRoLm1pbihNYXRoLm1pbih1LCBsKSwgTWF0aC5taW4oYSwgaCkpO1xuICAgICAgfSk7XG4gICAgZih4LCBcImxhc3RTaGFwZXNcIiwgdm9pZCAwKTtcbiAgICB2YXIgayA9IHUoZnVuY3Rpb24gdChlKSB7XG4gICAgICAgIHZhciByLCBpO1xuICAgICAgICBvKHRoaXMsIHQpLCBmKHRoaXMsIFwibWF0dGVLZXlcIiwgdm9pZCAwKSwgZih0aGlzLCBcImltYWdlS2V5XCIsIHZvaWQgMCksIGYodGhpcywgXCJmcmFtZXNcIiwgdm9pZCAwKSwgdGhpcy5tYXR0ZUtleSA9IGUubWF0dGVLZXksIHRoaXMuaW1hZ2VLZXkgPSBlLmltYWdlS2V5LCB0aGlzLmZyYW1lcyA9IG51bGwgIT09IChyID0gbnVsbCA9PT0gKGkgPSBlLmZyYW1lcykgfHwgdm9pZCAwID09PSBpID8gdm9pZCAwIDogaS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHgodCk7XG4gICAgICAgIH0pKSAmJiB2b2lkIDAgIT09IHIgPyByIDogW107XG4gICAgICB9KSxcbiAgICAgIEEgPSB1KGZ1bmN0aW9uIHQoZSwgcikge1xuICAgICAgICB2YXIgaSwgbjtcbiAgICAgICAgbyh0aGlzLCB0KSwgdGhpcy5zcGVjID0gZSwgZih0aGlzLCBcInZlcnNpb25cIiwgXCIyLjAuMFwiKSwgZih0aGlzLCBcInZpZGVvU2l6ZVwiLCB2b2lkIDApLCBmKHRoaXMsIFwic3JjXCIsIHZvaWQgMCksIGYodGhpcywgXCJGUFNcIiwgdm9pZCAwKSwgZih0aGlzLCBcImZyYW1lc1wiLCB2b2lkIDApLCBmKHRoaXMsIFwic3ByaXRlc1wiLCB2b2lkIDApLCBmKHRoaXMsIFwiYW5pbWF0ZUZyYW1lc1wiLCBbXSksIGYodGhpcywgXCJkZWNvZGVkSW1hZ2VzXCIsIHt9KSwgdGhpcy52ZXJzaW9uID0gZS52ZXIsIHRoaXMudmlkZW9TaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBlLnBhcmFtcy52aWV3Qm94V2lkdGggfHwgMCxcbiAgICAgICAgICBoZWlnaHQ6IGUucGFyYW1zLnZpZXdCb3hIZWlnaHQgfHwgMFxuICAgICAgICB9LCB0aGlzLkZQUyA9IGUucGFyYW1zLmZwcyB8fCAyMCwgdGhpcy5mcmFtZXMgPSBlLnBhcmFtcy5mcmFtZXMgfHwgMCwgdGhpcy5zcHJpdGVzID0gbnVsbCAhPT0gKGkgPSBudWxsID09PSAobiA9IGUuc3ByaXRlcykgfHwgdm9pZCAwID09PSBuID8gdm9pZCAwIDogbi5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGsodCk7XG4gICAgICAgIH0pKSAmJiB2b2lkIDAgIT09IGkgPyBpIDogW10sIHRoaXMuc3JjID0gcjtcbiAgICAgIH0pO1xuICAgIGZ1bmN0aW9uIFModCkge1xuICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoOyAtLWUgPj0gMDspIHRbZV0gPSAwO1xuICAgIH1cbiAgICB2YXIgTyA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwXSksXG4gICAgICBFID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxM10pLFxuICAgICAgVCA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XSksXG4gICAgICB6ID0gbmV3IFVpbnQ4QXJyYXkoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKSxcbiAgICAgIEIgPSBuZXcgQXJyYXkoNTc2KTtcbiAgICBTKEIpO1xuICAgIHZhciBJID0gbmV3IEFycmF5KDYwKTtcbiAgICBTKEkpO1xuICAgIHZhciBOID0gbmV3IEFycmF5KDUxMik7XG4gICAgUyhOKTtcbiAgICB2YXIgRiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIFMoRik7XG4gICAgdmFyIGogPSBuZXcgQXJyYXkoMjkpO1xuICAgIFMoaik7XG4gICAgdmFyIEwsXG4gICAgICBDLFxuICAgICAgUixcbiAgICAgIEQgPSBuZXcgQXJyYXkoMzApO1xuICAgIGZ1bmN0aW9uIE0odCwgZSwgciwgaSwgbikge1xuICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IHQsIHRoaXMuZXh0cmFfYml0cyA9IGUsIHRoaXMuZXh0cmFfYmFzZSA9IHIsIHRoaXMuZWxlbXMgPSBpLCB0aGlzLm1heF9sZW5ndGggPSBuLCB0aGlzLmhhc19zdHJlZSA9IHQgJiYgdC5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAodCwgZSkge1xuICAgICAgdGhpcy5keW5fdHJlZSA9IHQsIHRoaXMubWF4X2NvZGUgPSAwLCB0aGlzLnN0YXRfZGVzYyA9IGU7XG4gICAgfVxuICAgIFMoRCk7XG4gICAgdmFyIFUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA8IDI1NiA/IE5bdF0gOiBOWzI1NiArICh0ID4+PiA3KV07XG4gICAgICB9LFxuICAgICAgWiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdID0gMjU1ICYgZSwgdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK10gPSBlID4+PiA4ICYgMjU1O1xuICAgICAgfSxcbiAgICAgIHEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB0LmJpX3ZhbGlkID4gMTYgLSByID8gKHQuYmlfYnVmIHw9IGUgPDwgdC5iaV92YWxpZCAmIDY1NTM1LCBaKHQsIHQuYmlfYnVmKSwgdC5iaV9idWYgPSBlID4+IDE2IC0gdC5iaV92YWxpZCwgdC5iaV92YWxpZCArPSByIC0gMTYpIDogKHQuYmlfYnVmIHw9IGUgPDwgdC5iaV92YWxpZCAmIDY1NTM1LCB0LmJpX3ZhbGlkICs9IHIpO1xuICAgICAgfSxcbiAgICAgIEogPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICBxKHQsIHJbMiAqIGVdLCByWzIgKiBlICsgMV0pO1xuICAgICAgfSxcbiAgICAgIFYgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByIHw9IDEgJiB0LCB0ID4+Pj0gMSwgciA8PD0gMTtcbiAgICAgICAgfSB3aGlsZSAoLS1lID4gMCk7XG4gICAgICAgIHJldHVybiByID4+PiAxO1xuICAgICAgfSxcbiAgICAgIEggPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHMgPSBuZXcgQXJyYXkoMTYpLFxuICAgICAgICAgIG8gPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IDE1OyBpKyspIG8gPSBvICsgcltpIC0gMV0gPDwgMSwgc1tpXSA9IG87XG4gICAgICAgIGZvciAobiA9IDA7IG4gPD0gZTsgbisrKSB7XG4gICAgICAgICAgdmFyIGEgPSB0WzIgKiBuICsgMV07XG4gICAgICAgICAgMCAhPT0gYSAmJiAodFsyICogbl0gPSBWKHNbYV0rKywgYSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgMjg2OyBlKyspIHQuZHluX2x0cmVlWzIgKiBlXSA9IDA7XG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCAzMDsgZSsrKSB0LmR5bl9kdHJlZVsyICogZV0gPSAwO1xuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgMTk7IGUrKykgdC5ibF90cmVlWzIgKiBlXSA9IDA7XG4gICAgICAgIHQuZHluX2x0cmVlWzUxMl0gPSAxLCB0Lm9wdF9sZW4gPSB0LnN0YXRpY19sZW4gPSAwLCB0LnN5bV9uZXh0ID0gdC5tYXRjaGVzID0gMDtcbiAgICAgIH0sXG4gICAgICBLID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5iaV92YWxpZCA+IDggPyBaKHQsIHQuYmlfYnVmKSA6IHQuYmlfdmFsaWQgPiAwICYmICh0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXSA9IHQuYmlfYnVmKSwgdC5iaV9idWYgPSAwLCB0LmJpX3ZhbGlkID0gMDtcbiAgICAgIH0sXG4gICAgICBYID0gZnVuY3Rpb24gKHQsIGUsIHIsIGkpIHtcbiAgICAgICAgdmFyIG4gPSAyICogZSxcbiAgICAgICAgICBzID0gMiAqIHI7XG4gICAgICAgIHJldHVybiB0W25dIDwgdFtzXSB8fCB0W25dID09PSB0W3NdICYmIGlbZV0gPD0gaVtyXTtcbiAgICAgIH0sXG4gICAgICBZID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHQuaGVhcFtyXSwgbiA9IHIgPDwgMTsgbiA8PSB0LmhlYXBfbGVuICYmIChuIDwgdC5oZWFwX2xlbiAmJiBYKGUsIHQuaGVhcFtuICsgMV0sIHQuaGVhcFtuXSwgdC5kZXB0aCkgJiYgbisrLCAhWChlLCBpLCB0LmhlYXBbbl0sIHQuZGVwdGgpKTspIHQuaGVhcFtyXSA9IHQuaGVhcFtuXSwgciA9IG4sIG4gPDw9IDE7XG4gICAgICAgIHQuaGVhcFtyXSA9IGk7XG4gICAgICB9LFxuICAgICAgRyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyxcbiAgICAgICAgICBvLFxuICAgICAgICAgIGEgPSAwO1xuICAgICAgICBpZiAoMCAhPT0gdC5zeW1fbmV4dCkgZG8ge1xuICAgICAgICAgIGkgPSAyNTUgJiB0LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZiArIGErK10sIGkgKz0gKDI1NSAmIHQucGVuZGluZ19idWZbdC5zeW1fYnVmICsgYSsrXSkgPDwgOCwgbiA9IHQucGVuZGluZ19idWZbdC5zeW1fYnVmICsgYSsrXSwgMCA9PT0gaSA/IEoodCwgbiwgZSkgOiAocyA9IEZbbl0sIEoodCwgcyArIDI1NiArIDEsIGUpLCAwICE9PSAobyA9IE9bc10pICYmIChuIC09IGpbc10sIHEodCwgbiwgbykpLCBpLS0sIHMgPSBVKGkpLCBKKHQsIHMsIHIpLCAwICE9PSAobyA9IEVbc10pICYmIChpIC09IERbc10sIHEodCwgaSwgbykpKTtcbiAgICAgICAgfSB3aGlsZSAoYSA8IHQuc3ltX25leHQpO1xuICAgICAgICBKKHQsIDI1NiwgZSk7XG4gICAgICB9LFxuICAgICAgVyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICBzID0gZS5keW5fdHJlZSxcbiAgICAgICAgICBvID0gZS5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsXG4gICAgICAgICAgYSA9IGUuc3RhdF9kZXNjLmhhc19zdHJlZSxcbiAgICAgICAgICBoID0gZS5zdGF0X2Rlc2MuZWxlbXMsXG4gICAgICAgICAgdSA9IC0xO1xuICAgICAgICBmb3IgKHQuaGVhcF9sZW4gPSAwLCB0LmhlYXBfbWF4ID0gNTczLCByID0gMDsgciA8IGg7IHIrKykgMCAhPT0gc1syICogcl0gPyAodC5oZWFwWysrdC5oZWFwX2xlbl0gPSB1ID0gciwgdC5kZXB0aFtyXSA9IDApIDogc1syICogciArIDFdID0gMDtcbiAgICAgICAgZm9yICg7IHQuaGVhcF9sZW4gPCAyOykgc1syICogKG4gPSB0LmhlYXBbKyt0LmhlYXBfbGVuXSA9IHUgPCAyID8gKyt1IDogMCldID0gMSwgdC5kZXB0aFtuXSA9IDAsIHQub3B0X2xlbi0tLCBhICYmICh0LnN0YXRpY19sZW4gLT0gb1syICogbiArIDFdKTtcbiAgICAgICAgZm9yIChlLm1heF9jb2RlID0gdSwgciA9IHQuaGVhcF9sZW4gPj4gMTsgciA+PSAxOyByLS0pIFkodCwgcywgcik7XG4gICAgICAgIG4gPSBoO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgciA9IHQuaGVhcFsxXSwgdC5oZWFwWzFdID0gdC5oZWFwW3QuaGVhcF9sZW4tLV0sIFkodCwgcywgMSksIGkgPSB0LmhlYXBbMV0sIHQuaGVhcFstLXQuaGVhcF9tYXhdID0gciwgdC5oZWFwWy0tdC5oZWFwX21heF0gPSBpLCBzWzIgKiBuXSA9IHNbMiAqIHJdICsgc1syICogaV0sIHQuZGVwdGhbbl0gPSAodC5kZXB0aFtyXSA+PSB0LmRlcHRoW2ldID8gdC5kZXB0aFtyXSA6IHQuZGVwdGhbaV0pICsgMSwgc1syICogciArIDFdID0gc1syICogaSArIDFdID0gbiwgdC5oZWFwWzFdID0gbisrLCBZKHQsIHMsIDEpO1xuICAgICAgICB9IHdoaWxlICh0LmhlYXBfbGVuID49IDIpO1xuICAgICAgICB0LmhlYXBbLS10LmhlYXBfbWF4XSA9IHQuaGVhcFsxXSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgcixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgaCA9IGUuZHluX3RyZWUsXG4gICAgICAgICAgICB1ID0gZS5tYXhfY29kZSxcbiAgICAgICAgICAgIGwgPSBlLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxcbiAgICAgICAgICAgIGYgPSBlLnN0YXRfZGVzYy5oYXNfc3RyZWUsXG4gICAgICAgICAgICBjID0gZS5zdGF0X2Rlc2MuZXh0cmFfYml0cyxcbiAgICAgICAgICAgIGQgPSBlLnN0YXRfZGVzYy5leHRyYV9iYXNlLFxuICAgICAgICAgICAgcCA9IGUuc3RhdF9kZXNjLm1heF9sZW5ndGgsXG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICBmb3IgKHMgPSAwOyBzIDw9IDE1OyBzKyspIHQuYmxfY291bnRbc10gPSAwO1xuICAgICAgICAgIGZvciAoaFsyICogdC5oZWFwW3QuaGVhcF9tYXhdICsgMV0gPSAwLCByID0gdC5oZWFwX21heCArIDE7IHIgPCA1NzM7IHIrKykgKHMgPSBoWzIgKiBoWzIgKiAoaSA9IHQuaGVhcFtyXSkgKyAxXSArIDFdICsgMSkgPiBwICYmIChzID0gcCwgeSsrKSwgaFsyICogaSArIDFdID0gcywgaSA+IHUgfHwgKHQuYmxfY291bnRbc10rKywgbyA9IDAsIGkgPj0gZCAmJiAobyA9IGNbaSAtIGRdKSwgYSA9IGhbMiAqIGldLCB0Lm9wdF9sZW4gKz0gYSAqIChzICsgbyksIGYgJiYgKHQuc3RhdGljX2xlbiArPSBhICogKGxbMiAqIGkgKyAxXSArIG8pKSk7XG4gICAgICAgICAgaWYgKDAgIT09IHkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgZm9yIChzID0gcCAtIDE7IDAgPT09IHQuYmxfY291bnRbc107KSBzLS07XG4gICAgICAgICAgICAgIHQuYmxfY291bnRbc10tLSwgdC5ibF9jb3VudFtzICsgMV0gKz0gMiwgdC5ibF9jb3VudFtwXS0tLCB5IC09IDI7XG4gICAgICAgICAgICB9IHdoaWxlICh5ID4gMCk7XG4gICAgICAgICAgICBmb3IgKHMgPSBwOyAwICE9PSBzOyBzLS0pIGZvciAoaSA9IHQuYmxfY291bnRbc107IDAgIT09IGk7KSAobiA9IHQuaGVhcFstLXJdKSA+IHUgfHwgKGhbMiAqIG4gKyAxXSAhPT0gcyAmJiAodC5vcHRfbGVuICs9IChzIC0gaFsyICogbiArIDFdKSAqIGhbMiAqIG5dLCBoWzIgKiBuICsgMV0gPSBzKSwgaS0tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0odCwgZSksIEgocywgdSwgdC5ibF9jb3VudCk7XG4gICAgICB9LFxuICAgICAgUSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyA9IC0xLFxuICAgICAgICAgIG8gPSBlWzFdLFxuICAgICAgICAgIGEgPSAwLFxuICAgICAgICAgIGggPSA3LFxuICAgICAgICAgIHUgPSA0O1xuICAgICAgICBmb3IgKDAgPT09IG8gJiYgKGggPSAxMzgsIHUgPSAzKSwgZVsyICogKHIgKyAxKSArIDFdID0gNjU1MzUsIGkgPSAwOyBpIDw9IHI7IGkrKykgbiA9IG8sIG8gPSBlWzIgKiAoaSArIDEpICsgMV0sICsrYSA8IGggJiYgbiA9PT0gbyB8fCAoYSA8IHUgPyB0LmJsX3RyZWVbMiAqIG5dICs9IGEgOiAwICE9PSBuID8gKG4gIT09IHMgJiYgdC5ibF90cmVlWzIgKiBuXSsrLCB0LmJsX3RyZWVbMzJdKyspIDogYSA8PSAxMCA/IHQuYmxfdHJlZVszNF0rKyA6IHQuYmxfdHJlZVszNl0rKywgYSA9IDAsIHMgPSBuLCAwID09PSBvID8gKGggPSAxMzgsIHUgPSAzKSA6IG4gPT09IG8gPyAoaCA9IDYsIHUgPSAzKSA6IChoID0gNywgdSA9IDQpKTtcbiAgICAgIH0sXG4gICAgICBldCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyA9IC0xLFxuICAgICAgICAgIG8gPSBlWzFdLFxuICAgICAgICAgIGEgPSAwLFxuICAgICAgICAgIGggPSA3LFxuICAgICAgICAgIHUgPSA0O1xuICAgICAgICBmb3IgKDAgPT09IG8gJiYgKGggPSAxMzgsIHUgPSAzKSwgaSA9IDA7IGkgPD0gcjsgaSsrKSBpZiAobiA9IG8sIG8gPSBlWzIgKiAoaSArIDEpICsgMV0sICEoKythIDwgaCAmJiBuID09PSBvKSkge1xuICAgICAgICAgIGlmIChhIDwgdSkgZG8ge1xuICAgICAgICAgICAgSih0LCBuLCB0LmJsX3RyZWUpO1xuICAgICAgICAgIH0gd2hpbGUgKDAgIT0gLS1hKTtlbHNlIDAgIT09IG4gPyAobiAhPT0gcyAmJiAoSih0LCBuLCB0LmJsX3RyZWUpLCBhLS0pLCBKKHQsIDE2LCB0LmJsX3RyZWUpLCBxKHQsIGEgLSAzLCAyKSkgOiBhIDw9IDEwID8gKEoodCwgMTcsIHQuYmxfdHJlZSksIHEodCwgYSAtIDMsIDMpKSA6IChKKHQsIDE4LCB0LmJsX3RyZWUpLCBxKHQsIGEgLSAxMSwgNykpO1xuICAgICAgICAgIGEgPSAwLCBzID0gbiwgMCA9PT0gbyA/IChoID0gMTM4LCB1ID0gMykgOiBuID09PSBvID8gKGggPSA2LCB1ID0gMykgOiAoaCA9IDcsIHUgPSA0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJ0ID0gITEsXG4gICAgICBpdCA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIHEodCwgMCArIChpID8gMSA6IDApLCAzKSwgSyh0KSwgWih0LCByKSwgWih0LCB+ciksIHIgJiYgdC5wZW5kaW5nX2J1Zi5zZXQodC53aW5kb3cuc3ViYXJyYXkoZSwgZSArIHIpLCB0LnBlbmRpbmcpLCB0LnBlbmRpbmcgKz0gcjtcbiAgICAgIH0sXG4gICAgICBudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJ0IHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcyA9IG5ldyBBcnJheSgxNik7XG4gICAgICAgICAgZm9yIChyID0gMCwgaSA9IDA7IGkgPCAyODsgaSsrKSBmb3IgKGpbaV0gPSByLCB0ID0gMDsgdCA8IDEgPDwgT1tpXTsgdCsrKSBGW3IrK10gPSBpO1xuICAgICAgICAgIGZvciAoRltyIC0gMV0gPSBpLCBuID0gMCwgaSA9IDA7IGkgPCAxNjsgaSsrKSBmb3IgKERbaV0gPSBuLCB0ID0gMDsgdCA8IDEgPDwgRVtpXTsgdCsrKSBOW24rK10gPSBpO1xuICAgICAgICAgIGZvciAobiA+Pj0gNzsgaSA8IDMwOyBpKyspIGZvciAoRFtpXSA9IG4gPDwgNywgdCA9IDA7IHQgPCAxIDw8IEVbaV0gLSA3OyB0KyspIE5bMjU2ICsgbisrXSA9IGk7XG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8PSAxNTsgZSsrKSBzW2VdID0gMDtcbiAgICAgICAgICBmb3IgKHQgPSAwOyB0IDw9IDE0MzspIEJbMiAqIHQgKyAxXSA9IDgsIHQrKywgc1s4XSsrO1xuICAgICAgICAgIGZvciAoOyB0IDw9IDI1NTspIEJbMiAqIHQgKyAxXSA9IDksIHQrKywgc1s5XSsrO1xuICAgICAgICAgIGZvciAoOyB0IDw9IDI3OTspIEJbMiAqIHQgKyAxXSA9IDcsIHQrKywgc1s3XSsrO1xuICAgICAgICAgIGZvciAoOyB0IDw9IDI4NzspIEJbMiAqIHQgKyAxXSA9IDgsIHQrKywgc1s4XSsrO1xuICAgICAgICAgIGZvciAoSChCLCAyODcsIHMpLCB0ID0gMDsgdCA8IDMwOyB0KyspIElbMiAqIHQgKyAxXSA9IDUsIElbMiAqIHRdID0gVih0LCA1KTtcbiAgICAgICAgICBMID0gbmV3IE0oQiwgTywgMjU3LCAyODYsIDE1KSwgQyA9IG5ldyBNKEksIEUsIDAsIDMwLCAxNSksIFIgPSBuZXcgTShuZXcgQXJyYXkoMCksIFQsIDAsIDE5LCA3KTtcbiAgICAgICAgfSgpLCBydCA9ICEwKSwgdC5sX2Rlc2MgPSBuZXcgUCh0LmR5bl9sdHJlZSwgTCksIHQuZF9kZXNjID0gbmV3IFAodC5keW5fZHRyZWUsIEMpLCB0LmJsX2Rlc2MgPSBuZXcgUCh0LmJsX3RyZWUsIFIpLCB0LmJpX2J1ZiA9IDAsIHQuYmlfdmFsaWQgPSAwLCAkKHQpO1xuICAgICAgfSxcbiAgICAgIHN0ID0gaXQsXG4gICAgICBvdCA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbyA9IDA7XG4gICAgICAgIHQubGV2ZWwgPiAwID8gKDIgPT09IHQuc3RybS5kYXRhX3R5cGUgJiYgKHQuc3RybS5kYXRhX3R5cGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlLFxuICAgICAgICAgICAgciA9IDQwOTM2MjQ0NDc7XG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8PSAzMTsgZSsrLCByID4+Pj0gMSkgaWYgKDEgJiByICYmIDAgIT09IHQuZHluX2x0cmVlWzIgKiBlXSkgcmV0dXJuIDA7XG4gICAgICAgICAgaWYgKDAgIT09IHQuZHluX2x0cmVlWzE4XSB8fCAwICE9PSB0LmR5bl9sdHJlZVsyMF0gfHwgMCAhPT0gdC5keW5fbHRyZWVbMjZdKSByZXR1cm4gMTtcbiAgICAgICAgICBmb3IgKGUgPSAzMjsgZSA8IDI1NjsgZSsrKSBpZiAoMCAhPT0gdC5keW5fbHRyZWVbMiAqIGVdKSByZXR1cm4gMTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSh0KSksIFcodCwgdC5sX2Rlc2MpLCBXKHQsIHQuZF9kZXNjKSwgbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgZm9yIChRKHQsIHQuZHluX2x0cmVlLCB0LmxfZGVzYy5tYXhfY29kZSksIFEodCwgdC5keW5fZHRyZWUsIHQuZF9kZXNjLm1heF9jb2RlKSwgVyh0LCB0LmJsX2Rlc2MpLCBlID0gMTg7IGUgPj0gMyAmJiAwID09PSB0LmJsX3RyZWVbMiAqIHpbZV0gKyAxXTsgZS0tKTtcbiAgICAgICAgICByZXR1cm4gdC5vcHRfbGVuICs9IDMgKiAoZSArIDEpICsgNSArIDUgKyA0LCBlO1xuICAgICAgICB9KHQpLCBuID0gdC5vcHRfbGVuICsgMyArIDcgPj4+IDMsIChzID0gdC5zdGF0aWNfbGVuICsgMyArIDcgPj4+IDMpIDw9IG4gJiYgKG4gPSBzKSkgOiBuID0gcyA9IHIgKyA1LCByICsgNCA8PSBuICYmIC0xICE9PSBlID8gaXQodCwgZSwgciwgaSkgOiA0ID09PSB0LnN0cmF0ZWd5IHx8IHMgPT09IG4gPyAocSh0LCAyICsgKGkgPyAxIDogMCksIDMpLCBHKHQsIEIsIEkpKSA6IChxKHQsIDQgKyAoaSA/IDEgOiAwKSwgMyksIGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgZm9yIChxKHQsIGUgLSAyNTcsIDUpLCBxKHQsIHIgLSAxLCA1KSwgcSh0LCBpIC0gNCwgNCksIG4gPSAwOyBuIDwgaTsgbisrKSBxKHQsIHQuYmxfdHJlZVsyICogeltuXSArIDFdLCAzKTtcbiAgICAgICAgICBldCh0LCB0LmR5bl9sdHJlZSwgZSAtIDEpLCBldCh0LCB0LmR5bl9kdHJlZSwgciAtIDEpO1xuICAgICAgICB9KHQsIHQubF9kZXNjLm1heF9jb2RlICsgMSwgdC5kX2Rlc2MubWF4X2NvZGUgKyAxLCBvICsgMSksIEcodCwgdC5keW5fbHRyZWUsIHQuZHluX2R0cmVlKSksICQodCksIGkgJiYgSyh0KTtcbiAgICAgIH0sXG4gICAgICBhdCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiB0LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZiArIHQuc3ltX25leHQrK10gPSBlLCB0LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZiArIHQuc3ltX25leHQrK10gPSBlID4+IDgsIHQucGVuZGluZ19idWZbdC5zeW1fYnVmICsgdC5zeW1fbmV4dCsrXSA9IHIsIDAgPT09IGUgPyB0LmR5bl9sdHJlZVsyICogcl0rKyA6ICh0Lm1hdGNoZXMrKywgZS0tLCB0LmR5bl9sdHJlZVsyICogKEZbcl0gKyAyNTYgKyAxKV0rKywgdC5keW5fZHRyZWVbMiAqIFUoZSldKyspLCB0LnN5bV9uZXh0ID09PSB0LnN5bV9lbmQ7XG4gICAgICB9LFxuICAgICAgaHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBxKHQsIDIsIDMpLCBKKHQsIDI1NiwgQiksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgMTYgPT09IHQuYmlfdmFsaWQgPyAoWih0LCB0LmJpX2J1ZiksIHQuYmlfYnVmID0gMCwgdC5iaV92YWxpZCA9IDApIDogdC5iaV92YWxpZCA+PSA4ICYmICh0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXSA9IDI1NSAmIHQuYmlfYnVmLCB0LmJpX2J1ZiA+Pj0gOCwgdC5iaV92YWxpZCAtPSA4KTtcbiAgICAgICAgfSh0KTtcbiAgICAgIH0sXG4gICAgICB1dCA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSA2NTUzNSAmIHQsIHMgPSB0ID4+PiAxNiAmIDY1NTM1LCBvID0gMDsgMCAhPT0gcjspIHtcbiAgICAgICAgICByIC09IG8gPSByID4gMmUzID8gMmUzIDogcjtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBzID0gcyArIChuID0gbiArIGVbaSsrXSB8IDApIHwgMDtcbiAgICAgICAgICB9IHdoaWxlICgtLW8pO1xuICAgICAgICAgIG4gJT0gNjU1MjEsIHMgJT0gNjU1MjE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4gfCBzIDw8IDE2O1xuICAgICAgfSxcbiAgICAgIGx0ID0gbmV3IFVpbnQzMkFycmF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCwgZSA9IFtdLCByID0gMDsgciA8IDI1NjsgcisrKSB7XG4gICAgICAgICAgdCA9IHI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHQgPSAxICYgdCA/IDM5ODgyOTIzODQgXiB0ID4+PiAxIDogdCA+Pj4gMTtcbiAgICAgICAgICBlW3JdID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oKSksXG4gICAgICBmdCA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIHZhciBuID0gbHQsXG4gICAgICAgICAgcyA9IGkgKyByO1xuICAgICAgICB0IF49IC0xO1xuICAgICAgICBmb3IgKHZhciBvID0gaTsgbyA8IHM7IG8rKykgdCA9IHQgPj4+IDggXiBuWzI1NSAmICh0IF4gZVtvXSldO1xuICAgICAgICByZXR1cm4gfnQ7XG4gICAgICB9LFxuICAgICAgY3QgPSB7XG4gICAgICAgIDI6IFwibmVlZCBkaWN0aW9uYXJ5XCIsXG4gICAgICAgIDE6IFwic3RyZWFtIGVuZFwiLFxuICAgICAgICAwOiBcIlwiLFxuICAgICAgICBcIi0xXCI6IFwiZmlsZSBlcnJvclwiLFxuICAgICAgICBcIi0yXCI6IFwic3RyZWFtIGVycm9yXCIsXG4gICAgICAgIFwiLTNcIjogXCJkYXRhIGVycm9yXCIsXG4gICAgICAgIFwiLTRcIjogXCJpbnN1ZmZpY2llbnQgbWVtb3J5XCIsXG4gICAgICAgIFwiLTVcIjogXCJidWZmZXIgZXJyb3JcIixcbiAgICAgICAgXCItNlwiOiBcImluY29tcGF0aWJsZSB2ZXJzaW9uXCJcbiAgICAgIH0sXG4gICAgICBkdCA9IHtcbiAgICAgICAgWl9OT19GTFVTSDogMCxcbiAgICAgICAgWl9QQVJUSUFMX0ZMVVNIOiAxLFxuICAgICAgICBaX1NZTkNfRkxVU0g6IDIsXG4gICAgICAgIFpfRlVMTF9GTFVTSDogMyxcbiAgICAgICAgWl9GSU5JU0g6IDQsXG4gICAgICAgIFpfQkxPQ0s6IDUsXG4gICAgICAgIFpfVFJFRVM6IDYsXG4gICAgICAgIFpfT0s6IDAsXG4gICAgICAgIFpfU1RSRUFNX0VORDogMSxcbiAgICAgICAgWl9ORUVEX0RJQ1Q6IDIsXG4gICAgICAgIFpfRVJSTk86IC0xLFxuICAgICAgICBaX1NUUkVBTV9FUlJPUjogLTIsXG4gICAgICAgIFpfREFUQV9FUlJPUjogLTMsXG4gICAgICAgIFpfTUVNX0VSUk9SOiAtNCxcbiAgICAgICAgWl9CVUZfRVJST1I6IC01LFxuICAgICAgICBaX05PX0NPTVBSRVNTSU9OOiAwLFxuICAgICAgICBaX0JFU1RfU1BFRUQ6IDEsXG4gICAgICAgIFpfQkVTVF9DT01QUkVTU0lPTjogOSxcbiAgICAgICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSxcbiAgICAgICAgWl9GSUxURVJFRDogMSxcbiAgICAgICAgWl9IVUZGTUFOX09OTFk6IDIsXG4gICAgICAgIFpfUkxFOiAzLFxuICAgICAgICBaX0ZJWEVEOiA0LFxuICAgICAgICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsXG4gICAgICAgIFpfQklOQVJZOiAwLFxuICAgICAgICBaX1RFWFQ6IDEsXG4gICAgICAgIFpfVU5LTk9XTjogMixcbiAgICAgICAgWl9ERUZMQVRFRDogOFxuICAgICAgfSxcbiAgICAgIHB0ID0gbnQsXG4gICAgICB5dCA9IHN0LFxuICAgICAgdnQgPSBvdCxcbiAgICAgIGd0ID0gYXQsXG4gICAgICBtdCA9IGh0LFxuICAgICAgX3QgPSBkdC5aX05PX0ZMVVNILFxuICAgICAgd3QgPSBkdC5aX1BBUlRJQUxfRkxVU0gsXG4gICAgICBidCA9IGR0LlpfRlVMTF9GTFVTSCxcbiAgICAgIHh0ID0gZHQuWl9GSU5JU0gsXG4gICAgICBrdCA9IGR0LlpfQkxPQ0ssXG4gICAgICBBdCA9IGR0LlpfT0ssXG4gICAgICBTdCA9IGR0LlpfU1RSRUFNX0VORCxcbiAgICAgIE90ID0gZHQuWl9TVFJFQU1fRVJST1IsXG4gICAgICBFdCA9IGR0LlpfREFUQV9FUlJPUixcbiAgICAgIFR0ID0gZHQuWl9CVUZfRVJST1IsXG4gICAgICB6dCA9IGR0LlpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICAgIEJ0ID0gZHQuWl9GSUxURVJFRCxcbiAgICAgIEl0ID0gZHQuWl9IVUZGTUFOX09OTFksXG4gICAgICBOdCA9IGR0LlpfUkxFLFxuICAgICAgRnQgPSBkdC5aX0ZJWEVELFxuICAgICAganQgPSBkdC5aX1VOS05PV04sXG4gICAgICBMdCA9IGR0LlpfREVGTEFURUQsXG4gICAgICBDdCA9IDI1OCxcbiAgICAgIFJ0ID0gMjYyLFxuICAgICAgRHQgPSA0MixcbiAgICAgIE10ID0gMTEzLFxuICAgICAgUHQgPSA2NjYsXG4gICAgICBVdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0Lm1zZyA9IGN0W2VdLCBlO1xuICAgICAgfSxcbiAgICAgIFp0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIDIgKiB0IC0gKHQgPiA0ID8gOSA6IDApO1xuICAgICAgfSxcbiAgICAgIHF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHQubGVuZ3RoOyAtLWUgPj0gMDspIHRbZV0gPSAwO1xuICAgICAgfSxcbiAgICAgIEp0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgcixcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4gPSB0Lndfc2l6ZTtcbiAgICAgICAgaSA9IGUgPSB0Lmhhc2hfc2l6ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHIgPSB0LmhlYWRbLS1pXSwgdC5oZWFkW2ldID0gciA+PSBuID8gciAtIG4gOiAwO1xuICAgICAgICB9IHdoaWxlICgtLWUpO1xuICAgICAgICBpID0gZSA9IG47XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByID0gdC5wcmV2Wy0taV0sIHQucHJldltpXSA9IHIgPj0gbiA/IHIgLSBuIDogMDtcbiAgICAgICAgfSB3aGlsZSAoLS1lKTtcbiAgICAgIH0sXG4gICAgICBWdCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiAoZSA8PCB0Lmhhc2hfc2hpZnQgXiByKSAmIHQuaGFzaF9tYXNrO1xuICAgICAgfSxcbiAgICAgIEh0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LnN0YXRlLFxuICAgICAgICAgIHIgPSBlLnBlbmRpbmc7XG4gICAgICAgIHIgPiB0LmF2YWlsX291dCAmJiAociA9IHQuYXZhaWxfb3V0KSwgMCAhPT0gciAmJiAodC5vdXRwdXQuc2V0KGUucGVuZGluZ19idWYuc3ViYXJyYXkoZS5wZW5kaW5nX291dCwgZS5wZW5kaW5nX291dCArIHIpLCB0Lm5leHRfb3V0KSwgdC5uZXh0X291dCArPSByLCBlLnBlbmRpbmdfb3V0ICs9IHIsIHQudG90YWxfb3V0ICs9IHIsIHQuYXZhaWxfb3V0IC09IHIsIGUucGVuZGluZyAtPSByLCAwID09PSBlLnBlbmRpbmcgJiYgKGUucGVuZGluZ19vdXQgPSAwKSk7XG4gICAgICB9LFxuICAgICAgJHQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2dCh0LCB0LmJsb2NrX3N0YXJ0ID49IDAgPyB0LmJsb2NrX3N0YXJ0IDogLTEsIHQuc3Ryc3RhcnQgLSB0LmJsb2NrX3N0YXJ0LCBlKSwgdC5ibG9ja19zdGFydCA9IHQuc3Ryc3RhcnQsIEh0KHQuc3RybSk7XG4gICAgICB9LFxuICAgICAgS3QgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXSA9IGU7XG4gICAgICB9LFxuICAgICAgWHQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXSA9IGUgPj4+IDggJiAyNTUsIHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdID0gMjU1ICYgZTtcbiAgICAgIH0sXG4gICAgICBZdCA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIHZhciBuID0gdC5hdmFpbF9pbjtcbiAgICAgICAgcmV0dXJuIG4gPiBpICYmIChuID0gaSksIDAgPT09IG4gPyAwIDogKHQuYXZhaWxfaW4gLT0gbiwgZS5zZXQodC5pbnB1dC5zdWJhcnJheSh0Lm5leHRfaW4sIHQubmV4dF9pbiArIG4pLCByKSwgMSA9PT0gdC5zdGF0ZS53cmFwID8gdC5hZGxlciA9IHV0KHQuYWRsZXIsIGUsIG4sIHIpIDogMiA9PT0gdC5zdGF0ZS53cmFwICYmICh0LmFkbGVyID0gZnQodC5hZGxlciwgZSwgbiwgcikpLCB0Lm5leHRfaW4gKz0gbiwgdC50b3RhbF9pbiArPSBuLCBuKTtcbiAgICAgIH0sXG4gICAgICBHdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbiA9IHQubWF4X2NoYWluX2xlbmd0aCxcbiAgICAgICAgICBzID0gdC5zdHJzdGFydCxcbiAgICAgICAgICBvID0gdC5wcmV2X2xlbmd0aCxcbiAgICAgICAgICBhID0gdC5uaWNlX21hdGNoLFxuICAgICAgICAgIGggPSB0LnN0cnN0YXJ0ID4gdC53X3NpemUgLSBSdCA/IHQuc3Ryc3RhcnQgLSAodC53X3NpemUgLSBSdCkgOiAwLFxuICAgICAgICAgIHUgPSB0LndpbmRvdyxcbiAgICAgICAgICBsID0gdC53X21hc2ssXG4gICAgICAgICAgZiA9IHQucHJldixcbiAgICAgICAgICBjID0gdC5zdHJzdGFydCArIEN0LFxuICAgICAgICAgIGQgPSB1W3MgKyBvIC0gMV0sXG4gICAgICAgICAgcCA9IHVbcyArIG9dO1xuICAgICAgICB0LnByZXZfbGVuZ3RoID49IHQuZ29vZF9tYXRjaCAmJiAobiA+Pj0gMiksIGEgPiB0Lmxvb2thaGVhZCAmJiAoYSA9IHQubG9va2FoZWFkKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh1WyhyID0gZSkgKyBvXSA9PT0gcCAmJiB1W3IgKyBvIC0gMV0gPT09IGQgJiYgdVtyXSA9PT0gdVtzXSAmJiB1Wysrcl0gPT09IHVbcyArIDFdKSB7XG4gICAgICAgICAgICBzICs9IDIsIHIrKztcbiAgICAgICAgICAgIGRvIHt9IHdoaWxlICh1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiB1Wysrc10gPT09IHVbKytyXSAmJiBzIDwgYyk7XG4gICAgICAgICAgICBpZiAoaSA9IEN0IC0gKGMgLSBzKSwgcyA9IGMgLSBDdCwgaSA+IG8pIHtcbiAgICAgICAgICAgICAgaWYgKHQubWF0Y2hfc3RhcnQgPSBlLCBvID0gaSwgaSA+PSBhKSBicmVhaztcbiAgICAgICAgICAgICAgZCA9IHVbcyArIG8gLSAxXSwgcCA9IHVbcyArIG9dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKGUgPSBmW2UgJiBsXSkgPiBoICYmIDAgIT0gLS1uKTtcbiAgICAgICAgcmV0dXJuIG8gPD0gdC5sb29rYWhlYWQgPyBvIDogdC5sb29rYWhlYWQ7XG4gICAgICB9LFxuICAgICAgV3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbiA9IHQud19zaXplO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHIgPSB0LndpbmRvd19zaXplIC0gdC5sb29rYWhlYWQgLSB0LnN0cnN0YXJ0LCB0LnN0cnN0YXJ0ID49IG4gKyAobiAtIFJ0KSAmJiAodC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KG4sIG4gKyBuIC0gciksIDApLCB0Lm1hdGNoX3N0YXJ0IC09IG4sIHQuc3Ryc3RhcnQgLT0gbiwgdC5ibG9ja19zdGFydCAtPSBuLCB0Lmluc2VydCA+IHQuc3Ryc3RhcnQgJiYgKHQuaW5zZXJ0ID0gdC5zdHJzdGFydCksIEp0KHQpLCByICs9IG4pLCAwID09PSB0LnN0cm0uYXZhaWxfaW4pIGJyZWFrO1xuICAgICAgICAgIGlmIChlID0gWXQodC5zdHJtLCB0LndpbmRvdywgdC5zdHJzdGFydCArIHQubG9va2FoZWFkLCByKSwgdC5sb29rYWhlYWQgKz0gZSwgdC5sb29rYWhlYWQgKyB0Lmluc2VydCA+PSAzKSBmb3IgKGkgPSB0LnN0cnN0YXJ0IC0gdC5pbnNlcnQsIHQuaW5zX2ggPSB0LndpbmRvd1tpXSwgdC5pbnNfaCA9IFZ0KHQsIHQuaW5zX2gsIHQud2luZG93W2kgKyAxXSk7IHQuaW5zZXJ0ICYmICh0Lmluc19oID0gVnQodCwgdC5pbnNfaCwgdC53aW5kb3dbaSArIDMgLSAxXSksIHQucHJldltpICYgdC53X21hc2tdID0gdC5oZWFkW3QuaW5zX2hdLCB0LmhlYWRbdC5pbnNfaF0gPSBpLCBpKyssIHQuaW5zZXJ0LS0sICEodC5sb29rYWhlYWQgKyB0Lmluc2VydCA8IDMpKTspO1xuICAgICAgICB9IHdoaWxlICh0Lmxvb2thaGVhZCA8IFJ0ICYmIDAgIT09IHQuc3RybS5hdmFpbF9pbik7XG4gICAgICB9LFxuICAgICAgUXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgcixcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyA9IHQucGVuZGluZ19idWZfc2l6ZSAtIDUgPiB0Lndfc2l6ZSA/IHQud19zaXplIDogdC5wZW5kaW5nX2J1Zl9zaXplIC0gNSxcbiAgICAgICAgICBvID0gMCxcbiAgICAgICAgICBhID0gdC5zdHJtLmF2YWlsX2luO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHIgPSA2NTUzNSwgbiA9IHQuYmlfdmFsaWQgKyA0MiA+PiAzLCB0LnN0cm0uYXZhaWxfb3V0IDwgbikgYnJlYWs7XG4gICAgICAgICAgaWYgKG4gPSB0LnN0cm0uYXZhaWxfb3V0IC0gbiwgciA+IChpID0gdC5zdHJzdGFydCAtIHQuYmxvY2tfc3RhcnQpICsgdC5zdHJtLmF2YWlsX2luICYmIChyID0gaSArIHQuc3RybS5hdmFpbF9pbiksIHIgPiBuICYmIChyID0gbiksIHIgPCBzICYmICgwID09PSByICYmIGUgIT09IHh0IHx8IGUgPT09IF90IHx8IHIgIT09IGkgKyB0LnN0cm0uYXZhaWxfaW4pKSBicmVhaztcbiAgICAgICAgICBvID0gZSA9PT0geHQgJiYgciA9PT0gaSArIHQuc3RybS5hdmFpbF9pbiA/IDEgOiAwLCB5dCh0LCAwLCAwLCBvKSwgdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcgLSA0XSA9IHIsIHQucGVuZGluZ19idWZbdC5wZW5kaW5nIC0gM10gPSByID4+IDgsIHQucGVuZGluZ19idWZbdC5wZW5kaW5nIC0gMl0gPSB+ciwgdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcgLSAxXSA9IH5yID4+IDgsIEh0KHQuc3RybSksIGkgJiYgKGkgPiByICYmIChpID0gciksIHQuc3RybS5vdXRwdXQuc2V0KHQud2luZG93LnN1YmFycmF5KHQuYmxvY2tfc3RhcnQsIHQuYmxvY2tfc3RhcnQgKyBpKSwgdC5zdHJtLm5leHRfb3V0KSwgdC5zdHJtLm5leHRfb3V0ICs9IGksIHQuc3RybS5hdmFpbF9vdXQgLT0gaSwgdC5zdHJtLnRvdGFsX291dCArPSBpLCB0LmJsb2NrX3N0YXJ0ICs9IGksIHIgLT0gaSksIHIgJiYgKFl0KHQuc3RybSwgdC5zdHJtLm91dHB1dCwgdC5zdHJtLm5leHRfb3V0LCByKSwgdC5zdHJtLm5leHRfb3V0ICs9IHIsIHQuc3RybS5hdmFpbF9vdXQgLT0gciwgdC5zdHJtLnRvdGFsX291dCArPSByKTtcbiAgICAgICAgfSB3aGlsZSAoMCA9PT0gbyk7XG4gICAgICAgIHJldHVybiAoYSAtPSB0LnN0cm0uYXZhaWxfaW4pICYmIChhID49IHQud19zaXplID8gKHQubWF0Y2hlcyA9IDIsIHQud2luZG93LnNldCh0LnN0cm0uaW5wdXQuc3ViYXJyYXkodC5zdHJtLm5leHRfaW4gLSB0Lndfc2l6ZSwgdC5zdHJtLm5leHRfaW4pLCAwKSwgdC5zdHJzdGFydCA9IHQud19zaXplLCB0Lmluc2VydCA9IHQuc3Ryc3RhcnQpIDogKHQud2luZG93X3NpemUgLSB0LnN0cnN0YXJ0IDw9IGEgJiYgKHQuc3Ryc3RhcnQgLT0gdC53X3NpemUsIHQud2luZG93LnNldCh0LndpbmRvdy5zdWJhcnJheSh0Lndfc2l6ZSwgdC53X3NpemUgKyB0LnN0cnN0YXJ0KSwgMCksIHQubWF0Y2hlcyA8IDIgJiYgdC5tYXRjaGVzKyssIHQuaW5zZXJ0ID4gdC5zdHJzdGFydCAmJiAodC5pbnNlcnQgPSB0LnN0cnN0YXJ0KSksIHQud2luZG93LnNldCh0LnN0cm0uaW5wdXQuc3ViYXJyYXkodC5zdHJtLm5leHRfaW4gLSBhLCB0LnN0cm0ubmV4dF9pbiksIHQuc3Ryc3RhcnQpLCB0LnN0cnN0YXJ0ICs9IGEsIHQuaW5zZXJ0ICs9IGEgPiB0Lndfc2l6ZSAtIHQuaW5zZXJ0ID8gdC53X3NpemUgLSB0Lmluc2VydCA6IGEpLCB0LmJsb2NrX3N0YXJ0ID0gdC5zdHJzdGFydCksIHQuaGlnaF93YXRlciA8IHQuc3Ryc3RhcnQgJiYgKHQuaGlnaF93YXRlciA9IHQuc3Ryc3RhcnQpLCBvID8gNCA6IGUgIT09IF90ICYmIGUgIT09IHh0ICYmIDAgPT09IHQuc3RybS5hdmFpbF9pbiAmJiB0LnN0cnN0YXJ0ID09PSB0LmJsb2NrX3N0YXJ0ID8gMiA6IChuID0gdC53aW5kb3dfc2l6ZSAtIHQuc3Ryc3RhcnQsIHQuc3RybS5hdmFpbF9pbiA+IG4gJiYgdC5ibG9ja19zdGFydCA+PSB0Lndfc2l6ZSAmJiAodC5ibG9ja19zdGFydCAtPSB0Lndfc2l6ZSwgdC5zdHJzdGFydCAtPSB0Lndfc2l6ZSwgdC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KHQud19zaXplLCB0Lndfc2l6ZSArIHQuc3Ryc3RhcnQpLCAwKSwgdC5tYXRjaGVzIDwgMiAmJiB0Lm1hdGNoZXMrKywgbiArPSB0Lndfc2l6ZSwgdC5pbnNlcnQgPiB0LnN0cnN0YXJ0ICYmICh0Lmluc2VydCA9IHQuc3Ryc3RhcnQpKSwgbiA+IHQuc3RybS5hdmFpbF9pbiAmJiAobiA9IHQuc3RybS5hdmFpbF9pbiksIG4gJiYgKFl0KHQuc3RybSwgdC53aW5kb3csIHQuc3Ryc3RhcnQsIG4pLCB0LnN0cnN0YXJ0ICs9IG4sIHQuaW5zZXJ0ICs9IG4gPiB0Lndfc2l6ZSAtIHQuaW5zZXJ0ID8gdC53X3NpemUgLSB0Lmluc2VydCA6IG4pLCB0LmhpZ2hfd2F0ZXIgPCB0LnN0cnN0YXJ0ICYmICh0LmhpZ2hfd2F0ZXIgPSB0LnN0cnN0YXJ0KSwgbiA9IHQuYmlfdmFsaWQgKyA0MiA+PiAzLCBzID0gKG4gPSB0LnBlbmRpbmdfYnVmX3NpemUgLSBuID4gNjU1MzUgPyA2NTUzNSA6IHQucGVuZGluZ19idWZfc2l6ZSAtIG4pID4gdC53X3NpemUgPyB0Lndfc2l6ZSA6IG4sICgoaSA9IHQuc3Ryc3RhcnQgLSB0LmJsb2NrX3N0YXJ0KSA+PSBzIHx8IChpIHx8IGUgPT09IHh0KSAmJiBlICE9PSBfdCAmJiAwID09PSB0LnN0cm0uYXZhaWxfaW4gJiYgaSA8PSBuKSAmJiAociA9IGkgPiBuID8gbiA6IGksIG8gPSBlID09PSB4dCAmJiAwID09PSB0LnN0cm0uYXZhaWxfaW4gJiYgciA9PT0gaSA/IDEgOiAwLCB5dCh0LCB0LmJsb2NrX3N0YXJ0LCByLCBvKSwgdC5ibG9ja19zdGFydCArPSByLCBIdCh0LnN0cm0pKSwgbyA/IDMgOiAxKTtcbiAgICAgIH0sXG4gICAgICB0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIsIGk7Oykge1xuICAgICAgICAgIGlmICh0Lmxvb2thaGVhZCA8IFJ0KSB7XG4gICAgICAgICAgICBpZiAoV3QodCksIHQubG9va2FoZWFkIDwgUnQgJiYgZSA9PT0gX3QpIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKDAgPT09IHQubG9va2FoZWFkKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIgPSAwLCB0Lmxvb2thaGVhZCA+PSAzICYmICh0Lmluc19oID0gVnQodCwgdC5pbnNfaCwgdC53aW5kb3dbdC5zdHJzdGFydCArIDMgLSAxXSksIHIgPSB0LnByZXZbdC5zdHJzdGFydCAmIHQud19tYXNrXSA9IHQuaGVhZFt0Lmluc19oXSwgdC5oZWFkW3QuaW5zX2hdID0gdC5zdHJzdGFydCksIDAgIT09IHIgJiYgdC5zdHJzdGFydCAtIHIgPD0gdC53X3NpemUgLSBSdCAmJiAodC5tYXRjaF9sZW5ndGggPSBHdCh0LCByKSksIHQubWF0Y2hfbGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIGlmIChpID0gZ3QodCwgdC5zdHJzdGFydCAtIHQubWF0Y2hfc3RhcnQsIHQubWF0Y2hfbGVuZ3RoIC0gMyksIHQubG9va2FoZWFkIC09IHQubWF0Y2hfbGVuZ3RoLCB0Lm1hdGNoX2xlbmd0aCA8PSB0Lm1heF9sYXp5X21hdGNoICYmIHQubG9va2FoZWFkID49IDMpIHtcbiAgICAgICAgICAgICAgdC5tYXRjaF9sZW5ndGgtLTtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHQuc3Ryc3RhcnQrKywgdC5pbnNfaCA9IFZ0KHQsIHQuaW5zX2gsIHQud2luZG93W3Quc3Ryc3RhcnQgKyAzIC0gMV0pLCByID0gdC5wcmV2W3Quc3Ryc3RhcnQgJiB0LndfbWFza10gPSB0LmhlYWRbdC5pbnNfaF0sIHQuaGVhZFt0Lmluc19oXSA9IHQuc3Ryc3RhcnQ7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKDAgIT0gLS10Lm1hdGNoX2xlbmd0aCk7XG4gICAgICAgICAgICAgIHQuc3Ryc3RhcnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB0LnN0cnN0YXJ0ICs9IHQubWF0Y2hfbGVuZ3RoLCB0Lm1hdGNoX2xlbmd0aCA9IDAsIHQuaW5zX2ggPSB0LndpbmRvd1t0LnN0cnN0YXJ0XSwgdC5pbnNfaCA9IFZ0KHQsIHQuaW5zX2gsIHQud2luZG93W3Quc3Ryc3RhcnQgKyAxXSk7XG4gICAgICAgICAgfSBlbHNlIGkgPSBndCh0LCAwLCB0LndpbmRvd1t0LnN0cnN0YXJ0XSksIHQubG9va2FoZWFkLS0sIHQuc3Ryc3RhcnQrKztcbiAgICAgICAgICBpZiAoaSAmJiAoJHQodCwgITEpLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0KSkgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQuaW5zZXJ0ID0gdC5zdHJzdGFydCA8IDIgPyB0LnN0cnN0YXJ0IDogMiwgZSA9PT0geHQgPyAoJHQodCwgITApLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0ID8gMyA6IDQpIDogdC5zeW1fbmV4dCAmJiAoJHQodCwgITEpLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0KSA/IDEgOiAyO1xuICAgICAgfSxcbiAgICAgIGVlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciwgaSwgbjs7KSB7XG4gICAgICAgICAgaWYgKHQubG9va2FoZWFkIDwgUnQpIHtcbiAgICAgICAgICAgIGlmIChXdCh0KSwgdC5sb29rYWhlYWQgPCBSdCAmJiBlID09PSBfdCkgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoMCA9PT0gdC5sb29rYWhlYWQpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociA9IDAsIHQubG9va2FoZWFkID49IDMgJiYgKHQuaW5zX2ggPSBWdCh0LCB0Lmluc19oLCB0LndpbmRvd1t0LnN0cnN0YXJ0ICsgMyAtIDFdKSwgciA9IHQucHJldlt0LnN0cnN0YXJ0ICYgdC53X21hc2tdID0gdC5oZWFkW3QuaW5zX2hdLCB0LmhlYWRbdC5pbnNfaF0gPSB0LnN0cnN0YXJ0KSwgdC5wcmV2X2xlbmd0aCA9IHQubWF0Y2hfbGVuZ3RoLCB0LnByZXZfbWF0Y2ggPSB0Lm1hdGNoX3N0YXJ0LCB0Lm1hdGNoX2xlbmd0aCA9IDIsIDAgIT09IHIgJiYgdC5wcmV2X2xlbmd0aCA8IHQubWF4X2xhenlfbWF0Y2ggJiYgdC5zdHJzdGFydCAtIHIgPD0gdC53X3NpemUgLSBSdCAmJiAodC5tYXRjaF9sZW5ndGggPSBHdCh0LCByKSwgdC5tYXRjaF9sZW5ndGggPD0gNSAmJiAodC5zdHJhdGVneSA9PT0gQnQgfHwgMyA9PT0gdC5tYXRjaF9sZW5ndGggJiYgdC5zdHJzdGFydCAtIHQubWF0Y2hfc3RhcnQgPiA0MDk2KSAmJiAodC5tYXRjaF9sZW5ndGggPSAyKSksIHQucHJldl9sZW5ndGggPj0gMyAmJiB0Lm1hdGNoX2xlbmd0aCA8PSB0LnByZXZfbGVuZ3RoKSB7XG4gICAgICAgICAgICBuID0gdC5zdHJzdGFydCArIHQubG9va2FoZWFkIC0gMywgaSA9IGd0KHQsIHQuc3Ryc3RhcnQgLSAxIC0gdC5wcmV2X21hdGNoLCB0LnByZXZfbGVuZ3RoIC0gMyksIHQubG9va2FoZWFkIC09IHQucHJldl9sZW5ndGggLSAxLCB0LnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICsrdC5zdHJzdGFydCA8PSBuICYmICh0Lmluc19oID0gVnQodCwgdC5pbnNfaCwgdC53aW5kb3dbdC5zdHJzdGFydCArIDMgLSAxXSksIHIgPSB0LnByZXZbdC5zdHJzdGFydCAmIHQud19tYXNrXSA9IHQuaGVhZFt0Lmluc19oXSwgdC5oZWFkW3QuaW5zX2hdID0gdC5zdHJzdGFydCk7XG4gICAgICAgICAgICB9IHdoaWxlICgwICE9IC0tdC5wcmV2X2xlbmd0aCk7XG4gICAgICAgICAgICBpZiAodC5tYXRjaF9hdmFpbGFibGUgPSAwLCB0Lm1hdGNoX2xlbmd0aCA9IDIsIHQuc3Ryc3RhcnQrKywgaSAmJiAoJHQodCwgITEpLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0KSkgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIGlmICh0Lm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgICAgICAgaWYgKChpID0gZ3QodCwgMCwgdC53aW5kb3dbdC5zdHJzdGFydCAtIDFdKSkgJiYgJHQodCwgITEpLCB0LnN0cnN0YXJ0KyssIHQubG9va2FoZWFkLS0sIDAgPT09IHQuc3RybS5hdmFpbF9vdXQpIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB0Lm1hdGNoX2F2YWlsYWJsZSA9IDEsIHQuc3Ryc3RhcnQrKywgdC5sb29rYWhlYWQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC5tYXRjaF9hdmFpbGFibGUgJiYgKGkgPSBndCh0LCAwLCB0LndpbmRvd1t0LnN0cnN0YXJ0IC0gMV0pLCB0Lm1hdGNoX2F2YWlsYWJsZSA9IDApLCB0Lmluc2VydCA9IHQuc3Ryc3RhcnQgPCAyID8gdC5zdHJzdGFydCA6IDIsIGUgPT09IHh0ID8gKCR0KHQsICEwKSwgMCA9PT0gdC5zdHJtLmF2YWlsX291dCA/IDMgOiA0KSA6IHQuc3ltX25leHQgJiYgKCR0KHQsICExKSwgMCA9PT0gdC5zdHJtLmF2YWlsX291dCkgPyAxIDogMjtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gcmUodCwgZSwgciwgaSwgbikge1xuICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IHQsIHRoaXMubWF4X2xhenkgPSBlLCB0aGlzLm5pY2VfbGVuZ3RoID0gciwgdGhpcy5tYXhfY2hhaW4gPSBpLCB0aGlzLmZ1bmMgPSBuO1xuICAgIH1cbiAgICB2YXIgaWUgPSBbbmV3IHJlKDAsIDAsIDAsIDAsIFF0KSwgbmV3IHJlKDQsIDQsIDgsIDQsIHRlKSwgbmV3IHJlKDQsIDUsIDE2LCA4LCB0ZSksIG5ldyByZSg0LCA2LCAzMiwgMzIsIHRlKSwgbmV3IHJlKDQsIDQsIDE2LCAxNiwgZWUpLCBuZXcgcmUoOCwgMTYsIDMyLCAzMiwgZWUpLCBuZXcgcmUoOCwgMTYsIDEyOCwgMTI4LCBlZSksIG5ldyByZSg4LCAzMiwgMTI4LCAyNTYsIGVlKSwgbmV3IHJlKDMyLCAxMjgsIDI1OCwgMTAyNCwgZWUpLCBuZXcgcmUoMzIsIDI1OCwgMjU4LCA0MDk2LCBlZSldO1xuICAgIGZ1bmN0aW9uIG5lKCkge1xuICAgICAgdGhpcy5zdHJtID0gbnVsbCwgdGhpcy5zdGF0dXMgPSAwLCB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbCwgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMCwgdGhpcy5wZW5kaW5nX291dCA9IDAsIHRoaXMucGVuZGluZyA9IDAsIHRoaXMud3JhcCA9IDAsIHRoaXMuZ3poZWFkID0gbnVsbCwgdGhpcy5nemluZGV4ID0gMCwgdGhpcy5tZXRob2QgPSBMdCwgdGhpcy5sYXN0X2ZsdXNoID0gLTEsIHRoaXMud19zaXplID0gMCwgdGhpcy53X2JpdHMgPSAwLCB0aGlzLndfbWFzayA9IDAsIHRoaXMud2luZG93ID0gbnVsbCwgdGhpcy53aW5kb3dfc2l6ZSA9IDAsIHRoaXMucHJldiA9IG51bGwsIHRoaXMuaGVhZCA9IG51bGwsIHRoaXMuaW5zX2ggPSAwLCB0aGlzLmhhc2hfc2l6ZSA9IDAsIHRoaXMuaGFzaF9iaXRzID0gMCwgdGhpcy5oYXNoX21hc2sgPSAwLCB0aGlzLmhhc2hfc2hpZnQgPSAwLCB0aGlzLmJsb2NrX3N0YXJ0ID0gMCwgdGhpcy5tYXRjaF9sZW5ndGggPSAwLCB0aGlzLnByZXZfbWF0Y2ggPSAwLCB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDAsIHRoaXMuc3Ryc3RhcnQgPSAwLCB0aGlzLm1hdGNoX3N0YXJ0ID0gMCwgdGhpcy5sb29rYWhlYWQgPSAwLCB0aGlzLnByZXZfbGVuZ3RoID0gMCwgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMCwgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDAsIHRoaXMubGV2ZWwgPSAwLCB0aGlzLnN0cmF0ZWd5ID0gMCwgdGhpcy5nb29kX21hdGNoID0gMCwgdGhpcy5uaWNlX21hdGNoID0gMCwgdGhpcy5keW5fbHRyZWUgPSBuZXcgVWludDE2QXJyYXkoMTE0NiksIHRoaXMuZHluX2R0cmVlID0gbmV3IFVpbnQxNkFycmF5KDEyMiksIHRoaXMuYmxfdHJlZSA9IG5ldyBVaW50MTZBcnJheSg3OCksIHF0KHRoaXMuZHluX2x0cmVlKSwgcXQodGhpcy5keW5fZHRyZWUpLCBxdCh0aGlzLmJsX3RyZWUpLCB0aGlzLmxfZGVzYyA9IG51bGwsIHRoaXMuZF9kZXNjID0gbnVsbCwgdGhpcy5ibF9kZXNjID0gbnVsbCwgdGhpcy5ibF9jb3VudCA9IG5ldyBVaW50MTZBcnJheSgxNiksIHRoaXMuaGVhcCA9IG5ldyBVaW50MTZBcnJheSg1NzMpLCBxdCh0aGlzLmhlYXApLCB0aGlzLmhlYXBfbGVuID0gMCwgdGhpcy5oZWFwX21heCA9IDAsIHRoaXMuZGVwdGggPSBuZXcgVWludDE2QXJyYXkoNTczKSwgcXQodGhpcy5kZXB0aCksIHRoaXMuc3ltX2J1ZiA9IDAsIHRoaXMubGl0X2J1ZnNpemUgPSAwLCB0aGlzLnN5bV9uZXh0ID0gMCwgdGhpcy5zeW1fZW5kID0gMCwgdGhpcy5vcHRfbGVuID0gMCwgdGhpcy5zdGF0aWNfbGVuID0gMCwgdGhpcy5tYXRjaGVzID0gMCwgdGhpcy5pbnNlcnQgPSAwLCB0aGlzLmJpX2J1ZiA9IDAsIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAgIH1cbiAgICB2YXIgc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAoIXQpIHJldHVybiAxO1xuICAgICAgICB2YXIgZSA9IHQuc3RhdGU7XG4gICAgICAgIHJldHVybiAhZSB8fCBlLnN0cm0gIT09IHQgfHwgZS5zdGF0dXMgIT09IER0ICYmIDU3ICE9PSBlLnN0YXR1cyAmJiA2OSAhPT0gZS5zdGF0dXMgJiYgNzMgIT09IGUuc3RhdHVzICYmIDkxICE9PSBlLnN0YXR1cyAmJiAxMDMgIT09IGUuc3RhdHVzICYmIGUuc3RhdHVzICE9PSBNdCAmJiBlLnN0YXR1cyAhPT0gUHQgPyAxIDogMDtcbiAgICAgIH0sXG4gICAgICBvZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmIChzZSh0KSkgcmV0dXJuIFV0KHQsIE90KTtcbiAgICAgICAgdC50b3RhbF9pbiA9IHQudG90YWxfb3V0ID0gMCwgdC5kYXRhX3R5cGUgPSBqdDtcbiAgICAgICAgdmFyIGUgPSB0LnN0YXRlO1xuICAgICAgICByZXR1cm4gZS5wZW5kaW5nID0gMCwgZS5wZW5kaW5nX291dCA9IDAsIGUud3JhcCA8IDAgJiYgKGUud3JhcCA9IC1lLndyYXApLCBlLnN0YXR1cyA9IDIgPT09IGUud3JhcCA/IDU3IDogZS53cmFwID8gRHQgOiBNdCwgdC5hZGxlciA9IDIgPT09IGUud3JhcCA/IDAgOiAxLCBlLmxhc3RfZmx1c2ggPSAtMiwgcHQoZSksIEF0O1xuICAgICAgfSxcbiAgICAgIGFlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgciA9IG9lKHQpO1xuICAgICAgICByZXR1cm4gciA9PT0gQXQgJiYgKChlID0gdC5zdGF0ZSkud2luZG93X3NpemUgPSAyICogZS53X3NpemUsIHF0KGUuaGVhZCksIGUubWF4X2xhenlfbWF0Y2ggPSBpZVtlLmxldmVsXS5tYXhfbGF6eSwgZS5nb29kX21hdGNoID0gaWVbZS5sZXZlbF0uZ29vZF9sZW5ndGgsIGUubmljZV9tYXRjaCA9IGllW2UubGV2ZWxdLm5pY2VfbGVuZ3RoLCBlLm1heF9jaGFpbl9sZW5ndGggPSBpZVtlLmxldmVsXS5tYXhfY2hhaW4sIGUuc3Ryc3RhcnQgPSAwLCBlLmJsb2NrX3N0YXJ0ID0gMCwgZS5sb29rYWhlYWQgPSAwLCBlLmluc2VydCA9IDAsIGUubWF0Y2hfbGVuZ3RoID0gZS5wcmV2X2xlbmd0aCA9IDIsIGUubWF0Y2hfYXZhaWxhYmxlID0gMCwgZS5pbnNfaCA9IDApLCByO1xuICAgICAgfSxcbiAgICAgIGhlID0gZnVuY3Rpb24gKHQsIGUsIHIsIGksIG4sIHMpIHtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gT3Q7XG4gICAgICAgIHZhciBvID0gMTtcbiAgICAgICAgaWYgKGUgPT09IHp0ICYmIChlID0gNiksIGkgPCAwID8gKG8gPSAwLCBpID0gLWkpIDogaSA+IDE1ICYmIChvID0gMiwgaSAtPSAxNiksIG4gPCAxIHx8IG4gPiA5IHx8IHIgIT09IEx0IHx8IGkgPCA4IHx8IGkgPiAxNSB8fCBlIDwgMCB8fCBlID4gOSB8fCBzIDwgMCB8fCBzID4gRnQgfHwgOCA9PT0gaSAmJiAxICE9PSBvKSByZXR1cm4gVXQodCwgT3QpO1xuICAgICAgICA4ID09PSBpICYmIChpID0gOSk7XG4gICAgICAgIHZhciBhID0gbmV3IG5lKCk7XG4gICAgICAgIHJldHVybiB0LnN0YXRlID0gYSwgYS5zdHJtID0gdCwgYS5zdGF0dXMgPSBEdCwgYS53cmFwID0gbywgYS5nemhlYWQgPSBudWxsLCBhLndfYml0cyA9IGksIGEud19zaXplID0gMSA8PCBhLndfYml0cywgYS53X21hc2sgPSBhLndfc2l6ZSAtIDEsIGEuaGFzaF9iaXRzID0gbiArIDcsIGEuaGFzaF9zaXplID0gMSA8PCBhLmhhc2hfYml0cywgYS5oYXNoX21hc2sgPSBhLmhhc2hfc2l6ZSAtIDEsIGEuaGFzaF9zaGlmdCA9IH5+KChhLmhhc2hfYml0cyArIDMgLSAxKSAvIDMpLCBhLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KDIgKiBhLndfc2l6ZSksIGEuaGVhZCA9IG5ldyBVaW50MTZBcnJheShhLmhhc2hfc2l6ZSksIGEucHJldiA9IG5ldyBVaW50MTZBcnJheShhLndfc2l6ZSksIGEubGl0X2J1ZnNpemUgPSAxIDw8IG4gKyA2LCBhLnBlbmRpbmdfYnVmX3NpemUgPSA0ICogYS5saXRfYnVmc2l6ZSwgYS5wZW5kaW5nX2J1ZiA9IG5ldyBVaW50OEFycmF5KGEucGVuZGluZ19idWZfc2l6ZSksIGEuc3ltX2J1ZiA9IGEubGl0X2J1ZnNpemUsIGEuc3ltX2VuZCA9IDMgKiAoYS5saXRfYnVmc2l6ZSAtIDEpLCBhLmxldmVsID0gZSwgYS5zdHJhdGVneSA9IHMsIGEubWV0aG9kID0gciwgYWUodCk7XG4gICAgICB9LFxuICAgICAgdWUgPSBoZSxcbiAgICAgIGxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHNlKHQpIHx8IDIgIT09IHQuc3RhdGUud3JhcCA/IE90IDogKHQuc3RhdGUuZ3poZWFkID0gZSwgQXQpO1xuICAgICAgfSxcbiAgICAgIGZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKHNlKHQpIHx8IGUgPiBrdCB8fCBlIDwgMCkgcmV0dXJuIHQgPyBVdCh0LCBPdCkgOiBPdDtcbiAgICAgICAgdmFyIHIgPSB0LnN0YXRlO1xuICAgICAgICBpZiAoIXQub3V0cHV0IHx8IDAgIT09IHQuYXZhaWxfaW4gJiYgIXQuaW5wdXQgfHwgci5zdGF0dXMgPT09IFB0ICYmIGUgIT09IHh0KSByZXR1cm4gVXQodCwgMCA9PT0gdC5hdmFpbF9vdXQgPyBUdCA6IE90KTtcbiAgICAgICAgdmFyIGkgPSByLmxhc3RfZmx1c2g7XG4gICAgICAgIGlmIChyLmxhc3RfZmx1c2ggPSBlLCAwICE9PSByLnBlbmRpbmcpIHtcbiAgICAgICAgICBpZiAoSHQodCksIDAgPT09IHQuYXZhaWxfb3V0KSByZXR1cm4gci5sYXN0X2ZsdXNoID0gLTEsIEF0O1xuICAgICAgICB9IGVsc2UgaWYgKDAgPT09IHQuYXZhaWxfaW4gJiYgWnQoZSkgPD0gWnQoaSkgJiYgZSAhPT0geHQpIHJldHVybiBVdCh0LCBUdCk7XG4gICAgICAgIGlmIChyLnN0YXR1cyA9PT0gUHQgJiYgMCAhPT0gdC5hdmFpbF9pbikgcmV0dXJuIFV0KHQsIFR0KTtcbiAgICAgICAgaWYgKHIuc3RhdHVzID09PSBEdCAmJiAwID09PSByLndyYXAgJiYgKHIuc3RhdHVzID0gTXQpLCByLnN0YXR1cyA9PT0gRHQpIHtcbiAgICAgICAgICB2YXIgbiA9IEx0ICsgKHIud19iaXRzIC0gOCA8PCA0KSA8PCA4O1xuICAgICAgICAgIGlmIChuIHw9IChyLnN0cmF0ZWd5ID49IEl0IHx8IHIubGV2ZWwgPCAyID8gMCA6IHIubGV2ZWwgPCA2ID8gMSA6IDYgPT09IHIubGV2ZWwgPyAyIDogMykgPDwgNiwgMCAhPT0gci5zdHJzdGFydCAmJiAobiB8PSAzMiksIFh0KHIsIG4gKz0gMzEgLSBuICUgMzEpLCAwICE9PSByLnN0cnN0YXJ0ICYmIChYdChyLCB0LmFkbGVyID4+PiAxNiksIFh0KHIsIDY1NTM1ICYgdC5hZGxlcikpLCB0LmFkbGVyID0gMSwgci5zdGF0dXMgPSBNdCwgSHQodCksIDAgIT09IHIucGVuZGluZykgcmV0dXJuIHIubGFzdF9mbHVzaCA9IC0xLCBBdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoNTcgPT09IHIuc3RhdHVzKSBpZiAodC5hZGxlciA9IDAsIEt0KHIsIDMxKSwgS3QociwgMTM5KSwgS3QociwgOCksIHIuZ3poZWFkKSBLdChyLCAoci5nemhlYWQudGV4dCA/IDEgOiAwKSArIChyLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKHIuZ3poZWFkLmV4dHJhID8gNCA6IDApICsgKHIuZ3poZWFkLm5hbWUgPyA4IDogMCkgKyAoci5nemhlYWQuY29tbWVudCA/IDE2IDogMCkpLCBLdChyLCAyNTUgJiByLmd6aGVhZC50aW1lKSwgS3Qociwgci5nemhlYWQudGltZSA+PiA4ICYgMjU1KSwgS3Qociwgci5nemhlYWQudGltZSA+PiAxNiAmIDI1NSksIEt0KHIsIHIuZ3poZWFkLnRpbWUgPj4gMjQgJiAyNTUpLCBLdChyLCA5ID09PSByLmxldmVsID8gMiA6IHIuc3RyYXRlZ3kgPj0gSXQgfHwgci5sZXZlbCA8IDIgPyA0IDogMCksIEt0KHIsIDI1NSAmIHIuZ3poZWFkLm9zKSwgci5nemhlYWQuZXh0cmEgJiYgci5nemhlYWQuZXh0cmEubGVuZ3RoICYmIChLdChyLCAyNTUgJiByLmd6aGVhZC5leHRyYS5sZW5ndGgpLCBLdChyLCByLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCAmIDI1NSkpLCByLmd6aGVhZC5oY3JjICYmICh0LmFkbGVyID0gZnQodC5hZGxlciwgci5wZW5kaW5nX2J1Ziwgci5wZW5kaW5nLCAwKSksIHIuZ3ppbmRleCA9IDAsIHIuc3RhdHVzID0gNjk7ZWxzZSBpZiAoS3QociwgMCksIEt0KHIsIDApLCBLdChyLCAwKSwgS3QociwgMCksIEt0KHIsIDApLCBLdChyLCA5ID09PSByLmxldmVsID8gMiA6IHIuc3RyYXRlZ3kgPj0gSXQgfHwgci5sZXZlbCA8IDIgPyA0IDogMCksIEt0KHIsIDMpLCByLnN0YXR1cyA9IE10LCBIdCh0KSwgMCAhPT0gci5wZW5kaW5nKSByZXR1cm4gci5sYXN0X2ZsdXNoID0gLTEsIEF0O1xuICAgICAgICBpZiAoNjkgPT09IHIuc3RhdHVzKSB7XG4gICAgICAgICAgaWYgKHIuZ3poZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gci5wZW5kaW5nLCBvID0gKDY1NTM1ICYgci5nemhlYWQuZXh0cmEubGVuZ3RoKSAtIHIuZ3ppbmRleDsgci5wZW5kaW5nICsgbyA+IHIucGVuZGluZ19idWZfc2l6ZTspIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSByLnBlbmRpbmdfYnVmX3NpemUgLSByLnBlbmRpbmc7XG4gICAgICAgICAgICAgIGlmIChyLnBlbmRpbmdfYnVmLnNldChyLmd6aGVhZC5leHRyYS5zdWJhcnJheShyLmd6aW5kZXgsIHIuZ3ppbmRleCArIGEpLCByLnBlbmRpbmcpLCByLnBlbmRpbmcgPSByLnBlbmRpbmdfYnVmX3NpemUsIHIuZ3poZWFkLmhjcmMgJiYgci5wZW5kaW5nID4gcyAmJiAodC5hZGxlciA9IGZ0KHQuYWRsZXIsIHIucGVuZGluZ19idWYsIHIucGVuZGluZyAtIHMsIHMpKSwgci5nemluZGV4ICs9IGEsIEh0KHQpLCAwICE9PSByLnBlbmRpbmcpIHJldHVybiByLmxhc3RfZmx1c2ggPSAtMSwgQXQ7XG4gICAgICAgICAgICAgIHMgPSAwLCBvIC09IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaCA9IG5ldyBVaW50OEFycmF5KHIuZ3poZWFkLmV4dHJhKTtcbiAgICAgICAgICAgIHIucGVuZGluZ19idWYuc2V0KGguc3ViYXJyYXkoci5nemluZGV4LCByLmd6aW5kZXggKyBvKSwgci5wZW5kaW5nKSwgci5wZW5kaW5nICs9IG8sIHIuZ3poZWFkLmhjcmMgJiYgci5wZW5kaW5nID4gcyAmJiAodC5hZGxlciA9IGZ0KHQuYWRsZXIsIHIucGVuZGluZ19idWYsIHIucGVuZGluZyAtIHMsIHMpKSwgci5nemluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5zdGF0dXMgPSA3MztcbiAgICAgICAgfVxuICAgICAgICBpZiAoNzMgPT09IHIuc3RhdHVzKSB7XG4gICAgICAgICAgaWYgKHIuZ3poZWFkLm5hbWUpIHtcbiAgICAgICAgICAgIHZhciB1LFxuICAgICAgICAgICAgICBsID0gci5wZW5kaW5nO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAoci5wZW5kaW5nID09PSByLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5nemhlYWQuaGNyYyAmJiByLnBlbmRpbmcgPiBsICYmICh0LmFkbGVyID0gZnQodC5hZGxlciwgci5wZW5kaW5nX2J1Ziwgci5wZW5kaW5nIC0gbCwgbCkpLCBIdCh0KSwgMCAhPT0gci5wZW5kaW5nKSByZXR1cm4gci5sYXN0X2ZsdXNoID0gLTEsIEF0O1xuICAgICAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHUgPSByLmd6aW5kZXggPCByLmd6aGVhZC5uYW1lLmxlbmd0aCA/IDI1NSAmIHIuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChyLmd6aW5kZXgrKykgOiAwLCBLdChyLCB1KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKDAgIT09IHUpO1xuICAgICAgICAgICAgci5nemhlYWQuaGNyYyAmJiByLnBlbmRpbmcgPiBsICYmICh0LmFkbGVyID0gZnQodC5hZGxlciwgci5wZW5kaW5nX2J1Ziwgci5wZW5kaW5nIC0gbCwgbCkpLCByLmd6aW5kZXggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLnN0YXR1cyA9IDkxO1xuICAgICAgICB9XG4gICAgICAgIGlmICg5MSA9PT0gci5zdGF0dXMpIHtcbiAgICAgICAgICBpZiAoci5nemhlYWQuY29tbWVudCkge1xuICAgICAgICAgICAgdmFyIGYsXG4gICAgICAgICAgICAgIGMgPSByLnBlbmRpbmc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChyLnBlbmRpbmcgPT09IHIucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyLmd6aGVhZC5oY3JjICYmIHIucGVuZGluZyA+IGMgJiYgKHQuYWRsZXIgPSBmdCh0LmFkbGVyLCByLnBlbmRpbmdfYnVmLCByLnBlbmRpbmcgLSBjLCBjKSksIEh0KHQpLCAwICE9PSByLnBlbmRpbmcpIHJldHVybiByLmxhc3RfZmx1c2ggPSAtMSwgQXQ7XG4gICAgICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZiA9IHIuZ3ppbmRleCA8IHIuZ3poZWFkLmNvbW1lbnQubGVuZ3RoID8gMjU1ICYgci5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHIuZ3ppbmRleCsrKSA6IDAsIEt0KHIsIGYpO1xuICAgICAgICAgICAgfSB3aGlsZSAoMCAhPT0gZik7XG4gICAgICAgICAgICByLmd6aGVhZC5oY3JjICYmIHIucGVuZGluZyA+IGMgJiYgKHQuYWRsZXIgPSBmdCh0LmFkbGVyLCByLnBlbmRpbmdfYnVmLCByLnBlbmRpbmcgLSBjLCBjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIuc3RhdHVzID0gMTAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgxMDMgPT09IHIuc3RhdHVzKSB7XG4gICAgICAgICAgaWYgKHIuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICAgIGlmIChyLnBlbmRpbmcgKyAyID4gci5wZW5kaW5nX2J1Zl9zaXplICYmIChIdCh0KSwgMCAhPT0gci5wZW5kaW5nKSkgcmV0dXJuIHIubGFzdF9mbHVzaCA9IC0xLCBBdDtcbiAgICAgICAgICAgIEt0KHIsIDI1NSAmIHQuYWRsZXIpLCBLdChyLCB0LmFkbGVyID4+IDggJiAyNTUpLCB0LmFkbGVyID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIuc3RhdHVzID0gTXQsIEh0KHQpLCAwICE9PSByLnBlbmRpbmcpIHJldHVybiByLmxhc3RfZmx1c2ggPSAtMSwgQXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgIT09IHQuYXZhaWxfaW4gfHwgMCAhPT0gci5sb29rYWhlYWQgfHwgZSAhPT0gX3QgJiYgci5zdGF0dXMgIT09IFB0KSB7XG4gICAgICAgICAgdmFyIGQgPSAwID09PSByLmxldmVsID8gUXQociwgZSkgOiByLnN0cmF0ZWd5ID09PSBJdCA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByOzspIHtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHQubG9va2FoZWFkICYmIChXdCh0KSwgMCA9PT0gdC5sb29rYWhlYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IF90KSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodC5tYXRjaF9sZW5ndGggPSAwLCByID0gZ3QodCwgMCwgdC53aW5kb3dbdC5zdHJzdGFydF0pLCB0Lmxvb2thaGVhZC0tLCB0LnN0cnN0YXJ0KyssIHIgJiYgKCR0KHQsICExKSwgMCA9PT0gdC5zdHJtLmF2YWlsX291dCkpIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQuaW5zZXJ0ID0gMCwgZSA9PT0geHQgPyAoJHQodCwgITApLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0ID8gMyA6IDQpIDogdC5zeW1fbmV4dCAmJiAoJHQodCwgITEpLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0KSA/IDEgOiAyO1xuICAgICAgICAgIH0ociwgZSkgOiByLnN0cmF0ZWd5ID09PSBOdCA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByLCBpLCBuLCBzLCBvID0gdC53aW5kb3c7Oykge1xuICAgICAgICAgICAgICBpZiAodC5sb29rYWhlYWQgPD0gQ3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoV3QodCksIHQubG9va2FoZWFkIDw9IEN0ICYmIGUgPT09IF90KSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdC5sb29rYWhlYWQpIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0Lm1hdGNoX2xlbmd0aCA9IDAsIHQubG9va2FoZWFkID49IDMgJiYgdC5zdHJzdGFydCA+IDAgJiYgKGkgPSBvW24gPSB0LnN0cnN0YXJ0IC0gMV0pID09PSBvWysrbl0gJiYgaSA9PT0gb1srK25dICYmIGkgPT09IG9bKytuXSkge1xuICAgICAgICAgICAgICAgIHMgPSB0LnN0cnN0YXJ0ICsgQ3Q7XG4gICAgICAgICAgICAgICAgZG8ge30gd2hpbGUgKGkgPT09IG9bKytuXSAmJiBpID09PSBvWysrbl0gJiYgaSA9PT0gb1srK25dICYmIGkgPT09IG9bKytuXSAmJiBpID09PSBvWysrbl0gJiYgaSA9PT0gb1srK25dICYmIGkgPT09IG9bKytuXSAmJiBpID09PSBvWysrbl0gJiYgbiA8IHMpO1xuICAgICAgICAgICAgICAgIHQubWF0Y2hfbGVuZ3RoID0gQ3QgLSAocyAtIG4pLCB0Lm1hdGNoX2xlbmd0aCA+IHQubG9va2FoZWFkICYmICh0Lm1hdGNoX2xlbmd0aCA9IHQubG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodC5tYXRjaF9sZW5ndGggPj0gMyA/IChyID0gZ3QodCwgMSwgdC5tYXRjaF9sZW5ndGggLSAzKSwgdC5sb29rYWhlYWQgLT0gdC5tYXRjaF9sZW5ndGgsIHQuc3Ryc3RhcnQgKz0gdC5tYXRjaF9sZW5ndGgsIHQubWF0Y2hfbGVuZ3RoID0gMCkgOiAociA9IGd0KHQsIDAsIHQud2luZG93W3Quc3Ryc3RhcnRdKSwgdC5sb29rYWhlYWQtLSwgdC5zdHJzdGFydCsrKSwgciAmJiAoJHQodCwgITEpLCAwID09PSB0LnN0cm0uYXZhaWxfb3V0KSkgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC5pbnNlcnQgPSAwLCBlID09PSB4dCA/ICgkdCh0LCAhMCksIDAgPT09IHQuc3RybS5hdmFpbF9vdXQgPyAzIDogNCkgOiB0LnN5bV9uZXh0ICYmICgkdCh0LCAhMSksIDAgPT09IHQuc3RybS5hdmFpbF9vdXQpID8gMSA6IDI7XG4gICAgICAgICAgfShyLCBlKSA6IGllW3IubGV2ZWxdLmZ1bmMociwgZSk7XG4gICAgICAgICAgaWYgKDMgIT09IGQgJiYgNCAhPT0gZCB8fCAoci5zdGF0dXMgPSBQdCksIDEgPT09IGQgfHwgMyA9PT0gZCkgcmV0dXJuIDAgPT09IHQuYXZhaWxfb3V0ICYmIChyLmxhc3RfZmx1c2ggPSAtMSksIEF0O1xuICAgICAgICAgIGlmICgyID09PSBkICYmIChlID09PSB3dCA/IG10KHIpIDogZSAhPT0ga3QgJiYgKHl0KHIsIDAsIDAsICExKSwgZSA9PT0gYnQgJiYgKHF0KHIuaGVhZCksIDAgPT09IHIubG9va2FoZWFkICYmIChyLnN0cnN0YXJ0ID0gMCwgci5ibG9ja19zdGFydCA9IDAsIHIuaW5zZXJ0ID0gMCkpKSwgSHQodCksIDAgPT09IHQuYXZhaWxfb3V0KSkgcmV0dXJuIHIubGFzdF9mbHVzaCA9IC0xLCBBdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAhPT0geHQgPyBBdCA6IHIud3JhcCA8PSAwID8gU3QgOiAoMiA9PT0gci53cmFwID8gKEt0KHIsIDI1NSAmIHQuYWRsZXIpLCBLdChyLCB0LmFkbGVyID4+IDggJiAyNTUpLCBLdChyLCB0LmFkbGVyID4+IDE2ICYgMjU1KSwgS3QociwgdC5hZGxlciA+PiAyNCAmIDI1NSksIEt0KHIsIDI1NSAmIHQudG90YWxfaW4pLCBLdChyLCB0LnRvdGFsX2luID4+IDggJiAyNTUpLCBLdChyLCB0LnRvdGFsX2luID4+IDE2ICYgMjU1KSwgS3QociwgdC50b3RhbF9pbiA+PiAyNCAmIDI1NSkpIDogKFh0KHIsIHQuYWRsZXIgPj4+IDE2KSwgWHQociwgNjU1MzUgJiB0LmFkbGVyKSksIEh0KHQpLCByLndyYXAgPiAwICYmIChyLndyYXAgPSAtci53cmFwKSwgMCAhPT0gci5wZW5kaW5nID8gQXQgOiBTdCk7XG4gICAgICB9LFxuICAgICAgY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAoc2UodCkpIHJldHVybiBPdDtcbiAgICAgICAgdmFyIGUgPSB0LnN0YXRlLnN0YXR1cztcbiAgICAgICAgcmV0dXJuIHQuc3RhdGUgPSBudWxsLCBlID09PSBNdCA/IFV0KHQsIEV0KSA6IEF0O1xuICAgICAgfSxcbiAgICAgIGRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLmxlbmd0aDtcbiAgICAgICAgaWYgKHNlKHQpKSByZXR1cm4gT3Q7XG4gICAgICAgIHZhciBpID0gdC5zdGF0ZSxcbiAgICAgICAgICBuID0gaS53cmFwO1xuICAgICAgICBpZiAoMiA9PT0gbiB8fCAxID09PSBuICYmIGkuc3RhdHVzICE9PSBEdCB8fCBpLmxvb2thaGVhZCkgcmV0dXJuIE90O1xuICAgICAgICBpZiAoMSA9PT0gbiAmJiAodC5hZGxlciA9IHV0KHQuYWRsZXIsIGUsIHIsIDApKSwgaS53cmFwID0gMCwgciA+PSBpLndfc2l6ZSkge1xuICAgICAgICAgIDAgPT09IG4gJiYgKHF0KGkuaGVhZCksIGkuc3Ryc3RhcnQgPSAwLCBpLmJsb2NrX3N0YXJ0ID0gMCwgaS5pbnNlcnQgPSAwKTtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KGkud19zaXplKTtcbiAgICAgICAgICBzLnNldChlLnN1YmFycmF5KHIgLSBpLndfc2l6ZSwgciksIDApLCBlID0gcywgciA9IGkud19zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvID0gdC5hdmFpbF9pbixcbiAgICAgICAgICBhID0gdC5uZXh0X2luLFxuICAgICAgICAgIGggPSB0LmlucHV0O1xuICAgICAgICBmb3IgKHQuYXZhaWxfaW4gPSByLCB0Lm5leHRfaW4gPSAwLCB0LmlucHV0ID0gZSwgV3QoaSk7IGkubG9va2FoZWFkID49IDM7KSB7XG4gICAgICAgICAgdmFyIHUgPSBpLnN0cnN0YXJ0LFxuICAgICAgICAgICAgbCA9IGkubG9va2FoZWFkIC0gMjtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpLmluc19oID0gVnQoaSwgaS5pbnNfaCwgaS53aW5kb3dbdSArIDMgLSAxXSksIGkucHJldlt1ICYgaS53X21hc2tdID0gaS5oZWFkW2kuaW5zX2hdLCBpLmhlYWRbaS5pbnNfaF0gPSB1LCB1Kys7XG4gICAgICAgICAgfSB3aGlsZSAoLS1sKTtcbiAgICAgICAgICBpLnN0cnN0YXJ0ID0gdSwgaS5sb29rYWhlYWQgPSAyLCBXdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5zdHJzdGFydCArPSBpLmxvb2thaGVhZCwgaS5ibG9ja19zdGFydCA9IGkuc3Ryc3RhcnQsIGkuaW5zZXJ0ID0gaS5sb29rYWhlYWQsIGkubG9va2FoZWFkID0gMCwgaS5tYXRjaF9sZW5ndGggPSBpLnByZXZfbGVuZ3RoID0gMiwgaS5tYXRjaF9hdmFpbGFibGUgPSAwLCB0Lm5leHRfaW4gPSBhLCB0LmlucHV0ID0gaCwgdC5hdmFpbF9pbiA9IG8sIGkud3JhcCA9IG4sIEF0O1xuICAgICAgfSxcbiAgICAgIHBlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKTtcbiAgICAgIH0sXG4gICAgICB5ZSA9IHtcbiAgICAgICAgYXNzaWduOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyByLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBpID0gci5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHQoaSkpIHRocm93IG5ldyBUeXBlRXJyb3IoaSArIFwibXVzdCBiZSBub24tb2JqZWN0XCIpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIGkpIHBlKGksIG4pICYmIChlW25dID0gaVtuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gMCwgaSA9IHQubGVuZ3RoOyByIDwgaTsgcisrKSBlICs9IHRbcl0ubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIG4gPSBuZXcgVWludDhBcnJheShlKSwgcyA9IDAsIG8gPSAwLCBhID0gdC5sZW5ndGg7IHMgPCBhOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBoID0gdFtzXTtcbiAgICAgICAgICAgIG4uc2V0KGgsIG8pLCBvICs9IGgubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZlID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIHZlID0gITE7XG4gICAgfVxuICAgIGZvciAodmFyIGdlID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSwgbWUgPSAwOyBtZSA8IDI1NjsgbWUrKykgZ2VbbWVdID0gbWUgPj0gMjUyID8gNiA6IG1lID49IDI0OCA/IDUgOiBtZSA+PSAyNDAgPyA0IDogbWUgPj0gMjI0ID8gMyA6IG1lID49IDE5MiA/IDIgOiAxO1xuICAgIGdlWzI1NF0gPSBnZVsyNTRdID0gMTtcbiAgICB2YXIgX2UgPSB7XG4gICAgICAgIHN0cmluZzJidWY6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgVGV4dEVuY29kZXIgJiYgVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZSkgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KTtcbiAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBvID0gdC5sZW5ndGgsXG4gICAgICAgICAgICBhID0gMDtcbiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbzsgbisrKSA1NTI5NiA9PSAoNjQ1MTIgJiAociA9IHQuY2hhckNvZGVBdChuKSkpICYmIG4gKyAxIDwgbyAmJiA1NjMyMCA9PSAoNjQ1MTIgJiAoaSA9IHQuY2hhckNvZGVBdChuICsgMSkpKSAmJiAociA9IDY1NTM2ICsgKHIgLSA1NTI5NiA8PCAxMCkgKyAoaSAtIDU2MzIwKSwgbisrKSwgYSArPSByIDwgMTI4ID8gMSA6IHIgPCAyMDQ4ID8gMiA6IHIgPCA2NTUzNiA/IDMgOiA0O1xuICAgICAgICAgIGZvciAoZSA9IG5ldyBVaW50OEFycmF5KGEpLCBzID0gMCwgbiA9IDA7IHMgPCBhOyBuKyspIDU1Mjk2ID09ICg2NDUxMiAmIChyID0gdC5jaGFyQ29kZUF0KG4pKSkgJiYgbiArIDEgPCBvICYmIDU2MzIwID09ICg2NDUxMiAmIChpID0gdC5jaGFyQ29kZUF0KG4gKyAxKSkpICYmIChyID0gNjU1MzYgKyAociAtIDU1Mjk2IDw8IDEwKSArIChpIC0gNTYzMjApLCBuKyspLCByIDwgMTI4ID8gZVtzKytdID0gciA6IHIgPCAyMDQ4ID8gKGVbcysrXSA9IDE5MiB8IHIgPj4+IDYsIGVbcysrXSA9IDEyOCB8IDYzICYgcikgOiByIDwgNjU1MzYgPyAoZVtzKytdID0gMjI0IHwgciA+Pj4gMTIsIGVbcysrXSA9IDEyOCB8IHIgPj4+IDYgJiA2MywgZVtzKytdID0gMTI4IHwgNjMgJiByKSA6IChlW3MrK10gPSAyNDAgfCByID4+PiAxOCwgZVtzKytdID0gMTI4IHwgciA+Pj4gMTIgJiA2MywgZVtzKytdID0gMTI4IHwgciA+Pj4gNiAmIDYzLCBlW3MrK10gPSAxMjggfCA2MyAmIHIpO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBidWYyc3RyaW5nOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG4gPSBlIHx8IHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFRleHREZWNvZGVyICYmIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodC5zdWJhcnJheSgwLCBlKSk7XG4gICAgICAgICAgdmFyIHMgPSBuZXcgQXJyYXkoMiAqIG4pO1xuICAgICAgICAgIGZvciAoaSA9IDAsIHIgPSAwOyByIDwgbjspIHtcbiAgICAgICAgICAgIHZhciBvID0gdFtyKytdO1xuICAgICAgICAgICAgaWYgKG8gPCAxMjgpIHNbaSsrXSA9IG87ZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhID0gZ2Vbb107XG4gICAgICAgICAgICAgIGlmIChhID4gNCkgc1tpKytdID0gNjU1MzMsIHIgKz0gYSAtIDE7ZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChvICY9IDIgPT09IGEgPyAzMSA6IDMgPT09IGEgPyAxNSA6IDc7IGEgPiAxICYmIHIgPCBuOykgbyA9IG8gPDwgNiB8IDYzICYgdFtyKytdLCBhLS07XG4gICAgICAgICAgICAgICAgYSA+IDEgPyBzW2krK10gPSA2NTUzMyA6IG8gPCA2NTUzNiA/IHNbaSsrXSA9IG8gOiAobyAtPSA2NTUzNiwgc1tpKytdID0gNTUyOTYgfCBvID4+IDEwICYgMTAyMywgc1tpKytdID0gNTYzMjAgfCAxMDIzICYgbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBpZiAoZSA8IDY1NTM0ICYmIHQuc3ViYXJyYXkgJiYgdmUpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHQubGVuZ3RoID09PSBlID8gdCA6IHQuc3ViYXJyYXkoMCwgZSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IFwiXCIsIGkgPSAwOyBpIDwgZTsgaSsrKSByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodFtpXSk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9KHMsIGkpO1xuICAgICAgICB9LFxuICAgICAgICB1dGY4Ym9yZGVyOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIChlID0gZSB8fCB0Lmxlbmd0aCkgPiB0Lmxlbmd0aCAmJiAoZSA9IHQubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciByID0gZSAtIDE7IHIgPj0gMCAmJiAxMjggPT0gKDE5MiAmIHRbcl0pOykgci0tO1xuICAgICAgICAgIHJldHVybiByIDwgMCB8fCAwID09PSByID8gZSA6IHIgKyBnZVt0W3JdXSA+IGUgPyByIDogZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gbnVsbCwgdGhpcy5uZXh0X2luID0gMCwgdGhpcy5hdmFpbF9pbiA9IDAsIHRoaXMudG90YWxfaW4gPSAwLCB0aGlzLm91dHB1dCA9IG51bGwsIHRoaXMubmV4dF9vdXQgPSAwLCB0aGlzLmF2YWlsX291dCA9IDAsIHRoaXMudG90YWxfb3V0ID0gMCwgdGhpcy5tc2cgPSBcIlwiLCB0aGlzLnN0YXRlID0gbnVsbCwgdGhpcy5kYXRhX3R5cGUgPSAyLCB0aGlzLmFkbGVyID0gMDtcbiAgICAgIH0sXG4gICAgICBiZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICB4ZSA9IGR0LlpfTk9fRkxVU0gsXG4gICAgICBrZSA9IGR0LlpfU1lOQ19GTFVTSCxcbiAgICAgIEFlID0gZHQuWl9GVUxMX0ZMVVNILFxuICAgICAgU2UgPSBkdC5aX0ZJTklTSCxcbiAgICAgIE9lID0gZHQuWl9PSyxcbiAgICAgIEVlID0gZHQuWl9TVFJFQU1fRU5ELFxuICAgICAgVGUgPSBkdC5aX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgICB6ZSA9IGR0LlpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICAgIEJlID0gZHQuWl9ERUZMQVRFRDtcbiAgICBmdW5jdGlvbiBJZSh0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB5ZS5hc3NpZ24oe1xuICAgICAgICBsZXZlbDogVGUsXG4gICAgICAgIG1ldGhvZDogQmUsXG4gICAgICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgICAgICBtZW1MZXZlbDogOCxcbiAgICAgICAgc3RyYXRlZ3k6IHplXG4gICAgICB9LCB0IHx8IHt9KTtcbiAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zO1xuICAgICAgZS5yYXcgJiYgZS53aW5kb3dCaXRzID4gMCA/IGUud2luZG93Qml0cyA9IC1lLndpbmRvd0JpdHMgOiBlLmd6aXAgJiYgZS53aW5kb3dCaXRzID4gMCAmJiBlLndpbmRvd0JpdHMgPCAxNiAmJiAoZS53aW5kb3dCaXRzICs9IDE2KSwgdGhpcy5lcnIgPSAwLCB0aGlzLm1zZyA9IFwiXCIsIHRoaXMuZW5kZWQgPSAhMSwgdGhpcy5jaHVua3MgPSBbXSwgdGhpcy5zdHJtID0gbmV3IHdlKCksIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgdmFyIHIgPSB1ZSh0aGlzLnN0cm0sIGUubGV2ZWwsIGUubWV0aG9kLCBlLndpbmRvd0JpdHMsIGUubWVtTGV2ZWwsIGUuc3RyYXRlZ3kpO1xuICAgICAgaWYgKHIgIT09IE9lKSB0aHJvdyBuZXcgRXJyb3IoY3Rbcl0pO1xuICAgICAgaWYgKGUuaGVhZGVyICYmIGxlKHRoaXMuc3RybSwgZS5oZWFkZXIpLCBlLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChpID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5kaWN0aW9uYXJ5ID8gX2Uuc3RyaW5nMmJ1ZihlLmRpY3Rpb25hcnkpIDogXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiID09PSBiZS5jYWxsKGUuZGljdGlvbmFyeSkgPyBuZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpIDogZS5kaWN0aW9uYXJ5LCAociA9IGRlKHRoaXMuc3RybSwgaSkpICE9PSBPZSkgdGhyb3cgbmV3IEVycm9yKGN0W3JdKTtcbiAgICAgICAgdGhpcy5fZGljdF9zZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgSWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgIGksXG4gICAgICAgIG4gPSB0aGlzLnN0cm0sXG4gICAgICAgIHMgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiAhMTtcbiAgICAgIGZvciAoaSA9IGUgPT09IH5+ZSA/IGUgOiAhMCA9PT0gZSA/IFNlIDogeGUsIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBuLmlucHV0ID0gX2Uuc3RyaW5nMmJ1Zih0KSA6IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiA9PT0gYmUuY2FsbCh0KSA/IG4uaW5wdXQgPSBuZXcgVWludDhBcnJheSh0KSA6IG4uaW5wdXQgPSB0LCBuLm5leHRfaW4gPSAwLCBuLmF2YWlsX2luID0gbi5pbnB1dC5sZW5ndGg7OykgaWYgKDAgPT09IG4uYXZhaWxfb3V0ICYmIChuLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KHMpLCBuLm5leHRfb3V0ID0gMCwgbi5hdmFpbF9vdXQgPSBzKSwgKGkgPT09IGtlIHx8IGkgPT09IEFlKSAmJiBuLmF2YWlsX291dCA8PSA2KSB0aGlzLm9uRGF0YShuLm91dHB1dC5zdWJhcnJheSgwLCBuLm5leHRfb3V0KSksIG4uYXZhaWxfb3V0ID0gMDtlbHNlIHtcbiAgICAgICAgaWYgKChyID0gZmUobiwgaSkpID09PSBFZSkgcmV0dXJuIG4ubmV4dF9vdXQgPiAwICYmIHRoaXMub25EYXRhKG4ub3V0cHV0LnN1YmFycmF5KDAsIG4ubmV4dF9vdXQpKSwgciA9IGNlKHRoaXMuc3RybSksIHRoaXMub25FbmQociksIHRoaXMuZW5kZWQgPSAhMCwgciA9PT0gT2U7XG4gICAgICAgIGlmICgwICE9PSBuLmF2YWlsX291dCkge1xuICAgICAgICAgIGlmIChpID4gMCAmJiBuLm5leHRfb3V0ID4gMCkgdGhpcy5vbkRhdGEobi5vdXRwdXQuc3ViYXJyYXkoMCwgbi5uZXh0X291dCkpLCBuLmF2YWlsX291dCA9IDA7ZWxzZSBpZiAoMCA9PT0gbi5hdmFpbF9pbikgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB0aGlzLm9uRGF0YShuLm91dHB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgSWUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKHQpO1xuICAgIH0sIEllLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ID09PSBPZSAmJiAodGhpcy5yZXN1bHQgPSB5ZS5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuZXJyID0gdCwgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xuICAgIH07XG4gICAgdmFyIE5lID0gMTYyMDksXG4gICAgICBGZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbixcbiAgICAgICAgICBzLFxuICAgICAgICAgIG8sXG4gICAgICAgICAgYSxcbiAgICAgICAgICBoLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIHksXG4gICAgICAgICAgdixcbiAgICAgICAgICBnLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgXyxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGIsXG4gICAgICAgICAgeCxcbiAgICAgICAgICBrLFxuICAgICAgICAgIEEsXG4gICAgICAgICAgUyxcbiAgICAgICAgICBPID0gdC5zdGF0ZTtcbiAgICAgICAgciA9IHQubmV4dF9pbiwgQSA9IHQuaW5wdXQsIGkgPSByICsgKHQuYXZhaWxfaW4gLSA1KSwgbiA9IHQubmV4dF9vdXQsIFMgPSB0Lm91dHB1dCwgcyA9IG4gLSAoZSAtIHQuYXZhaWxfb3V0KSwgbyA9IG4gKyAodC5hdmFpbF9vdXQgLSAyNTcpLCBhID0gTy5kbWF4LCBoID0gTy53c2l6ZSwgdSA9IE8ud2hhdmUsIGwgPSBPLnduZXh0LCBmID0gTy53aW5kb3csIGMgPSBPLmhvbGQsIGQgPSBPLmJpdHMsIHAgPSBPLmxlbmNvZGUsIHkgPSBPLmRpc3Rjb2RlLCB2ID0gKDEgPDwgTy5sZW5iaXRzKSAtIDEsIGcgPSAoMSA8PCBPLmRpc3RiaXRzKSAtIDE7XG4gICAgICAgIHQ6IGRvIHtcbiAgICAgICAgICBkIDwgMTUgJiYgKGMgKz0gQVtyKytdIDw8IGQsIGQgKz0gOCwgYyArPSBBW3IrK10gPDwgZCwgZCArPSA4KSwgbSA9IHBbYyAmIHZdO1xuICAgICAgICAgIGU6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChjID4+Pj0gXyA9IG0gPj4+IDI0LCBkIC09IF8sIDAgPT0gKF8gPSBtID4+PiAxNiAmIDI1NSkpIFNbbisrXSA9IDY1NTM1ICYgbTtlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCEoMTYgJiBfKSkge1xuICAgICAgICAgICAgICAgIGlmICg2NCAmIF8pIHtcbiAgICAgICAgICAgICAgICAgIGlmICgzMiAmIF8pIHtcbiAgICAgICAgICAgICAgICAgICAgTy5tb2RlID0gMTYxOTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCIsIE8ubW9kZSA9IE5lO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHBbKDY1NTM1ICYgbSkgKyAoYyAmICgxIDw8IF8pIC0gMSldO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh3ID0gNjU1MzUgJiBtLCAoXyAmPSAxNSkgJiYgKGQgPCBfICYmIChjICs9IEFbcisrXSA8PCBkLCBkICs9IDgpLCB3ICs9IGMgJiAoMSA8PCBfKSAtIDEsIGMgPj4+PSBfLCBkIC09IF8pLCBkIDwgMTUgJiYgKGMgKz0gQVtyKytdIDw8IGQsIGQgKz0gOCwgYyArPSBBW3IrK10gPDwgZCwgZCArPSA4KSwgbSA9IHlbYyAmIGddOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+Pj49IF8gPSBtID4+PiAyNCwgZCAtPSBfLCAxNiAmIChfID0gbSA+Pj4gMTYgJiAyNTUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYiA9IDY1NTM1ICYgbSwgZCA8IChfICY9IDE1KSAmJiAoYyArPSBBW3IrK10gPDwgZCwgKGQgKz0gOCkgPCBfICYmIChjICs9IEFbcisrXSA8PCBkLCBkICs9IDgpKSwgKGIgKz0gYyAmICgxIDw8IF8pIC0gMSkgPiBhKSB7XG4gICAgICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLCBPLm1vZGUgPSBOZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjID4+Pj0gXywgZCAtPSBfLCBiID4gKF8gPSBuIC0gcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfID0gYiAtIF8pID4gdSAmJiBPLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIiwgTy5tb2RlID0gTmU7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9IDAsIGsgPSBmLCAwID09PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHggKz0gaCAtIF8sIF8gPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3IC09IF87XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFNbbisrXSA9IGZbeCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gbiAtIGIsIGsgPSBTO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsIDwgXykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICs9IGggKyBsIC0gXywgKF8gLT0gbCkgPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3IC09IF87XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFNbbisrXSA9IGZbeCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA9IDAsIGwgPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHcgLT0gXyA9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTW24rK10gPSBmW3grK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBuIC0gYiwgayA9IFM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggKz0gbCAtIF8sIF8gPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdyAtPSBfO1xuICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNbbisrXSA9IGZbeCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLV8pO1xuICAgICAgICAgICAgICAgICAgICAgIHggPSBuIC0gYiwgayA9IFM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHcgPiAyOykgU1tuKytdID0ga1t4KytdLCBTW24rK10gPSBrW3grK10sIFNbbisrXSA9IGtbeCsrXSwgdyAtPSAzO1xuICAgICAgICAgICAgICAgICAgICB3ICYmIChTW24rK10gPSBrW3grK10sIHcgPiAxICYmIChTW24rK10gPSBrW3grK10pKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBuIC0gYjtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIFNbbisrXSA9IFNbeCsrXSwgU1tuKytdID0gU1t4KytdLCBTW24rK10gPSBTW3grK10sIHcgLT0gMztcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodyA+IDIpO1xuICAgICAgICAgICAgICAgICAgICB3ICYmIChTW24rK10gPSBTW3grK10sIHcgPiAxICYmIChTW24rK10gPSBTW3grK10pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoNjQgJiBfKSB7XG4gICAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsIE8ubW9kZSA9IE5lO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHlbKDY1NTM1ICYgbSkgKyAoYyAmICgxIDw8IF8pIC0gMSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHIgPCBpICYmIG4gPCBvKTtcbiAgICAgICAgciAtPSB3ID0gZCA+PiAzLCBjICY9ICgxIDw8IChkIC09IHcgPDwgMykpIC0gMSwgdC5uZXh0X2luID0gciwgdC5uZXh0X291dCA9IG4sIHQuYXZhaWxfaW4gPSByIDwgaSA/IGkgLSByICsgNSA6IDUgLSAociAtIGkpLCB0LmF2YWlsX291dCA9IG4gPCBvID8gbyAtIG4gKyAyNTcgOiAyNTcgLSAobiAtIG8pLCBPLmhvbGQgPSBjLCBPLmJpdHMgPSBkO1xuICAgICAgfSxcbiAgICAgIGplID0gbmV3IFVpbnQxNkFycmF5KFszLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLCAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMF0pLFxuICAgICAgTGUgPSBuZXcgVWludDhBcnJheShbMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhdKSxcbiAgICAgIENlID0gbmV3IFVpbnQxNkFycmF5KFsxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSwgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMF0pLFxuICAgICAgUmUgPSBuZXcgVWludDhBcnJheShbMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LCAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XSksXG4gICAgICBEZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBpLCBuLCBzLCBvLCBhKSB7XG4gICAgICAgIHZhciBoLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIHksXG4gICAgICAgICAgdixcbiAgICAgICAgICBnID0gYS5iaXRzLFxuICAgICAgICAgIG0gPSAwLFxuICAgICAgICAgIF8gPSAwLFxuICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgIGIgPSAwLFxuICAgICAgICAgIHggPSAwLFxuICAgICAgICAgIGsgPSAwLFxuICAgICAgICAgIEEgPSAwLFxuICAgICAgICAgIFMgPSAwLFxuICAgICAgICAgIE8gPSAwLFxuICAgICAgICAgIEUgPSAwLFxuICAgICAgICAgIFQgPSBudWxsLFxuICAgICAgICAgIHogPSBuZXcgVWludDE2QXJyYXkoMTYpLFxuICAgICAgICAgIEIgPSBuZXcgVWludDE2QXJyYXkoMTYpLFxuICAgICAgICAgIEkgPSBudWxsO1xuICAgICAgICBmb3IgKG0gPSAwOyBtIDw9IDE1OyBtKyspIHpbbV0gPSAwO1xuICAgICAgICBmb3IgKF8gPSAwOyBfIDwgaTsgXysrKSB6W2VbciArIF9dXSsrO1xuICAgICAgICBmb3IgKHggPSBnLCBiID0gMTU7IGIgPj0gMSAmJiAwID09PSB6W2JdOyBiLS0pO1xuICAgICAgICBpZiAoeCA+IGIgJiYgKHggPSBiKSwgMCA9PT0gYikgcmV0dXJuIG5bcysrXSA9IDIwOTcxNTIwLCBuW3MrK10gPSAyMDk3MTUyMCwgYS5iaXRzID0gMSwgMDtcbiAgICAgICAgZm9yICh3ID0gMTsgdyA8IGIgJiYgMCA9PT0gelt3XTsgdysrKTtcbiAgICAgICAgZm9yICh4IDwgdyAmJiAoeCA9IHcpLCBTID0gMSwgbSA9IDE7IG0gPD0gMTU7IG0rKykgaWYgKFMgPDw9IDEsIChTIC09IHpbbV0pIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoUyA+IDAgJiYgKDAgPT09IHQgfHwgMSAhPT0gYikpIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChCWzFdID0gMCwgbSA9IDE7IG0gPCAxNTsgbSsrKSBCW20gKyAxXSA9IEJbbV0gKyB6W21dO1xuICAgICAgICBmb3IgKF8gPSAwOyBfIDwgaTsgXysrKSAwICE9PSBlW3IgKyBfXSAmJiAob1tCW2VbciArIF9dXSsrXSA9IF8pO1xuICAgICAgICBpZiAoMCA9PT0gdCA/IChUID0gSSA9IG8sIGQgPSAyMCkgOiAxID09PSB0ID8gKFQgPSBqZSwgSSA9IExlLCBkID0gMjU3KSA6IChUID0gQ2UsIEkgPSBSZSwgZCA9IDApLCBFID0gMCwgXyA9IDAsIG0gPSB3LCBjID0gcywgayA9IHgsIEEgPSAwLCBsID0gLTEsIGYgPSAoTyA9IDEgPDwgeCkgLSAxLCAxID09PSB0ICYmIE8gPiA4NTIgfHwgMiA9PT0gdCAmJiBPID4gNTkyKSByZXR1cm4gMTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHAgPSBtIC0gQSwgb1tfXSArIDEgPCBkID8gKHkgPSAwLCB2ID0gb1tfXSkgOiBvW19dID49IGQgPyAoeSA9IElbb1tfXSAtIGRdLCB2ID0gVFtvW19dIC0gZF0pIDogKHkgPSA5NiwgdiA9IDApLCBoID0gMSA8PCBtIC0gQSwgdyA9IHUgPSAxIDw8IGs7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbltjICsgKEUgPj4gQSkgKyAodSAtPSBoKV0gPSBwIDw8IDI0IHwgeSA8PCAxNiB8IHY7XG4gICAgICAgICAgfSB3aGlsZSAoMCAhPT0gdSk7XG4gICAgICAgICAgZm9yIChoID0gMSA8PCBtIC0gMTsgRSAmIGg7KSBoID4+PSAxO1xuICAgICAgICAgIGlmICgwICE9PSBoID8gKEUgJj0gaCAtIDEsIEUgKz0gaCkgOiBFID0gMCwgXysrLCAwID09IC0telttXSkge1xuICAgICAgICAgICAgaWYgKG0gPT09IGIpIGJyZWFrO1xuICAgICAgICAgICAgbSA9IGVbciArIG9bX11dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobSA+IHggJiYgKEUgJiBmKSAhPT0gbCkge1xuICAgICAgICAgICAgZm9yICgwID09PSBBICYmIChBID0geCksIGMgKz0gdywgUyA9IDEgPDwgKGsgPSBtIC0gQSk7IGsgKyBBIDwgYiAmJiAhKChTIC09IHpbayArIEFdKSA8PSAwKTspIGsrKywgUyA8PD0gMTtcbiAgICAgICAgICAgIGlmIChPICs9IDEgPDwgaywgMSA9PT0gdCAmJiBPID4gODUyIHx8IDIgPT09IHQgJiYgTyA+IDU5MikgcmV0dXJuIDE7XG4gICAgICAgICAgICBuW2wgPSBFICYgZl0gPSB4IDw8IDI0IHwgayA8PCAxNiB8IGMgLSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAhPT0gRSAmJiAobltjICsgRV0gPSBtIC0gQSA8PCAyNCB8IDY0IDw8IDE2KSwgYS5iaXRzID0geCwgMDtcbiAgICAgIH0sXG4gICAgICBNZSA9IGR0LlpfRklOSVNILFxuICAgICAgUGUgPSBkdC5aX0JMT0NLLFxuICAgICAgVWUgPSBkdC5aX1RSRUVTLFxuICAgICAgWmUgPSBkdC5aX09LLFxuICAgICAgcWUgPSBkdC5aX1NUUkVBTV9FTkQsXG4gICAgICBKZSA9IGR0LlpfTkVFRF9ESUNULFxuICAgICAgVmUgPSBkdC5aX1NUUkVBTV9FUlJPUixcbiAgICAgIEhlID0gZHQuWl9EQVRBX0VSUk9SLFxuICAgICAgJGUgPSBkdC5aX01FTV9FUlJPUixcbiAgICAgIEtlID0gZHQuWl9CVUZfRVJST1IsXG4gICAgICBYZSA9IGR0LlpfREVGTEFURUQsXG4gICAgICBZZSA9IDE2MTgwLFxuICAgICAgR2UgPSAxNjE5MCxcbiAgICAgIFdlID0gMTYxOTEsXG4gICAgICBRZSA9IDE2MTkyLFxuICAgICAgdHIgPSAxNjE5NCxcbiAgICAgIGVyID0gMTYxOTksXG4gICAgICByciA9IDE2MjAwLFxuICAgICAgaXIgPSAxNjIwNixcbiAgICAgIG5yID0gMTYyMDksXG4gICAgICBzciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAodCA+Pj4gMjQgJiAyNTUpICsgKHQgPj4+IDggJiA2NTI4MCkgKyAoKDY1MjgwICYgdCkgPDwgOCkgKyAoKDI1NSAmIHQpIDw8IDI0KTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gb3IoKSB7XG4gICAgICB0aGlzLnN0cm0gPSBudWxsLCB0aGlzLm1vZGUgPSAwLCB0aGlzLmxhc3QgPSAhMSwgdGhpcy53cmFwID0gMCwgdGhpcy5oYXZlZGljdCA9ICExLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5kbWF4ID0gMCwgdGhpcy5jaGVjayA9IDAsIHRoaXMudG90YWwgPSAwLCB0aGlzLmhlYWQgPSBudWxsLCB0aGlzLndiaXRzID0gMCwgdGhpcy53c2l6ZSA9IDAsIHRoaXMud2hhdmUgPSAwLCB0aGlzLnduZXh0ID0gMCwgdGhpcy53aW5kb3cgPSBudWxsLCB0aGlzLmhvbGQgPSAwLCB0aGlzLmJpdHMgPSAwLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMub2Zmc2V0ID0gMCwgdGhpcy5leHRyYSA9IDAsIHRoaXMubGVuY29kZSA9IG51bGwsIHRoaXMuZGlzdGNvZGUgPSBudWxsLCB0aGlzLmxlbmJpdHMgPSAwLCB0aGlzLmRpc3RiaXRzID0gMCwgdGhpcy5uY29kZSA9IDAsIHRoaXMubmxlbiA9IDAsIHRoaXMubmRpc3QgPSAwLCB0aGlzLmhhdmUgPSAwLCB0aGlzLm5leHQgPSBudWxsLCB0aGlzLmxlbnMgPSBuZXcgVWludDE2QXJyYXkoMzIwKSwgdGhpcy53b3JrID0gbmV3IFVpbnQxNkFycmF5KDI4OCksIHRoaXMubGVuZHluID0gbnVsbCwgdGhpcy5kaXN0ZHluID0gbnVsbCwgdGhpcy5zYW5lID0gMCwgdGhpcy5iYWNrID0gMCwgdGhpcy53YXMgPSAwO1xuICAgIH1cbiAgICB2YXIgYXIsXG4gICAgICBocixcbiAgICAgIHVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gMTtcbiAgICAgICAgdmFyIGUgPSB0LnN0YXRlO1xuICAgICAgICByZXR1cm4gIWUgfHwgZS5zdHJtICE9PSB0IHx8IGUubW9kZSA8IFllIHx8IGUubW9kZSA+IDE2MjExID8gMSA6IDA7XG4gICAgICB9LFxuICAgICAgbHIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodXIodCkpIHJldHVybiBWZTtcbiAgICAgICAgdmFyIGUgPSB0LnN0YXRlO1xuICAgICAgICByZXR1cm4gdC50b3RhbF9pbiA9IHQudG90YWxfb3V0ID0gZS50b3RhbCA9IDAsIHQubXNnID0gXCJcIiwgZS53cmFwICYmICh0LmFkbGVyID0gMSAmIGUud3JhcCksIGUubW9kZSA9IFllLCBlLmxhc3QgPSAwLCBlLmhhdmVkaWN0ID0gMCwgZS5mbGFncyA9IC0xLCBlLmRtYXggPSAzMjc2OCwgZS5oZWFkID0gbnVsbCwgZS5ob2xkID0gMCwgZS5iaXRzID0gMCwgZS5sZW5jb2RlID0gZS5sZW5keW4gPSBuZXcgSW50MzJBcnJheSg4NTIpLCBlLmRpc3Rjb2RlID0gZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoNTkyKSwgZS5zYW5lID0gMSwgZS5iYWNrID0gLTEsIFplO1xuICAgICAgfSxcbiAgICAgIGZyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHVyKHQpKSByZXR1cm4gVmU7XG4gICAgICAgIHZhciBlID0gdC5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIGUud3NpemUgPSAwLCBlLndoYXZlID0gMCwgZS53bmV4dCA9IDAsIGxyKHQpO1xuICAgICAgfSxcbiAgICAgIGNyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICh1cih0KSkgcmV0dXJuIFZlO1xuICAgICAgICB2YXIgaSA9IHQuc3RhdGU7XG4gICAgICAgIHJldHVybiBlIDwgMCA/IChyID0gMCwgZSA9IC1lKSA6IChyID0gNSArIChlID4+IDQpLCBlIDwgNDggJiYgKGUgJj0gMTUpKSwgZSAmJiAoZSA8IDggfHwgZSA+IDE1KSA/IFZlIDogKG51bGwgIT09IGkud2luZG93ICYmIGkud2JpdHMgIT09IGUgJiYgKGkud2luZG93ID0gbnVsbCksIGkud3JhcCA9IHIsIGkud2JpdHMgPSBlLCBmcih0KSk7XG4gICAgICB9LFxuICAgICAgZHIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAoIXQpIHJldHVybiBWZTtcbiAgICAgICAgdmFyIHIgPSBuZXcgb3IoKTtcbiAgICAgICAgdC5zdGF0ZSA9IHIsIHIuc3RybSA9IHQsIHIud2luZG93ID0gbnVsbCwgci5tb2RlID0gWWU7XG4gICAgICAgIHZhciBpID0gY3IodCwgZSk7XG4gICAgICAgIHJldHVybiBpICE9PSBaZSAmJiAodC5zdGF0ZSA9IG51bGwpLCBpO1xuICAgICAgfSxcbiAgICAgIHByID0gITAsXG4gICAgICB5ciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmIChwcikge1xuICAgICAgICAgIGFyID0gbmV3IEludDMyQXJyYXkoNTEyKSwgaHIgPSBuZXcgSW50MzJBcnJheSgzMik7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCAxNDQ7KSB0LmxlbnNbZSsrXSA9IDg7XG4gICAgICAgICAgZm9yICg7IGUgPCAyNTY7KSB0LmxlbnNbZSsrXSA9IDk7XG4gICAgICAgICAgZm9yICg7IGUgPCAyODA7KSB0LmxlbnNbZSsrXSA9IDc7XG4gICAgICAgICAgZm9yICg7IGUgPCAyODg7KSB0LmxlbnNbZSsrXSA9IDg7XG4gICAgICAgICAgZm9yIChEZSgxLCB0LmxlbnMsIDAsIDI4OCwgYXIsIDAsIHQud29yaywge1xuICAgICAgICAgICAgYml0czogOVxuICAgICAgICAgIH0pLCBlID0gMDsgZSA8IDMyOykgdC5sZW5zW2UrK10gPSA1O1xuICAgICAgICAgIERlKDIsIHQubGVucywgMCwgMzIsIGhyLCAwLCB0LndvcmssIHtcbiAgICAgICAgICAgIGJpdHM6IDVcbiAgICAgICAgICB9KSwgcHIgPSAhMTtcbiAgICAgICAgfVxuICAgICAgICB0LmxlbmNvZGUgPSBhciwgdC5sZW5iaXRzID0gOSwgdC5kaXN0Y29kZSA9IGhyLCB0LmRpc3RiaXRzID0gNTtcbiAgICAgIH0sXG4gICAgICB2ciA9IGZ1bmN0aW9uICh0LCBlLCByLCBpKSB7XG4gICAgICAgIHZhciBuLFxuICAgICAgICAgIHMgPSB0LnN0YXRlO1xuICAgICAgICByZXR1cm4gbnVsbCA9PT0gcy53aW5kb3cgJiYgKHMud3NpemUgPSAxIDw8IHMud2JpdHMsIHMud25leHQgPSAwLCBzLndoYXZlID0gMCwgcy53aW5kb3cgPSBuZXcgVWludDhBcnJheShzLndzaXplKSksIGkgPj0gcy53c2l6ZSA/IChzLndpbmRvdy5zZXQoZS5zdWJhcnJheShyIC0gcy53c2l6ZSwgciksIDApLCBzLnduZXh0ID0gMCwgcy53aGF2ZSA9IHMud3NpemUpIDogKChuID0gcy53c2l6ZSAtIHMud25leHQpID4gaSAmJiAobiA9IGkpLCBzLndpbmRvdy5zZXQoZS5zdWJhcnJheShyIC0gaSwgciAtIGkgKyBuKSwgcy53bmV4dCksIChpIC09IG4pID8gKHMud2luZG93LnNldChlLnN1YmFycmF5KHIgLSBpLCByKSwgMCksIHMud25leHQgPSBpLCBzLndoYXZlID0gcy53c2l6ZSkgOiAocy53bmV4dCArPSBuLCBzLnduZXh0ID09PSBzLndzaXplICYmIChzLnduZXh0ID0gMCksIHMud2hhdmUgPCBzLndzaXplICYmIChzLndoYXZlICs9IG4pKSksIDA7XG4gICAgICB9LFxuICAgICAgZ3IgPSB7XG4gICAgICAgIGluZmxhdGVSZXNldDogZnIsXG4gICAgICAgIGluZmxhdGVSZXNldDI6IGNyLFxuICAgICAgICBpbmZsYXRlUmVzZXRLZWVwOiBscixcbiAgICAgICAgaW5mbGF0ZUluaXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGRyKHQsIDE1KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5mbGF0ZUluaXQyOiBkcixcbiAgICAgICAgaW5mbGF0ZTogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgcixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIEEsXG4gICAgICAgICAgICBTLFxuICAgICAgICAgICAgTyA9IDAsXG4gICAgICAgICAgICBFID0gbmV3IFVpbnQ4QXJyYXkoNCksXG4gICAgICAgICAgICBUID0gbmV3IFVpbnQ4QXJyYXkoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbiAgICAgICAgICBpZiAodXIodCkgfHwgIXQub3V0cHV0IHx8ICF0LmlucHV0ICYmIDAgIT09IHQuYXZhaWxfaW4pIHJldHVybiBWZTtcbiAgICAgICAgICAociA9IHQuc3RhdGUpLm1vZGUgPT09IFdlICYmIChyLm1vZGUgPSBRZSksIG8gPSB0Lm5leHRfb3V0LCBuID0gdC5vdXRwdXQsIGggPSB0LmF2YWlsX291dCwgcyA9IHQubmV4dF9pbiwgaSA9IHQuaW5wdXQsIGEgPSB0LmF2YWlsX2luLCB1ID0gci5ob2xkLCBsID0gci5iaXRzLCBmID0gYSwgYyA9IGgsIGsgPSBaZTtcbiAgICAgICAgICB0OiBmb3IgKDs7KSBzd2l0Y2ggKHIubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBZZTpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHIud3JhcCkge1xuICAgICAgICAgICAgICAgIHIubW9kZSA9IFFlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgMTY7KSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDIgJiByLndyYXAgJiYgMzU2MTUgPT09IHUpIHtcbiAgICAgICAgICAgICAgICAwID09PSByLndiaXRzICYmIChyLndiaXRzID0gMTUpLCByLmNoZWNrID0gMCwgRVswXSA9IDI1NSAmIHUsIEVbMV0gPSB1ID4+PiA4ICYgMjU1LCByLmNoZWNrID0gZnQoci5jaGVjaywgRSwgMiwgMCksIHUgPSAwLCBsID0gMCwgci5tb2RlID0gMTYxODE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIuaGVhZCAmJiAoci5oZWFkLmRvbmUgPSAhMSksICEoMSAmIHIud3JhcCkgfHwgKCgoMjU1ICYgdSkgPDwgOCkgKyAodSA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXCIsIHIubW9kZSA9IG5yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgoMTUgJiB1KSAhPT0gWGUpIHtcbiAgICAgICAgICAgICAgICB0Lm1zZyA9IFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGwgLT0gNCwgeCA9IDggKyAoMTUgJiAodSA+Pj49IDQpKSwgMCA9PT0gci53Yml0cyAmJiAoci53Yml0cyA9IHgpLCB4ID4gMTUgfHwgeCA+IHIud2JpdHMpIHtcbiAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCB3aW5kb3cgc2l6ZVwiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLmRtYXggPSAxIDw8IHIud2JpdHMsIHIuZmxhZ3MgPSAwLCB0LmFkbGVyID0gci5jaGVjayA9IDEsIHIubW9kZSA9IDUxMiAmIHUgPyAxNjE4OSA6IFdlLCB1ID0gMCwgbCA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjE4MTpcbiAgICAgICAgICAgICAgZm9yICg7IGwgPCAxNjspIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoci5mbGFncyA9IHUsICgyNTUgJiByLmZsYWdzKSAhPT0gWGUpIHtcbiAgICAgICAgICAgICAgICB0Lm1zZyA9IFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDU3MzQ0ICYgci5mbGFncykge1xuICAgICAgICAgICAgICAgIHQubXNnID0gXCJ1bmtub3duIGhlYWRlciBmbGFncyBzZXRcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgci5oZWFkICYmIChyLmhlYWQudGV4dCA9IHUgPj4gOCAmIDEpLCA1MTIgJiByLmZsYWdzICYmIDQgJiByLndyYXAgJiYgKEVbMF0gPSAyNTUgJiB1LCBFWzFdID0gdSA+Pj4gOCAmIDI1NSwgci5jaGVjayA9IGZ0KHIuY2hlY2ssIEUsIDIsIDApKSwgdSA9IDAsIGwgPSAwLCByLm1vZGUgPSAxNjE4MjtcbiAgICAgICAgICAgIGNhc2UgMTYxODI6XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgMzI7KSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgci5oZWFkICYmIChyLmhlYWQudGltZSA9IHUpLCA1MTIgJiByLmZsYWdzICYmIDQgJiByLndyYXAgJiYgKEVbMF0gPSAyNTUgJiB1LCBFWzFdID0gdSA+Pj4gOCAmIDI1NSwgRVsyXSA9IHUgPj4+IDE2ICYgMjU1LCBFWzNdID0gdSA+Pj4gMjQgJiAyNTUsIHIuY2hlY2sgPSBmdChyLmNoZWNrLCBFLCA0LCAwKSksIHUgPSAwLCBsID0gMCwgci5tb2RlID0gMTYxODM7XG4gICAgICAgICAgICBjYXNlIDE2MTgzOlxuICAgICAgICAgICAgICBmb3IgKDsgbCA8IDE2Oykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgIGEtLSwgdSArPSBpW3MrK10gPDwgbCwgbCArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIuaGVhZCAmJiAoci5oZWFkLnhmbGFncyA9IDI1NSAmIHUsIHIuaGVhZC5vcyA9IHUgPj4gOCksIDUxMiAmIHIuZmxhZ3MgJiYgNCAmIHIud3JhcCAmJiAoRVswXSA9IDI1NSAmIHUsIEVbMV0gPSB1ID4+PiA4ICYgMjU1LCByLmNoZWNrID0gZnQoci5jaGVjaywgRSwgMiwgMCkpLCB1ID0gMCwgbCA9IDAsIHIubW9kZSA9IDE2MTg0O1xuICAgICAgICAgICAgY2FzZSAxNjE4NDpcbiAgICAgICAgICAgICAgaWYgKDEwMjQgJiByLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGwgPCAxNjspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIubGVuZ3RoID0gdSwgci5oZWFkICYmIChyLmhlYWQuZXh0cmFfbGVuID0gdSksIDUxMiAmIHIuZmxhZ3MgJiYgNCAmIHIud3JhcCAmJiAoRVswXSA9IDI1NSAmIHUsIEVbMV0gPSB1ID4+PiA4ICYgMjU1LCByLmNoZWNrID0gZnQoci5jaGVjaywgRSwgMiwgMCkpLCB1ID0gMCwgbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSByLmhlYWQgJiYgKHIuaGVhZC5leHRyYSA9IG51bGwpO1xuICAgICAgICAgICAgICByLm1vZGUgPSAxNjE4NTtcbiAgICAgICAgICAgIGNhc2UgMTYxODU6XG4gICAgICAgICAgICAgIGlmICgxMDI0ICYgci5mbGFncyAmJiAoKGQgPSByLmxlbmd0aCkgPiBhICYmIChkID0gYSksIGQgJiYgKHIuaGVhZCAmJiAoeCA9IHIuaGVhZC5leHRyYV9sZW4gLSByLmxlbmd0aCwgci5oZWFkLmV4dHJhIHx8IChyLmhlYWQuZXh0cmEgPSBuZXcgVWludDhBcnJheShyLmhlYWQuZXh0cmFfbGVuKSksIHIuaGVhZC5leHRyYS5zZXQoaS5zdWJhcnJheShzLCBzICsgZCksIHgpKSwgNTEyICYgci5mbGFncyAmJiA0ICYgci53cmFwICYmIChyLmNoZWNrID0gZnQoci5jaGVjaywgaSwgZCwgcykpLCBhIC09IGQsIHMgKz0gZCwgci5sZW5ndGggLT0gZCksIHIubGVuZ3RoKSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgci5sZW5ndGggPSAwLCByLm1vZGUgPSAxNjE4NjtcbiAgICAgICAgICAgIGNhc2UgMTYxODY6XG4gICAgICAgICAgICAgIGlmICgyMDQ4ICYgci5mbGFncykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgIGQgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHggPSBpW3MgKyBkKytdLCByLmhlYWQgJiYgeCAmJiByLmxlbmd0aCA8IDY1NTM2ICYmIChyLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh4ICYmIGQgPCBhKTtcbiAgICAgICAgICAgICAgICBpZiAoNTEyICYgci5mbGFncyAmJiA0ICYgci53cmFwICYmIChyLmNoZWNrID0gZnQoci5jaGVjaywgaSwgZCwgcykpLCBhIC09IGQsIHMgKz0gZCwgeCkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHIuaGVhZCAmJiAoci5oZWFkLm5hbWUgPSBudWxsKTtcbiAgICAgICAgICAgICAgci5sZW5ndGggPSAwLCByLm1vZGUgPSAxNjE4NztcbiAgICAgICAgICAgIGNhc2UgMTYxODc6XG4gICAgICAgICAgICAgIGlmICg0MDk2ICYgci5mbGFncykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgIGQgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHggPSBpW3MgKyBkKytdLCByLmhlYWQgJiYgeCAmJiByLmxlbmd0aCA8IDY1NTM2ICYmIChyLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh4ICYmIGQgPCBhKTtcbiAgICAgICAgICAgICAgICBpZiAoNTEyICYgci5mbGFncyAmJiA0ICYgci53cmFwICYmIChyLmNoZWNrID0gZnQoci5jaGVjaywgaSwgZCwgcykpLCBhIC09IGQsIHMgKz0gZCwgeCkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHIuaGVhZCAmJiAoci5oZWFkLmNvbW1lbnQgPSBudWxsKTtcbiAgICAgICAgICAgICAgci5tb2RlID0gMTYxODg7XG4gICAgICAgICAgICBjYXNlIDE2MTg4OlxuICAgICAgICAgICAgICBpZiAoNTEyICYgci5mbGFncykge1xuICAgICAgICAgICAgICAgIGZvciAoOyBsIDwgMTY7KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICAgIGEtLSwgdSArPSBpW3MrK10gPDwgbCwgbCArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoNCAmIHIud3JhcCAmJiB1ICE9PSAoNjU1MzUgJiByLmNoZWNrKSkge1xuICAgICAgICAgICAgICAgICAgdC5tc2cgPSBcImhlYWRlciBjcmMgbWlzbWF0Y2hcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdSA9IDAsIGwgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIuaGVhZCAmJiAoci5oZWFkLmhjcmMgPSByLmZsYWdzID4+IDkgJiAxLCByLmhlYWQuZG9uZSA9ICEwKSwgdC5hZGxlciA9IHIuY2hlY2sgPSAwLCByLm1vZGUgPSBXZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2MTg5OlxuICAgICAgICAgICAgICBmb3IgKDsgbCA8IDMyOykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgIGEtLSwgdSArPSBpW3MrK10gPDwgbCwgbCArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHQuYWRsZXIgPSByLmNoZWNrID0gc3IodSksIHUgPSAwLCBsID0gMCwgci5tb2RlID0gR2U7XG4gICAgICAgICAgICBjYXNlIEdlOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gci5oYXZlZGljdCkgcmV0dXJuIHQubmV4dF9vdXQgPSBvLCB0LmF2YWlsX291dCA9IGgsIHQubmV4dF9pbiA9IHMsIHQuYXZhaWxfaW4gPSBhLCByLmhvbGQgPSB1LCByLmJpdHMgPSBsLCBKZTtcbiAgICAgICAgICAgICAgdC5hZGxlciA9IHIuY2hlY2sgPSAxLCByLm1vZGUgPSBXZTtcbiAgICAgICAgICAgIGNhc2UgV2U6XG4gICAgICAgICAgICAgIGlmIChlID09PSBQZSB8fCBlID09PSBVZSkgYnJlYWsgdDtcbiAgICAgICAgICAgIGNhc2UgUWU6XG4gICAgICAgICAgICAgIGlmIChyLmxhc3QpIHtcbiAgICAgICAgICAgICAgICB1ID4+Pj0gNyAmIGwsIGwgLT0gNyAmIGwsIHIubW9kZSA9IGlyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgMzspIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKHIubGFzdCA9IDEgJiB1LCBsIC09IDEsIDMgJiAodSA+Pj49IDEpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgci5tb2RlID0gMTYxOTM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBpZiAoeXIociksIHIubW9kZSA9IGVyLCBlID09PSBVZSkge1xuICAgICAgICAgICAgICAgICAgICB1ID4+Pj0gMiwgbCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgci5tb2RlID0gMTYxOTY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCBibG9jayB0eXBlXCIsIHIubW9kZSA9IG5yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHUgPj4+PSAyLCBsIC09IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjE5MzpcbiAgICAgICAgICAgICAgZm9yICh1ID4+Pj0gNyAmIGwsIGwgLT0gNyAmIGw7IGwgPCAzMjspIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKDY1NTM1ICYgdSkgIT0gKHUgPj4+IDE2IF4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIubGVuZ3RoID0gNjU1MzUgJiB1LCB1ID0gMCwgbCA9IDAsIHIubW9kZSA9IHRyLCBlID09PSBVZSkgYnJlYWsgdDtcbiAgICAgICAgICAgIGNhc2UgdHI6XG4gICAgICAgICAgICAgIHIubW9kZSA9IDE2MTk1O1xuICAgICAgICAgICAgY2FzZSAxNjE5NTpcbiAgICAgICAgICAgICAgaWYgKGQgPSByLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChkID4gYSAmJiAoZCA9IGEpLCBkID4gaCAmJiAoZCA9IGgpLCAwID09PSBkKSBicmVhayB0O1xuICAgICAgICAgICAgICAgIG4uc2V0KGkuc3ViYXJyYXkocywgcyArIGQpLCBvKSwgYSAtPSBkLCBzICs9IGQsIGggLT0gZCwgbyArPSBkLCByLmxlbmd0aCAtPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIubW9kZSA9IFdlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTYxOTY6XG4gICAgICAgICAgICAgIGZvciAoOyBsIDwgMTQ7KSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIubmxlbiA9IDI1NyArICgzMSAmIHUpLCB1ID4+Pj0gNSwgbCAtPSA1LCByLm5kaXN0ID0gMSArICgzMSAmIHUpLCB1ID4+Pj0gNSwgbCAtPSA1LCByLm5jb2RlID0gNCArICgxNSAmIHUpLCB1ID4+Pj0gNCwgbCAtPSA0LCByLm5sZW4gPiAyODYgfHwgci5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCIsIHIubW9kZSA9IG5yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIuaGF2ZSA9IDAsIHIubW9kZSA9IDE2MTk3O1xuICAgICAgICAgICAgY2FzZSAxNjE5NzpcbiAgICAgICAgICAgICAgZm9yICg7IHIuaGF2ZSA8IHIubmNvZGU7KSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGwgPCAzOykge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgci5sZW5zW1Rbci5oYXZlKytdXSA9IDcgJiB1LCB1ID4+Pj0gMywgbCAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoOyByLmhhdmUgPCAxOTspIHIubGVuc1tUW3IuaGF2ZSsrXV0gPSAwO1xuICAgICAgICAgICAgICBpZiAoci5sZW5jb2RlID0gci5sZW5keW4sIHIubGVuYml0cyA9IDcsIEEgPSB7XG4gICAgICAgICAgICAgICAgYml0czogci5sZW5iaXRzXG4gICAgICAgICAgICAgIH0sIGsgPSBEZSgwLCByLmxlbnMsIDAsIDE5LCByLmxlbmNvZGUsIDAsIHIud29yaywgQSksIHIubGVuYml0cyA9IEEuYml0cywgaykge1xuICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXRcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgci5oYXZlID0gMCwgci5tb2RlID0gMTYxOTg7XG4gICAgICAgICAgICBjYXNlIDE2MTk4OlxuICAgICAgICAgICAgICBmb3IgKDsgci5oYXZlIDwgci5ubGVuICsgci5uZGlzdDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgZyA9IChPID0gci5sZW5jb2RlW3UgJiAoMSA8PCByLmxlbmJpdHMpIC0gMV0pID4+PiAxNiAmIDI1NSwgbSA9IDY1NTM1ICYgTywgISgodiA9IE8gPj4+IDI0KSA8PSBsKTspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtIDwgMTYpIHUgPj4+PSB2LCBsIC09IHYsIHIubGVuc1tyLmhhdmUrK10gPSBtO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKDE2ID09PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoUyA9IHYgKyAyOyBsIDwgUzspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodSA+Pj49IHYsIGwgLT0gdiwgMCA9PT0gci5oYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeCA9IHIubGVuc1tyLmhhdmUgLSAxXSwgZCA9IDMgKyAoMyAmIHUpLCB1ID4+Pj0gMiwgbCAtPSAyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgxNyA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFMgPSB2ICsgMzsgbCA8IFM7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbCAtPSB2LCB4ID0gMCwgZCA9IDMgKyAoNyAmICh1ID4+Pj0gdikpLCB1ID4+Pj0gMywgbCAtPSAzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChTID0gdiArIDc7IGwgPCBTOykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgICAgIGEtLSwgdSArPSBpW3MrK10gPDwgbCwgbCArPSA4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGwgLT0gdiwgeCA9IDAsIGQgPSAxMSArICgxMjcgJiAodSA+Pj49IHYpKSwgdSA+Pj49IDcsIGwgLT0gNztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyLmhhdmUgKyBkID4gci5ubGVuICsgci5uZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0Lm1zZyA9IFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgZC0tOykgci5sZW5zW3IuaGF2ZSsrXSA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyLm1vZGUgPT09IG5yKSBicmVhaztcbiAgICAgICAgICAgICAgaWYgKDAgPT09IHIubGVuc1syNTZdKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9ja1wiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoci5sZW5iaXRzID0gOSwgQSA9IHtcbiAgICAgICAgICAgICAgICBiaXRzOiByLmxlbmJpdHNcbiAgICAgICAgICAgICAgfSwgayA9IERlKDEsIHIubGVucywgMCwgci5ubGVuLCByLmxlbmNvZGUsIDAsIHIud29yaywgQSksIHIubGVuYml0cyA9IEEuYml0cywgaykge1xuICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXRcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIuZGlzdGJpdHMgPSA2LCByLmRpc3Rjb2RlID0gci5kaXN0ZHluLCBBID0ge1xuICAgICAgICAgICAgICAgIGJpdHM6IHIuZGlzdGJpdHNcbiAgICAgICAgICAgICAgfSwgayA9IERlKDIsIHIubGVucywgci5ubGVuLCByLm5kaXN0LCByLmRpc3Rjb2RlLCAwLCByLndvcmssIEEpLCByLmRpc3RiaXRzID0gQS5iaXRzLCBrKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgZGlzdGFuY2VzIHNldFwiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoci5tb2RlID0gZXIsIGUgPT09IFVlKSBicmVhayB0O1xuICAgICAgICAgICAgY2FzZSBlcjpcbiAgICAgICAgICAgICAgci5tb2RlID0gcnI7XG4gICAgICAgICAgICBjYXNlIHJyOlxuICAgICAgICAgICAgICBpZiAoYSA+PSA2ICYmIGggPj0gMjU4KSB7XG4gICAgICAgICAgICAgICAgdC5uZXh0X291dCA9IG8sIHQuYXZhaWxfb3V0ID0gaCwgdC5uZXh0X2luID0gcywgdC5hdmFpbF9pbiA9IGEsIHIuaG9sZCA9IHUsIHIuYml0cyA9IGwsIEZlKHQsIGMpLCBvID0gdC5uZXh0X291dCwgbiA9IHQub3V0cHV0LCBoID0gdC5hdmFpbF9vdXQsIHMgPSB0Lm5leHRfaW4sIGkgPSB0LmlucHV0LCBhID0gdC5hdmFpbF9pbiwgdSA9IHIuaG9sZCwgbCA9IHIuYml0cywgci5tb2RlID09PSBXZSAmJiAoci5iYWNrID0gLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoci5iYWNrID0gMDsgZyA9IChPID0gci5sZW5jb2RlW3UgJiAoMSA8PCByLmxlbmJpdHMpIC0gMV0pID4+PiAxNiAmIDI1NSwgbSA9IDY1NTM1ICYgTywgISgodiA9IE8gPj4+IDI0KSA8PSBsKTspIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZyAmJiAhKDI0MCAmIGcpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChfID0gdiwgdyA9IGcsIGIgPSBtOyBnID0gKE8gPSByLmxlbmNvZGVbYiArICgodSAmICgxIDw8IF8gKyB3KSAtIDEpID4+IF8pXSkgPj4+IDE2ICYgMjU1LCBtID0gNjU1MzUgJiBPLCAhKF8gKyAodiA9IE8gPj4+IDI0KSA8PSBsKTspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHUgPj4+PSBfLCBsIC09IF8sIHIuYmFjayArPSBfO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1ID4+Pj0gdiwgbCAtPSB2LCByLmJhY2sgKz0gdiwgci5sZW5ndGggPSBtLCAwID09PSBnKSB7XG4gICAgICAgICAgICAgICAgci5tb2RlID0gMTYyMDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDMyICYgZykge1xuICAgICAgICAgICAgICAgIHIuYmFjayA9IC0xLCByLm1vZGUgPSBXZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoNjQgJiBnKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLmV4dHJhID0gMTUgJiBnLCByLm1vZGUgPSAxNjIwMTtcbiAgICAgICAgICAgIGNhc2UgMTYyMDE6XG4gICAgICAgICAgICAgIGlmIChyLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgZm9yIChTID0gci5leHRyYTsgbCA8IFM7KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYSkgYnJlYWsgdDtcbiAgICAgICAgICAgICAgICAgIGEtLSwgdSArPSBpW3MrK10gPDwgbCwgbCArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByLmxlbmd0aCArPSB1ICYgKDEgPDwgci5leHRyYSkgLSAxLCB1ID4+Pj0gci5leHRyYSwgbCAtPSByLmV4dHJhLCByLmJhY2sgKz0gci5leHRyYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLndhcyA9IHIubGVuZ3RoLCByLm1vZGUgPSAxNjIwMjtcbiAgICAgICAgICAgIGNhc2UgMTYyMDI6XG4gICAgICAgICAgICAgIGZvciAoOyBnID0gKE8gPSByLmRpc3Rjb2RlW3UgJiAoMSA8PCByLmRpc3RiaXRzKSAtIDFdKSA+Pj4gMTYgJiAyNTUsIG0gPSA2NTUzNSAmIE8sICEoKHYgPSBPID4+PiAyNCkgPD0gbCk7KSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEoMjQwICYgZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKF8gPSB2LCB3ID0gZywgYiA9IG07IGcgPSAoTyA9IHIuZGlzdGNvZGVbYiArICgodSAmICgxIDw8IF8gKyB3KSAtIDEpID4+IF8pXSkgPj4+IDE2ICYgMjU1LCBtID0gNjU1MzUgJiBPLCAhKF8gKyAodiA9IE8gPj4+IDI0KSA8PSBsKTspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHUgPj4+PSBfLCBsIC09IF8sIHIuYmFjayArPSBfO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1ID4+Pj0gdiwgbCAtPSB2LCByLmJhY2sgKz0gdiwgNjQgJiBnKSB7XG4gICAgICAgICAgICAgICAgdC5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLm9mZnNldCA9IG0sIHIuZXh0cmEgPSAxNSAmIGcsIHIubW9kZSA9IDE2MjAzO1xuICAgICAgICAgICAgY2FzZSAxNjIwMzpcbiAgICAgICAgICAgICAgaWYgKHIuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKFMgPSByLmV4dHJhOyBsIDwgUzspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1ICs9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIub2Zmc2V0ICs9IHUgJiAoMSA8PCByLmV4dHJhKSAtIDEsIHUgPj4+PSByLmV4dHJhLCBsIC09IHIuZXh0cmEsIHIuYmFjayArPSByLmV4dHJhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyLm9mZnNldCA+IHIuZG1heCkge1xuICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLm1vZGUgPSAxNjIwNDtcbiAgICAgICAgICAgIGNhc2UgMTYyMDQ6XG4gICAgICAgICAgICAgIGlmICgwID09PSBoKSBicmVhayB0O1xuICAgICAgICAgICAgICBpZiAoZCA9IGMgLSBoLCByLm9mZnNldCA+IGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGQgPSByLm9mZnNldCAtIGQpID4gci53aGF2ZSAmJiByLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkID4gci53bmV4dCA/IChkIC09IHIud25leHQsIHAgPSByLndzaXplIC0gZCkgOiBwID0gci53bmV4dCAtIGQsIGQgPiByLmxlbmd0aCAmJiAoZCA9IHIubGVuZ3RoKSwgeSA9IHIud2luZG93O1xuICAgICAgICAgICAgICB9IGVsc2UgeSA9IG4sIHAgPSBvIC0gci5vZmZzZXQsIGQgPSByLmxlbmd0aDtcbiAgICAgICAgICAgICAgZCA+IGggJiYgKGQgPSBoKSwgaCAtPSBkLCByLmxlbmd0aCAtPSBkO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbltvKytdID0geVtwKytdO1xuICAgICAgICAgICAgICB9IHdoaWxlICgtLWQpO1xuICAgICAgICAgICAgICAwID09PSByLmxlbmd0aCAmJiAoci5tb2RlID0gcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTYyMDU6XG4gICAgICAgICAgICAgIGlmICgwID09PSBoKSBicmVhayB0O1xuICAgICAgICAgICAgICBuW28rK10gPSByLmxlbmd0aCwgaC0tLCByLm1vZGUgPSBycjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGlyOlxuICAgICAgICAgICAgICBpZiAoci53cmFwKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGwgPCAzMjspIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhKSBicmVhayB0O1xuICAgICAgICAgICAgICAgICAgYS0tLCB1IHw9IGlbcysrXSA8PCBsLCBsICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjIC09IGgsIHQudG90YWxfb3V0ICs9IGMsIHIudG90YWwgKz0gYywgNCAmIHIud3JhcCAmJiBjICYmICh0LmFkbGVyID0gci5jaGVjayA9IHIuZmxhZ3MgPyBmdChyLmNoZWNrLCBuLCBjLCBvIC0gYykgOiB1dChyLmNoZWNrLCBuLCBjLCBvIC0gYykpLCBjID0gaCwgNCAmIHIud3JhcCAmJiAoci5mbGFncyA/IHUgOiBzcih1KSkgIT09IHIuY2hlY2spIHtcbiAgICAgICAgICAgICAgICAgIHQubXNnID0gXCJpbmNvcnJlY3QgZGF0YSBjaGVja1wiLCByLm1vZGUgPSBucjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1ID0gMCwgbCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgci5tb2RlID0gMTYyMDc7XG4gICAgICAgICAgICBjYXNlIDE2MjA3OlxuICAgICAgICAgICAgICBpZiAoci53cmFwICYmIHIuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbCA8IDMyOykge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGEpIGJyZWFrIHQ7XG4gICAgICAgICAgICAgICAgICBhLS0sIHUgKz0gaVtzKytdIDw8IGwsIGwgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDQgJiByLndyYXAgJiYgdSAhPT0gKDQyOTQ5NjcyOTUgJiByLnRvdGFsKSkge1xuICAgICAgICAgICAgICAgICAgdC5tc2cgPSBcImluY29ycmVjdCBsZW5ndGggY2hlY2tcIiwgci5tb2RlID0gbnI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdSA9IDAsIGwgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIubW9kZSA9IDE2MjA4O1xuICAgICAgICAgICAgY2FzZSAxNjIwODpcbiAgICAgICAgICAgICAgayA9IHFlO1xuICAgICAgICAgICAgICBicmVhayB0O1xuICAgICAgICAgICAgY2FzZSBucjpcbiAgICAgICAgICAgICAgayA9IEhlO1xuICAgICAgICAgICAgICBicmVhayB0O1xuICAgICAgICAgICAgY2FzZSAxNjIxMDpcbiAgICAgICAgICAgICAgcmV0dXJuICRlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIFZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdC5uZXh0X291dCA9IG8sIHQuYXZhaWxfb3V0ID0gaCwgdC5uZXh0X2luID0gcywgdC5hdmFpbF9pbiA9IGEsIHIuaG9sZCA9IHUsIHIuYml0cyA9IGwsIChyLndzaXplIHx8IGMgIT09IHQuYXZhaWxfb3V0ICYmIHIubW9kZSA8IG5yICYmIChyLm1vZGUgPCBpciB8fCBlICE9PSBNZSkpICYmIHZyKHQsIHQub3V0cHV0LCB0Lm5leHRfb3V0LCBjIC0gdC5hdmFpbF9vdXQpLCBmIC09IHQuYXZhaWxfaW4sIGMgLT0gdC5hdmFpbF9vdXQsIHQudG90YWxfaW4gKz0gZiwgdC50b3RhbF9vdXQgKz0gYywgci50b3RhbCArPSBjLCA0ICYgci53cmFwICYmIGMgJiYgKHQuYWRsZXIgPSByLmNoZWNrID0gci5mbGFncyA/IGZ0KHIuY2hlY2ssIG4sIGMsIHQubmV4dF9vdXQgLSBjKSA6IHV0KHIuY2hlY2ssIG4sIGMsIHQubmV4dF9vdXQgLSBjKSksIHQuZGF0YV90eXBlID0gci5iaXRzICsgKHIubGFzdCA/IDY0IDogMCkgKyAoci5tb2RlID09PSBXZSA/IDEyOCA6IDApICsgKHIubW9kZSA9PT0gZXIgfHwgci5tb2RlID09PSB0ciA/IDI1NiA6IDApLCAoMCA9PT0gZiAmJiAwID09PSBjIHx8IGUgPT09IE1lKSAmJiBrID09PSBaZSAmJiAoayA9IEtlKSwgaztcbiAgICAgICAgfSxcbiAgICAgICAgaW5mbGF0ZUVuZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodXIodCkpIHJldHVybiBWZTtcbiAgICAgICAgICB2YXIgZSA9IHQuc3RhdGU7XG4gICAgICAgICAgcmV0dXJuIGUud2luZG93ICYmIChlLndpbmRvdyA9IG51bGwpLCB0LnN0YXRlID0gbnVsbCwgWmU7XG4gICAgICAgIH0sXG4gICAgICAgIGluZmxhdGVHZXRIZWFkZXI6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKHVyKHQpKSByZXR1cm4gVmU7XG4gICAgICAgICAgdmFyIHIgPSB0LnN0YXRlO1xuICAgICAgICAgIHJldHVybiAyICYgci53cmFwID8gKHIuaGVhZCA9IGUsIGUuZG9uZSA9ICExLCBaZSkgOiBWZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5mbGF0ZVNldERpY3Rpb25hcnk6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBpID0gZS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHVyKHQpIHx8IDAgIT09IChyID0gdC5zdGF0ZSkud3JhcCAmJiByLm1vZGUgIT09IEdlID8gVmUgOiByLm1vZGUgPT09IEdlICYmIHV0KDEsIGUsIGksIDApICE9PSByLmNoZWNrID8gSGUgOiB2cih0LCBlLCBpLCBpKSA/IChyLm1vZGUgPSAxNjIxMCwgJGUpIDogKHIuaGF2ZWRpY3QgPSAxLCBaZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluZmxhdGVJbmZvOiBcInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdClcIlxuICAgICAgfSxcbiAgICAgIG1yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRleHQgPSAwLCB0aGlzLnRpbWUgPSAwLCB0aGlzLnhmbGFncyA9IDAsIHRoaXMub3MgPSAwLCB0aGlzLmV4dHJhID0gbnVsbCwgdGhpcy5leHRyYV9sZW4gPSAwLCB0aGlzLm5hbWUgPSBcIlwiLCB0aGlzLmNvbW1lbnQgPSBcIlwiLCB0aGlzLmhjcmMgPSAwLCB0aGlzLmRvbmUgPSAhMTtcbiAgICAgIH0sXG4gICAgICBfciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICB3ciA9IGR0LlpfTk9fRkxVU0gsXG4gICAgICBiciA9IGR0LlpfRklOSVNILFxuICAgICAgeHIgPSBkdC5aX09LLFxuICAgICAga3IgPSBkdC5aX1NUUkVBTV9FTkQsXG4gICAgICBBciA9IGR0LlpfTkVFRF9ESUNULFxuICAgICAgU3IgPSBkdC5aX1NUUkVBTV9FUlJPUixcbiAgICAgIE9yID0gZHQuWl9EQVRBX0VSUk9SLFxuICAgICAgRXIgPSBkdC5aX01FTV9FUlJPUjtcbiAgICBmdW5jdGlvbiBUcih0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB5ZS5hc3NpZ24oe1xuICAgICAgICBjaHVua1NpemU6IDY1NTM2LFxuICAgICAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICAgICAgdG86IFwiXCJcbiAgICAgIH0sIHQgfHwge30pO1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBlLnJhdyAmJiBlLndpbmRvd0JpdHMgPj0gMCAmJiBlLndpbmRvd0JpdHMgPCAxNiAmJiAoZS53aW5kb3dCaXRzID0gLWUud2luZG93Qml0cywgMCA9PT0gZS53aW5kb3dCaXRzICYmIChlLndpbmRvd0JpdHMgPSAtMTUpKSwgIShlLndpbmRvd0JpdHMgPj0gMCAmJiBlLndpbmRvd0JpdHMgPCAxNikgfHwgdCAmJiB0LndpbmRvd0JpdHMgfHwgKGUud2luZG93Qml0cyArPSAzMiksIGUud2luZG93Qml0cyA+IDE1ICYmIGUud2luZG93Qml0cyA8IDQ4ICYmICgxNSAmIGUud2luZG93Qml0cyB8fCAoZS53aW5kb3dCaXRzIHw9IDE1KSksIHRoaXMuZXJyID0gMCwgdGhpcy5tc2cgPSBcIlwiLCB0aGlzLmVuZGVkID0gITEsIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuc3RybSA9IG5ldyB3ZSgpLCB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIHZhciByID0gZ3IuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSwgZS53aW5kb3dCaXRzKTtcbiAgICAgIGlmIChyICE9PSB4cikgdGhyb3cgbmV3IEVycm9yKGN0W3JdKTtcbiAgICAgIGlmICh0aGlzLmhlYWRlciA9IG5ldyBtcigpLCBnci5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpLCBlLmRpY3Rpb25hcnkgJiYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuZGljdGlvbmFyeSA/IGUuZGljdGlvbmFyeSA9IF9lLnN0cmluZzJidWYoZS5kaWN0aW9uYXJ5KSA6IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiA9PT0gX3IuY2FsbChlLmRpY3Rpb25hcnkpICYmIChlLmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpKSwgZS5yYXcgJiYgKHIgPSBnci5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGUuZGljdGlvbmFyeSkpICE9PSB4cikpIHRocm93IG5ldyBFcnJvcihjdFtyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpyKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IFRyKGUpO1xuICAgICAgaWYgKHIucHVzaCh0KSwgci5lcnIpIHRocm93IHIubXNnIHx8IGN0W3IuZXJyXTtcbiAgICAgIHJldHVybiByLnJlc3VsdDtcbiAgICB9XG4gICAgVHIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIHMgPSB0aGlzLnN0cm0sXG4gICAgICAgIG8gPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICBhID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gICAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuICExO1xuICAgICAgZm9yIChpID0gZSA9PT0gfn5lID8gZSA6ICEwID09PSBlID8gYnIgOiB3ciwgXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiID09PSBfci5jYWxsKHQpID8gcy5pbnB1dCA9IG5ldyBVaW50OEFycmF5KHQpIDogcy5pbnB1dCA9IHQsIHMubmV4dF9pbiA9IDAsIHMuYXZhaWxfaW4gPSBzLmlucHV0Lmxlbmd0aDs7KSB7XG4gICAgICAgIGZvciAoMCA9PT0gcy5hdmFpbF9vdXQgJiYgKHMub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobyksIHMubmV4dF9vdXQgPSAwLCBzLmF2YWlsX291dCA9IG8pLCAociA9IGdyLmluZmxhdGUocywgaSkpID09PSBBciAmJiBhICYmICgociA9IGdyLmluZmxhdGVTZXREaWN0aW9uYXJ5KHMsIGEpKSA9PT0geHIgPyByID0gZ3IuaW5mbGF0ZShzLCBpKSA6IHIgPT09IE9yICYmIChyID0gQXIpKTsgcy5hdmFpbF9pbiA+IDAgJiYgciA9PT0ga3IgJiYgcy5zdGF0ZS53cmFwID4gMCAmJiAwICE9PSB0W3MubmV4dF9pbl07KSBnci5pbmZsYXRlUmVzZXQocyksIHIgPSBnci5pbmZsYXRlKHMsIGkpO1xuICAgICAgICBzd2l0Y2ggKHIpIHtcbiAgICAgICAgICBjYXNlIFNyOlxuICAgICAgICAgIGNhc2UgT3I6XG4gICAgICAgICAgY2FzZSBBcjpcbiAgICAgICAgICBjYXNlIEVyOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FbmQociksIHRoaXMuZW5kZWQgPSAhMCwgITE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPSBzLmF2YWlsX291dCwgcy5uZXh0X291dCAmJiAoMCA9PT0gcy5hdmFpbF9vdXQgfHwgciA9PT0ga3IpKSBpZiAoXCJzdHJpbmdcIiA9PT0gdGhpcy5vcHRpb25zLnRvKSB7XG4gICAgICAgICAgdmFyIGggPSBfZS51dGY4Ym9yZGVyKHMub3V0cHV0LCBzLm5leHRfb3V0KSxcbiAgICAgICAgICAgIHUgPSBzLm5leHRfb3V0IC0gaCxcbiAgICAgICAgICAgIGwgPSBfZS5idWYyc3RyaW5nKHMub3V0cHV0LCBoKTtcbiAgICAgICAgICBzLm5leHRfb3V0ID0gdSwgcy5hdmFpbF9vdXQgPSBvIC0gdSwgdSAmJiBzLm91dHB1dC5zZXQocy5vdXRwdXQuc3ViYXJyYXkoaCwgaCArIHUpLCAwKSwgdGhpcy5vbkRhdGEobCk7XG4gICAgICAgIH0gZWxzZSB0aGlzLm9uRGF0YShzLm91dHB1dC5sZW5ndGggPT09IHMubmV4dF9vdXQgPyBzLm91dHB1dCA6IHMub3V0cHV0LnN1YmFycmF5KDAsIHMubmV4dF9vdXQpKTtcbiAgICAgICAgaWYgKHIgIT09IHhyIHx8IDAgIT09IG4pIHtcbiAgICAgICAgICBpZiAociA9PT0ga3IpIHJldHVybiByID0gZ3IuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pLCB0aGlzLm9uRW5kKHIpLCB0aGlzLmVuZGVkID0gITAsICEwO1xuICAgICAgICAgIGlmICgwID09PSBzLmF2YWlsX2luKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIFRyLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh0KTtcbiAgICB9LCBUci5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCA9PT0geHIgJiYgKFwic3RyaW5nXCIgPT09IHRoaXMub3B0aW9ucy50byA/IHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbihcIlwiKSA6IHRoaXMucmVzdWx0ID0geWUuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLCB0aGlzLmNodW5rcyA9IFtdLCB0aGlzLmVyciA9IHQsIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbiAgICB9O1xuICAgIHZhciBCciA9IHpyLFxuICAgICAgSXIgPSByKDcwMCksXG4gICAgICBOciA9IEpTT04ucGFyc2UoJ3tcIm5lc3RlZFwiOntcImNvbVwiOntcIm5lc3RlZFwiOntcIm9wZW5zb3VyY2VcIjp7XCJuZXN0ZWRcIjp7XCJzdmdhXCI6e1wib3B0aW9uc1wiOntcIm9iamNfY2xhc3NfcHJlZml4XCI6XCJTVkdBUHJvdG9cIixcImphdmFfcGFja2FnZVwiOlwiY29tLm9wZW5zb3VyY2Uuc3ZnYXBsYXllci5wcm90b1wifSxcIm5lc3RlZFwiOntcIk1vdmllUGFyYW1zXCI6e1wiZmllbGRzXCI6e1widmlld0JveFdpZHRoXCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6MX0sXCJ2aWV3Qm94SGVpZ2h0XCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6Mn0sXCJmcHNcIjp7XCJ0eXBlXCI6XCJpbnQzMlwiLFwiaWRcIjozfSxcImZyYW1lc1wiOntcInR5cGVcIjpcImludDMyXCIsXCJpZFwiOjR9fX0sXCJTcHJpdGVFbnRpdHlcIjp7XCJmaWVsZHNcIjp7XCJpbWFnZUtleVwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiaWRcIjoxfSxcImZyYW1lc1wiOntcInJ1bGVcIjpcInJlcGVhdGVkXCIsXCJ0eXBlXCI6XCJGcmFtZUVudGl0eVwiLFwiaWRcIjoyfSxcIm1hdHRlS2V5XCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJpZFwiOjN9fX0sXCJBdWRpb0VudGl0eVwiOntcImZpZWxkc1wiOntcImF1ZGlvS2V5XCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJpZFwiOjF9LFwic3RhcnRGcmFtZVwiOntcInR5cGVcIjpcImludDMyXCIsXCJpZFwiOjJ9LFwiZW5kRnJhbWVcIjp7XCJ0eXBlXCI6XCJpbnQzMlwiLFwiaWRcIjozfSxcInN0YXJ0VGltZVwiOntcInR5cGVcIjpcImludDMyXCIsXCJpZFwiOjR9LFwidG90YWxUaW1lXCI6e1widHlwZVwiOlwiaW50MzJcIixcImlkXCI6NX19fSxcIkxheW91dFwiOntcImZpZWxkc1wiOntcInhcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjoxfSxcInlcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjoyfSxcIndpZHRoXCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6M30sXCJoZWlnaHRcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjo0fX19LFwiVHJhbnNmb3JtXCI6e1wiZmllbGRzXCI6e1wiYVwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjF9LFwiYlwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjJ9LFwiY1wiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjN9LFwiZFwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjR9LFwidHhcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjo1fSxcInR5XCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6Nn19fSxcIlNoYXBlRW50aXR5XCI6e1wib25lb2ZzXCI6e1wiYXJnc1wiOntcIm9uZW9mXCI6W1wic2hhcGVcIixcInJlY3RcIixcImVsbGlwc2VcIl19fSxcImZpZWxkc1wiOntcInR5cGVcIjp7XCJ0eXBlXCI6XCJTaGFwZVR5cGVcIixcImlkXCI6MX0sXCJzaGFwZVwiOntcInR5cGVcIjpcIlNoYXBlQXJnc1wiLFwiaWRcIjoyfSxcInJlY3RcIjp7XCJ0eXBlXCI6XCJSZWN0QXJnc1wiLFwiaWRcIjozfSxcImVsbGlwc2VcIjp7XCJ0eXBlXCI6XCJFbGxpcHNlQXJnc1wiLFwiaWRcIjo0fSxcInN0eWxlc1wiOntcInR5cGVcIjpcIlNoYXBlU3R5bGVcIixcImlkXCI6MTB9LFwidHJhbnNmb3JtXCI6e1widHlwZVwiOlwiVHJhbnNmb3JtXCIsXCJpZFwiOjExfX0sXCJuZXN0ZWRcIjp7XCJTaGFwZVR5cGVcIjp7XCJ2YWx1ZXNcIjp7XCJTSEFQRVwiOjAsXCJSRUNUXCI6MSxcIkVMTElQU0VcIjoyLFwiS0VFUFwiOjN9fSxcIlNoYXBlQXJnc1wiOntcImZpZWxkc1wiOntcImRcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImlkXCI6MX19fSxcIlJlY3RBcmdzXCI6e1wiZmllbGRzXCI6e1wieFwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjF9LFwieVwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjJ9LFwid2lkdGhcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjozfSxcImhlaWdodFwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjR9LFwiY29ybmVyUmFkaXVzXCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6NX19fSxcIkVsbGlwc2VBcmdzXCI6e1wiZmllbGRzXCI6e1wieFwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjF9LFwieVwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjJ9LFwicmFkaXVzWFwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjN9LFwicmFkaXVzWVwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjR9fX0sXCJTaGFwZVN0eWxlXCI6e1wiZmllbGRzXCI6e1wiZmlsbFwiOntcInR5cGVcIjpcIlJHQkFDb2xvclwiLFwiaWRcIjoxfSxcInN0cm9rZVwiOntcInR5cGVcIjpcIlJHQkFDb2xvclwiLFwiaWRcIjoyfSxcInN0cm9rZVdpZHRoXCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6M30sXCJsaW5lQ2FwXCI6e1widHlwZVwiOlwiTGluZUNhcFwiLFwiaWRcIjo0fSxcImxpbmVKb2luXCI6e1widHlwZVwiOlwiTGluZUpvaW5cIixcImlkXCI6NX0sXCJtaXRlckxpbWl0XCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6Nn0sXCJsaW5lRGFzaElcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjo3fSxcImxpbmVEYXNoSUlcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjo4fSxcImxpbmVEYXNoSUlJXCI6e1widHlwZVwiOlwiZmxvYXRcIixcImlkXCI6OX19LFwibmVzdGVkXCI6e1wiUkdCQUNvbG9yXCI6e1wiZmllbGRzXCI6e1wiclwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjF9LFwiZ1wiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjJ9LFwiYlwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjN9LFwiYVwiOntcInR5cGVcIjpcImZsb2F0XCIsXCJpZFwiOjR9fX0sXCJMaW5lQ2FwXCI6e1widmFsdWVzXCI6e1wiTGluZUNhcF9CVVRUXCI6MCxcIkxpbmVDYXBfUk9VTkRcIjoxLFwiTGluZUNhcF9TUVVBUkVcIjoyfX0sXCJMaW5lSm9pblwiOntcInZhbHVlc1wiOntcIkxpbmVKb2luX01JVEVSXCI6MCxcIkxpbmVKb2luX1JPVU5EXCI6MSxcIkxpbmVKb2luX0JFVkVMXCI6Mn19fX19fSxcIkZyYW1lRW50aXR5XCI6e1wiZmllbGRzXCI6e1wiYWxwaGFcIjp7XCJ0eXBlXCI6XCJmbG9hdFwiLFwiaWRcIjoxfSxcImxheW91dFwiOntcInR5cGVcIjpcIkxheW91dFwiLFwiaWRcIjoyfSxcInRyYW5zZm9ybVwiOntcInR5cGVcIjpcIlRyYW5zZm9ybVwiLFwiaWRcIjozfSxcImNsaXBQYXRoXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJpZFwiOjR9LFwic2hhcGVzXCI6e1wicnVsZVwiOlwicmVwZWF0ZWRcIixcInR5cGVcIjpcIlNoYXBlRW50aXR5XCIsXCJpZFwiOjV9fX0sXCJNb3ZpZUVudGl0eVwiOntcImZpZWxkc1wiOntcInZlcnNpb25cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImlkXCI6MX0sXCJwYXJhbXNcIjp7XCJ0eXBlXCI6XCJNb3ZpZVBhcmFtc1wiLFwiaWRcIjoyfSxcImltYWdlc1wiOntcImtleVR5cGVcIjpcInN0cmluZ1wiLFwidHlwZVwiOlwiYnl0ZXNcIixcImlkXCI6M30sXCJzcHJpdGVzXCI6e1wicnVsZVwiOlwicmVwZWF0ZWRcIixcInR5cGVcIjpcIlNwcml0ZUVudGl0eVwiLFwiaWRcIjo0fSxcImF1ZGlvc1wiOntcInJ1bGVcIjpcInJlcGVhdGVkXCIsXCJ0eXBlXCI6XCJBdWRpb0VudGl0eVwiLFwiaWRcIjo1fX19fX19fX19fX0nKSxcbiAgICAgIEZyID0gSXIuUm9vdC5mcm9tSlNPTihOcikubG9va3VwVHlwZShcImNvbS5vcGVuc291cmNlLnN2Z2EuTW92aWVFbnRpdHlcIiksXG4gICAgICBqciA9IHt9LFxuICAgICAgTHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1KGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgbyh0aGlzLCB0KTtcbiAgICAgICAgfSwgW3tcbiAgICAgICAgICBrZXk6IFwibG9hZFwiLFxuICAgICAgICAgIHZhbHVlOiAodCA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChyKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHJldHVybiBlKCkud3JhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBmb3IgKDs7KSBzd2l0Y2ggKHQucHJldiA9IHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICghanJbcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5uZXh0ID0gMywganJbcl07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgaWYgKDEgIT09IChpID0gdC5zZW50KS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoXCLpooTliqDovb3lkb3kuK1cIiwgci5zdWJzdHJpbmcoci5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSksIHQuYWJydXB0KFwicmV0dXJuXCIsIGkuZGF0YSk7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgaWYgKDAgIT09IHIuaW5kZXhPZihcImh0dHA6Ly9cIikgJiYgMCAhPT0gci5pbmRleE9mKFwiaHR0cHM6Ly9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5sb2FkVXJsKHIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5sb2FkRmlsZShyKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHQsIHRoaXMpO1xuICAgICAgICAgIH0pKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsb2FkVXJsXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgICAgaWYgKFwiaDVcIiA9PT0gXygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICBpLm9wZW4oXCJHRVRcIiwgdCwgITApLCBpLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIiwgaS5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBpLnJlc3BvbnNlIHx8IDIwMCAhPT0gaS5zdGF0dXMgJiYgMzA0ICE9PSBpLnN0YXR1cykgcihuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCwgXCIuY29uY2F0KGkuc3RhdHVzVGV4dCkpKTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBCcihpLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgICBzID0gRnIuZGVjb2RlKG4pO1xuICAgICAgICAgICAgICAgICAgICBlKG5ldyBBKHMsIHQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBpLnNlbmQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGwoKS5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHQsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBCcihpLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgIHMgPSBGci5kZWNvZGUobik7XG4gICAgICAgICAgICAgICAgICAgIGUobmV3IEEocywgdCkpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICByKHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHIobmV3IEVycm9yKHQuZXJyTXNnIHx8IFwibG9hZCB1cmwgZmFpbGVkXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImxvYWRGaWxlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgICAgXCJoNVwiID09PSBfKCkgPyByKG5ldyBFcnJvcihcIuaaguS4jeaUr+aMgVwiKSkgOiBsKCkuZ2V0RmlsZVN5c3RlbU1hbmFnZXIoKS5yZWFkRmlsZSh7XG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IHQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gQnIoaS5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICBzID0gRnIuZGVjb2RlKG4pO1xuICAgICAgICAgICAgICAgICAgICBlKG5ldyBBKHMsIHQpKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcih0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICByKG5ldyBFcnJvcih0LmVyck1zZyB8fCBcImxvYWQgZmlsZSBmYWlsZWRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dLCBbe1xuICAgICAgICAgIGtleTogXCJwcmVsb2FkXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAoIXQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICBtc2c6IFwibm8gcHJlbG9hZCB1cmxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoanJbdF0pIHJldHVybiBqclt0XTtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGkgPSBfKCk7XG4gICAgICAgICAgICAgIFwiaDVcIiA9PT0gaSA/IGUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgbXNnOiBcInBsYXRmb3JtIHVuc3VwcG9ydGVkXCJcbiAgICAgICAgICAgICAgfSkgOiBsKCkucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0LFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImFsaXBheVwiID09PSBpID8gXCJhcnJheWJ1ZmZlclwiIDogXCLlhbbku5ZcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBCcihpLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgIHMgPSBGci5kZWNvZGUobik7XG4gICAgICAgICAgICAgICAgICAgIHkoXCLpooTliqDovb3lrozmiJAsIOiAl+aXtjogXCIuY29uY2F0KERhdGUubm93KCkgLSByLCBcIm1zXCIpLCB0LnN1YnN0cmluZyh0Lmxhc3RJbmRleE9mKFwiL1wiKSArIDEpKSwgZSh7XG4gICAgICAgICAgICAgICAgICAgICAgY29kZTogMSxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBuZXcgQShzLCB0KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeShcIumihOWKoOi9veino+aekOWksei0pSwg6ICX5pe2OiBcIi5jb25jYXQoRGF0ZS5ub3coKSAtIHIsIFwibXNcIiksIHQpLCBlKHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIG1zZzogXCJmaWxlIHBhcnNlIGZhaWxlZFwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHkoXCLpooTliqDovb3lpLHotKUsIOiAl+aXtjogXCIuY29uY2F0KERhdGUubm93KCkgLSByLCBcIm1zXCIpLCB0KSwgZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1zZzogXCJmaWxlIHJlYWQgZmFpbGVkXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBqclt0XSA9IGUsIGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInVubG9hZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZGVsZXRlIGpyW3RdLCBqclt0XSA9IHZvaWQgMCwgeShcIumHiuaUvumihOWKoOi9vVwiLCB0LnN1YnN0cmluZyh0Lmxhc3RJbmRleE9mKFwiL1wiKSArIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICB9KCk7XG4gICAgZnVuY3Rpb24gQ3IodCwgZSkge1xuICAgICAgdmFyIHIgPSBPYmplY3Qua2V5cyh0KTtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtcbiAgICAgICAgZSAmJiAoaSA9IGkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgZSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSkpLCByLnB1c2guYXBwbHkociwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUnIodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHIgPSBudWxsICE9IGFyZ3VtZW50c1tlXSA/IGFyZ3VtZW50c1tlXSA6IHt9O1xuICAgICAgICBlICUgMiA/IENyKE9iamVjdChyKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBmKHQsIGUsIHJbZV0pO1xuICAgICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpIDogQ3IoT2JqZWN0KHIpKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IociwgZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBEcih0KSB7XG4gICAgICByZXR1cm4gRHIgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgICAgIH0sIERyKHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICByZXR1cm4gKE1yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0O1xuICAgICAgfSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUHIoZSwgciwgaSkge1xuICAgICAgcmV0dXJuIHIgPSBEcihyKSwgZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgaWYgKHIgJiYgKFwib2JqZWN0XCIgPT0gdChyKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIpKSByZXR1cm4gcjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSB0KSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0oZSk7XG4gICAgICB9KGUsIE1yKCkgPyBSZWZsZWN0LmNvbnN0cnVjdChyLCBpIHx8IFtdLCBEcihlKS5jb25zdHJ1Y3RvcikgOiByLmFwcGx5KGUsIGkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVXIodCwgZSkge1xuICAgICAgcmV0dXJuIFVyID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gICAgICB9LCBVcih0LCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWnIodCwgZSkge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgICB3cml0YWJsZTogITFcbiAgICAgIH0pLCBlICYmIFVyKHQsIGUpO1xuICAgIH1cbiAgICB2YXIgcXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKHQsIHIsIGksIG4sIHMsIGEpIHtcbiAgICAgICAgICB2YXIgaDtcbiAgICAgICAgICByZXR1cm4gbyh0aGlzLCBlKSwgZihoID0gUHIodGhpcywgZSwgW1wiXCIsIHMsIGFdKSwgXCJfeFwiLCB2b2lkIDApLCBmKGgsIFwiX3lcIiwgdm9pZCAwKSwgZihoLCBcIl9yYWRpdXNYXCIsIHZvaWQgMCksIGYoaCwgXCJfcmFkaXVzWVwiLCB2b2lkIDApLCBmKGgsIFwiX3RyYW5zZm9ybVwiLCB2b2lkIDApLCBmKGgsIFwiX3N0eWxlc1wiLCB2b2lkIDApLCBoLl94ID0gdCwgaC5feSA9IHIsIGguX3JhZGl1c1ggPSBpLCBoLl9yYWRpdXNZID0gbiwgaC5fdHJhbnNmb3JtID0gcywgaC5fc3R5bGVzID0gYSwgaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWnIoZSwgdCksIHUoZSk7XG4gICAgICB9KGIpLFxuICAgICAgSnIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKHQsIHIsIGksIG4sIHMsIGEsIGgpIHtcbiAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICByZXR1cm4gbyh0aGlzLCBlKSwgZih1ID0gUHIodGhpcywgZSwgW1wiXCIsIGEsIGhdKSwgXCJfeFwiLCB2b2lkIDApLCBmKHUsIFwiX3lcIiwgdm9pZCAwKSwgZih1LCBcIl93aWR0aFwiLCB2b2lkIDApLCBmKHUsIFwiX2hlaWdodFwiLCB2b2lkIDApLCBmKHUsIFwiX2Nvcm5lclJhZGl1c1wiLCB2b2lkIDApLCBmKHUsIFwiX3RyYW5zZm9ybVwiLCB2b2lkIDApLCBmKHUsIFwiX3N0eWxlc1wiLCB2b2lkIDApLCB1Ll94ID0gdCwgdS5feSA9IHIsIHUuX3dpZHRoID0gaSwgdS5faGVpZ2h0ID0gbiwgdS5fY29ybmVyUmFkaXVzID0gcywgdS5fdHJhbnNmb3JtID0gYSwgdS5fc3R5bGVzID0gaCwgdTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWnIoZSwgdCksIHUoZSk7XG4gICAgICB9KGIpLFxuICAgICAgVnIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogNixcbiAgICAgICAgICByID0gTWF0aC5wb3coMTAsIGUpO1xuICAgICAgICByZXR1cm4gfn4odCAqIHIpIC8gcjtcbiAgICAgIH0sXG4gICAgICBIciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB+fnQ7XG4gICAgICB9LFxuICAgICAgJHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1KGZ1bmN0aW9uIHQoZSwgciwgaSkge1xuICAgICAgICAgIG8odGhpcywgdCksIHRoaXMudmlkZW9JdGVtID0gZSwgdGhpcy53aWR0aCA9IHIsIHRoaXMuaGVpZ2h0ID0gaSwgZih0aGlzLCBcImNhbnZhc1wiLCB2b2lkIDApLCBmKHRoaXMsIFwiY3R4XCIsIHZvaWQgMCksIGYodGhpcywgXCJfdHJhbnNmb3JtXCIsIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICAgICAgc2NhbGU6IDFcbiAgICAgICAgICB9KSwgZih0aGlzLCBcImRwclwiLCBcImg1XCIgPT09IF8oKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogbCgpLmdldFN5c3RlbUluZm9TeW5jKCkucGl4ZWxSYXRpbyksIGYodGhpcywgXCJnbG9iYWxUcmFuc2Zvcm1cIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9keW5hbWljSW1hZ2VcIiwge30pLCBmKHRoaXMsIFwiX2R5bmFtaWNUZXh0XCIsIHt9KSwgZih0aGlzLCBcImlzTWF0dGVpbmdcIiwgITEpLCBmKHRoaXMsIFwibWF0dGVTcHJpdGVzXCIsIHt9KSwgdGhpcy52aWRlb0l0ZW0gPSBlLCB0aGlzLmNhbnZhcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbXkgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBteS5jcmVhdGVPZmZzY3JlZW5DYW52YXMpIHJldHVybiBteS5jcmVhdGVPZmZzY3JlZW5DYW52YXMoe1xuICAgICAgICAgICAgICB3aWR0aDogdC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0LmhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgdHQgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBoYXMuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gaGFzLmNyZWF0ZU9mZnNjcmVlbkNhbnZhcygpO1xuICAgICAgICAgICAgICByZXR1cm4gZS53aWR0aCA9IHQud2lkdGgsIGUuaGVpZ2h0ID0gdC5oZWlnaHQsIGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd3ggJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBoYXMuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKSByZXR1cm4gaGFzLmNyZWF0ZU9mZnNjcmVlbkNhbnZhcyh0KTtcbiAgICAgICAgICAgIGlmIChcIk9mZnNjcmVlbkNhbnZhc1wiIGluIHdpbmRvdykgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXModC53aWR0aCwgdC5oZWlnaHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5pqC5LiN5pSv5oyB5b2T5YmN546v5aKDXCIpO1xuICAgICAgICAgIH0oe1xuICAgICAgICAgICAgd2lkdGg6IHIsXG4gICAgICAgICAgICBoZWlnaHQ6IGksXG4gICAgICAgICAgICB0eXBlOiBcIjJkXCJcbiAgICAgICAgICB9KSwgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIH0sIFt7XG4gICAgICAgICAga2V5OiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5jdHgsXG4gICAgICAgICAgICAgIGUgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgdC5jbGVhclJlY3QoZS54LCBlLnksIGUud2lkdGgsIGUuaGVpZ2h0KSwgdGhpcy5pc01hdHRlaW5nID0gITEsIHRoaXMubWF0dGVTcHJpdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRyYXdGcmFtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogWzAsIDFdLCByID0gdGhpcy5jdHgsIGkgPSB0aGlzLmlzTWF0dGVpbmcsIG4gPSB0aGlzLm1hdHRlU3ByaXRlcywgcyA9IHRoaXMudmlkZW9JdGVtLnNwcml0ZXMsIG8gPSBIcihzLmxlbmd0aCAqIGVbMF0pLCBhID0gSHIocy5sZW5ndGggKiBlWzFdKTsgbyA8IGE7IG8rKykge1xuICAgICAgICAgICAgICB2YXIgaCxcbiAgICAgICAgICAgICAgICB1LFxuICAgICAgICAgICAgICAgIGwgPSBzW29dO1xuICAgICAgICAgICAgICBpZiAoLTEgIT0gKG51bGwgPT09IChoID0gc1swXS5pbWFnZUtleSkgfHwgdm9pZCAwID09PSBoID8gdm9pZCAwIDogaC5pbmRleE9mKFwiLm1hdHRlXCIpKSkge1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PSAobnVsbCA9PT0gKHUgPSBsLmltYWdlS2V5KSB8fCB2b2lkIDAgPT09IHUgPyB2b2lkIDAgOiB1LmluZGV4T2YoXCIubWF0dGVcIikpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZiA9IHNbbyAtIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKGkgJiYgKCFsLm1hdHRlS2V5IHx8IDAgPT0gbC5tYXR0ZUtleS5sZW5ndGggfHwgbC5tYXR0ZUtleSAhPSBmLm1hdHRlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTWF0dGVpbmcgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuW2wubWF0dGVLZXldO1xuICAgICAgICAgICAgICAgICAgICByLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIiwgdGhpcy5kcmF3U3ByaXRlKGMsIHQpLCByLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIiwgci5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBudWxsID09IGwubWF0dGVLZXkgfHwgbnVsbCAhPSBmLm1hdHRlS2V5ICYmIDAgIT0gZi5tYXR0ZUtleS5sZW5ndGggJiYgZi5tYXR0ZUtleSA9PSBsLm1hdHRlS2V5IHx8ICh0aGlzLmlzTWF0dGVpbmcgPSAhMCksIHRoaXMuZHJhd1Nwcml0ZShsLCB0KSwgaSAmJiBvID09IHMubGVuZ3RoIC0gMSAmJiAoYyA9IG4uZ2V0KGwubWF0dGVLZXkpLCByLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIiwgdGhpcy5kcmF3U3ByaXRlKGMsIHQpLCByLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIiwgci5yZXN0b3JlKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBjW2wuaW1hZ2VLZXldID0gbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuZHJhd1Nwcml0ZShsLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZHJhd1Nwcml0ZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIG4gPSB0aGlzLFxuICAgICAgICAgICAgICBzID0gdC5mcmFtZXNbZV07XG4gICAgICAgICAgICBpZiAocyAmJiAhKHMuYWxwaGEgPCAuMDUpKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gdGhpcy5jdHg7XG4gICAgICAgICAgICAgIG8uc2F2ZSgpLCB0aGlzLmdsb2JhbFRyYW5zZm9ybSAmJiBvLnRyYW5zZm9ybShWcih0aGlzLmdsb2JhbFRyYW5zZm9ybS5hKSwgVnIodGhpcy5nbG9iYWxUcmFuc2Zvcm0uYiksIFZyKHRoaXMuZ2xvYmFsVHJhbnNmb3JtLmMpLCBWcih0aGlzLmdsb2JhbFRyYW5zZm9ybS5kKSwgfn50aGlzLmdsb2JhbFRyYW5zZm9ybS50eCwgfn50aGlzLmdsb2JhbFRyYW5zZm9ybS50eSksIG8uZ2xvYmFsQWxwaGEgPSBzLmFscGhhLCBvLnRyYW5zZm9ybShWcihzLnRyYW5zZm9ybS5hKSwgVnIocy50cmFuc2Zvcm0uYiksIFZyKHMudHJhbnNmb3JtLmMpLCBWcihzLnRyYW5zZm9ybS5kKSwgfn5zLnRyYW5zZm9ybS50eCwgfn5zLnRyYW5zZm9ybS50eSk7XG4gICAgICAgICAgICAgIHZhciBhID0gbnVsbCA9PT0gKHIgPSB0LmltYWdlS2V5KSB8fCB2b2lkIDAgPT09IHIgPyB2b2lkIDAgOiByLnJlcGxhY2UoXCIubWF0dGVcIiwgXCJcIik7XG4gICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBudWxsICE9PSAoaSA9IHRoaXMuX2R5bmFtaWNJbWFnZVthXSkgJiYgdm9pZCAwICE9PSBpID8gaSA6IHRoaXMudmlkZW9JdGVtLmRlY29kZWRJbWFnZXNbYV07XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcy5tYXNrUGF0aCAmJiBudWxsICE9PSBzLm1hc2tQYXRoICYmIChzLm1hc2tQYXRoLl9zdHlsZXMgPSB2b2lkIDAsIHRoaXMuZHJhd0JlemllcihzLm1hc2tQYXRoKSwgby5jbGlwKCkpLCBoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdSA9IHMubGF5b3V0LndpZHRoICogdGhpcy50cmFuc2Zvcm0uc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGwgPSBzLmxheW91dC5oZWlnaHQgKiB0aGlzLnRyYW5zZm9ybS5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgZiA9IHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0ZVggKiB0aGlzLmRwciAtICh1IC0gcy5sYXlvdXQud2lkdGgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0ZVkgKiB0aGlzLmRwciAtIChsIC0gcy5sYXlvdXQuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgICBvLmRyYXdJbWFnZShoLCAwLCAwLCBoLndpZHRoLCBoLmhlaWdodCwgZiwgYywgdSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMuc2hhcGVzICYmIHMuc2hhcGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlID0gdC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCIgPT09IHQudHlwZSAmJiB0LnBhdGhBcmdzICYmIHQucGF0aEFyZ3MuZCAmJiBuLmRyYXdCZXppZXIobmV3IGIodC5wYXRoQXJncy5kLCBlLCB0LnN0eWxlcykpLCBcImVsbGlwc2VcIiA9PT0gdC50eXBlICYmIHQucGF0aEFyZ3MgJiYgbi5kcmF3RWxsaXBzZShuZXcgcXIocGFyc2VGbG9hdCh0LnBhdGhBcmdzLngpIHx8IDAsIHBhcnNlRmxvYXQodC5wYXRoQXJncy55KSB8fCAwLCBwYXJzZUZsb2F0KHQucGF0aEFyZ3MucmFkaXVzWCkgfHwgMCwgcGFyc2VGbG9hdCh0LnBhdGhBcmdzLnJhZGl1c1kpIHx8IDAsIGUsIHQuc3R5bGVzKSksIFwicmVjdFwiID09PSB0LnR5cGUgJiYgdC5wYXRoQXJncyAmJiBuLmRyYXdSZWN0KG5ldyBKcihwYXJzZUZsb2F0KHQucGF0aEFyZ3MueCkgfHwgMCwgcGFyc2VGbG9hdCh0LnBhdGhBcmdzLnkpIHx8IDAsIHBhcnNlRmxvYXQodC5wYXRoQXJncy53aWR0aCkgfHwgMCwgcGFyc2VGbG9hdCh0LnBhdGhBcmdzLmhlaWdodCkgfHwgMCwgcGFyc2VGbG9hdCh0LnBhdGhBcmdzLmNvcm5lclJhZGl1cykgfHwgMCwgZSwgdC5zdHlsZXMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuX2R5bmFtaWNUZXh0W2FdO1xuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgICAgby5mb250ID0gXCJcIi5jb25jYXQoZC5zaXplLCBcInB4IFwiKS5jb25jYXQobnVsbCAhPT0gKHAgPSBkLmZhbWlseSkgJiYgdm9pZCAwICE9PSBwID8gcCA6IFwiQXJpYWxcIik7XG4gICAgICAgICAgICAgICAgICB2YXIgeSA9IG8ubWVhc3VyZVRleHQoZC50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgICAgICAgIG8uZmlsbFN0eWxlID0gZC5jb2xvcjtcbiAgICAgICAgICAgICAgICAgIHZhciB2ID0gdm9pZCAwICE9PSBkLm9mZnNldCAmJiB2b2lkIDAgIT09IGQub2Zmc2V0LnggPyBpc05hTihkLm9mZnNldC54KSA/IDAgOiBkLm9mZnNldC54IDogMCxcbiAgICAgICAgICAgICAgICAgICAgZyA9IHZvaWQgMCAhPT0gZC5vZmZzZXQgJiYgdm9pZCAwICE9PSBkLm9mZnNldC55ID8gaXNOYU4oZC5vZmZzZXQueSkgPyAwIDogZC5vZmZzZXQueSA6IDA7XG4gICAgICAgICAgICAgICAgICBvLmZpbGxUZXh0KGQudGV4dCwgKHMubGF5b3V0LndpZHRoIC0geSkgLyAyICsgdiwgcy5sYXlvdXQuaGVpZ2h0IC8gMiArIGcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZXNldFNoYXBlU3R5bGVzXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuY3R4LFxuICAgICAgICAgICAgICByID0gdC5fc3R5bGVzO1xuICAgICAgICAgICAgciAmJiAociAmJiByLnN0cm9rZSA/IGUuc3Ryb2tlU3R5bGUgPSBcInJnYmEoXCIuY29uY2F0KCgyNTUgKiByLnN0cm9rZVswXSkudG9GaXhlZCgwKSwgXCIsIFwiKS5jb25jYXQoKDI1NSAqIHIuc3Ryb2tlWzFdKS50b0ZpeGVkKDApLCBcIiwgXCIpLmNvbmNhdCgoMjU1ICogci5zdHJva2VbMl0pLnRvRml4ZWQoMCksIFwiLCBcIikuY29uY2F0KHIuc3Ryb2tlWzNdLCBcIilcIikgOiBlLnN0cm9rZVN0eWxlID0gXCJ0cmFuc3BhcmVudFwiLCByICYmIChlLmxpbmVXaWR0aCA9IHIuc3Ryb2tlV2lkdGggfHwgdm9pZCAwLCBlLmxpbmVDYXAgPSByLmxpbmVDYXAgfHwgdm9pZCAwLCBlLmxpbmVKb2luID0gci5saW5lSm9pbiB8fCB2b2lkIDAsIGUubWl0ZXJMaW1pdCA9IHIubWl0ZXJMaW1pdCB8fCB2b2lkIDApLCByICYmIHIuZmlsbCA/IGUuZmlsbFN0eWxlID0gXCJyZ2JhKFwiLmNvbmNhdCgoMjU1ICogci5maWxsWzBdKS50b0ZpeGVkKDApLCBcIiwgXCIpLmNvbmNhdCgoMjU1ICogci5maWxsWzFdKS50b0ZpeGVkKDApLCBcIiwgXCIpLmNvbmNhdCgoMjU1ICogci5maWxsWzJdKS50b0ZpeGVkKDApLCBcIiwgXCIpLmNvbmNhdChyLmZpbGxbM10sIFwiKVwiKSA6IGUuZmlsbFN0eWxlID0gXCJ0cmFuc3BhcmVudFwiLCByICYmIHIubGluZURhc2ggJiYgKGUubGluZURhc2hPZmZzZXQgPSByLmxpbmVEYXNoWzJdLCBlLnNldExpbmVEYXNoKFtyLmxpbmVEYXNoWzBdLCByLmxpbmVEYXNoWzFdXSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZHJhd0JlemllclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgICByID0gdGhpcy5jdHg7XG4gICAgICAgICAgICByLnNhdmUoKSwgdGhpcy5yZXNldFNoYXBlU3R5bGVzKHQpLCB2b2lkIDAgIT09IHQuX3RyYW5zZm9ybSAmJiBudWxsICE9PSB0Ll90cmFuc2Zvcm0gJiYgci50cmFuc2Zvcm0oVnIodC5fdHJhbnNmb3JtLmEpLCBWcih0Ll90cmFuc2Zvcm0uYiksIFZyKHQuX3RyYW5zZm9ybS5jKSwgVnIodC5fdHJhbnNmb3JtLmQpLCB+fnQuX3RyYW5zZm9ybS50eCwgfn50Ll90cmFuc2Zvcm0udHkpO1xuICAgICAgICAgICAgdmFyIGkgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICAgIHkyOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgci5iZWdpblBhdGgoKSwgdC5fZC5yZXBsYWNlKC8oW2EtekEtWl0pL2csIFwifHx8JDEgXCIpLnJlcGxhY2UoLywvZywgXCIgXCIpLnNwbGl0KFwifHx8XCIpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgaWYgKDAgIT0gdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQuc3Vic3RyaW5nKDAsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChcIk1MSFZDU1FSWm1saHZjc3FyelwiLmluZGV4T2YocikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0LnN1YnN0cmluZygxKS50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgZS5kcmF3QmV6aWVyRWxlbWVudChpLCByLCBuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB0Ll9zdHlsZXMgJiYgdC5fc3R5bGVzLmZpbGwgJiYgci5maWxsKCksIHQuX3N0eWxlcyAmJiB0Ll9zdHlsZXMuc3Ryb2tlICYmIHIuc3Ryb2tlKCksIHIucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkcmF3QmV6aWVyRWxlbWVudFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgIHQueCA9IEhyKHJbMF0pLCB0LnkgPSBIcihyWzFdKSwgaS5tb3ZlVG8odC54LCB0LnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICAgIHQueCArPSBIcihyWzBdKSwgdC55ICs9IEhyKHJbMV0pLCBpLm1vdmVUbyh0LngsIHQueSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgdC54ID0gSHIoclswXSksIHQueSA9IEhyKHJbMV0pLCBpLmxpbmVUbyh0LngsIHQueSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICAgICAgdC54ICs9IEhyKHJbMF0pLCB0LnkgKz0gSHIoclsxXSksIGkubGluZVRvKHQueCwgdC55KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICB0LnggPSBIcihyWzBdKSwgaS5saW5lVG8odC54LCB0LnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICAgIHQueCArPSBIcihyWzBdKSwgaS5saW5lVG8odC54LCB0LnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiVlwiOlxuICAgICAgICAgICAgICAgIHQueSA9IEhyKHJbMF0pLCBpLmxpbmVUbyh0LngsIHQueSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgdC55ICs9IEhyKHJbMF0pLCBpLmxpbmVUbyh0LngsIHQueSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgICAgICAgdC54MSA9IEhyKHJbMF0pLCB0LnkxID0gSHIoclsxXSksIHQueDIgPSBIcihyWzJdKSwgdC55MiA9IEhyKHJbM10pLCB0LnggPSBIcihyWzRdKSwgdC55ID0gSHIocls1XSksIGkuYmV6aWVyQ3VydmVUbyh0LngxLCB0LnkxLCB0LngyLCB0LnkyLCB0LngsIHQueSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgdC54MSA9IHQueCArIEhyKHJbMF0pLCB0LnkxID0gdC55ICsgSHIoclsxXSksIHQueDIgPSB0LnggKyBIcihyWzJdKSwgdC55MiA9IHQueSArIEhyKHJbM10pLCB0LnggKz0gSHIocls0XSksIHQueSArPSBIcihyWzVdKSwgaS5iZXppZXJDdXJ2ZVRvKHQueDEsIHQueTEsIHQueDIsIHQueTIsIHQueCwgdC55KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICB0LngxICYmIHQueTEgJiYgdC54MiAmJiB0LnkyID8gKHQueDEgPSB0LnggLSB0LngyICsgdC54LCB0LnkxID0gdC55IC0gdC55MiArIHQueSwgdC54MiA9IEhyKHJbMF0pLCB0LnkyID0gSHIoclsxXSksIHQueCA9IEhyKHJbMl0pLCB0LnkgPSBIcihyWzNdKSwgaS5iZXppZXJDdXJ2ZVRvKHQueDEsIHQueTEsIHQueDIsIHQueTIsIHQueCwgdC55KSkgOiAodC54MSA9IEhyKHJbMF0pLCB0LnkxID0gSHIoclsxXSksIHQueCA9IEhyKHJbMl0pLCB0LnkgPSBIcihyWzNdKSwgaS5xdWFkcmF0aWNDdXJ2ZVRvKHQueDEsIHQueTEsIHQueCwgdC55KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgdC54MSAmJiB0LnkxICYmIHQueDIgJiYgdC55MiA/ICh0LngxID0gdC54IC0gdC54MiArIHQueCwgdC55MSA9IHQueSAtIHQueTIgKyB0LnksIHQueDIgPSB0LnggKyBIcihyWzBdKSwgdC55MiA9IHQueSArIEhyKHJbMV0pLCB0LnggKz0gSHIoclsyXSksIHQueSArPSBIcihyWzNdKSwgaS5iZXppZXJDdXJ2ZVRvKHQueDEsIHQueTEsIHQueDIsIHQueTIsIHQueCwgdC55KSkgOiAodC54MSA9IHQueCArIEhyKHJbMF0pLCB0LnkxID0gdC55ICsgSHIoclsxXSksIHQueCArPSBIcihyWzJdKSwgdC55ICs9IEhyKHJbM10pLCBpLnF1YWRyYXRpY0N1cnZlVG8odC54MSwgdC55MSwgdC54LCB0LnkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgICAgICB0LngxID0gSHIoclswXSksIHQueTEgPSBIcihyWzFdKSwgdC54ID0gSHIoclsyXSksIHQueSA9IEhyKHJbM10pLCBpLnF1YWRyYXRpY0N1cnZlVG8odC54MSwgdC55MSwgdC54LCB0LnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgICAgIHQueDEgPSB0LnggKyBIcihyWzBdKSwgdC55MSA9IHQueSArIEhyKHJbMV0pLCB0LnggKz0gSHIoclsyXSksIHQueSArPSBIcihyWzNdKSwgaS5xdWFkcmF0aWNDdXJ2ZVRvKHQueDEsIHQueTEsIHQueCwgdC55KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgICAgICBpLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkcmF3RWxsaXBzZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGUuc2F2ZSgpLCB0aGlzLnJlc2V0U2hhcGVTdHlsZXModCksIHZvaWQgMCAhPT0gdC5fdHJhbnNmb3JtICYmIG51bGwgIT09IHQuX3RyYW5zZm9ybSAmJiBlLnRyYW5zZm9ybShWcih0Ll90cmFuc2Zvcm0uYSksIFZyKHQuX3RyYW5zZm9ybS5iKSwgVnIodC5fdHJhbnNmb3JtLmMpLCBWcih0Ll90cmFuc2Zvcm0uZCksIH5+dC5fdHJhbnNmb3JtLnR4LCB+fnQuX3RyYW5zZm9ybS50eSk7XG4gICAgICAgICAgICB2YXIgciA9IHQuX3ggLSB0Ll9yYWRpdXNYLFxuICAgICAgICAgICAgICBpID0gdC5feSAtIHQuX3JhZGl1c1ksXG4gICAgICAgICAgICAgIG4gPSAyICogdC5fcmFkaXVzWCxcbiAgICAgICAgICAgICAgcyA9IDIgKiB0Ll9yYWRpdXNZLFxuICAgICAgICAgICAgICBvID0gLjU1MjI4NDgsXG4gICAgICAgICAgICAgIGEgPSBuIC8gMiAqIG8sXG4gICAgICAgICAgICAgIGggPSBzIC8gMiAqIG8sXG4gICAgICAgICAgICAgIHUgPSByICsgbixcbiAgICAgICAgICAgICAgbCA9IGkgKyBzLFxuICAgICAgICAgICAgICBmID0gciArIG4gLyAyLFxuICAgICAgICAgICAgICBjID0gaSArIHMgLyAyO1xuICAgICAgICAgICAgZS5iZWdpblBhdGgoKSwgZS5tb3ZlVG8ociwgYyksIGUuYmV6aWVyQ3VydmVUbyhyLCBjIC0gaCwgZiAtIGEsIGksIGYsIGkpLCBlLmJlemllckN1cnZlVG8oZiArIGEsIGksIHUsIGMgLSBoLCB1LCBjKSwgZS5iZXppZXJDdXJ2ZVRvKHUsIGMgKyBoLCBmICsgYSwgbCwgZiwgbCksIGUuYmV6aWVyQ3VydmVUbyhmIC0gYSwgbCwgciwgYyArIGgsIHIsIGMpLCB0Ll9zdHlsZXMgJiYgdC5fc3R5bGVzLmZpbGwgJiYgZS5maWxsKCksIHQuX3N0eWxlcyAmJiB0Ll9zdHlsZXMuc3Ryb2tlICYmIGUuc3Ryb2tlKCksIGUucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkcmF3UmVjdFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGUuc2F2ZSgpLCB0aGlzLnJlc2V0U2hhcGVTdHlsZXModCksIHZvaWQgMCAhPT0gdC5fdHJhbnNmb3JtICYmIG51bGwgIT09IHQuX3RyYW5zZm9ybSAmJiBlLnRyYW5zZm9ybShWcih0Ll90cmFuc2Zvcm0uYSksIFZyKHQuX3RyYW5zZm9ybS5iKSwgVnIodC5fdHJhbnNmb3JtLmMpLCBWcih0Ll90cmFuc2Zvcm0uZCksIH5+dC5fdHJhbnNmb3JtLnR4LCB+fnQuX3RyYW5zZm9ybS50eSk7XG4gICAgICAgICAgICB2YXIgciA9IHQuX3gsXG4gICAgICAgICAgICAgIGkgPSB0Ll95LFxuICAgICAgICAgICAgICBuID0gdC5fd2lkdGgsXG4gICAgICAgICAgICAgIHMgPSB0Ll9oZWlnaHQsXG4gICAgICAgICAgICAgIG8gPSB0Ll9jb3JuZXJSYWRpdXM7XG4gICAgICAgICAgICBuIDwgMiAqIG8gJiYgKG8gPSBuIC8gMiksIHMgPCAyICogbyAmJiAobyA9IHMgLyAyKSwgZS5iZWdpblBhdGgoKSwgZS5tb3ZlVG8ociArIG8sIGkpLCBlLmFyY1RvKHIgKyBuLCBpLCByICsgbiwgaSArIHMsIG8pLCBlLmFyY1RvKHIgKyBuLCBpICsgcywgciwgaSArIHMsIG8pLCBlLmFyY1RvKHIsIGkgKyBzLCByLCBpLCBvKSwgZS5hcmNUbyhyLCBpLCByICsgbiwgaSwgbyksIGUuY2xvc2VQYXRoKCksIHQuX3N0eWxlcyAmJiB0Ll9zdHlsZXMuZmlsbCAmJiBlLmZpbGwoKSwgdC5fc3R5bGVzICYmIHQuX3N0eWxlcy5zdHJva2UgJiYgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNyZWF0ZUltYWdlRGF0YVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfSgpLFxuICAgICAgS3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgbyh0aGlzLCB0KSwgZih0aGlzLCBcImNhbnZhc1wiLCB2b2lkIDApLCBmKHRoaXMsIFwic3RhcnRWYWx1ZVwiLCAwKSwgZih0aGlzLCBcImVuZFZhbHVlXCIsIDApLCBmKHRoaXMsIFwiZHVyYXRpb25cIiwgMCksIGYodGhpcywgXCJsb29wc1wiLCAxKSwgZih0aGlzLCBcImZpbGxSdWxlXCIsIDApLCBmKHRoaXMsIFwibVJ1bm5pbmdcIiwgITEpLCBmKHRoaXMsIFwibVN0YXJ0VGltZVwiLCAwKSwgZih0aGlzLCBcIm1DdXJyZW50RnJpY2F0aW9uXCIsIDApLCBmKHRoaXMsIFwibVJldmVyc2VcIiwgITEpLCBmKHRoaXMsIFwicmVxdWVzdElkXCIsIHZvaWQgMCksIGYodGhpcywgXCJwbGF0Zm9ybVwiLCBfKCkpLCBmKHRoaXMsIFwib25TdGFydFwiLCBmdW5jdGlvbiAoKSB7fSksIGYodGhpcywgXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAodCkge30pLCBmKHRoaXMsIFwib25FbmRcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1KHQsIFt7XG4gICAgICAgICAga2V5OiBcInN0YXJ0XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0aGlzLmRvU3RhcnQoITEsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJyZXZlcnNlXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0aGlzLmRvU3RhcnQoITAsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9TdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImFuaW1hdGVkVmFsdWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVuZFZhbHVlIC0gdGhpcy5zdGFydFZhbHVlKSAqIHRoaXMubUN1cnJlbnRGcmljYXRpb24gKyB0aGlzLnN0YXJ0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImRvU3RhcnRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLm1SZXZlcnNlID0gZSwgdGhpcy5tUnVubmluZyA9ICEwLCB0aGlzLm1TdGFydFRpbWUgPSB0LmN1cnJlbnRUaW1lTWlsbFNlY29uZCgpLCByICYmICh0aGlzLm1TdGFydFRpbWUgLT0gZSA/ICgxIC0gciAvICh0aGlzLmVuZFZhbHVlIC0gdGhpcy5zdGFydFZhbHVlKSkgKiB0aGlzLmR1cmF0aW9uIDogciAvICh0aGlzLmVuZFZhbHVlIC0gdGhpcy5zdGFydFZhbHVlKSAqIHRoaXMuZHVyYXRpb24pLCB0aGlzLm1DdXJyZW50RnJpY2F0aW9uID0gMCwgdGhpcy5vblN0YXJ0KCksIHRoaXMuZG9GcmFtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkb1N0b3BcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5tUnVubmluZyA9ICExLCB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICByZXR1cm4gXCJoNVwiID09PSB0aGlzLnBsYXRmb3JtID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KSA6IG51bGwgPT09IChlID0gdGhpcy5jYW52YXMpIHx8IHZvaWQgMCA9PT0gZSA/IHZvaWQgMCA6IGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjYW5jZWxBbmltYXRpb25GcmFtZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGlmIChcImg1XCIgPT09IHRoaXMucGxhdGZvcm0pIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0SWQpO1xuICAgICAgICAgICAgbnVsbCA9PT0gKHQgPSB0aGlzLmNhbnZhcykgfHwgdm9pZCAwID09PSB0IHx8IHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJkb0ZyYW1lXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdElkID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gcigpIHtcbiAgICAgICAgICAgICAgZS5tUnVubmluZyAmJiAoZS5kb0RlbHRhVGltZSh0LmN1cnJlbnRUaW1lTWlsbFNlY29uZCgpIC0gZS5tU3RhcnRUaW1lKSwgZS5yZXF1ZXN0SWQgPSBlLnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiZG9EZWx0YVRpbWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gITE7XG4gICAgICAgICAgICB0ID49IHRoaXMuZHVyYXRpb24gKiB0aGlzLmxvb3BzID8gKHRoaXMubUN1cnJlbnRGcmljYXRpb24gPSAxID09PSB0aGlzLmZpbGxSdWxlID8gMCA6IDEsIHRoaXMubVJldmVyc2UgJiYgKHRoaXMubUN1cnJlbnRGcmljYXRpb24gPSAxIC0gdGhpcy5tQ3VycmVudEZyaWNhdGlvbiksIHRoaXMubVJ1bm5pbmcgPSAhMSwgZSA9ICEwKSA6ICh0aGlzLm1DdXJyZW50RnJpY2F0aW9uID0gdCAlIHRoaXMuZHVyYXRpb24gLyB0aGlzLmR1cmF0aW9uLCB0aGlzLm1SZXZlcnNlICYmICh0aGlzLm1DdXJyZW50RnJpY2F0aW9uID0gMSAtIHRoaXMubUN1cnJlbnRGcmljYXRpb24pKSwgdGhpcy5vblVwZGF0ZSh0aGlzLmFuaW1hdGVkVmFsdWUoKSksICExID09PSB0aGlzLm1SdW5uaW5nICYmIGUgJiYgdGhpcy5vbkVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgfSgpO1xuICAgIGYoS3IsIFwiY3VycmVudFRpbWVNaWxsU2Vjb25kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBwZXJmb3JtYW5jZSA/IERhdGUubm93KCkgOiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9KTtcbiAgICB2YXIgWHIgPSAwO1xuICAgIGZ1bmN0aW9uIFlyKCkge1xuICAgICAgaWYgKFwiaDVcIiA9PT0gXygpKSByZXR1cm4gITE7XG4gICAgICB2YXIgdCA9IGwoKS5nZXRGaWxlU3lzdGVtTWFuYWdlcigpLFxuICAgICAgICBlID0gdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHQuYWNjZXNzU3luYyhlKSwgITA7XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHQubWtkaXJTeW5jKGUsICEwKSwgeShcIuWIm+W7uue8k+WtmOebruW9lVwiKSwgITA7XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICByZXR1cm4geShcIuWIm+W7uue8k+WtmOebruW9leWksei0pVwiLCB0KSwgITE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEdyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdShmdW5jdGlvbiB0KCkge1xuICAgICAgICAgIG8odGhpcywgdCksIGYodGhpcywgXCJjYW52YXNcIiwgdm9pZCAwKSwgZih0aGlzLCBcImN0eFwiLCB2b2lkIDApLCBmKHRoaXMsIFwicGxhdGZvcm1cIiwgXygpKSwgZih0aGlzLCBcImxvb3BzXCIsIDApLCBmKHRoaXMsIFwiY2xlYXJzQWZ0ZXJTdG9wXCIsICEwKSwgZih0aGlzLCBcImZpbGxNb2RlXCIsIFwiRm9yd2FyZFwiKSwgZih0aGlzLCBcIl92aWRlb0l0ZW1cIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9jb250ZW50TW9kZVwiLCBcIkFzcGVjdEZpdFwiKSwgZih0aGlzLCBcIl9yZW5kZXJlclwiLCB2b2lkIDApLCBmKHRoaXMsIFwiX2FuaW1hdG9yXCIsIHZvaWQgMCksIGYodGhpcywgXCJfZm9yd2FyZEFuaW1hdGluZ1wiLCAhMSksIGYodGhpcywgXCJfY3VycmVudEZyYW1lXCIsIDApLCBmKHRoaXMsIFwiX2R5bmFtaWNJbWFnZVwiLCB7fSksIGYodGhpcywgXCJfZHluYW1pY1RleHRcIiwge30pLCBmKHRoaXMsIFwiX29uRmluaXNoZWRcIiwgdm9pZCAwKSwgZih0aGlzLCBcIl9vbkZyYW1lXCIsIHZvaWQgMCksIGYodGhpcywgXCJfb25QZXJjZW50YWdlXCIsIHZvaWQgMCk7XG4gICAgICAgIH0sIFt7XG4gICAgICAgICAga2V5OiBcInNldENhbnZhc1wiLFxuICAgICAgICAgIHZhbHVlOiAoaSA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChyLCBpKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZSgpLndyYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgZm9yICg7Oykgc3dpdGNoICh0LnByZXYgPSB0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaDVcIiA9PT0gbi5wbGF0Zm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyKTtcbiAgICAgICAgICAgICAgICAgICAgICBuLmNhbnZhcyA9IHM7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgICBuLmNhbnZhcy53aWR0aCA9IHMuY2xpZW50V2lkdGggKiBvLCBuLmNhbnZhcy5oZWlnaHQgPSBzLmNsaWVudEhlaWdodCAqIG8sIG4uY3R4ID0gcy5nZXRDb250ZXh0KFwiMmRcIiksIHQodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGwoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBhLmNyZWF0ZVNlbGVjdG9yUXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpICYmIChoID0gaC5pbihpKSksIGguc2VsZWN0KHIpLmZpZWxkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgfSkuZXhlYyhmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5jYW52YXMgPSBudWxsID09IHIgfHwgbnVsbCA9PT0gKGkgPSByWzBdKSB8fCB2b2lkIDAgPT09IGkgPyB2b2lkIDAgOiBpLm5vZGUsIG4uY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmN0eCA9IG4uY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgbi5jdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGEuZ2V0U3lzdGVtSW5mb1N5bmMoKS5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uY2FudmFzLndpZHRoID0gclswXS53aWR0aCAqIHMsIG4uY2FudmFzLmhlaWdodCA9IHJbMF0uaGVpZ2h0ICogcywgdCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZShcImNhbnZhcyBjb250ZXh0IG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZShcImNhbnZhcyBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdCk7XG4gICAgICAgICAgfSkpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIGkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInNldFZpZGVvSXRlbVwiLFxuICAgICAgICAgIHZhbHVlOiAociA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChyLCBpKSB7XG4gICAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgYSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZSgpLndyYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgZm9yICg7Oykgc3dpdGNoICh0LnByZXYgPSB0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKCEwKSwgdGhpcy5fY3VycmVudEZyYW1lID0gMCwgdGhpcy5fdmlkZW9JdGVtID0gciB8fCB2b2lkIDAsICFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBZcigpLCB0Lm5leHQgPSA3LCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhyLnNwZWMuaW1hZ2VzKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUoKS53cmFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSBzd2l0Y2ggKHQucHJldiA9IHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQucHJldiA9IDAsIHQubmV4dCA9IDMsIGEubG9hZFdYSW1hZ2Uoci5zcGVjLmltYWdlc1tuXSwgdihcIlwiLmNvbmNhdChyLnNyYywgXCIvXCIpLmNvbmNhdChuKSksIG51bGwgPT0gaSA/IHZvaWQgMCA6IGkuZnJhbWVNb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzID0gdC5zZW50LCB0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQucHJldiA9IDcsIHQudDAgPSB0LmNhdGNoKDApLCB0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSwgdCwgbnVsbCwgW1swLCA3XV0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICBuID0gdC5zZW50LCBkZWxldGUgci5zcGVjLmltYWdlcywgZGVsZXRlIHIuc3BlYy5zcHJpdGVzLCBvID0ge30sIG4uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBvW3Qua2V5XSA9IHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KSwgci5kZWNvZGVkSW1hZ2VzID0gbywgdGhpcy5fcmVuZGVyZXIgPSBuZXcgJHIodGhpcy5fdmlkZW9JdGVtLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KSwgdC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHQsIHRoaXMpO1xuICAgICAgICAgIH0pKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJsb2FkV1hJbWFnZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhcykgdGhyb3cgbmV3IEVycm9yKFwibm8gY2FudmFzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChuLCBzKSB7XG4gICAgICAgICAgICAgIGlmIChcImg1XCIgIT09IGkucGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IGkuY2FudmFzLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG8ub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgbihvKTtcbiAgICAgICAgICAgICAgICB9LCBvLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBzKG5ldyBFcnJvcihcImltYWdlIGRlY29kZWQgZmFpbC5cIikpO1xuICAgICAgICAgICAgICAgIH0sIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQpIHN3aXRjaCAocikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIndvcmtlclwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIndhc21cIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgICAgICAgICAgby5zcmMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIi5jb25jYXQoZyh0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgIHQgfHwgeShcImZyYW1lTmFtZeacquaMh+WumlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IHcoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZSwgXCIvXCIpLmNvbmNhdCh0IHx8IFwic3ZnYV90ZW1wX1wiLmNvbmNhdCgrK1hyKSwgXCIucG5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KGUpO1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwoKS5nZXRGaWxlU3lzdGVtTWFuYWdlcigpLndyaXRlRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KShhLCB0LmJ1ZmZlci5zbGljZSh0LmJ5dGVPZmZzZXQsIHQuYnl0ZU9mZnNldCArIHQuYnl0ZUxlbmd0aCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIG8uc3JjID0gYTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB5KFwi5Li05pe25paH5Lu25L+d5a2Y5aSx6LSlLCDpmY3nuqfkvb/nlKhiYXNlNjTmqKHlvI9cIiwgZSksIG8uc3JjID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIuY29uY2F0KGcodCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugby5zcmMgPSB0O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHMobmV3IEVycm9yKFwiaW1hZ2UgZGVjb2RlZCBmYWlsLlwiKSk7ZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSB0LmJ1ZmZlci5zbGljZSh0LmJ5dGVPZmZzZXQsIHQuYnl0ZU9mZnNldCArIHQuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbihjcmVhdGVJbWFnZUJpdG1hcChuZXcgQmxvYihbaF0pKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzZXRDb250ZW50TW9kZVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudE1vZGUgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhcnRBbmltYXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oITEpLCB0aGlzLl9kb1N0YXJ0KHZvaWQgMCwgdCwgdm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwic3RhcnRBbmltYXRpb25XaXRoUmFuZ2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCExKSwgdGhpcy5fZG9TdGFydCh0LCBlLCB2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJwYXVzZUFuaW1hdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oITEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzdG9wQW5pbWF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB0aGlzLl9mb3J3YXJkQW5pbWF0aW5nID0gITEsIHZvaWQgMCAhPT0gdGhpcy5fYW5pbWF0b3IgJiYgdGhpcy5fYW5pbWF0b3Iuc3RvcCgpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLmNsZWFyc0FmdGVyU3RvcCksIHQgJiYgdGhpcy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIG51bGwgPT09ICh0ID0gdGhpcy5fcmVuZGVyZXIpIHx8IHZvaWQgMCA9PT0gdCB8fCB0LmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0ZXBUb0ZyYW1lXCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgciA9IHRoaXMuX3ZpZGVvSXRlbTtcbiAgICAgICAgICAgIHIgJiYgKHQgPj0gci5mcmFtZXMgfHwgdCA8IDAgfHwgKHRoaXMucGF1c2VBbmltYXRpb24oKSwgdGhpcy5fY3VycmVudEZyYW1lID0gdCwgdGhpcy5fdXBkYXRlKCksIGUgJiYgdGhpcy5fZG9TdGFydCh2b2lkIDAsICExLCB0aGlzLl9jdXJyZW50RnJhbWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInN0ZXBUb1BlcmNlbnRhZ2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgICByID0gdGhpcy5fdmlkZW9JdGVtO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSB0ICogci5mcmFtZXM7XG4gICAgICAgICAgICAgIGkgPj0gci5mcmFtZXMgJiYgaSA+IDAgJiYgKGkgPSByLmZyYW1lcyAtIDEpLCB0aGlzLnN0ZXBUb0ZyYW1lKGksIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJzZXRJbWFnZVwiLFxuICAgICAgICAgIHZhbHVlOiAodCA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChyLCBpKSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIHJldHVybiBlKCkud3JhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBmb3IgKDs7KSBzd2l0Y2ggKHQucHJldiA9IHQubmV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBZcigpLCB0Lm5leHQgPSAzLCB0aGlzLmxvYWRXWEltYWdlKHIsIFwiZHluYW1pY19mcmFtZV9cIi5jb25jYXQoaSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIG4gPSB0LnNlbnQsIHRoaXMuX2R5bmFtaWNJbWFnZVtpXSA9IG47XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdCwgdGhpcyk7XG4gICAgICAgICAgfSkpLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInNldFRleHRcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNUZXh0W2VdID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY2xlYXJEeW5hbWljT2JqZWN0c1wiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9keW5hbWljSW1hZ2UgPSB7fSwgdGhpcy5fZHluYW1pY1RleHQgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwib25GaW5pc2hlZFwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2hlZCA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIm9uRnJhbWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRnJhbWUgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJvblBlcmNlbnRhZ2VcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUGVyY2VudGFnZSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl9kb1N0YXJ0XCIsXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICAgIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IDAsXG4gICAgICAgICAgICAgIG4gPSB0aGlzLl92aWRlb0l0ZW07XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICB0aGlzLl9hbmltYXRvciA9IG5ldyBLcigpLCB0aGlzLl9hbmltYXRvci5jYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgICAgICAgdmFyIHMgPSAxIC8gbi5GUFMgKiAxZTM7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gdCA/ICh0aGlzLl9hbmltYXRvci5zdGFydFZhbHVlID0gTWF0aC5tYXgoMCwgdC5sb2NhdGlvbiksIHRoaXMuX2FuaW1hdG9yLmVuZFZhbHVlID0gTWF0aC5taW4obi5mcmFtZXMgLSAxLCB0LmxvY2F0aW9uICsgdC5sZW5ndGgpLCB0aGlzLl9hbmltYXRvci5kdXJhdGlvbiA9ICh0aGlzLl9hbmltYXRvci5lbmRWYWx1ZSAtIHRoaXMuX2FuaW1hdG9yLnN0YXJ0VmFsdWUgKyAxKSAqIHMpIDogKHRoaXMuX2FuaW1hdG9yLnN0YXJ0VmFsdWUgPSAwLCB0aGlzLl9hbmltYXRvci5lbmRWYWx1ZSA9IG4uZnJhbWVzIC0gMSwgdGhpcy5fYW5pbWF0b3IuZHVyYXRpb24gPSBuLmZyYW1lcyAqIHMpLCB0aGlzLl9hbmltYXRvci5sb29wcyA9IHRoaXMubG9vcHMgPD0gMCA/IDEgLyAwIDogdGhpcy5sb29wcywgdGhpcy5fYW5pbWF0b3IuZmlsbFJ1bGUgPSBcIkJhY2t3YXJkXCIgPT09IHRoaXMuZmlsbE1vZGUgPyAxIDogMCwgdGhpcy5fYW5pbWF0b3Iub25VcGRhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGUuX2N1cnJlbnRGcmFtZSAhPT0gTWF0aC5mbG9vcih0KSAmJiAoZS5fY3VycmVudEZyYW1lID0gTWF0aC5mbG9vcih0KSwgZS5fdXBkYXRlRnJhbWUoZS5fY3VycmVudEZyYW1lICsgMSksIGUuX3VwZGF0ZSgpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuX29uRnJhbWUgJiYgZS5fb25GcmFtZShlLl9jdXJyZW50RnJhbWUpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuX29uUGVyY2VudGFnZSAmJiBlLl9vblBlcmNlbnRhZ2UoKGUuX2N1cnJlbnRGcmFtZSArIDEpIC8gbi5mcmFtZXMpKTtcbiAgICAgICAgICAgICAgfSwgdGhpcy5fYW5pbWF0b3Iub25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZS5fZm9yd2FyZEFuaW1hdGluZyA9ICExLCAhMCA9PT0gZS5jbGVhcnNBZnRlclN0b3AgJiYgZS5jbGVhcigpLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUuX29uRmluaXNoZWQgJiYgZS5fb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICB9LCB0aGlzLl9jdXJyZW50RnJhbWUgPSB0aGlzLl9hbmltYXRvci5zdGFydFZhbHVlLCB0aGlzLl91cGRhdGVGcmFtZSh0aGlzLl9jdXJyZW50RnJhbWUpLCB0aGlzLl91cGRhdGVGcmFtZSh0aGlzLl9jdXJyZW50RnJhbWUgKyAxKSwgdGhpcy5fdXBkYXRlKCksICEwID09PSByID8gKHRoaXMuX2FuaW1hdG9yLnJldmVyc2UoaSksIHRoaXMuX2ZvcndhcmRBbmltYXRpbmcgPSAhMSkgOiAodGhpcy5fYW5pbWF0b3Iuc3RhcnQoaSksIHRoaXMuX2ZvcndhcmRBbmltYXRpbmcgPSAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIHZhciBlID0ge307XG4gICAgICAgICAgICAgIHQudHJhbnNsYXRlVG9YID8gZS50cmFuc2xhdGVYID0gdC50cmFuc2xhdGVUb1ggOiB0LnRyYW5zbGF0ZUJ5WCAmJiAoZS50cmFuc2xhdGVYID0gdGhpcy5fcmVuZGVyZXIudHJhbnNmb3JtLnRyYW5zbGF0ZVggKyB0LnRyYW5zbGF0ZUJ5WCksIHQudHJhbnNsYXRlVG9ZID8gZS50cmFuc2xhdGVZID0gdC50cmFuc2xhdGVUb1kgOiB0LnRyYW5zbGF0ZUJ5WSAmJiAoZS50cmFuc2xhdGVZID0gdGhpcy5fcmVuZGVyZXIudHJhbnNmb3JtLnRyYW5zbGF0ZVkgKyB0LnRyYW5zbGF0ZUJ5WSksIHQuc2NhbGVUbyA/IGUuc2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heCh0LnNjYWxlVG8sIC4xKSwgNSkgOiB0LnNjYWxlQnkgJiYgKGUuc2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLl9yZW5kZXJlci50cmFuc2Zvcm0uc2NhbGUgKyB0LnNjYWxlQnksIC4xKSwgNSkpLCB0aGlzLl9yZW5kZXJlci50cmFuc2Zvcm0gPSBScihScih7fSwgdGhpcy5fcmVuZGVyZXIudHJhbnNmb3JtKSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl9yZXNpemVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmN0eCxcbiAgICAgICAgICAgICAgZSA9IHRoaXMuX3ZpZGVvSXRlbTtcbiAgICAgICAgICAgIGlmICh0ICYmIGUpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSAxLFxuICAgICAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgICAgICAgIHMgPSAwLFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGggPSBlLnZpZGVvU2l6ZTtcbiAgICAgICAgICAgICAgaWYgKFwiRmlsbFwiID09PSB0aGlzLl9jb250ZW50TW9kZSkgciA9IG8gLyBoLndpZHRoLCBpID0gYSAvIGguaGVpZ2h0O2Vsc2UgaWYgKFwiQXNwZWN0Rml0XCIgPT09IHRoaXMuX2NvbnRlbnRNb2RlIHx8IFwiQXNwZWN0RmlsbFwiID09PSB0aGlzLl9jb250ZW50TW9kZSkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gaC53aWR0aCAvIGguaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgbCA9IG8gLyBhO1xuICAgICAgICAgICAgICAgIHUgPj0gbCAmJiBcIkFzcGVjdEZpdFwiID09PSB0aGlzLl9jb250ZW50TW9kZSB8fCB1IDw9IGwgJiYgXCJBc3BlY3RGaWxsXCIgPT09IHRoaXMuX2NvbnRlbnRNb2RlID8gKHIgPSBpID0gbyAvIGgud2lkdGgsIHMgPSAoYSAtIGguaGVpZ2h0ICogaSkgLyAyKSA6ICh1IDwgbCAmJiBcIkFzcGVjdEZpdFwiID09PSB0aGlzLl9jb250ZW50TW9kZSB8fCB1ID4gbCAmJiBcIkFzcGVjdEZpbGxcIiA9PT0gdGhpcy5fY29udGVudE1vZGUpICYmIChyID0gaSA9IGEgLyBoLmhlaWdodCwgbiA9IChvIC0gaC53aWR0aCAqIHIpIC8gMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgJiYgKHRoaXMuX3JlbmRlcmVyLmdsb2JhbFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICBhOiByLFxuICAgICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgICAgICBkOiBpLFxuICAgICAgICAgICAgICAgIHR4OiBuLFxuICAgICAgICAgICAgICAgIHR5OiBzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJfdXBkYXRlRnJhbWVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpLCB0aGlzLl9yZW5kZXJlciAmJiAodGhpcy5fcmVuZGVyZXIuY2xlYXIoKSwgdGhpcy5fcmVuZGVyZXIuX2R5bmFtaWNJbWFnZSA9IHRoaXMuX2R5bmFtaWNJbWFnZSwgdGhpcy5fcmVuZGVyZXIuX2R5bmFtaWNUZXh0ID0gdGhpcy5fZHluYW1pY1RleHQsIHRoaXMuX3JlbmRlcmVyLmRyYXdGcmFtZSh0IDwgMCA/IDAgOiB0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcIl91cGRhdGVcIixcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KSwgdGhpcy5fcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICAgICAgZSA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUltYWdlRGF0YSgpO1xuICAgICAgICAgICAgICBlICYmIChudWxsID09PSAodCA9IHRoaXMuY3R4KSB8fCB2b2lkIDAgPT09IHQgfHwgdC5wdXRJbWFnZURhdGEoZSwgMCwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgICB2YXIgdCwgciwgaTtcbiAgICAgIH0oKSxcbiAgICAgIFdyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0LFxuICAgICAgICAgIGkgPSBuaVtlXSxcbiAgICAgICAgICBuID0gbnVsbCxcbiAgICAgICAgICBzID0gMCxcbiAgICAgICAgICBvID0gbnVsbCxcbiAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgaCA9IHt9LFxuICAgICAgICAgIHUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGUgPSBuZXcgQXJyYXkodCksIHIgPSAwOyByIDwgdDsgciArPSAxKSB7XG4gICAgICAgICAgICAgICAgZVtyXSA9IG5ldyBBcnJheSh0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7IGkgKz0gMSkgZVtyXVtpXSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICB9KHMgPSA0ICogciArIDE3KSwgbCgwLCAwKSwgbChzIC0gNywgMCksIGwoMCwgcyAtIDcpLCBjKCksIGYoKSwgcCh0LCBlKSwgciA+PSA3ICYmIGQodCksIG51bGwgPT0gbyAmJiAobyA9IHYociwgaSwgYSkpLCB5KG8sIGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgciArPSAxKSBpZiAoISh0ICsgciA8PSAtMSB8fCBzIDw9IHQgKyByKSkgZm9yICh2YXIgaSA9IC0xOyBpIDw9IDc7IGkgKz0gMSkgZSArIGkgPD0gLTEgfHwgcyA8PSBlICsgaSB8fCAoblt0ICsgcl1bZSArIGldID0gciA+PSAwICYmIHIgPD0gNiAmJiAoMCA9PSBpIHx8IDYgPT0gaSkgfHwgaSA+PSAwICYmIGkgPD0gNiAmJiAoMCA9PSByIHx8IDYgPT0gcikgfHwgciA+PSAyICYmIHIgPD0gNCAmJiBpID49IDIgJiYgaSA8PSA0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gODsgdCA8IHMgLSA4OyB0ICs9IDEpIG51bGwgPT0gblt0XVs2XSAmJiAoblt0XVs2XSA9IHQgJSAyID09IDApO1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IDg7IGUgPCBzIC0gODsgZSArPSAxKSBudWxsID09IG5bNl1bZV0gJiYgKG5bNl1bZV0gPSBlICUgMiA9PSAwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gc2kuZ2V0UGF0dGVyblBvc2l0aW9uKHIpLCBlID0gMDsgZSA8IHQubGVuZ3RoOyBlICs9IDEpIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgcyA9IHRbZV0sXG4gICAgICAgICAgICAgICAgbyA9IHRbaV07XG4gICAgICAgICAgICAgIGlmIChudWxsID09IG5bc11bb10pIGZvciAodmFyIGEgPSAtMjsgYSA8PSAyOyBhICs9IDEpIGZvciAodmFyIGggPSAtMjsgaCA8PSAyOyBoICs9IDEpIG5bcyArIGFdW28gKyBoXSA9IC0yID09IGEgfHwgMiA9PSBhIHx8IC0yID09IGggfHwgMiA9PSBoIHx8IDAgPT0gYSAmJiAwID09IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSBzaS5nZXRCQ0hUeXBlTnVtYmVyKHIpLCBpID0gMDsgaSA8IDE4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSAhdCAmJiAxID09IChlID4+IGkgJiAxKTtcbiAgICAgICAgICAgICAgbltNYXRoLmZsb29yKGkgLyAzKV1baSAlIDMgKyBzIC0gOCAtIDNdID0gbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxODsgaSArPSAxKSBvID0gIXQgJiYgMSA9PSAoZSA+PiBpICYgMSksIG5baSAlIDMgKyBzIC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG87XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSBpIDw8IDMgfCBlLCBvID0gc2kuZ2V0QkNIVHlwZUluZm8ociksIGEgPSAwOyBhIDwgMTU7IGEgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgaCA9ICF0ICYmIDEgPT0gKG8gPj4gYSAmIDEpO1xuICAgICAgICAgICAgICBhIDwgNiA/IG5bYV1bOF0gPSBoIDogYSA8IDggPyBuW2EgKyAxXVs4XSA9IGggOiBuW3MgLSAxNSArIGFdWzhdID0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCAxNTsgYSArPSAxKSBoID0gIXQgJiYgMSA9PSAobyA+PiBhICYgMSksIGEgPCA4ID8gbls4XVtzIC0gYSAtIDFdID0gaCA6IGEgPCA5ID8gbls4XVsxNSAtIGEgLSAxICsgMV0gPSBoIDogbls4XVsxNSAtIGEgLSAxXSA9IGg7XG4gICAgICAgICAgICBuW3MgLSA4XVs4XSA9ICF0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gLTEsIGkgPSBzIC0gMSwgbyA9IDcsIGEgPSAwLCBoID0gc2kuZ2V0TWFza0Z1bmN0aW9uKGUpLCB1ID0gcyAtIDE7IHUgPiAwOyB1IC09IDIpIGZvciAoNiA9PSB1ICYmICh1IC09IDEpOzspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCAyOyBsICs9IDEpIGlmIChudWxsID09IG5baV1bdSAtIGxdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAhMTtcbiAgICAgICAgICAgICAgICBhIDwgdC5sZW5ndGggJiYgKGYgPSAxID09ICh0W2FdID4+PiBvICYgMSkpLCBoKGksIHUgLSBsKSAmJiAoZiA9ICFmKSwgbltpXVt1IC0gbF0gPSBmLCAtMSA9PSAobyAtPSAxKSAmJiAoYSArPSAxLCBvID0gNyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKChpICs9IHIpIDwgMCB8fCBzIDw9IGkpIHtcbiAgICAgICAgICAgICAgICBpIC09IHIsIHIgPSAtcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaGkuZ2V0UlNCbG9ja3ModCwgZSksIG4gPSB1aSgpLCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSByW3NdO1xuICAgICAgICAgICAgICBuLnB1dChvLmdldE1vZGUoKSwgNCksIG4ucHV0KG8uZ2V0TGVuZ3RoKCksIHNpLmdldExlbmd0aEluQml0cyhvLmdldE1vZGUoKSwgdCkpLCBvLndyaXRlKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGEgPSAwO1xuICAgICAgICAgICAgZm9yIChzID0gMDsgcyA8IGkubGVuZ3RoOyBzICs9IDEpIGEgKz0gaVtzXS5kYXRhQ291bnQ7XG4gICAgICAgICAgICBpZiAobi5nZXRMZW5ndGhJbkJpdHMoKSA+IDggKiBhKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKFwiICsgbi5nZXRMZW5ndGhJbkJpdHMoKSArIFwiPlwiICsgOCAqIGEgKyBcIilcIik7XG4gICAgICAgICAgICBmb3IgKG4uZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IDggKiBhICYmIG4ucHV0KDAsIDQpOyBuLmdldExlbmd0aEluQml0cygpICUgOCAhPSAwOykgbi5wdXRCaXQoITEpO1xuICAgICAgICAgICAgZm9yICg7ICEobi5nZXRMZW5ndGhJbkJpdHMoKSA+PSA4ICogYSB8fCAobi5wdXQoMjM2LCA4KSwgbi5nZXRMZW5ndGhJbkJpdHMoKSA+PSA4ICogYSkpOykgbi5wdXQoMTcsIDgpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gMCwgbiA9IDAsIHMgPSBuZXcgQXJyYXkoZS5sZW5ndGgpLCBvID0gbmV3IEFycmF5KGUubGVuZ3RoKSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBlW2FdLmRhdGFDb3VudCxcbiAgICAgICAgICAgICAgICAgIHUgPSBlW2FdLnRvdGFsQ291bnQgLSBoO1xuICAgICAgICAgICAgICAgIGkgPSBNYXRoLm1heChpLCBoKSwgbiA9IE1hdGgubWF4KG4sIHUpLCBzW2FdID0gbmV3IEFycmF5KGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc1thXS5sZW5ndGg7IGwgKz0gMSkgc1thXVtsXSA9IDI1NSAmIHQuZ2V0QnVmZmVyKClbbCArIHJdO1xuICAgICAgICAgICAgICAgIHIgKz0gaDtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IHNpLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwodSksXG4gICAgICAgICAgICAgICAgICBjID0gYWkoc1thXSwgZi5nZXRMZW5ndGgoKSAtIDEpLm1vZChmKTtcbiAgICAgICAgICAgICAgICBmb3IgKG9bYV0gPSBuZXcgQXJyYXkoZi5nZXRMZW5ndGgoKSAtIDEpLCBsID0gMDsgbCA8IG9bYV0ubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkID0gbCArIGMuZ2V0TGVuZ3RoKCkgLSBvW2FdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIG9bYV1bbF0gPSBkID49IDAgPyBjLmdldEF0KGQpIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHAgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgZS5sZW5ndGg7IGwgKz0gMSkgcCArPSBlW2xdLnRvdGFsQ291bnQ7XG4gICAgICAgICAgICAgIHZhciB5ID0gbmV3IEFycmF5KHApLFxuICAgICAgICAgICAgICAgIHYgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgaTsgbCArPSAxKSBmb3IgKGEgPSAwOyBhIDwgZS5sZW5ndGg7IGEgKz0gMSkgbCA8IHNbYV0ubGVuZ3RoICYmICh5W3ZdID0gc1thXVtsXSwgdiArPSAxKTtcbiAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IG47IGwgKz0gMSkgZm9yIChhID0gMDsgYSA8IGUubGVuZ3RoOyBhICs9IDEpIGwgPCBvW2FdLmxlbmd0aCAmJiAoeVt2XSA9IG9bYV1bbF0sIHYgKz0gMSk7XG4gICAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICAgICAgfShuLCBpKTtcbiAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaC5hZGREYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IGxpKHQpO1xuICAgICAgICAgIGEucHVzaChlKSwgbyA9IG51bGw7XG4gICAgICAgIH0sIGguaXNEYXJrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBpZiAodCA8IDAgfHwgcyA8PSB0IHx8IGUgPCAwIHx8IHMgPD0gZSkgdGhyb3cgbmV3IEVycm9yKHQgKyBcIixcIiArIGUpO1xuICAgICAgICAgIHJldHVybiBuW3RdW2VdO1xuICAgICAgICB9LCBoLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LCBoLm1ha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdSghMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSAwLCByID0gMDsgciA8IDg7IHIgKz0gMSkge1xuICAgICAgICAgICAgICB1KCEwLCByKTtcbiAgICAgICAgICAgICAgdmFyIGkgPSBzaS5nZXRMb3N0UG9pbnQoaCk7XG4gICAgICAgICAgICAgICgwID09IHIgfHwgdCA+IGkpICYmICh0ID0gaSwgZSA9IHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgfSgpKTtcbiAgICAgICAgfSwgaC5jcmVhdGVUYWJsZVRhZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdCA9IHQgfHwgMjtcbiAgICAgICAgICB2YXIgciA9IFwiXCI7XG4gICAgICAgICAgciArPSAnPHRhYmxlIHN0eWxlPVwiJywgciArPSBcIiBib3JkZXItd2lkdGg6IDBweDsgYm9yZGVyLXN0eWxlOiBub25lO1wiLCByICs9IFwiIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCIsIHIgKz0gXCIgcGFkZGluZzogMHB4OyBtYXJnaW46IFwiICsgKGUgPSB2b2lkIDAgPT09IGUgPyA0ICogdCA6IGUpICsgXCJweDtcIiwgciArPSAnXCI+JywgciArPSBcIjx0Ym9keT5cIjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGguZ2V0TW9kdWxlQ291bnQoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICByICs9IFwiPHRyPlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBoLmdldE1vZHVsZUNvdW50KCk7IG4gKz0gMSkgciArPSAnPHRkIHN0eWxlPVwiJywgciArPSBcIiBib3JkZXItd2lkdGg6IDBweDsgYm9yZGVyLXN0eWxlOiBub25lO1wiLCByICs9IFwiIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XCIsIHIgKz0gXCIgcGFkZGluZzogMHB4OyBtYXJnaW46IDBweDtcIiwgciArPSBcIiB3aWR0aDogXCIgKyB0ICsgXCJweDtcIiwgciArPSBcIiBoZWlnaHQ6IFwiICsgdCArIFwicHg7XCIsIHIgKz0gXCIgYmFja2dyb3VuZC1jb2xvcjogXCIsIHIgKz0gaC5pc0RhcmsoaSwgbikgPyBcIiMwMDAwMDBcIiA6IFwiI2ZmZmZmZlwiLCByICs9IFwiO1wiLCByICs9ICdcIi8+JztcbiAgICAgICAgICAgIHIgKz0gXCI8L3RyPlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKHIgKz0gXCI8L3Rib2R5PlwiKSArIFwiPC90YWJsZT5cIjtcbiAgICAgICAgfSwgaC5jcmVhdGVJbWdUYWcgPSBmdW5jdGlvbiAodCwgZSwgciwgaSwgbikge1xuICAgICAgICAgIHQgPSB0IHx8IDI7XG4gICAgICAgICAgdmFyIHMgPSBlID0gdm9pZCAwID09PSBlID8gNCAqIHQgOiBlLFxuICAgICAgICAgICAgbyA9IGguZ2V0TW9kdWxlQ291bnQoKSAqIHQgKyBlO1xuICAgICAgICAgIHJldHVybiBkaShyLCByLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgaWYgKHMgPD0gZSAmJiBlIDwgbyAmJiBzIDw9IHIgJiYgciA8IG8pIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKChlIC0gcykgLyB0KSxcbiAgICAgICAgICAgICAgICBuID0gTWF0aC5mbG9vcigociAtIHMpIC8gdCk7XG4gICAgICAgICAgICAgIHJldHVybiBoLmlzRGFyayhuLCBpKSA/IDAgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSwgaSwgbik7XG4gICAgICAgIH0sIGg7XG4gICAgICB9O1xuICAgIFdyLnN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgdmFyIGkgPSB0LmNoYXJDb2RlQXQocik7XG4gICAgICAgIGUucHVzaCgyNTUgJiBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0sIFdyLmNyZWF0ZVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IGNpKHQpLCBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdCA9IHIucmVhZCgpO1xuICAgICAgICAgICAgICBpZiAoLTEgPT0gdCkgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSwgbiA9IDAsIHMgPSB7fTs7KSB7XG4gICAgICAgICAgICB2YXIgbyA9IHIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKC0xID09IG8pIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGEgPSBpKCksXG4gICAgICAgICAgICAgIGggPSBpKCkgPDwgOCB8IGkoKTtcbiAgICAgICAgICAgIHNbU3RyaW5nLmZyb21DaGFyQ29kZShvIDw8IDggfCBhKV0gPSBoLCBuICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuICE9IGUpIHRocm93IG5ldyBFcnJvcihuICsgXCIgIT0gXCIgKyBlKTtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSgpLFxuICAgICAgICBpID0gXCI/XCIuY2hhckNvZGVBdCgwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gW10sIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgIHZhciBzID0gdC5jaGFyQ29kZUF0KG4pO1xuICAgICAgICAgIGlmIChzIDwgMTI4KSBlLnB1c2gocyk7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgbyA9IHJbdC5jaGFyQXQobildO1xuICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgbyA/ICgyNTUgJiBvKSA9PSBvID8gZS5wdXNoKG8pIDogKGUucHVzaChvID4+PiA4KSwgZS5wdXNoKDI1NSAmIG8pKSA6IGUucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIFFyLFxuICAgICAgdGksXG4gICAgICBlaSxcbiAgICAgIHJpLFxuICAgICAgaWksXG4gICAgICBuaSA9IHtcbiAgICAgICAgTDogMSxcbiAgICAgICAgTTogMCxcbiAgICAgICAgUTogMyxcbiAgICAgICAgSDogMlxuICAgICAgfSxcbiAgICAgIHNpID0gKFFyID0gW1tdLCBbNiwgMThdLCBbNiwgMjJdLCBbNiwgMjZdLCBbNiwgMzBdLCBbNiwgMzRdLCBbNiwgMjIsIDM4XSwgWzYsIDI0LCA0Ml0sIFs2LCAyNiwgNDZdLCBbNiwgMjgsIDUwXSwgWzYsIDMwLCA1NF0sIFs2LCAzMiwgNThdLCBbNiwgMzQsIDYyXSwgWzYsIDI2LCA0NiwgNjZdLCBbNiwgMjYsIDQ4LCA3MF0sIFs2LCAyNiwgNTAsIDc0XSwgWzYsIDMwLCA1NCwgNzhdLCBbNiwgMzAsIDU2LCA4Ml0sIFs2LCAzMCwgNTgsIDg2XSwgWzYsIDM0LCA2MiwgOTBdLCBbNiwgMjgsIDUwLCA3MiwgOTRdLCBbNiwgMjYsIDUwLCA3NCwgOThdLCBbNiwgMzAsIDU0LCA3OCwgMTAyXSwgWzYsIDI4LCA1NCwgODAsIDEwNl0sIFs2LCAzMiwgNTgsIDg0LCAxMTBdLCBbNiwgMzAsIDU4LCA4NiwgMTE0XSwgWzYsIDM0LCA2MiwgOTAsIDExOF0sIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSwgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2XSwgWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwXSwgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSwgWzYsIDM0LCA2MCwgODYsIDExMiwgMTM4XSwgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSwgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSwgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdLCBbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0sIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSwgWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdLCBbNiwgMjYsIDU0LCA4MiwgMTEwLCAxMzgsIDE2Nl0sIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXV0sIHRpID0gMTMzNSwgZWkgPSA3OTczLCBpaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwOyAwICE9IHQ7KSBlICs9IDEsIHQgPj4+PSAxO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sIChyaSA9IHt9KS5nZXRCQ0hUeXBlSW5mbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSB0IDw8IDEwOyBpaShlKSAtIGlpKHRpKSA+PSAwOykgZSBePSB0aSA8PCBpaShlKSAtIGlpKHRpKTtcbiAgICAgICAgcmV0dXJuIDIxNTIyIF4gKHQgPDwgMTAgfCBlKTtcbiAgICAgIH0sIHJpLmdldEJDSFR5cGVOdW1iZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdCA8PCAxMjsgaWkoZSkgLSBpaShlaSkgPj0gMDspIGUgXj0gZWkgPDwgaWkoZSkgLSBpaShlaSk7XG4gICAgICAgIHJldHVybiB0IDw8IDEyIHwgZTtcbiAgICAgIH0sIHJpLmdldFBhdHRlcm5Qb3NpdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBRclt0IC0gMV07XG4gICAgICB9LCByaS5nZXRNYXNrRnVuY3Rpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0ICsgZSkgJSAyID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdCAlIDIgPT0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlICUgMyA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0ICsgZSkgJSAzID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IodCAvIDIpICsgTWF0aC5mbG9vcihlIC8gMykpICUgMiA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQgKiBlICUgMiArIHQgKiBlICUgMyA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0ICogZSAlIDIgKyB0ICogZSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0ICogZSAlIDMgKyAodCArIGUpICUgMikgJSAyID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbWFza1BhdHRlcm46XCIgKyB0KTtcbiAgICAgICAgfVxuICAgICAgfSwgcmkuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBhaShbMV0sIDApLCByID0gMDsgciA8IHQ7IHIgKz0gMSkgZSA9IGUubXVsdGlwbHkoYWkoWzEsIG9pLmdleHAocildLCAwKSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSwgcmkuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKGUgPj0gMSAmJiBlIDwgMTApIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGU6XCIgKyB0KTtcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMjcpIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZTpcIiArIHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghKGUgPCA0MSkpIHRocm93IG5ldyBFcnJvcihcInR5cGU6XCIgKyBlKTtcbiAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0dXJuIDE0O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gMTM7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kZTpcIiArIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgcmkuZ2V0TG9zdFBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHQuZ2V0TW9kdWxlQ291bnQoKSwgciA9IDAsIGkgPSAwOyBpIDwgZTsgaSArPSAxKSBmb3IgKHZhciBuID0gMDsgbiA8IGU7IG4gKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIHMgPSAwLCBvID0gdC5pc0RhcmsoaSwgbiksIGEgPSAtMTsgYSA8PSAxOyBhICs9IDEpIGlmICghKGkgKyBhIDwgMCB8fCBlIDw9IGkgKyBhKSkgZm9yICh2YXIgaCA9IC0xOyBoIDw9IDE7IGggKz0gMSkgbiArIGggPCAwIHx8IGUgPD0gbiArIGggfHwgMCA9PSBhICYmIDAgPT0gaCB8fCBvID09IHQuaXNEYXJrKGkgKyBhLCBuICsgaCkgJiYgKHMgKz0gMSk7XG4gICAgICAgICAgcyA+IDUgJiYgKHIgKz0gMyArIHMgLSA1KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZSAtIDE7IGkgKz0gMSkgZm9yIChuID0gMDsgbiA8IGUgLSAxOyBuICs9IDEpIHtcbiAgICAgICAgICB2YXIgdSA9IDA7XG4gICAgICAgICAgdC5pc0RhcmsoaSwgbikgJiYgKHUgKz0gMSksIHQuaXNEYXJrKGkgKyAxLCBuKSAmJiAodSArPSAxKSwgdC5pc0RhcmsoaSwgbiArIDEpICYmICh1ICs9IDEpLCB0LmlzRGFyayhpICsgMSwgbiArIDEpICYmICh1ICs9IDEpLCAwICE9IHUgJiYgNCAhPSB1IHx8IChyICs9IDMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlOyBpICs9IDEpIGZvciAobiA9IDA7IG4gPCBlIC0gNjsgbiArPSAxKSB0LmlzRGFyayhpLCBuKSAmJiAhdC5pc0RhcmsoaSwgbiArIDEpICYmIHQuaXNEYXJrKGksIG4gKyAyKSAmJiB0LmlzRGFyayhpLCBuICsgMykgJiYgdC5pc0RhcmsoaSwgbiArIDQpICYmICF0LmlzRGFyayhpLCBuICsgNSkgJiYgdC5pc0RhcmsoaSwgbiArIDYpICYmIChyICs9IDQwKTtcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGU7IG4gKz0gMSkgZm9yIChpID0gMDsgaSA8IGUgLSA2OyBpICs9IDEpIHQuaXNEYXJrKGksIG4pICYmICF0LmlzRGFyayhpICsgMSwgbikgJiYgdC5pc0RhcmsoaSArIDIsIG4pICYmIHQuaXNEYXJrKGkgKyAzLCBuKSAmJiB0LmlzRGFyayhpICsgNCwgbikgJiYgIXQuaXNEYXJrKGkgKyA1LCBuKSAmJiB0LmlzRGFyayhpICsgNiwgbikgJiYgKHIgKz0gNDApO1xuICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBlOyBuICs9IDEpIGZvciAoaSA9IDA7IGkgPCBlOyBpICs9IDEpIHQuaXNEYXJrKGksIG4pICYmIChsICs9IDEpO1xuICAgICAgICByZXR1cm4gciArIE1hdGguYWJzKDEwMCAqIGwgLyBlIC8gZSAtIDUwKSAvIDUgKiAxMDtcbiAgICAgIH0sIHJpKSxcbiAgICAgIG9pID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0ID0gbmV3IEFycmF5KDI1NiksIGUgPSBuZXcgQXJyYXkoMjU2KSwgciA9IDA7IHIgPCA4OyByICs9IDEpIHRbcl0gPSAxIDw8IHI7XG4gICAgICAgIGZvciAociA9IDg7IHIgPCAyNTY7IHIgKz0gMSkgdFtyXSA9IHRbciAtIDRdIF4gdFtyIC0gNV0gXiB0W3IgLSA2XSBeIHRbciAtIDhdO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgMjU1OyByICs9IDEpIGVbdFtyXV0gPSByO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdsb2c6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAodCA8IDEpIHRocm93IG5ldyBFcnJvcihcImdsb2coXCIgKyB0ICsgXCIpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGVbdF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXhwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZm9yICg7IGUgPCAwOykgZSArPSAyNTU7XG4gICAgICAgICAgICBmb3IgKDsgZSA+PSAyNTY7KSBlIC09IDI1NTtcbiAgICAgICAgICAgIHJldHVybiB0W2VdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICBmdW5jdGlvbiBhaSh0LCBlKSB7XG4gICAgICBpZiAodm9pZCAwID09PSB0Lmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKHQubGVuZ3RoICsgXCIvXCIgKyBlKTtcbiAgICAgIHZhciByID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGggJiYgMCA9PSB0W3JdOykgciArPSAxO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBuZXcgQXJyYXkodC5sZW5ndGggLSByICsgZSksIG4gPSAwOyBuIDwgdC5sZW5ndGggLSByOyBuICs9IDEpIGlbbl0gPSB0W24gKyByXTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSgpLFxuICAgICAgICBpID0ge1xuICAgICAgICAgIGdldEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHJbdF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByLmxlbmd0aDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IG5ldyBBcnJheShpLmdldExlbmd0aCgpICsgdC5nZXRMZW5ndGgoKSAtIDEpLCByID0gMDsgciA8IGkuZ2V0TGVuZ3RoKCk7IHIgKz0gMSkgZm9yICh2YXIgbiA9IDA7IG4gPCB0LmdldExlbmd0aCgpOyBuICs9IDEpIGVbciArIG5dIF49IG9pLmdleHAob2kuZ2xvZyhpLmdldEF0KHIpKSArIG9pLmdsb2codC5nZXRBdChuKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFpKGUsIDApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKGkuZ2V0TGVuZ3RoKCkgLSB0LmdldExlbmd0aCgpIDwgMCkgcmV0dXJuIGk7XG4gICAgICAgICAgICBmb3IgKHZhciBlID0gb2kuZ2xvZyhpLmdldEF0KDApKSAtIG9pLmdsb2codC5nZXRBdCgwKSksIHIgPSBuZXcgQXJyYXkoaS5nZXRMZW5ndGgoKSksIG4gPSAwOyBuIDwgaS5nZXRMZW5ndGgoKTsgbiArPSAxKSByW25dID0gaS5nZXRBdChuKTtcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCB0LmdldExlbmd0aCgpOyBuICs9IDEpIHJbbl0gXj0gb2kuZ2V4cChvaS5nbG9nKHQuZ2V0QXQobikpICsgZSk7XG4gICAgICAgICAgICByZXR1cm4gYWkociwgMCkubW9kKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB2YXIgaGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gW1sxLCAyNiwgMTldLCBbMSwgMjYsIDE2XSwgWzEsIDI2LCAxM10sIFsxLCAyNiwgOV0sIFsxLCA0NCwgMzRdLCBbMSwgNDQsIDI4XSwgWzEsIDQ0LCAyMl0sIFsxLCA0NCwgMTZdLCBbMSwgNzAsIDU1XSwgWzEsIDcwLCA0NF0sIFsyLCAzNSwgMTddLCBbMiwgMzUsIDEzXSwgWzEsIDEwMCwgODBdLCBbMiwgNTAsIDMyXSwgWzIsIDUwLCAyNF0sIFs0LCAyNSwgOV0sIFsxLCAxMzQsIDEwOF0sIFsyLCA2NywgNDNdLCBbMiwgMzMsIDE1LCAyLCAzNCwgMTZdLCBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLCBbMiwgODYsIDY4XSwgWzQsIDQzLCAyN10sIFs0LCA0MywgMTldLCBbNCwgNDMsIDE1XSwgWzIsIDk4LCA3OF0sIFs0LCA0OSwgMzFdLCBbMiwgMzIsIDE0LCA0LCAzMywgMTVdLCBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLCBbMiwgMTIxLCA5N10sIFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sIFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sIFsyLCAxNDYsIDExNl0sIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sIFs0LCAzNiwgMTYsIDQsIDM3LCAxN10sIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sIFsyLCA4NiwgNjgsIDIsIDg3LCA2OV0sIFs0LCA2OSwgNDMsIDEsIDcwLCA0NF0sIFs2LCA0MywgMTksIDIsIDQ0LCAyMF0sIFs2LCA0MywgMTUsIDIsIDQ0LCAxNl0sIFs0LCAxMDEsIDgxXSwgWzEsIDgwLCA1MCwgNCwgODEsIDUxXSwgWzQsIDUwLCAyMiwgNCwgNTEsIDIzXSwgWzMsIDM2LCAxMiwgOCwgMzcsIDEzXSwgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLCBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLCBbNCwgNDYsIDIwLCA2LCA0NywgMjFdLCBbNywgNDIsIDE0LCA0LCA0MywgMTVdLCBbNCwgMTMzLCAxMDddLCBbOCwgNTksIDM3LCAxLCA2MCwgMzhdLCBbOCwgNDQsIDIwLCA0LCA0NSwgMjFdLCBbMTIsIDMzLCAxMSwgNCwgMzQsIDEyXSwgWzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sIFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sIFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLCBbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSwgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLCBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLCBbNSwgNTQsIDI0LCA3LCA1NSwgMjVdLCBbMTEsIDM2LCAxMl0sIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSwgWzcsIDczLCA0NSwgMywgNzQsIDQ2XSwgWzE1LCA0MywgMTksIDIsIDQ0LCAyMF0sIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLCBbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSwgWzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sIFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLCBbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSwgWzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sIFs5LCA2OSwgNDMsIDQsIDcwLCA0NF0sIFsxNywgNTAsIDIyLCAxLCA1MSwgMjNdLCBbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSwgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sIFszLCA3MCwgNDQsIDExLCA3MSwgNDVdLCBbMTcsIDQ3LCAyMSwgNCwgNDgsIDIyXSwgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sIFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLCBbMywgNjcsIDQxLCAxMywgNjgsIDQyXSwgWzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sIFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSwgWzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sIFsxNywgNjgsIDQyXSwgWzE3LCA1MCwgMjIsIDYsIDUxLCAyM10sIFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLCBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSwgWzE3LCA3NCwgNDZdLCBbNywgNTQsIDI0LCAxNiwgNTUsIDI1XSwgWzM0LCAzNywgMTNdLCBbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSwgWzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sIFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLCBbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSwgWzYsIDczLCA0NSwgMTQsIDc0LCA0Nl0sIFsxMSwgNTQsIDI0LCAxNiwgNTUsIDI1XSwgWzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLCBbOCwgNzUsIDQ3LCAxMywgNzYsIDQ4XSwgWzcsIDU0LCAyNCwgMjIsIDU1LCAyNV0sIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSwgWzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLCBbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSwgWzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sIFszMywgNDYsIDE2LCA0LCA0NywgMTddLCBbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSwgWzIyLCA3MywgNDUsIDMsIDc0LCA0Nl0sIFs4LCA1MywgMjMsIDI2LCA1NCwgMjRdLCBbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSwgWzMsIDczLCA0NSwgMjMsIDc0LCA0Nl0sIFs0LCA1NCwgMjQsIDMxLCA1NSwgMjVdLCBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sIFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLCBbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSwgWzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sIFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSwgWzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLCBbMTksIDc1LCA0NywgMTAsIDc2LCA0OF0sIFsxNSwgNTQsIDI0LCAyNSwgNTUsIDI1XSwgWzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLCBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sIFsyLCA3NCwgNDYsIDI5LCA3NSwgNDddLCBbNDIsIDU0LCAyNCwgMSwgNTUsIDI1XSwgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLCBbMTcsIDE0NSwgMTE1XSwgWzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLCBbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sIFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSwgWzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLCBbMTQsIDc0LCA0NiwgMjEsIDc1LCA0N10sIFsyOSwgNTQsIDI0LCAxOSwgNTUsIDI1XSwgWzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLCBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sIFsxNCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSwgWzQ0LCA1NCwgMjQsIDcsIDU1LCAyNV0sIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLCBbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sIFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSwgWzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLCBbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sIFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSwgWzYsIDc1LCA0NywgMzQsIDc2LCA0OF0sIFs0NiwgNTQsIDI0LCAxMCwgNTUsIDI1XSwgWzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSwgWzI5LCA3NCwgNDYsIDE0LCA3NSwgNDddLCBbNDksIDU0LCAyNCwgMTAsIDU1LCAyNV0sIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSwgWzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLCBbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sIFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLCBbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sIFs0MCwgNzUsIDQ3LCA3LCA3NiwgNDhdLCBbNDMsIDU0LCAyNCwgMjIsIDU1LCAyNV0sIFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSwgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLCBbMTgsIDc1LCA0NywgMzEsIDc2LCA0OF0sIFszNCwgNTQsIDI0LCAzNCwgNTUsIDI1XSwgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXSxcbiAgICAgICAgICBlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgICByZXR1cm4gci50b3RhbENvdW50ID0gdCwgci5kYXRhQ291bnQgPSBlLCByO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgciA9IHtcbiAgICAgICAgICAgIGdldFJTQmxvY2tzOiBmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIG5pLkw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0WzQgKiAoZSAtIDEpICsgMF07XG4gICAgICAgICAgICAgICAgICBjYXNlIG5pLk06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0WzQgKiAoZSAtIDEpICsgMV07XG4gICAgICAgICAgICAgICAgICBjYXNlIG5pLlE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0WzQgKiAoZSAtIDEpICsgMl07XG4gICAgICAgICAgICAgICAgICBjYXNlIG5pLkg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0WzQgKiAoZSAtIDEpICsgM107XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KHIsIGkpO1xuICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBuKSB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOlwiICsgciArIFwiL2Vycm9yQ29ycmVjdExldmVsOlwiICsgaSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIHMgPSBuLmxlbmd0aCAvIDMsIG8gPSBbXSwgYSA9IDA7IGEgPCBzOyBhICs9IDEpIGZvciAodmFyIGggPSBuWzMgKiBhICsgMF0sIHUgPSBuWzMgKiBhICsgMV0sIGwgPSBuWzMgKiBhICsgMl0sIGYgPSAwOyBmIDwgaDsgZiArPSAxKSBvLnB1c2goZSh1LCBsKSk7XG4gICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSgpLFxuICAgICAgdWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gW10sXG4gICAgICAgICAgZSA9IDAsXG4gICAgICAgICAgciA9IHtcbiAgICAgICAgICAgIGdldEJ1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRBdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKGUgLyA4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIDEgPT0gKHRbcl0gPj4+IDcgLSBlICUgOCAmIDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1dDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlOyBpICs9IDEpIHIucHV0Qml0KDEgPT0gKHQgPj4+IGUgLSBpIC0gMSAmIDEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRMZW5ndGhJbkJpdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHV0Qml0OiBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoZSAvIDgpO1xuICAgICAgICAgICAgICB0Lmxlbmd0aCA8PSBpICYmIHQucHVzaCgwKSwgciAmJiAodFtpXSB8PSAxMjggPj4+IGUgJSA4KSwgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSxcbiAgICAgIGxpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHQsIHIgPSBbXSwgaSA9IHt9LCBuID0gMCwgcyA9IGUubGVuZ3RoOyBuIDwgczsgbisrKSB7XG4gICAgICAgICAgdmFyIG8gPSBbXSxcbiAgICAgICAgICAgIGEgPSBlLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgYSA+IDY1NTM2ID8gKG9bMF0gPSAyNDAgfCAoMTgzNTAwOCAmIGEpID4+PiAxOCwgb1sxXSA9IDEyOCB8ICgyNTgwNDggJiBhKSA+Pj4gMTIsIG9bMl0gPSAxMjggfCAoNDAzMiAmIGEpID4+PiA2LCBvWzNdID0gMTI4IHwgNjMgJiBhKSA6IGEgPiAyMDQ4ID8gKG9bMF0gPSAyMjQgfCAoNjE0NDAgJiBhKSA+Pj4gMTIsIG9bMV0gPSAxMjggfCAoNDAzMiAmIGEpID4+PiA2LCBvWzJdID0gMTI4IHwgNjMgJiBhKSA6IGEgPiAxMjggPyAob1swXSA9IDE5MiB8ICgxOTg0ICYgYSkgPj4+IDYsIG9bMV0gPSAxMjggfCA2MyAmIGEpIDogb1swXSA9IGEsIHIucHVzaChvKTtcbiAgICAgICAgfVxuICAgICAgICAociA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHIpKS5sZW5ndGggIT0gZS5sZW5ndGggJiYgKHIudW5zaGlmdCgxOTEpLCByLnVuc2hpZnQoMTg3KSwgci51bnNoaWZ0KDIzOSkpO1xuICAgICAgICB2YXIgaCA9IHI7XG4gICAgICAgIHJldHVybiBpLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH0sIGkuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBoLmxlbmd0aDtcbiAgICAgICAgfSwgaS53cml0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBoLmxlbmd0aDsgZSArPSAxKSB0LnB1dChoW2VdLCA4KTtcbiAgICAgICAgfSwgaTtcbiAgICAgIH0sXG4gICAgICBmaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBbXSxcbiAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgd3JpdGVCeXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB0LnB1c2goMjU1ICYgZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGVTaG9ydDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgZS53cml0ZUJ5dGUodCksIGUud3JpdGVCeXRlKHQgPj4+IDgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uICh0LCByLCBpKSB7XG4gICAgICAgICAgICAgIHIgPSByIHx8IDAsIGkgPSBpIHx8IHQubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGk7IG4gKz0gMSkgZS53cml0ZUJ5dGUodFtuICsgcl0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDEpIGUud3JpdGVCeXRlKHQuY2hhckNvZGVBdChyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9CeXRlQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBcIlwiO1xuICAgICAgICAgICAgICBlICs9IFwiW1wiO1xuICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDEpIHIgPiAwICYmIChlICs9IFwiLFwiKSwgZSArPSB0W3JdO1xuICAgICAgICAgICAgICByZXR1cm4gZSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGNpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LFxuICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG4gPSAwLFxuICAgICAgICAgIHMgPSB7XG4gICAgICAgICAgICByZWFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAoOyBuIDwgODspIHtcbiAgICAgICAgICAgICAgICBpZiAociA+PSBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gbikgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBlbmQgb2YgZmlsZS4vXCIgKyBuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlLmNoYXJBdChyKTtcbiAgICAgICAgICAgICAgICBpZiAociArPSAxLCBcIj1cIiA9PSB0KSByZXR1cm4gbiA9IDAsIC0xO1xuICAgICAgICAgICAgICAgIHQubWF0Y2goL15cXHMkLykgfHwgKGkgPSBpIDw8IDYgfCBvKHQuY2hhckNvZGVBdCgwKSksIG4gKz0gNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHMgPSBpID4+PiBuIC0gOCAmIDI1NTtcbiAgICAgICAgICAgICAgcmV0dXJuIG4gLT0gOCwgcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKHQgPj0gNjUgJiYgdCA8PSA5MCkgcmV0dXJuIHQgLSA2NTtcbiAgICAgICAgICAgIGlmICh0ID49IDk3ICYmIHQgPD0gMTIyKSByZXR1cm4gdCAtIDk3ICsgMjY7XG4gICAgICAgICAgICBpZiAodCA+PSA0OCAmJiB0IDw9IDU3KSByZXR1cm4gdCAtIDQ4ICsgNTI7XG4gICAgICAgICAgICBpZiAoNDMgPT0gdCkgcmV0dXJuIDYyO1xuICAgICAgICAgICAgaWYgKDQ3ID09IHQpIHJldHVybiA2MztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImM6XCIgKyB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sXG4gICAgICBkaSA9IGZ1bmN0aW9uICh0LCBlLCByLCBpLCBuKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0LFxuICAgICAgICAgICAgICBpID0gZSxcbiAgICAgICAgICAgICAgbiA9IG5ldyBBcnJheSh0ICogZSksXG4gICAgICAgICAgICAgIHMgPSB7XG4gICAgICAgICAgICAgICAgc2V0UGl4ZWw6IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgICAgICAgICBuW2UgKiByICsgdF0gPSBpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IFwiI2ZmZmZmZlwiO1xuICAgICAgICAgICAgICAgICAgdC53cml0ZVN0cmluZyhcIkdJRjg3YVwiKSwgdC53cml0ZVNob3J0KHIpLCB0LndyaXRlU2hvcnQoaSksIHQud3JpdGVCeXRlKDEyOCksIHQud3JpdGVCeXRlKDApLCB0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzID0gZS5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgIHQud3JpdGVCeXRlKHBhcnNlSW50KFwiXCIuY29uY2F0KHNbMV0pLmNvbmNhdChzWzJdKSwgMTYpKSwgdC53cml0ZUJ5dGUocGFyc2VJbnQoXCJcIi5jb25jYXQoc1szXSkuY29uY2F0KHNbNF0pLCAxNikpLCB0LndyaXRlQnl0ZShwYXJzZUludChcIlwiLmNvbmNhdChzWzVdKS5jb25jYXQoc1s2XSksIDE2KSk7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IG4uc3BsaXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICB0LndyaXRlQnl0ZShwYXJzZUludChcIlwiLmNvbmNhdChhWzFdKS5jb25jYXQoYVsyXSksIDE2KSksIHQud3JpdGVCeXRlKHBhcnNlSW50KFwiXCIuY29uY2F0KGFbM10pLmNvbmNhdChhWzRdKSwgMTYpKSwgdC53cml0ZUJ5dGUocGFyc2VJbnQoXCJcIi5jb25jYXQoYVs1XSkuY29uY2F0KGFbNl0pLCAxNikpLCB0LndyaXRlU3RyaW5nKFwiLFwiKSwgdC53cml0ZVNob3J0KDApLCB0LndyaXRlU2hvcnQoMCksIHQud3JpdGVTaG9ydChyKSwgdC53cml0ZVNob3J0KGkpLCB0LndyaXRlQnl0ZSgwKTtcbiAgICAgICAgICAgICAgICAgIHZhciBoID0gbygyKTtcbiAgICAgICAgICAgICAgICAgIHQud3JpdGVCeXRlKDIpO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdSA9IDA7IGgubGVuZ3RoIC0gdSA+IDI1NTspIHQud3JpdGVCeXRlKDI1NSksIHQud3JpdGVCeXRlcyhoLCB1LCAyNTUpLCB1ICs9IDI1NTtcbiAgICAgICAgICAgICAgICAgIHQud3JpdGVCeXRlKGgubGVuZ3RoIC0gdSksIHQud3JpdGVCeXRlcyhoLCB1LCBoLmxlbmd0aCAtIHUpLCB0LndyaXRlQnl0ZSgwKSwgdC53cml0ZVN0cmluZyhcIjtcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMSA8PCB0LCByID0gMSArICgxIDw8IHQpLCBpID0gdCArIDEsIHMgPSBhKCksIG8gPSAwOyBvIDwgZTsgbyArPSAxKSBzLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKG8pKTtcbiAgICAgICAgICAgICAgICBzLmFkZChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKSwgcy5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShyKSk7XG4gICAgICAgICAgICAgICAgdmFyIGgsXG4gICAgICAgICAgICAgICAgICB1LFxuICAgICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICAgIGYgPSBmaSgpLFxuICAgICAgICAgICAgICAgICAgYyA9IChoID0gZiwgdSA9IDAsIGwgPSAwLCB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID4+PiBlICE9IDApIHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvdmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyB1ICsgZSA+PSA4OykgaC53cml0ZUJ5dGUoMjU1ICYgKHQgPDwgdSB8IGwpKSwgZSAtPSA4IC0gdSwgdCA+Pj49IDggLSB1LCBsID0gMCwgdSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgbCB8PSB0IDw8IHUsIHUgKz0gZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB1ID4gMCAmJiBoLndyaXRlQnl0ZShsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYy53cml0ZShlLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICAgICAgICBwID0gU3RyaW5nLmZyb21DaGFyQ29kZShuW2RdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGQgKz0gMTsgZCA8IG4ubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgdmFyIHkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5bZF0pO1xuICAgICAgICAgICAgICAgICAgZCArPSAxLCBzLmNvbnRhaW5zKHAgKyB5KSA/IHAgKz0geSA6IChjLndyaXRlKHMuaW5kZXhPZihwKSwgaSksIHMuc2l6ZSgpIDwgNDA5NSAmJiAocy5zaXplKCkgPT0gMSA8PCBpICYmIChpICs9IDEpLCBzLmFkZChwICsgeSkpLCBwID0geSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjLndyaXRlKHMuaW5kZXhPZihwKSwgaSksIGMud3JpdGUociwgaSksIGMuZmx1c2goKSwgZi50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0ge30sXG4gICAgICAgICAgICAgICAgICBlID0gMCxcbiAgICAgICAgICAgICAgICAgIHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoci5jb250YWlucyhpKSkgdGhyb3cgbmV3IEVycm9yKFwiZHVwIGtleTpcIiArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgIHRbaV0gPSBlLCBlICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFtlXTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdFtlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH0odCwgZSksIG8gPSAwOyBvIDwgZTsgbyArPSAxKSBmb3IgKHZhciBhID0gMDsgYSA8IHQ7IGEgKz0gMSkgcy5zZXRQaXhlbChhLCBvLCByKGEsIG8pKTtcbiAgICAgICAgdmFyIGggPSBmaSgpO1xuICAgICAgICBzLndyaXRlKGgsIGksIG4pO1xuICAgICAgICBmb3IgKHZhciB1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHQgPSAwLFxuICAgICAgICAgICAgICBlID0gMCxcbiAgICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICAgIGkgPSBcIlwiLFxuICAgICAgICAgICAgICBuID0ge30sXG4gICAgICAgICAgICAgIHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvKDYzICYgdCkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodCA8IDApIDtlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0IDwgMjYpIHJldHVybiA2NSArIHQ7XG4gICAgICAgICAgICAgICAgICBpZiAodCA8IDUyKSByZXR1cm4gdCAtIDI2ICsgOTc7XG4gICAgICAgICAgICAgICAgICBpZiAodCA8IDYyKSByZXR1cm4gdCAtIDUyICsgNDg7XG4gICAgICAgICAgICAgICAgICBpZiAoNjIgPT0gdCkgcmV0dXJuIDQzO1xuICAgICAgICAgICAgICAgICAgaWYgKDYzID09IHQpIHJldHVybiA0NztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibjpcIiArIHQpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG4ud3JpdGVCeXRlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgZm9yICh0ID0gdCA8PCA4IHwgMjU1ICYgaSwgZSArPSA4LCByICs9IDE7IGUgPj0gNjspIHModCA+Pj4gZSAtIDYpLCBlIC09IDY7XG4gICAgICAgICAgICB9LCBuLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZSA+IDAgJiYgKHModCA8PCA2IC0gZSksIHQgPSAwLCBlID0gMCksIHIgJSAzICE9IDApIGZvciAodmFyIG4gPSAzIC0gciAlIDMsIG8gPSAwOyBvIDwgbjsgbyArPSAxKSBpICs9IFwiPVwiO1xuICAgICAgICAgICAgfSwgbi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9LCBuO1xuICAgICAgICAgIH0oKSwgbCA9IGgudG9CeXRlQXJyYXkoKSwgZiA9IDA7IGYgPCBsLmxlbmd0aDsgZiArPSAxKSB1LndyaXRlQnl0ZShsW2ZdKTtcbiAgICAgICAgdS5mbHVzaCgpO1xuICAgICAgICB2YXIgYyA9IFwiXCI7XG4gICAgICAgIHJldHVybiAoYyArPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxcIikgKyB1O1xuICAgICAgfSxcbiAgICAgIHBpID0gMDtcbiAgICBmdW5jdGlvbiB5aSh0LCBlLCByKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHRyeSB7XG4gICAgICAgIChpID0gV3IociwgZSkpLmFkZERhdGEodCksIGkubWFrZSgpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICBpZiAociA+PSA0MCkgdGhyb3cgbmV3IEVycm9yKFwiVGV4dCB0b28gbG9uZyB0byBlbmNvZGVcIik7XG4gICAgICAgIHJldHVybiB5aSh0LCBlLCByICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgdmFyIHZpID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gcih0LCBlLCBpKSB7XG4gICAgICAgIHN3aXRjaCAobyh0aGlzLCByKSwgZih0aGlzLCBcInBsYXRmb3JtXCIsIHZvaWQgMCksIGYodGhpcywgXCJzaXplXCIsIHZvaWQgMCksIGYodGhpcywgXCJkcGlcIiwgMSksIGYodGhpcywgXCJjb250ZXh0XCIsIHZvaWQgMCksIGYodGhpcywgXCJjYW52YXNcIiwgdm9pZCAwKSwgZih0aGlzLCBcImNhY2hlZEltYWdlc1wiLCB7fSksIHRoaXMucGxhdGZvcm0gPSBfKCksIHRoaXMuZHBpID0gaSB8fCB0aGlzLmRwaSwgdGhpcy5zaXplID0ge1xuICAgICAgICAgIHdpZHRoOiB0IHx8IDMwMCxcbiAgICAgICAgICBoZWlnaHQ6IGUgfHwgMzAwXG4gICAgICAgIH0sIHRoaXMucGxhdGZvcm0pIHtcbiAgICAgICAgICBjYXNlIFwid2VhcHBcIjpcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gaGFzLmNyZWF0ZU9mZnNjcmVlbkNhbnZhcyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiMmRcIixcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCAqIHRoaXMuZHBpLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQgKiB0aGlzLmRwaVxuICAgICAgICAgICAgfSksIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhbGlwYXlcIjpcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbXkuY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKHtcbiAgICAgICAgICAgICAgdHlwZTogXCIyZFwiLFxuICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoICogdGhpcy5kcGksXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCAqIHRoaXMuZHBpXG4gICAgICAgICAgICB9KSwgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInR0XCI6XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGhhcy5jcmVhdGVPZmZzY3JlZW5DYW52YXMoe1xuICAgICAgICAgICAgICB0eXBlOiBcIjJkXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGggKiB0aGlzLmRwaSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0ICogdGhpcy5kcGlcbiAgICAgICAgICAgIH0pLCB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaDVcIjpcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0aGlzLnNpemUud2lkdGggKiB0aGlzLmRwaSwgdGhpcy5zaXplLmhlaWdodCAqIHRoaXMuZHBpKSwgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHkoXCJbcGFpbnRlcl3kuI3mlK/mjIHlvZPliY3lubPlj7BcIiwgdGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1KHIsIFt7XG4gICAgICAgIGtleTogXCJjYWxjQm91bmRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbiA9IHRoaXMuY2FsY0JvdW5kU2l6ZShlLndpZHRoLCB0aGlzLnNpemUud2lkdGgpIHx8IDAsXG4gICAgICAgICAgICBzID0gdGhpcy5jYWxjQm91bmRTaXplKGUuaGVpZ2h0LCB0aGlzLnNpemUuaGVpZ2h0KSB8fCAwLFxuICAgICAgICAgICAgbyA9IHRoaXMuY2FsY0JvdW5kU2l6ZShlLmxlZnQsIHRoaXMuc2l6ZS53aWR0aCksXG4gICAgICAgICAgICBhID0gdGhpcy5jYWxjQm91bmRTaXplKGUucmlnaHQsIHRoaXMuc2l6ZS53aWR0aCksXG4gICAgICAgICAgICBoID0gdGhpcy5jYWxjQm91bmRTaXplKGUudG9wLCB0aGlzLnNpemUuaGVpZ2h0KSxcbiAgICAgICAgICAgIHUgPSB0aGlzLmNhbGNCb3VuZFNpemUoZS5ib3R0b20sIHRoaXMuc2l6ZS5oZWlnaHQpLFxuICAgICAgICAgICAgbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4sIHMpKSxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNhbGNCb3VuZFNpemUoXCJvYmplY3RcIiA9PT0gdChlLnJhZGl1cykgPyBlLnJhZGl1cy50bCA6IGUucmFkaXVzLCBsKSB8fCAwO1xuICAgICAgICAgIGYgPSBNYXRoLm1pbihsIC8gMiwgTWF0aC5tYXgoZiwgMCkpO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jYWxjQm91bmRTaXplKFwib2JqZWN0XCIgPT09IHQoZS5yYWRpdXMpID8gZS5yYWRpdXMudHIgOiBlLnJhZGl1cywgbCkgfHwgMDtcbiAgICAgICAgICBjID0gTWF0aC5taW4obCAvIDIsIE1hdGgubWF4KGMsIDApKTtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuY2FsY0JvdW5kU2l6ZShcIm9iamVjdFwiID09PSB0KGUucmFkaXVzKSA/IGUucmFkaXVzLmJsIDogZS5yYWRpdXMsIGwpIHx8IDA7XG4gICAgICAgICAgZCA9IE1hdGgubWluKGwgLyAyLCBNYXRoLm1heChkLCAwKSk7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzLmNhbGNCb3VuZFNpemUoXCJvYmplY3RcIiA9PT0gdChlLnJhZGl1cykgPyBlLnJhZGl1cy5iciA6IGUucmFkaXVzLCBsKSB8fCAwO1xuICAgICAgICAgIHJldHVybiBwID0gTWF0aC5taW4obCAvIDIsIE1hdGgubWF4KHAsIDApKSwgciA9IHZvaWQgMCAhPT0gbyA/IHZvaWQgMCAhPT0gYSA/IG8gKyAodGhpcy5zaXplLndpZHRoIC0gbyAtIGEgLSBuKSAvIDIgOiBvIDogdm9pZCAwICE9PSBhID8gdGhpcy5zaXplLndpZHRoIC0gYSAtIG4gOiAwLCBpID0gdm9pZCAwICE9PSBoID8gdm9pZCAwICE9PSB1ID8gaCArICh0aGlzLnNpemUuaGVpZ2h0IC0gaCAtIHUgLSBzKSAvIDIgOiBoIDogdm9pZCAwICE9PSB1ID8gdGhpcy5zaXplLmhlaWdodCAtIHUgLSBzIDogMCwge1xuICAgICAgICAgICAgeDogciAqIHRoaXMuZHBpLFxuICAgICAgICAgICAgeTogaSAqIHRoaXMuZHBpLFxuICAgICAgICAgICAgd2lkdGg6IG4gKiB0aGlzLmRwaSxcbiAgICAgICAgICAgIGhlaWdodDogcyAqIHRoaXMuZHBpLFxuICAgICAgICAgICAgcmFkaXVzVEw6IGYgKiB0aGlzLmRwaSxcbiAgICAgICAgICAgIHJhZGl1c1RSOiBjICogdGhpcy5kcGksXG4gICAgICAgICAgICByYWRpdXNCTDogZCAqIHRoaXMuZHBpLFxuICAgICAgICAgICAgcmFkaXVzQlI6IHAgKiB0aGlzLmRwaVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNhbGNCb3VuZFNpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyAvW1xcZFxcLl0rJSQvLnRlc3QodCkgPyBlICogTnVtYmVyKHQuc3Vic3RyaW5nKDAsIHQubGVuZ3RoIC0gMSkpIC8gMTAwIDogMCA6IHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRyYXdJbWFnZVwiLFxuICAgICAgICB2YWx1ZTogKGQgPSBzKGUoKS5tYXJrKGZ1bmN0aW9uIHQociwgaSkge1xuICAgICAgICAgIHZhciBuLCBzLCBvLCBhLCBoLCB1LCBsLCBmO1xuICAgICAgICAgIHJldHVybiBlKCkud3JhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZm9yICg7Oykgc3dpdGNoICh0LnByZXYgPSB0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2F2ZSgpLCB0Lm5leHQgPSAzLCB0aGlzLmxvYWRJbWFnZShyKTtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG4gPSB0LnNlbnQsIHMgPSBuLndpZHRoLCBvID0gbi5oZWlnaHQsIGEgPSBuLndpZHRoLCBoID0gbi5oZWlnaHQsIHUgPSB0aGlzLmNhbGNCb3VuZFNpemUoaS53aWR0aCwgdGhpcy5zaXplLndpZHRoKSwgKGwgPSB0aGlzLmNhbGNCb3VuZFNpemUoaS5oZWlnaHQsIHRoaXMuc2l6ZS5oZWlnaHQpKSA/IHUgPyAoYSA9IHUsIGggPSBsKSA6IChhID0gbi53aWR0aCAqIGwgLyBuLmhlaWdodCwgaCA9IGwpIDogdSA/IChhID0gdSwgaCA9IG4uaGVpZ2h0ICogdSAvIG4ud2lkdGgpIDogKGEgPSBuLndpZHRoLCBoID0gbi5oZWlnaHQpLCBmID0gdGhpcy5jYWxjQm91bmQoUnIoUnIoe30sIGkpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGEsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgICAgICB9KSksIHRoaXMuZHJhd1JlY3QoZiksIHRoaXMuY29udGV4dC5jbGlwKCksIHRoaXMuY29udGV4dC5kcmF3SW1hZ2Uobi5kYXRhLCAwLCAwLCBzLCBvLCBmLngsIGYueSwgZi53aWR0aCwgZi5oZWlnaHQpLCB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHQsIHRoaXMpO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSlcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRyYXdUZXh0XCIsXG4gICAgICAgIHZhbHVlOiAoYyA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChyLCBpLCBuKSB7XG4gICAgICAgICAgdmFyIHMsIG8sIGEsIGg7XG4gICAgICAgICAgcmV0dXJuIGUoKS53cmFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBmb3IgKDs7KSBzd2l0Y2ggKHQucHJldiA9IHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zYXZlKCksIHMgPSB0aGlzLmNhbGNCb3VuZChpKSwgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IChudWxsID09IG4gPyB2b2lkIDAgOiBuLmNvbG9yKSB8fCBcIiMwMDAwMDBcIiwgbyA9ICgobnVsbCA9PSBuID8gdm9pZCAwIDogbi5mb250U2l6ZSkgfHwgMTYpICogdGhpcy5kcGksIHRoaXMuY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQoKG51bGwgPT0gbiA/IHZvaWQgMCA6IG4uZm9udFdlaWdodCkgfHwgXCJub3JtYWxcIiwgXCIgXCIpLmNvbmNhdChvLCBcInB4IFwiKS5jb25jYXQoKG51bGwgPT0gbiA/IHZvaWQgMCA6IG4uZm9udEZhbWlseSkgfHwgXCJzYW5zLXNlcmlmXCIpLCB0aGlzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJ0b3BcIiwgdGhpcy5jb250ZXh0LnRleHRBbGlnbiA9IChudWxsID09IG4gPyB2b2lkIDAgOiBuLnRleHRBbGlnbikgfHwgXCJzdGFydFwiLCBhID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHIpLCBoID0gYS53aWR0aCwgaS53aWR0aCA/IHRoaXMuY29udGV4dC5maWxsVGV4dChyLCBzLngsIHMueSwgcy53aWR0aCkgOiB0aGlzLmNvbnRleHQuZmlsbFRleHQociwgcy54LCBzLnkpLCB0aGlzLmNvbnRleHQucmVzdG9yZSgpLCB0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogaS53aWR0aCA/IHMud2lkdGggOiBoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBvXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdCwgdGhpcyk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZHJhd1FyQ29kZVwiLFxuICAgICAgICB2YWx1ZTogKGggPSBzKGUoKS5tYXJrKGZ1bmN0aW9uIHQociwgaSwgbikge1xuICAgICAgICAgIHZhciBzLCBvLCBhLCBoLCB1LCBsLCBmLCBjLCBkLCBwLCB5O1xuICAgICAgICAgIHJldHVybiBlKCkud3JhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgZm9yICg7Oykgc3dpdGNoICh0LnByZXYgPSB0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZvciAodGhpcy5jb250ZXh0LnNhdmUoKSwgcyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHIgPyB5aShyLCBuLmxldmVsLCA0KSA6IHIsIG8gPSBzLmdldE1vZHVsZUNvdW50KCksIGEgPSBNYXRoLmNlaWwobi5zaXplIC8gbyksIGggPSBhICogbyArIDIgKiBuLm1hcmdpbiwgdSA9IHRoaXMuY2FsY0JvdW5kKFJyKFJyKHt9LCBpKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgICAgICAgICAgfSkpLCBsID0gbi5tYXJnaW4gKiB0aGlzLmRwaSwgZiA9IGEgKiB0aGlzLmRwaSwgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IG4uYmdDb2xvciwgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHUueCwgdS55LCB1LnggKyB1LndpZHRoLCB1LnkgKyB1LmhlaWdodCksIGMgPSAwOyBjIDwgcy5nZXRNb2R1bGVDb3VudCgpOyBjKyspIGZvciAoZCA9IDA7IGQgPCBzLmdldE1vZHVsZUNvdW50KCk7IGQrKykgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHMuaXNEYXJrKGMsIGQpID8gbi5mZ0NvbG9yIDogbi5iZ0NvbG9yLCBwID0gTWF0aC5jZWlsKChkICsgMSkgKiBmKSAtIE1hdGguZmxvb3IoZCAqIGYpLCB5ID0gTWF0aC5jZWlsKChjICsgMSkgKiBmKSAtIE1hdGguZmxvb3IoYyAqIGYpLCB0aGlzLmNvbnRleHQuZmlsbFJlY3QodS54ICsgTWF0aC5yb3VuZChkICogZikgKyBsLCB1LnkgKyBNYXRoLnJvdW5kKGMgKiBmKSArIGwsIHAsIHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucmVzdG9yZSgpLCB0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogdS53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdS5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0LCB0aGlzKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiBoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJkcmF3Q29sb3JcIixcbiAgICAgICAgdmFsdWU6IChhID0gcyhlKCkubWFyayhmdW5jdGlvbiB0KHIsIGkpIHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICByZXR1cm4gZSgpLndyYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAoOzspIHN3aXRjaCAodC5wcmV2ID0gdC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpLCBuID0gdGhpcy5jYWxjQm91bmQoUnIoUnIoe30sIGkpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGkud2lkdGggfHwgMTAwLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpLmhlaWdodCB8fCAxMDBcbiAgICAgICAgICAgICAgICB9KSksIHRoaXMuZHJhd1JlY3QobiksIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSByLCB0aGlzLmNvbnRleHQuZmlsbCgpLCB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdCwgdGhpcyk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwibG9hZEltYWdlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgIGlmIChcImg1XCIgPT09IGUucGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgICBuLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIiwgbi5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcih7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogbi5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IG4ubmF0dXJhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGkoXCLliqDovb3lpLHotKVcIik7XG4gICAgICAgICAgICAgIH0sIG4uc3JjID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzID0gZS5jYW52YXMuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgICAgICAgZS5jYWNoZWRJbWFnZXNbdF0gPyAocy5zcmMgPSB0LCB5KFwiW3BhaW50ZXJdY2FjaGUgaW1hZ2UgbWF0Y2hlZFwiLCB0KSwgcih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGUuY2FjaGVkSW1hZ2VzW3RdLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZS5jYWNoZWRJbWFnZXNbdF0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRhdGE6IHNcbiAgICAgICAgICAgICAgfSkpIDogKHMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGUuY2FjaGVkSW1hZ2VzW3RdID0gcywgcih7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sIHMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpKFwi5Yqg6L295aSx6LSlXCIpO1xuICAgICAgICAgICAgICB9LCBzLnNyYyA9IHQuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpID8gdCA6IHQuaW5jbHVkZXMoXCI/XCIpID8gXCJcIi5jb25jYXQodCwgXCImdD1cIikuY29uY2F0KERhdGUubm93KCkpIDogXCJcIi5jb25jYXQodCwgXCI/dD1cIikuY29uY2F0KERhdGUubm93KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZHJhd1JlY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpLCB0aGlzLmNvbnRleHQubW92ZVRvKHQueCArIHQucmFkaXVzVEwsIHQueSksIHRoaXMuY29udGV4dC5saW5lVG8odC54ICsgdC53aWR0aCAtIHQucmFkaXVzVFIsIHQueSksIHRoaXMuY29udGV4dC5hcmNUbyh0LnggKyB0LndpZHRoLCB0LnksIHQueCArIHQud2lkdGgsIHQueSArIHQucmFkaXVzVFIsIHQucmFkaXVzVFIpLCB0aGlzLmNvbnRleHQubGluZVRvKHQueCArIHQud2lkdGgsIHQueSArIHQuaGVpZ2h0IC0gdC5yYWRpdXNCUiksIHRoaXMuY29udGV4dC5hcmNUbyh0LnggKyB0LndpZHRoLCB0LnkgKyB0LmhlaWdodCwgdC54ICsgdC53aWR0aCAtIHQucmFkaXVzQlIsIHQueSArIHQuaGVpZ2h0LCB0LnJhZGl1c0JSKSwgdGhpcy5jb250ZXh0LmxpbmVUbyh0LnggKyB0LnJhZGl1c0JMLCB0LnkgKyB0LmhlaWdodCksIHRoaXMuY29udGV4dC5hcmNUbyh0LngsIHQueSArIHQuaGVpZ2h0LCB0LngsIHQueSArIHQuaGVpZ2h0IC0gdC5yYWRpdXNCTCwgdC5yYWRpdXNCTCksIHRoaXMuY29udGV4dC5saW5lVG8odC54LCB0LnkgKyB0LnJhZGl1c1RMKSwgdGhpcy5jb250ZXh0LmFyY1RvKHQueCwgdC55LCB0LnggKyB0LnJhZGl1c1RMLCB0LnksIHQucmFkaXVzVEwpLCB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRyYXdDdXN0b21cIixcbiAgICAgICAgdmFsdWU6IChuID0gcyhlKCkubWFyayhmdW5jdGlvbiB0KHIpIHtcbiAgICAgICAgICByZXR1cm4gZSgpLndyYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAoOzspIHN3aXRjaCAodC5wcmV2ID0gdC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNhdmUoKSwgdC5uZXh0ID0gMywgcih0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHQsIHRoaXMpO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSlcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm91dHB1dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUucGxhdGZvcm0pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImg1XCI6XG4gICAgICAgICAgICAgICAgZS5jYW52YXMuY29udmVydFRvQmxvYih7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlL3BuZ1wiLFxuICAgICAgICAgICAgICAgICAgcXVhbGl0eTogMVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgIGUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpKHtcbiAgICAgICAgICAgICAgICAgICAgICBzcmM6IHQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFzaDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sIGUub25lcnJvciA9IG4sIGUucmVhZEFzRGF0YVVSTCh0KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChuKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImFsaXBheVwiOlxuICAgICAgICAgICAgICAgIHZhciBzID0gZS5jb250ZXh0LmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgaWYgKFwiZmlsZVwiID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICBZcigpO1xuICAgICAgICAgICAgICAgICAgdmFyIG8gPSBsKCksXG4gICAgICAgICAgICAgICAgICAgIGEgPSBvLmdldEZpbGVTeXN0ZW1NYW5hZ2VyKCksXG4gICAgICAgICAgICAgICAgICAgIGggPSBcIlwiLmNvbmNhdCh3KCksIFwiL3BhaW50ZXJfaW1hZ2VfXCIpLmNvbmNhdCgrK3BpLCBcIi5wbmdcIik7XG4gICAgICAgICAgICAgICAgICBvLmRvd25sb2FkRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhLnNhdmVGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEZpbGVQYXRoOiB0LnRlbXBGaWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgci5nZXRIYXNoKGgsIFwiZmlsZVwiKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW3N2Z2EvcGFpbnRlcl1oYXNoIGZhaWxlZFwiLCB0KSwgaSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG4obmV3IEVycm9yKHQuZXJyTXNnIHx8IFwib3V0cHV0IGZhaWxlZCgxKVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbihuZXcgRXJyb3IodC5lcnJNc2cgfHwgXCJvdXRwdXQgZmFpbGVkKDApXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGkoe1xuICAgICAgICAgICAgICAgICAgc3JjOiBzLFxuICAgICAgICAgICAgICAgICAgaGFzaDogdihzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid2VhcHBcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInR0XCI6XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBlLmNvbnRleHQuY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJmaWxlXCIgPT09IHQpIHtcbiAgICAgICAgICAgICAgICAgIFlyKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZiA9IGwoKS5nZXRGaWxlU3lzdGVtTWFuYWdlcigpLFxuICAgICAgICAgICAgICAgICAgICBjID0gXCJcIi5jb25jYXQodygpLCBcIi9wYWludGVyX2ltYWdlX1wiKS5jb25jYXQoKytwaSwgXCIucG5nXCIpO1xuICAgICAgICAgICAgICAgICAgZi53cml0ZUZpbGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDogYyxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHUuc3Vic3RyaW5nKDIyKSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHIuZ2V0SGFzaChjLCBcImZpbGVcIikudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltzdmdhL3BhaW50ZXJdaGFzaCBmYWlsZWRcIiwgdCksIGkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWlsOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgIG4obmV3IEVycm9yKHQuZXJyTXNnIHx8IFwib3V0cHV0IGZhaWxlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpKHtcbiAgICAgICAgICAgICAgICAgIHNyYzogdSxcbiAgICAgICAgICAgICAgICAgIGhhc2g6IHYodSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBuKG5ldyBFcnJvcihcIuaaguS4jeaUr+aMgeW9k+WJjeW5s+WPsFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1dLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0SGFzaFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgIFwiYmFzZTY0XCIgIT09IGUgPyBsKCkuZ2V0RmlsZVN5c3RlbU1hbmFnZXIoKS5nZXRGaWxlSW5mbyh7XG4gICAgICAgICAgICAgIGZpbGVQYXRoOiB0LFxuICAgICAgICAgICAgICBkaWdlc3RBbGdvcml0aG06IFwibWQ1XCIsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcih0LmRpZ2VzdCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgaSh0LmVyck1zZyB8fCBcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pIDogcih2KHQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwicXJjb2RlXCIsXG4gICAgICAgIHZhbHVlOiAoaSA9IHMoZSgpLm1hcmsoZnVuY3Rpb24gdChpLCBuKSB7XG4gICAgICAgICAgdmFyIHMsIG8sIGEsIGgsIHUsIGwsIGYsIGMsIGQsIHA7XG4gICAgICAgICAgcmV0dXJuIGUoKS53cmFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBmb3IgKDs7KSBzd2l0Y2ggKHQucHJldiA9IHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgPSAobnVsbCA9PSBuID8gdm9pZCAwIDogbi5sZXZlbCkgfHwgXCJNXCIsIG8gPSB5aShpLCBzLCA0KSwgYSA9IG8uZ2V0TW9kdWxlQ291bnQoKSwgaCA9IChudWxsID09IG4gPyB2b2lkIDAgOiBuLnNpemUpIHx8IDMwMCwgdSA9IE1hdGguY2VpbChoIC8gYSksIGwgPSB1ICogYSwgZiA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIChudWxsID09IG4gPyB2b2lkIDAgOiBuLm1hcmdpbikgPyBuLm1hcmdpbiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIChudWxsID09IG4gPyB2b2lkIDAgOiBuLm1hcmdpbikgJiYgbi5tYXJnaW4uZW5kc1dpdGgoXCJ0XCIpID8gdSAqIChOdW1iZXIobi5tYXJnaW4uc3Vic3RyaW5nKDAsIG4ubWFyZ2luLmxlbmd0aCAtIDEpKSB8fCAwKSA6IHUsIGQgPSBuZXcgcihjID0gbCArIDIgKiBmLCBjLCAxKSwgdC5uZXh0ID0gMTEsIGQuZHJhd1FyQ29kZShpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgc2l6ZTogbCxcbiAgICAgICAgICAgICAgICAgIG1hcmdpbjogZixcbiAgICAgICAgICAgICAgICAgIGxldmVsOiBzLFxuICAgICAgICAgICAgICAgICAgYmdDb2xvcjogKG51bGwgPT0gbiA/IHZvaWQgMCA6IG4uYmdDb2xvcikgfHwgXCIjZmZmZmZmXCIsXG4gICAgICAgICAgICAgICAgICBmZ0NvbG9yOiAobnVsbCA9PSBuID8gdm9pZCAwIDogbi5mZ0NvbG9yKSB8fCBcIiMwMDAwMDBcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHJldHVybiB0Lm5leHQgPSAxMywgZC5vdXRwdXQoKTtcbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcCA9IHQuc2VudCwgdC5hYnJ1cHQoXCJyZXR1cm5cIiwgcCk7XG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gaS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KVxuICAgICAgfV0pO1xuICAgICAgdmFyIGksIG4sIGEsIGgsIGMsIGQ7XG4gICAgfSgpO1xuICAgIGNvbnN0IGdpID0ge1xuICAgICAgaW5pdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHMoZSgpLm1hcmsoZnVuY3Rpb24gcigpIHtcbiAgICAgICAgICByZXR1cm4gZSgpLndyYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGZvciAoOzspIHN3aXRjaCAoZS5wcmV2ID0gZS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbSh0KSwgZS5uZXh0ID0gMywgXCJoNVwiID09PSBfKCkgPyBQcm9taXNlLnJlc29sdmUoITEpIDogbmV3IFByb21pc2UoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlID0gbCgpLmdldEZpbGVTeXN0ZW1NYW5hZ2VyKCksXG4gICAgICAgICAgICAgICAgICAgIHIgPSB3KCk7XG4gICAgICAgICAgICAgICAgICBlLmFjY2Vzcyh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHIsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5ybWRpclN5bmMociwgITApLCB0KCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5KFwiaW5mb1wiLCBcIltzdmdhXea4heeQhue8k+WtmOebruW9leWksei0pVwiLCBlKSwgdCghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdCghMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgeShcImluaXRlZFwiLCB0KTtcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHIpO1xuICAgICAgICB9KSkoKTtcbiAgICAgIH0sXG4gICAgICBtZDU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBkLmhhc2hTdHIodCk7XG4gICAgICB9LFxuICAgICAgUGxheWVyOiBHcixcbiAgICAgIFBhcnNlcjogTHIsXG4gICAgICBQYWludGVyOiB2aVxuICAgIH07XG4gIH0pKCksIGk7XG59KSgpKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/svga-2dfire.js\n");

/***/ }),

/***/ "./miniprogram_npm/@ungap/url-search-params/cjs/index.js":
/*!***************************************************************!*\
  !*** ./miniprogram_npm/@ungap/url-search-params/cjs/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*! (c) Andrea Giammarchi - ISC */\nvar self = {};\ntry {\n  (function (URLSearchParams, plus) {\n    if (new URLSearchParams('q=%2B').get('q') !== plus || new URLSearchParams({\n      q: plus\n    }).get('q') !== plus || new URLSearchParams([['q', plus]]).get('q') !== plus || new URLSearchParams('q=\\n').toString() !== 'q=%0A' || new URLSearchParams({\n      q: ' &'\n    }).toString() !== 'q=+%26' || new URLSearchParams({\n      q: '%zx'\n    }).toString() !== 'q=%25zx') throw URLSearchParams;\n    self.URLSearchParams = URLSearchParams;\n  })(URLSearchParams, '+');\n} catch (URLSearchParams) {\n  (function (Object, String, isArray) {\n    'use strict';\n\n    var create = Object.create;\n    var defineProperty = Object.defineProperty;\n    var find = /[!'\\(\\)~]|%20|%00/g;\n    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;\n    var plus = /\\+/g;\n    var replace = {\n      '!': '%21',\n      \"'\": '%27',\n      '(': '%28',\n      ')': '%29',\n      '~': '%7E',\n      '%20': '+',\n      '%00': '\\x00'\n    };\n    var proto = {\n      append: function (key, value) {\n        appendTo(this._ungap, key, value);\n      },\n      delete: function (key) {\n        delete this._ungap[key];\n      },\n      get: function (key) {\n        return this.has(key) ? this._ungap[key][0] : null;\n      },\n      getAll: function (key) {\n        return this.has(key) ? this._ungap[key].slice(0) : [];\n      },\n      has: function (key) {\n        return key in this._ungap;\n      },\n      set: function (key, value) {\n        this._ungap[key] = [String(value)];\n      },\n      forEach: function (callback, thisArg) {\n        var self = this;\n        for (var key in self._ungap) self._ungap[key].forEach(invoke, key);\n        function invoke(value) {\n          callback.call(thisArg, value, String(key), self);\n        }\n      },\n      toJSON: function () {\n        return {};\n      },\n      toString: function () {\n        var query = [];\n        for (var key in this._ungap) {\n          var encoded = encode(key);\n          for (var i = 0, value = this._ungap[key]; i < value.length; i++) {\n            query.push(encoded + '=' + encode(value[i]));\n          }\n        }\n        return query.join('&');\n      }\n    };\n    for (var key in proto) defineProperty(URLSearchParams.prototype, key, {\n      configurable: true,\n      writable: true,\n      value: proto[key]\n    });\n    self.URLSearchParams = URLSearchParams;\n    function URLSearchParams(query) {\n      var dict = create(null);\n      defineProperty(this, '_ungap', {\n        value: dict\n      });\n      switch (true) {\n        case !query:\n          break;\n        case typeof query === 'string':\n          if (query.charAt(0) === '?') {\n            query = query.slice(1);\n          }\n          for (var pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {\n            var value = pairs[i];\n            var index = value.indexOf('=');\n            if (-1 < index) {\n              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n            } else if (value.length) {\n              appendTo(dict, decode(value), '');\n            }\n          }\n          break;\n        case isArray(query):\n          for (var i = 0, length = query.length; i < length; i++) {\n            var value = query[i];\n            appendTo(dict, value[0], value[1]);\n          }\n          break;\n        case 'forEach' in query:\n          query.forEach(addEach, dict);\n          break;\n        default:\n          for (var key in query) appendTo(dict, key, query[key]);\n      }\n    }\n    function addEach(value, key) {\n      appendTo(this, key, value);\n    }\n    function appendTo(dict, key, value) {\n      var res = isArray(value) ? value.join(',') : value;\n      if (key in dict) dict[key].push(res);else dict[key] = [res];\n    }\n    function decode(str) {\n      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));\n    }\n    function encode(str) {\n      return encodeURIComponent(str).replace(find, replacer);\n    }\n    function replacer(match) {\n      return replace[match];\n    }\n  })(Object, String, Array.isArray);\n}\n(function (URLSearchParamsProto) {\n  var iterable = false;\n  try {\n    iterable = !!Symbol.iterator;\n  } catch (o_O) {}\n\n  /* istanbul ignore else */\n  if (!('forEach' in URLSearchParamsProto)) {\n    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {\n      var self = this;\n      var names = Object.create(null);\n      this.toString().replace(/=[\\s\\S]*?(?:&|$)/g, '=').split('=').forEach(function (name) {\n        if (!name.length || name in names) return;\n        (names[name] = self.getAll(name)).forEach(function (value) {\n          callback.call(thisArg, value, name, self);\n        });\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('keys' in URLSearchParamsProto)) {\n    URLSearchParamsProto.keys = function keys() {\n      return iterator(this, function (value, key) {\n        this.push(key);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('values' in URLSearchParamsProto)) {\n    URLSearchParamsProto.values = function values() {\n      return iterator(this, function (value, key) {\n        this.push(value);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (!('entries' in URLSearchParamsProto)) {\n    URLSearchParamsProto.entries = function entries() {\n      return iterator(this, function (value, key) {\n        this.push([key, value]);\n      });\n    };\n  }\n\n  /* istanbul ignore else */\n  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {\n    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;\n  }\n\n  /* istanbul ignore else */\n  if (!('sort' in URLSearchParamsProto)) {\n    URLSearchParamsProto.sort = function sort() {\n      var entries = this.entries(),\n        entry = entries.next(),\n        done = entry.done,\n        keys = [],\n        values = Object.create(null),\n        i,\n        key,\n        value;\n      while (!done) {\n        value = entry.value;\n        key = value[0];\n        keys.push(key);\n        if (!(key in values)) {\n          values[key] = [];\n        }\n        values[key].push(value[1]);\n        entry = entries.next();\n        done = entry.done;\n      }\n      // not the champion in efficiency\n      // but these two bits just do the job\n      keys.sort();\n      for (i = 0; i < keys.length; i++) {\n        this.delete(keys[i]);\n      }\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        this.append(key, values[key].shift());\n      }\n    };\n  }\n  function iterator(self, callback) {\n    var items = [];\n    self.forEach(callback, items);\n    /* istanbul ignore next */\n    return iterable ? items[Symbol.iterator]() : {\n      next: function () {\n        var value = items.shift();\n        return {\n          done: value === void 0,\n          value: value\n        };\n      }\n    };\n  }\n\n  /* istanbul ignore next */\n  (function (Object) {\n    var dP = Object.defineProperty,\n      gOPD = Object.getOwnPropertyDescriptor,\n      createSearchParamsPollute = function (search) {\n        function append(name, value) {\n          URLSearchParamsProto.append.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        function del(name) {\n          URLSearchParamsProto.delete.call(this, name);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        function set(name, value) {\n          URLSearchParamsProto.set.call(this, name, value);\n          name = this.toString();\n          search.set.call(this._usp, name ? '?' + name : '');\n        }\n        return function (sp, value) {\n          sp.append = append;\n          sp.delete = del;\n          sp.set = set;\n          return dP(sp, '_usp', {\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        };\n      },\n      createSearchParamsCreate = function (polluteSearchParams) {\n        return function (obj, sp) {\n          dP(obj, '_searchParams', {\n            configurable: true,\n            writable: true,\n            value: polluteSearchParams(sp, obj)\n          });\n          return sp;\n        };\n      },\n      updateSearchParams = function (sp) {\n        var append = sp.append;\n        sp.append = URLSearchParamsProto.append;\n        URLSearchParams.call(sp, sp._usp.search.slice(1));\n        sp.append = append;\n      },\n      verifySearchParams = function (obj, Class) {\n        if (!(obj instanceof Class)) throw new TypeError(\"'searchParams' accessed on an object that \" + \"does not implement interface \" + Class.name);\n      },\n      upgradeClass = function (Class) {\n        var ClassProto = Class.prototype,\n          searchParams = gOPD(ClassProto, 'searchParams'),\n          href = gOPD(ClassProto, 'href'),\n          search = gOPD(ClassProto, 'search'),\n          createSearchParams;\n        if (!searchParams && search && search.set) {\n          createSearchParams = createSearchParamsCreate(createSearchParamsPollute(search));\n          Object.defineProperties(ClassProto, {\n            href: {\n              get: function () {\n                return href.get.call(this);\n              },\n              set: function (value) {\n                var sp = this._searchParams;\n                href.set.call(this, value);\n                if (sp) updateSearchParams(sp);\n              }\n            },\n            search: {\n              get: function () {\n                return search.get.call(this);\n              },\n              set: function (value) {\n                var sp = this._searchParams;\n                search.set.call(this, value);\n                if (sp) updateSearchParams(sp);\n              }\n            },\n            searchParams: {\n              get: function () {\n                verifySearchParams(this, Class);\n                return this._searchParams || createSearchParams(this, new URLSearchParams(this.search.slice(1)));\n              },\n              set: function (sp) {\n                verifySearchParams(this, Class);\n                createSearchParams(this, sp);\n              }\n            }\n          });\n        }\n      };\n    try {\n      upgradeClass(HTMLAnchorElement);\n      if (/^function|object$/.test(typeof URL) && URL.prototype) upgradeClass(URL);\n    } catch (meh) {}\n  })(Object);\n})(self.URLSearchParams.prototype, Object);\nmodule.exports = self.URLSearchParams;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9taW5pcHJvZ3JhbV9ucG0vQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2Nqcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWluaXByb2dyYW0td2VhcHAvLi9taW5pcHJvZ3JhbV9ucG0vQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2Nqcy9pbmRleC5qcz9hYmZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiEgKGMpIEFuZHJlYSBHaWFtbWFyY2hpIC0gSVNDICovXG52YXIgc2VsZiA9IHt9O1xudHJ5IHtcbiAgKGZ1bmN0aW9uIChVUkxTZWFyY2hQYXJhbXMsIHBsdXMpIHtcbiAgICBpZiAobmV3IFVSTFNlYXJjaFBhcmFtcygncT0lMkInKS5nZXQoJ3EnKSAhPT0gcGx1cyB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHE6IHBsdXNcbiAgICB9KS5nZXQoJ3EnKSAhPT0gcGx1cyB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKFtbJ3EnLCBwbHVzXV0pLmdldCgncScpICE9PSBwbHVzIHx8IG5ldyBVUkxTZWFyY2hQYXJhbXMoJ3E9XFxuJykudG9TdHJpbmcoKSAhPT0gJ3E9JTBBJyB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHE6ICcgJidcbiAgICB9KS50b1N0cmluZygpICE9PSAncT0rJTI2JyB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHE6ICclengnXG4gICAgfSkudG9TdHJpbmcoKSAhPT0gJ3E9JTI1engnKSB0aHJvdyBVUkxTZWFyY2hQYXJhbXM7XG4gICAgc2VsZi5VUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gIH0pKFVSTFNlYXJjaFBhcmFtcywgJysnKTtcbn0gY2F0Y2ggKFVSTFNlYXJjaFBhcmFtcykge1xuICAoZnVuY3Rpb24gKE9iamVjdCwgU3RyaW5nLCBpc0FycmF5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBmaW5kID0gL1shJ1xcKFxcKX5dfCUyMHwlMDAvZztcbiAgICB2YXIgZmluZFBlcmNlbnRTaWduID0gLyUoPyFbMC05YS1mQS1GXXsyfSkvZztcbiAgICB2YXIgcGx1cyA9IC9cXCsvZztcbiAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICd+JzogJyU3RScsXG4gICAgICAnJTIwJzogJysnLFxuICAgICAgJyUwMCc6ICdcXHgwMCdcbiAgICB9O1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXBwZW5kVG8odGhpcy5fdW5nYXAsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldWzBdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldLnNsaWNlKDApIDogW107XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5fdW5nYXA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmdhcFtrZXldID0gW1N0cmluZyh2YWx1ZSldO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLl91bmdhcCkgc2VsZi5fdW5nYXBba2V5XS5mb3JFYWNoKGludm9rZSwga2V5KTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlKHZhbHVlKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgU3RyaW5nKGtleSksIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3VuZ2FwKSB7XG4gICAgICAgICAgdmFyIGVuY29kZWQgPSBlbmNvZGUoa2V5KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdmFsdWUgPSB0aGlzLl91bmdhcFtrZXldOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlZCArICc9JyArIGVuY29kZSh2YWx1ZVtpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnkuam9pbignJicpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIHByb3RvKSBkZWZpbmVQcm9wZXJ0eShVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHByb3RvW2tleV1cbiAgICB9KTtcbiAgICBzZWxmLlVSTFNlYXJjaFBhcmFtcyA9IFVSTFNlYXJjaFBhcmFtcztcbiAgICBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMocXVlcnkpIHtcbiAgICAgIHZhciBkaWN0ID0gY3JlYXRlKG51bGwpO1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ191bmdhcCcsIHtcbiAgICAgICAgdmFsdWU6IGRpY3RcbiAgICAgIH0pO1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgIXF1ZXJ5OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZyc6XG4gICAgICAgICAgaWYgKHF1ZXJ5LmNoYXJBdCgwKSA9PT0gJz8nKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksIGkgPSAwLCBsZW5ndGggPSBwYWlycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFpcnNbaV07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBpZiAoLTEgPCBpbmRleCkge1xuICAgICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCBkZWNvZGUodmFsdWUuc2xpY2UoMCwgaW5kZXgpKSwgZGVjb2RlKHZhbHVlLnNsaWNlKGluZGV4ICsgMSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKGRpY3QsIGRlY29kZSh2YWx1ZSksICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaXNBcnJheShxdWVyeSk6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBxdWVyeVtpXTtcbiAgICAgICAgICAgIGFwcGVuZFRvKGRpY3QsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3JFYWNoJyBpbiBxdWVyeTpcbiAgICAgICAgICBxdWVyeS5mb3JFYWNoKGFkZEVhY2gsIGRpY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBxdWVyeSkgYXBwZW5kVG8oZGljdCwga2V5LCBxdWVyeVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRWFjaCh2YWx1ZSwga2V5KSB7XG4gICAgICBhcHBlbmRUbyh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kVG8oZGljdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWU7XG4gICAgICBpZiAoa2V5IGluIGRpY3QpIGRpY3Rba2V5XS5wdXNoKHJlcyk7ZWxzZSBkaWN0W2tleV0gPSBbcmVzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZShmaW5kUGVyY2VudFNpZ24sICclMjUnKS5yZXBsYWNlKHBsdXMsICcgJykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfVxuICB9KShPYmplY3QsIFN0cmluZywgQXJyYXkuaXNBcnJheSk7XG59XG4oZnVuY3Rpb24gKFVSTFNlYXJjaFBhcmFtc1Byb3RvKSB7XG4gIHZhciBpdGVyYWJsZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGl0ZXJhYmxlID0gISFTeW1ib2wuaXRlcmF0b3I7XG4gIH0gY2F0Y2ggKG9fTykge31cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnZm9yRWFjaCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLnRvU3RyaW5nKCkucmVwbGFjZSgvPVtcXHNcXFNdKj8oPzomfCQpL2csICc9Jykuc3BsaXQoJz0nKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghbmFtZS5sZW5ndGggfHwgbmFtZSBpbiBuYW1lcykgcmV0dXJuO1xuICAgICAgICAobmFtZXNbbmFtZV0gPSBzZWxmLmdldEFsbChuYW1lKSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCBzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2tleXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXMucHVzaChrZXkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCd2YWx1ZXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghKCdlbnRyaWVzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXRlcmFibGUgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXM7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnc29ydCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcygpLFxuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpLFxuICAgICAgICBkb25lID0gZW50cnkuZG9uZSxcbiAgICAgICAga2V5cyA9IFtdLFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBpLFxuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlO1xuICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIHZhbHVlID0gZW50cnkudmFsdWU7XG4gICAgICAgIGtleSA9IHZhbHVlWzBdO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlcykpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1trZXldLnB1c2godmFsdWVbMV0pO1xuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpO1xuICAgICAgICBkb25lID0gZW50cnkuZG9uZTtcbiAgICAgIH1cbiAgICAgIC8vIG5vdCB0aGUgY2hhbXBpb24gaW4gZWZmaWNpZW5jeVxuICAgICAgLy8gYnV0IHRoZXNlIHR3byBiaXRzIGp1c3QgZG8gdGhlIGpvYlxuICAgICAga2V5cy5zb3J0KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRlbGV0ZShrZXlzW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWVzW2tleV0uc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBjYWxsYmFjaykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHNlbGYuZm9yRWFjaChjYWxsYmFjaywgaXRlbXMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGl0ZXJhYmxlID8gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpIDoge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHZhbHVlID09PSB2b2lkIDAsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIChmdW5jdGlvbiAoT2JqZWN0KSB7XG4gICAgdmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNQb2xsdXRlID0gZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5hcHBlbmQuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzZWFyY2guc2V0LmNhbGwodGhpcy5fdXNwLCBuYW1lID8gJz8nICsgbmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWwobmFtZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmRlbGV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgc2VhcmNoLnNldC5jYWxsKHRoaXMuX3VzcCwgbmFtZSA/ICc/JyArIG5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgc2VhcmNoLnNldC5jYWxsKHRoaXMuX3VzcCwgbmFtZSA/ICc/JyArIG5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzcCwgdmFsdWUpIHtcbiAgICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICAgICAgc3AuZGVsZXRlID0gZGVsO1xuICAgICAgICAgIHNwLnNldCA9IHNldDtcbiAgICAgICAgICByZXR1cm4gZFAoc3AsICdfdXNwJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWFyY2hQYXJhbXNDcmVhdGUgPSBmdW5jdGlvbiAocG9sbHV0ZVNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgc3ApIHtcbiAgICAgICAgICBkUChvYmosICdfc2VhcmNoUGFyYW1zJywge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogcG9sbHV0ZVNlYXJjaFBhcmFtcyhzcCwgb2JqKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzcDtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNwLmFwcGVuZDtcbiAgICAgICAgc3AuYXBwZW5kID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uYXBwZW5kO1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMuY2FsbChzcCwgc3AuX3VzcC5zZWFyY2guc2xpY2UoMSkpO1xuICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICB9LFxuICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKG9iaiwgQ2xhc3MpIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ2xhc3MpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ3NlYXJjaFBhcmFtcycgYWNjZXNzZWQgb24gYW4gb2JqZWN0IHRoYXQgXCIgKyBcImRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgXCIgKyBDbGFzcy5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB1cGdyYWRlQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MpIHtcbiAgICAgICAgdmFyIENsYXNzUHJvdG8gPSBDbGFzcy5wcm90b3R5cGUsXG4gICAgICAgICAgc2VhcmNoUGFyYW1zID0gZ09QRChDbGFzc1Byb3RvLCAnc2VhcmNoUGFyYW1zJyksXG4gICAgICAgICAgaHJlZiA9IGdPUEQoQ2xhc3NQcm90bywgJ2hyZWYnKSxcbiAgICAgICAgICBzZWFyY2ggPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2gnKSxcbiAgICAgICAgICBjcmVhdGVTZWFyY2hQYXJhbXM7XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zICYmIHNlYXJjaCAmJiBzZWFyY2guc2V0KSB7XG4gICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zQ3JlYXRlKGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUoc2VhcmNoKSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xhc3NQcm90bywge1xuICAgICAgICAgICAgaHJlZjoge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHJlZi5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3AgPSB0aGlzLl9zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgaHJlZi5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2guZ2V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwID0gdGhpcy5fc2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaFBhcmFtcyB8fCBjcmVhdGVTZWFyY2hQYXJhbXModGhpcywgbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLnNlYXJjaC5zbGljZSgxKSkpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcCkge1xuICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zKHRoaXMsIHNwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRyeSB7XG4gICAgICB1cGdyYWRlQ2xhc3MoSFRNTEFuY2hvckVsZW1lbnQpO1xuICAgICAgaWYgKC9eZnVuY3Rpb258b2JqZWN0JC8udGVzdCh0eXBlb2YgVVJMKSAmJiBVUkwucHJvdG90eXBlKSB1cGdyYWRlQ2xhc3MoVVJMKTtcbiAgICB9IGNhdGNoIChtZWgpIHt9XG4gIH0pKE9iamVjdCk7XG59KShzZWxmLlVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUsIE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuVVJMU2VhcmNoUGFyYW1zOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./miniprogram_npm/@ungap/url-search-params/cjs/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app.json?package=app");
/******/ 	
/******/ })()
;
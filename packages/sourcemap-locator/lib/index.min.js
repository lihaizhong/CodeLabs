!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("fs"),require("path"),require("url")):"function"==typeof define&&define.amd?define(["exports","fs","path","url"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).SourcemapLocator={},e.fs,e.path,e.require$$0)}(this,(function(e,t,n,r){"use strict";var s,o;e.ErrorType=void 0,(s=e.ErrorType||(e.ErrorType={})).FILE_NOT_FOUND="FILE_NOT_FOUND",s.INVALID_SOURCEMAP="INVALID_SOURCEMAP",s.POSITION_OUT_OF_RANGE="POSITION_OUT_OF_RANGE",s.MAX_RECURSION_EXCEEDED="MAX_RECURSION_EXCEEDED",s.MAX_DEPTH_EXCEEDED="MAX_DEPTH_EXCEEDED",s.CIRCULAR_REFERENCE="CIRCULAR_REFERENCE",s.PARSE_ERROR="PARSE_ERROR";class i extends Error{constructor(e,t,n){super(t),this.name="SourcemapLocatorError",this.type=e,this.details=n}}e.EventType=void 0,(o=e.EventType||(e.EventType={})).PARSE_START="PARSE_START",o.PARSE_COMPLETE="PARSE_COMPLETE",o.MAPPING_FOUND="MAPPING_FOUND",o.RECURSIVE_PARSE="RECURSIVE_PARSE",o.CACHE_HIT="CACHE_HIT",o.CACHE_MISS="CACHE_MISS",o.LOCATE_START="locate_start",o.STEP_COMPLETE="step_complete",o.LOCATE_COMPLETE="locate_complete";var a={},l={};const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");l.encode=function(e){if(0<=e&&e<u.length)return u[e];throw new TypeError("Must be between 0 and 63: "+e)};const c=l;a.encode=function(e){let t,n="",r=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&r,r>>>=5,r>0&&(t|=32),n+=c.encode(t)}while(r>0);return n};var h={};const p="function"==typeof URL?URL:r.URL;h.getArg=function(e,t,n){if(t in e)return e[t];if(3===arguments.length)return n;throw new Error('"'+t+'" is a required argument.')};const m=!("__proto__"in Object.create(null));function g(e){return e}function f(e){if(!e)return!1;const t=e.length;if(t<9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(let n=t-10;n>=0;n--)if(36!==e.charCodeAt(n))return!1;return!0}function d(e,t){return e===t?0:null===e?1:null===t?-1:e>t?1:-1}h.toSetString=m?g:function(e){return f(e)?"$"+e:e},h.fromSetString=m?g:function(e){return f(e)?e.slice(1):e},h.compareByGeneratedPositionsInflated=function(e,t){let n=e.generatedLine-t.generatedLine;return 0!==n?n:(n=e.generatedColumn-t.generatedColumn,0!==n?n:(n=d(e.source,t.source),0!==n?n:(n=e.originalLine-t.originalLine,0!==n?n:(n=e.originalColumn-t.originalColumn,0!==n?n:d(e.name,t.name)))))},h.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))};const _="http:",E=`${_}//host`;function C(e){return t=>{const n=A(t),r=y(t),s=new p(t,r);e(s);const o=s.toString();return"absolute"===n?o:"scheme-relative"===n?o.slice(5):"path-absolute"===n?o.slice(E.length):L(r,o)}}function S(e,t){return new p(e,t).toString()}function y(e){const t=e.split("..").length-1,n=function(e,t){let n=0;for(;;){const r=e+n++;if(-1===t.indexOf(r))return r}}("p",e);let r=`${E}/`;for(let e=0;e<t;e++)r+=`${n}/`;return r}const w=/^[A-Za-z0-9\+\-\.]+:/;function A(e){return"/"===e[0]?"/"===e[1]?"scheme-relative":"path-absolute":w.test(e)?"absolute":"path-relative"}function L(e,t){"string"==typeof e&&(e=new p(e)),"string"==typeof t&&(t=new p(t));const n=t.pathname.split("/"),r=e.pathname.split("/");for(r.length>0&&!r[r.length-1]&&r.pop();n.length>0&&r.length>0&&n[0]===r[0];)n.shift(),r.shift();return r.map((()=>"..")).concat(n).join("/")+t.search+t.hash}const v=C((e=>{e.pathname=e.pathname.replace(/\/?$/,"/")})),R=C((e=>{e.href=new p(".",e.toString()).toString()})),O=C((e=>{}));function P(e,t){const n=A(t),r=A(e);if(e=v(e),"absolute"===n)return S(t,void 0);if("absolute"===r)return S(t,e);if("scheme-relative"===n)return O(t);if("scheme-relative"===r)return S(t,S(e,E)).slice(5);if("path-absolute"===n)return O(t);if("path-absolute"===r)return S(t,S(e,E)).slice(E.length);const s=y(t+e);return L(s,S(t,S(e,s)))}h.normalize=O,h.join=P,h.relative=function(e,t){const n=function(e,t){const n=A(e);if(n!==A(t))return null;const r=y(e+t),s=new p(e,r),o=new p(t,r);try{new p("",o.toString())}catch(e){return null}if(o.protocol!==s.protocol||o.user!==s.user||o.password!==s.password||o.hostname!==s.hostname||o.port!==s.port)return null;return L(s,o)}(e,t);return"string"==typeof n?n:O(t)},h.computeSourceURL=function(e,t,n){e&&"path-absolute"===A(t)&&(t=t.replace(/^\//,""));let r=O(t||"");return e&&(r=P(e,r)),n&&(r=P(R(n),r)),r};var b={};b.ArraySet=class e{constructor(){this._array=[],this._set=new Map}static fromArray(t,n){const r=new e;for(let e=0,s=t.length;e<s;e++)r.add(t[e],n);return r}size(){return this._set.size}add(e,t){const n=this.has(e),r=this._array.length;n&&!t||this._array.push(e),n||this._set.set(e,r)}has(e){return this._set.has(e)}indexOf(e){const t=this._set.get(e);if(t>=0)return t;throw new Error('"'+e+'" is not in the set.')}at(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)}toArray(){return this._array.slice()}};var T={};const M=h;T.MappingList=class{constructor(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}unsortedForEach(e,t){this._array.forEach(e,t)}add(e){!function(e,t){const n=e.generatedLine,r=t.generatedLine,s=e.generatedColumn,o=t.generatedColumn;return r>n||r==n&&o>=s||M.compareByGeneratedPositionsInflated(e,t)<=0}(this._last,e)?(this._sorted=!1,this._array.push(e)):(this._last=e,this._array.push(e))}toArray(){return this._sorted||(this._array.sort(M.compareByGeneratedPositionsInflated),this._sorted=!0),this._array}};const I=a,x=h,F=b.ArraySet,N=T.MappingList;class U{constructor(e){e||(e={}),this._file=x.getArg(e,"file",null),this._sourceRoot=x.getArg(e,"sourceRoot",null),this._skipValidation=x.getArg(e,"skipValidation",!1),this._sources=new F,this._names=new F,this._mappings=new N,this._sourcesContents=null}static fromSourceMap(e){const t=e.sourceRoot,n=new U({file:e.file,sourceRoot:t});return e.eachMapping((function(e){const r={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(r.source=e.source,null!=t&&(r.source=x.relative(t,r.source)),r.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(r.name=e.name)),n.addMapping(r)})),e.sources.forEach((function(r){let s=r;null!=t&&(s=x.relative(t,r)),n._sources.has(s)||n._sources.add(s);const o=e.sourceContentFor(r);null!=o&&n.setSourceContent(r,o)})),n}addMapping(e){const t=x.getArg(e,"generated"),n=x.getArg(e,"original",null);let r=x.getArg(e,"source",null),s=x.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,n,r,s),null!=r&&(r=String(r),this._sources.has(r)||this._sources.add(r)),null!=s&&(s=String(s),this._names.has(s)||this._names.add(s)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:n&&n.line,originalColumn:n&&n.column,source:r,name:s})}setSourceContent(e,t){let n=e;null!=this._sourceRoot&&(n=x.relative(this._sourceRoot,n)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[x.toSetString(n)]=t):this._sourcesContents&&(delete this._sourcesContents[x.toSetString(n)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))}applySourceMap(e,t,n){let r=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');r=e.file}const s=this._sourceRoot;null!=s&&(r=x.relative(s,r));const o=this._mappings.toArray().length>0?new F:this._sources,i=new F;this._mappings.unsortedForEach((function(t){if(t.source===r&&null!=t.originalLine){const r=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=r.source&&(t.source=r.source,null!=n&&(t.source=x.join(n,t.source)),null!=s&&(t.source=x.relative(s,t.source)),t.originalLine=r.line,t.originalColumn=r.column,null!=r.name&&(t.name=r.name))}const a=t.source;null==a||o.has(a)||o.add(a);const l=t.name;null==l||i.has(l)||i.add(l)}),this),this._sources=o,this._names=i,e.sources.forEach((function(t){const r=e.sourceContentFor(t);null!=r&&(null!=n&&(t=x.join(n,t)),null!=s&&(t=x.relative(s,t)),this.setSourceContent(t,r))}),this)}_validateMapping(e,t,n,r){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0&&!t&&!n&&!r);else if(!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&n))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:n,original:t,name:r}))}_serializeMappings(){let e,t,n,r,s=0,o=1,i=0,a=0,l=0,u=0,c="";const h=this._mappings.toArray();for(let p=0,m=h.length;p<m;p++){if(t=h[p],e="",t.generatedLine!==o)for(s=0;t.generatedLine!==o;)e+=";",o++;else if(p>0){if(!x.compareByGeneratedPositionsInflated(t,h[p-1]))continue;e+=","}e+=I.encode(t.generatedColumn-s),s=t.generatedColumn,null!=t.source&&(r=this._sources.indexOf(t.source),e+=I.encode(r-u),u=r,e+=I.encode(t.originalLine-1-a),a=t.originalLine-1,e+=I.encode(t.originalColumn-i),i=t.originalColumn,null!=t.name&&(n=this._names.indexOf(t.name),e+=I.encode(n-l),l=n)),c+=e}return c}_generateSourcesContent(e,t){return e.map((function(e){if(!this._sourcesContents)return null;null!=t&&(e=x.relative(t,e));const n=x.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,n)?this._sourcesContents[n]:null}),this)}toJSON(){const e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e}toString(){return JSON.stringify(this.toJSON())}}U.prototype._version=3;var D={},$={};!function(e){function t(n,r,s,o,i,a){const l=Math.floor((r-n)/2)+n,u=i(s,o[l],!0);return 0===u?l:u>0?r-l>1?t(l,r,s,o,i,a):a===e.LEAST_UPPER_BOUND?r<o.length?r:-1:l:l-n>1?t(n,l,s,o,i,a):a==e.LEAST_UPPER_BOUND?l:n<0?-1:n}e.GREATEST_LOWER_BOUND=1,e.LEAST_UPPER_BOUND=2,e.search=function(n,r,s,o){if(0===r.length)return-1;let i=t(-1,r.length,n,r,s,o||e.GREATEST_LOWER_BOUND);if(i<0)return-1;for(;i-1>=0&&0===s(r[i],r[i-1],!0);)--i;return i}}($);var G={exports:{}};let k=null;G.exports=function(){if("string"==typeof k)return fetch(k).then((e=>e.arrayBuffer()));if(k instanceof ArrayBuffer)return Promise.resolve(k);throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer")},G.exports.initialize=e=>{k=e};var B=G.exports;const j=B;function H(){this.generatedLine=0,this.generatedColumn=0,this.lastGeneratedColumn=null,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}let V=null;const W=h,z=$,X=b.ArraySet,q=B,J=function(){if(V)return V;const e=[];return V=j().then((t=>WebAssembly.instantiate(t,{env:{mapping_callback(t,n,r,s,o,i,a,l,u,c){const h=new H;h.generatedLine=t+1,h.generatedColumn=n,r&&(h.lastGeneratedColumn=s-1),o&&(h.source=i,h.originalLine=a+1,h.originalColumn=l,u&&(h.name=c)),e[e.length-1](h)},start_all_generated_locations_for(){},end_all_generated_locations_for(){},start_compute_column_spans(){},end_compute_column_spans(){},start_generated_location_for(){},end_generated_location_for(){},start_original_location_for(){},end_original_location_for(){},start_parse_mappings(){},end_parse_mappings(){},start_sort_by_generated_location(){},end_sort_by_generated_location(){},start_sort_by_original_location(){},end_sort_by_original_location(){}}}))).then((t=>({exports:t.instance.exports,withMappingCallback:(t,n)=>{e.push(t);try{n()}finally{e.pop()}}}))).then(null,(e=>{throw V=null,e})),V},Q=Symbol("smcInternal");let Y=class e{constructor(e,t){return e==Q?Promise.resolve(this):function(e,t){let n=e;"string"==typeof e&&(n=W.parseSourceMapInput(e));const r=null!=n.sections?new K(n,t):new Z(n,t);return Promise.resolve(r)}(e,t)}static initialize(e){q.initialize(e["lib/mappings.wasm"])}static fromSourceMap(e,t){return function(e,t){return Z.fromSourceMap(e,t)}(e,t)}static async with(t,n,r){const s=await new e(t,n);try{return await r(s)}finally{s.destroy()}}eachMapping(e,t,n){throw new Error("Subclasses must implement eachMapping")}allGeneratedPositionsFor(e){throw new Error("Subclasses must implement allGeneratedPositionsFor")}destroy(){throw new Error("Subclasses must implement destroy")}};Y.prototype._version=3,Y.GENERATED_ORDER=1,Y.ORIGINAL_ORDER=2,Y.GREATEST_LOWER_BOUND=1,Y.LEAST_UPPER_BOUND=2,D.SourceMapConsumer=Y;class Z extends Y{constructor(e,t){return super(Q).then((n=>{let r=e;"string"==typeof e&&(r=W.parseSourceMapInput(e));const s=W.getArg(r,"version"),o=W.getArg(r,"sources").map(String),i=W.getArg(r,"names",[]),a=W.getArg(r,"sourceRoot",null),l=W.getArg(r,"sourcesContent",null),u=W.getArg(r,"mappings"),c=W.getArg(r,"file",null),h=W.getArg(r,"x_google_ignoreList",null);if(s!=n._version)throw new Error("Unsupported version: "+s);return n._sourceLookupCache=new Map,n._names=X.fromArray(i.map(String),!0),n._sources=X.fromArray(o,!0),n._absoluteSources=X.fromArray(n._sources.toArray().map((function(e){return W.computeSourceURL(a,e,t)})),!0),n.sourceRoot=a,n.sourcesContent=l,n._mappings=u,n._sourceMapURL=t,n.file=c,n.x_google_ignoreList=h,n._computedColumnSpans=!1,n._mappingsPtr=0,n._wasm=null,J().then((e=>(n._wasm=e,n)))}))}_findSourceIndex(e){const t=this._sourceLookupCache.get(e);if("number"==typeof t)return t;const n=W.computeSourceURL(null,e,this._sourceMapURL);if(this._absoluteSources.has(n)){const t=this._absoluteSources.indexOf(n);return this._sourceLookupCache.set(e,t),t}const r=W.computeSourceURL(this.sourceRoot,e,this._sourceMapURL);if(this._absoluteSources.has(r)){const t=this._absoluteSources.indexOf(r);return this._sourceLookupCache.set(e,t),t}return-1}static fromSourceMap(e,t){return new Z(e.toString())}get sources(){return this._absoluteSources.toArray()}_getMappingsPtr(){return 0===this._mappingsPtr&&this._parseMappings(),this._mappingsPtr}_parseMappings(){const e=this._mappings,t=e.length,n=this._wasm.exports.allocate_mappings(t)>>>0,r=new Uint8Array(this._wasm.exports.memory.buffer,n,t);for(let n=0;n<t;n++)r[n]=e.charCodeAt(n);const s=this._wasm.exports.parse_mappings(n);if(!s){const e=this._wasm.exports.get_last_error();let t=`Error parsing mappings (code ${e}): `;switch(e){case 1:t+="the mappings contained a negative line, column, source index, or name index";break;case 2:t+="the mappings contained a number larger than 2**32";break;case 3:t+="reached EOF while in the middle of parsing a VLQ";break;case 4:t+="invalid base 64 character while parsing a VLQ";break;default:t+="unknown error code"}throw new Error(t)}this._mappingsPtr=s}eachMapping(e,t,n){const r=t||null,s=n||Y.GENERATED_ORDER;this._wasm.withMappingCallback((t=>{null!==t.source&&(t.source=this._absoluteSources.at(t.source),null!==t.name&&(t.name=this._names.at(t.name))),this._computedColumnSpans&&null===t.lastGeneratedColumn&&(t.lastGeneratedColumn=1/0),e.call(r,t)}),(()=>{switch(s){case Y.GENERATED_ORDER:this._wasm.exports.by_generated_location(this._getMappingsPtr());break;case Y.ORIGINAL_ORDER:this._wasm.exports.by_original_location(this._getMappingsPtr());break;default:throw new Error("Unknown order of iteration.")}}))}allGeneratedPositionsFor(e){let t=W.getArg(e,"source");const n=W.getArg(e,"line"),r=e.column||0;if(t=this._findSourceIndex(t),t<0)return[];if(n<1)throw new Error("Line numbers must be >= 1");if(r<0)throw new Error("Column numbers must be >= 0");const s=[];return this._wasm.withMappingCallback((e=>{let t=e.lastGeneratedColumn;this._computedColumnSpans&&null===t&&(t=1/0),s.push({line:e.generatedLine,column:e.generatedColumn,lastColumn:t})}),(()=>{this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(),t,n-1,"column"in e,r)})),s}destroy(){0!==this._mappingsPtr&&(this._wasm.exports.free_mappings(this._mappingsPtr),this._mappingsPtr=0)}computeColumnSpans(){this._computedColumnSpans||(this._wasm.exports.compute_column_spans(this._getMappingsPtr()),this._computedColumnSpans=!0)}originalPositionFor(e){const t={generatedLine:W.getArg(e,"line"),generatedColumn:W.getArg(e,"column")};if(t.generatedLine<1)throw new Error("Line numbers must be >= 1");if(t.generatedColumn<0)throw new Error("Column numbers must be >= 0");let n,r=W.getArg(e,"bias",Y.GREATEST_LOWER_BOUND);if(null==r&&(r=Y.GREATEST_LOWER_BOUND),this._wasm.withMappingCallback((e=>n=e),(()=>{this._wasm.exports.original_location_for(this._getMappingsPtr(),t.generatedLine-1,t.generatedColumn,r)})),n&&n.generatedLine===t.generatedLine){let e=W.getArg(n,"source",null);null!==e&&(e=this._absoluteSources.at(e));let t=W.getArg(n,"name",null);return null!==t&&(t=this._names.at(t)),{source:e,line:W.getArg(n,"originalLine",null),column:W.getArg(n,"originalColumn",null),name:t}}return{source:null,line:null,column:null,name:null}}hasContentsOfAllSources(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(e){return null==e})))}sourceContentFor(e,t){if(!this.sourcesContent)return null;const n=this._findSourceIndex(e);if(n>=0)return this.sourcesContent[n];if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')}generatedPositionFor(e){let t=W.getArg(e,"source");if(t=this._findSourceIndex(t),t<0)return{line:null,column:null,lastColumn:null};const n={source:t,originalLine:W.getArg(e,"line"),originalColumn:W.getArg(e,"column")};if(n.originalLine<1)throw new Error("Line numbers must be >= 1");if(n.originalColumn<0)throw new Error("Column numbers must be >= 0");let r,s=W.getArg(e,"bias",Y.GREATEST_LOWER_BOUND);if(null==s&&(s=Y.GREATEST_LOWER_BOUND),this._wasm.withMappingCallback((e=>r=e),(()=>{this._wasm.exports.generated_location_for(this._getMappingsPtr(),n.source,n.originalLine-1,n.originalColumn,s)})),r&&r.source===n.source){let e=r.lastGeneratedColumn;return this._computedColumnSpans&&null===e&&(e=1/0),{line:W.getArg(r,"generatedLine",null),column:W.getArg(r,"generatedColumn",null),lastColumn:e}}return{line:null,column:null,lastColumn:null}}}Z.prototype.consumer=Y,D.BasicSourceMapConsumer=Z;class K extends Y{constructor(e,t){return super(Q).then((n=>{let r=e;"string"==typeof e&&(r=W.parseSourceMapInput(e));const s=W.getArg(r,"version"),o=W.getArg(r,"sections");if(s!=n._version)throw new Error("Unsupported version: "+s);let i={line:-1,column:0};return Promise.all(o.map((e=>{if(e.url)throw new Error("Support for url field in sections not implemented.");const n=W.getArg(e,"offset"),r=W.getArg(n,"line"),s=W.getArg(n,"column");if(r<i.line||r===i.line&&s<i.column)throw new Error("Section offsets must be ordered and non-overlapping.");i=n;return new Y(W.getArg(e,"map"),t).then((e=>({generatedOffset:{generatedLine:r+1,generatedColumn:s+1},consumer:e})))}))).then((e=>(n._sections=e,n)))}))}get sources(){const e=[];for(let t=0;t<this._sections.length;t++)for(let n=0;n<this._sections[t].consumer.sources.length;n++)e.push(this._sections[t].consumer.sources[n]);return e}originalPositionFor(e){const t={generatedLine:W.getArg(e,"line"),generatedColumn:W.getArg(e,"column")},n=z.search(t,this._sections,(function(e,t){const n=e.generatedLine-t.generatedOffset.generatedLine;return n||e.generatedColumn-(t.generatedOffset.generatedColumn-1)})),r=this._sections[n];return r?r.consumer.originalPositionFor({line:t.generatedLine-(r.generatedOffset.generatedLine-1),column:t.generatedColumn-(r.generatedOffset.generatedLine===t.generatedLine?r.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}}hasContentsOfAllSources(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))}sourceContentFor(e,t){for(let t=0;t<this._sections.length;t++){const n=this._sections[t].consumer.sourceContentFor(e,!0);if(n)return n}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')}_findSectionIndex(e){for(let t=0;t<this._sections.length;t++){const{consumer:n}=this._sections[t];if(-1!==n._findSourceIndex(e))return t}return-1}generatedPositionFor(e){const t=this._findSectionIndex(W.getArg(e,"source")),n=t>=0?this._sections[t]:null,r=t>=0&&t+1<this._sections.length?this._sections[t+1]:null,s=n&&n.consumer.generatedPositionFor(e);if(s&&null!==s.line){const e=n.generatedOffset.generatedLine-1,t=n.generatedOffset.generatedColumn-1;return 1===s.line&&(s.column+=t,"number"==typeof s.lastColumn&&(s.lastColumn+=t)),s.lastColumn===1/0&&r&&s.line===r.generatedOffset.generatedLine&&(s.lastColumn=r.generatedOffset.generatedColumn-2),s.line+=e,s}return{line:null,column:null,lastColumn:null}}allGeneratedPositionsFor(e){const t=this._findSectionIndex(W.getArg(e,"source")),n=t>=0?this._sections[t]:null,r=t>=0&&t+1<this._sections.length?this._sections[t+1]:null;return n?n.consumer.allGeneratedPositionsFor(e).map((e=>{const t=n.generatedOffset.generatedLine-1,s=n.generatedOffset.generatedColumn-1;return 1===e.line&&(e.column+=s,"number"==typeof e.lastColumn&&(e.lastColumn+=s)),e.lastColumn===1/0&&r&&e.line===r.generatedOffset.generatedLine&&(e.lastColumn=r.generatedOffset.generatedColumn-2),e.line+=t,e})):[]}eachMapping(e,t,n){this._sections.forEach(((r,s)=>{const o=s+1<this._sections.length?this._sections[s+1]:null,{generatedOffset:i}=r,a=i.generatedLine-1,l=i.generatedColumn-1;r.consumer.eachMapping((function(t){1===t.generatedLine&&(t.generatedColumn+=l,"number"==typeof t.lastGeneratedColumn&&(t.lastGeneratedColumn+=l)),t.lastGeneratedColumn===1/0&&o&&t.generatedLine===o.generatedOffset.generatedLine&&(t.lastGeneratedColumn=o.generatedOffset.generatedColumn-2),t.generatedLine+=a,e.call(this,t)}),t,n)}))}computeColumnSpans(){for(let e=0;e<this._sections.length;e++)this._sections[e].consumer.computeColumnSpans()}destroy(){for(let e=0;e<this._sections.length;e++)this._sections[e].consumer.destroy()}}D.IndexedSourceMapConsumer=K;var ee=D.SourceMapConsumer;class te{constructor(e={}){this.cache=new Map,this.listeners=new Map,this.config={strict:!0,maxRecursionDepth:10,...e}}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(t)}removeEventListener(e,t){const n=this.listeners.get(e);if(n){const e=n.indexOf(t);e>-1&&n.splice(e,1)}}emitEvent(e,t){const n=this.listeners.get(e);if(n){const r={type:e,timestamp:Date.now(),data:t};n.forEach((e=>e(r)))}}async parseSourcemap(n){if(this.emitEvent(e.EventType.PARSE_START,{sourcemapPath:n}),this.cache.has(n))return this.emitEvent(e.EventType.CACHE_HIT,{sourcemapPath:n}),this.cache.get(n);if(this.emitEvent(e.EventType.CACHE_MISS,{sourcemapPath:n}),!t.existsSync(n))throw new i(e.ErrorType.FILE_NOT_FOUND,`Sourcemap file not found: ${n}`);try{const r=t.readFileSync(n,"utf-8"),s=JSON.parse(r);this.validateSourcemap(s);const o=await new ee(s);return this.cache.set(n,o),this.emitEvent(e.EventType.PARSE_COMPLETE,{sourcemapPath:n}),o}catch(t){if(t instanceof i)throw t;throw new i(e.ErrorType.PARSE_ERROR,`Failed to parse sourcemap: ${t instanceof Error?t.message:String(t)}`,{sourcemapPath:n,originalError:t})}}validateSourcemap(t){if(!t||"object"!=typeof t)throw new i(e.ErrorType.INVALID_SOURCEMAP,"Invalid sourcemap format: not an object");const n=["version","sources","mappings"];for(const r of n)if(!(r in t))throw new i(e.ErrorType.INVALID_SOURCEMAP,`Invalid sourcemap format: missing required field '${r}'`);if(3!==t.version)throw new i(e.ErrorType.INVALID_SOURCEMAP,`Unsupported sourcemap version: ${t.version}. Only version 3 is supported.`)}async locate(t){try{const n=await this.parseSourcemap(t.sourcemapPath);this.validatePosition(t.line,t.column);const r=n.originalPositionFor({line:t.line,column:t.column});if(!r.source)return{success:!1,error:`No mapping found for position (${t.line}, ${t.column})`};this.emitEvent(e.EventType.MAPPING_FOUND,{from:{line:t.line,column:t.column},to:{source:r.source,line:r.line,column:r.column}});const s=this.resolveSourcePath(r.source,t.sourcemapPath),o=this.getSourceContent(n,r.source,s);return{success:!0,result:{sourceFile:s,sourceLine:r.line||1,sourceColumn:r.column||0,sourceContent:o,isOriginal:!0}}}catch(e){return e instanceof i?{success:!1,error:e.message}:{success:!1,error:`Unexpected error: ${e instanceof Error?e.message:String(e)}`}}}validatePosition(t,n){if(!Number.isInteger(t)||t<1)throw new i(e.ErrorType.POSITION_OUT_OF_RANGE,`Invalid line number: ${t}. Line numbers must be positive integers starting from 1.`);if(!Number.isInteger(n)||n<0)throw new i(e.ErrorType.POSITION_OUT_OF_RANGE,`Invalid column number: ${n}. Column numbers must be non-negative integers starting from 0.`)}resolveSourcePath(e,t){const r=n.dirname(t);return this.config.sourceRoot?n.resolve(this.config.sourceRoot,e):n.resolve(r,e)}getSourceContent(e,n,r){const s=e.sourceContentFor(n);if(s)return s;try{if(t.existsSync(r))return t.readFileSync(r,"utf-8")}catch(e){}}clearCache(){for(const e of this.cache.values())e.destroy();this.cache.clear()}destroy(){this.clearCache(),this.listeners.clear()}}class ne{constructor(e={}){this.visitedFiles=new Set,this.listeners=new Map,this.parser=new te(e),this.maxDepth=e.maxRecursionDepth||10}async locateRecursively(t){this.visitedFiles.clear();const n=[];this.emitEvent(e.EventType.LOCATE_START,{sourcemapPath:t.sourcemapPath,line:t.line,column:t.column});try{const r=await this.locateWithDepth(t.sourcemapPath,t.line,t.column,0,n);return r?(this.emitEvent(e.EventType.LOCATE_COMPLETE,{success:!0,result:r,mappingSteps:n}),{success:!0,result:{...r,mappingSteps:n}}):(this.emitEvent(e.EventType.LOCATE_COMPLETE,{success:!1,error:`No mapping found for position (${t.line}, ${t.column})`}),{success:!1,error:`No mapping found for position (${t.line}, ${t.column})`})}catch(t){const n=t instanceof i?t.message:`Unexpected error: ${t instanceof Error?t.message:String(t)}`;return this.emitEvent(e.EventType.LOCATE_COMPLETE,{success:!1,error:n}),t instanceof i?{success:!1,error:t.message}:{success:!1,error:n}}}async locateWithDepth(r,s,o,a,l){if(a>=this.maxDepth)throw new i(e.ErrorType.MAX_DEPTH_EXCEEDED,`Maximum recursion depth (${this.maxDepth}) exceeded`);const u=n.resolve(r);if(this.visitedFiles.has(u))throw new i(e.ErrorType.CIRCULAR_REFERENCE,`Circular reference detected: ${u}`);this.visitedFiles.add(u);const c=await this.parser.locate({sourcemapPath:r,line:s,column:o});if(!c.success||!c.result)return null;const h=c.result,p={stepIndex:l.length,fromFile:u,toFile:h.sourceFile,fromLine:s,fromColumn:o,toLine:h.sourceLine,toColumn:h.sourceColumn,depth:a,sourcemapPath:u,inputPosition:{line:s,column:o},outputPosition:{line:h.sourceLine,column:h.sourceColumn},sourceFile:h.sourceFile};l.push(p),this.emitEvent(e.EventType.STEP_COMPLETE,{step:p,depth:a,totalSteps:l.length});const m=await this.findNextSourcemap(h.sourceFile);if(m&&t.existsSync(m)){const e=await this.locateWithDepth(m,h.sourceLine,h.sourceColumn,a+1,l);if(e)return{...e,isOriginal:!0}}return{...h,isOriginal:!0}}async findNextSourcemap(e){const r=await this.extractSourcemapFromFile(e);if(r){return n.resolve(n.dirname(e),r)}const s=e.split("/").pop()?.replace(/\.[^.]+$/,"")||"",o=n.dirname(e),i=[`${s}.js.map`,`${s}.map`,`${s}.ts.map`,`${s}.jsx.map`,`${s}.tsx.map`];for(const e of i){const r=n.resolve(o,e);if(t.existsSync(r))return r}return null}extractSourcemapFromFile(e){try{if(!/\.(js|jsx|ts|tsx)$/.test(e))return null;if(!t.existsSync(e))return null;const r=t.readFileSync(e,"utf-8"),s=/\/\/#\s*sourceMappingURL=(.+)$/m,o=r.match(s);if(o&&o[1]){const r=o[1].trim();if(!r.startsWith("http")){const s=n.dirname(e),o=n.resolve(s,r);if(t.existsSync(o))return o}}return null}catch(e){return null}}async batchLocateRecursively(e){const t=[],n=[];for(const r of e.locations)try{const e=await this.locateRecursively(r);t.push(e),e.success||n.push(`${r.sourcemapPath}:${r.line}:${r.column} - ${e.error}`)}catch(e){const s=e instanceof Error?e.message:String(e),o={success:!1,error:s};t.push(o),n.push(`${r.sourcemapPath}:${r.line}:${r.column} - ${s}`)}const r=t.filter((e=>e.success)).length,s=t.length;return{success:r>0,results:t,summary:{total:s,successful:r,failed:s-r,errors:n.length>0?n:void 0}}}getMappingChainSummary(e){if(0===e.length)return"No mapping steps";const t=e.map(((e,t)=>`${t+1}. ${`(${e.inputPosition.line},${e.inputPosition.column})`} → ${`(${e.outputPosition.line},${e.outputPosition.column})`} in ${e.sourceFile.split("/").pop()||e.sourceFile}`)).join("\n");return`Mapping chain (${e.length} steps):\n${t}`}emitEvent(e,t){const n=this.listeners.get(e);if(n){const r={type:e,timestamp:Date.now(),data:t};n.forEach((e=>e(r)))}}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(t),this.parser.addEventListener(e,t)}removeEventListener(e,t){const n=this.listeners.get(e);if(n){const e=n.indexOf(t);e>-1&&n.splice(e,1)}this.parser.removeEventListener(e,t)}clearCache(){this.parser.clearCache(),this.visitedFiles.clear()}destroy(){this.parser.destroy(),this.visitedFiles.clear()}}class re{constructor(e){this.locator=new ne(e),this.parser=new te(e)}async locate(e,t,n){const r={sourcemapPath:e,line:t,column:n};return this.locator.locateRecursively(r)}async locateOnce(e,t,n){const r={sourcemapPath:e,line:t,column:n};return this.parser.locate(r)}async batchLocate(e){const t={locations:e};return this.locator.batchLocateRecursively(t)}async validateSourcemap(e){try{return(await this.parser.parseSourcemap(e)).destroy(),{valid:!0}}catch(e){return{valid:!1,error:e instanceof Error?e.message:String(e)}}}async getSourcemapInfo(e){const n=await this.parser.parseSourcemap(e),r=JSON.parse(await t.promises.readFile(e,"utf-8")),s={version:3,sources:r.sources||[],names:r.names||[],sourceRoot:r.sourceRoot||void 0};return n.destroy(),s}addEventListener(e,t){this.locator.addEventListener(e,t)}removeEventListener(e,t){this.locator.removeEventListener(e,t)}clearCache(){this.locator.clearCache(),this.parser.clearCache()}destroy(){this.locator.destroy(),this.parser.destroy()}}e.RecursiveLocator=ne,e.SourcemapLocatorAPI=re,e.SourcemapLocatorError=i,e.SourcemapParser=te,e.batchLocate=async function(e,t){const n=new re(t);try{return await n.batchLocate(e)}finally{n.destroy()}},e.createLocator=function(e){return new re(e)},e.createParser=function(e){return new te(e)},e.createRecursiveLocator=function(e){return new ne(e)},e.default=re,e.getSourcemapInfo=async function(e,t){const n=new re(t);try{return await n.getSourcemapInfo(e)}finally{n.destroy()}},e.locate=async function(e,t,n,r){const s=new re(r);try{return await s.locate(e,t,n)}finally{s.destroy()}},e.validateSourcemap=async function(e,t){const n=new re(t);try{return await n.validateSourcemap(e)}finally{n.destroy()}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.min.js.map

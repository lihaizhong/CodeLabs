{"version":3,"file":"index.min.js","sources":["../src/types.ts","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/base64.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/base64-vlq.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/util.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/url.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/array-set.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/mapping-list.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/source-map-generator.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/binary-search.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/read-wasm-browser.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/wasm.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/lib/source-map-consumer.js","../../../node_modules/.pnpm/source-map@0.7.6/node_modules/source-map/source-map.js","../src/parser.ts","../src/recursive-locator.ts","../src/index.ts"],"sourcesContent":[null,"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = require(\"./base64\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst URL = require(\"./url\");\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\nexports.getArg = getArg;\n\nconst supportsNullProto = (function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n})();\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (\n    s.charCodeAt(length - 1) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 2) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n    s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n    s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n    s.charCodeAt(length - 8) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 9) !== 95 /* '_' */\n  ) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated =\n  compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n// We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n\n    cb(url);\n\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    }\n\n    // This assumes that the callback will only change\n    // the path, search and hash values.\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n  do {\n    const ident = prefix + id++;\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1;\n\n  // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n  const segment = buildUniqueSegment(\"p\", str);\n\n  let base = `${PROTOCOL_AND_HOST}/`;\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\");\n\n  // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (\n    targetParts.length > 0 &&\n    rootParts.length > 0 &&\n    targetParts[0] === rootParts[0]\n  ) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts\n    .map(() => \"..\")\n    .concat(targetParts)\n    .join(\"/\");\n\n  return relativePath + targetURL.search + targetURL.hash;\n}\n\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL.length\n    );\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL_AND_HOST.length\n    );\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\nexports.join = join;\n\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (\n    target.protocol !== root.protocol ||\n    target.user !== root.user ||\n    target.password !== root.password ||\n    target.hostname !== root.hostname ||\n    target.port !== root.port\n  ) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\");\n\n  // Parsing URLs can be expensive, so we only perform these joins when needed.\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\nexports.computeSourceURL = computeSourceURL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\"use strict\";\n\n// Note: This file is overridden in the 'package.json#browser' field to\n// substitute lib/url-browser.js instead.\n\n// Use the URL global for Node 10, and the 'url' module for Node 8.\nmodule.exports = typeof URL === \"function\" ? URL : require(\"url\").URL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n    return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n      return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return (\n    lineB > lineA ||\n    (lineB == lineA && columnB >= columnA) ||\n    util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0\n  );\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = { generatedLine: -1, generatedColumn: 0 };\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst util = require(\"./util\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst MappingList = require(\"./mapping-list\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot,\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn,\n        },\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot != null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original && original.line,\n      originalColumn: original && original.column,\n      source,\n      name,\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources =\n      this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (\n      aOriginal &&\n      typeof aOriginal.line !== \"number\" &&\n      typeof aOriginal.column !== \"number\"\n    ) {\n      throw new Error(\n        \"original.line and original.column are not numbers -- you probably meant to omit \" +\n          \"the original mapping entirely and only map the generated position. If so, pass \" +\n          \"null for the original mapping instead of an object with empty or null values.\"\n      );\n    }\n\n    if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      !aOriginal &&\n      !aSource &&\n      !aName\n    ) {\n      // Case 1.\n    } else if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aOriginal &&\n      \"line\" in aOriginal &&\n      \"column\" in aOriginal &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      aOriginal.line > 0 &&\n      aOriginal.column >= 0 &&\n      aSource\n    ) {\n      // Cases 2 and 3.\n    } else {\n      throw new Error(\n        \"Invalid mapping: \" +\n          JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName,\n          })\n      );\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (\n          !util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])\n        ) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(\n        mapping.generatedColumn - previousGeneratedColumn\n      );\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(\n          mapping.originalLine - 1 - previousOriginalLine\n        );\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(\n          mapping.originalColumn - previousOriginalColumn\n        );\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings(),\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(\n        map.sources,\n        map.sourceRoot\n      );\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias === exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(\n    -1,\n    aHaystack.length,\n    aNeedle,\n    aHaystack,\n    aCompare,\n    aBias || exports.GREATEST_LOWER_BOUND\n  );\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element to\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","\"use strict\";\n\nlet mappingsWasm = null;\n\nmodule.exports = function readWasm() {\n  if (typeof mappingsWasm === \"string\") {\n    return fetch(mappingsWasm).then(response => response.arrayBuffer());\n  }\n  if (mappingsWasm instanceof ArrayBuffer) {\n    return Promise.resolve(mappingsWasm);\n  }\n\n  throw new Error(\n    \"You must provide the string URL or ArrayBuffer contents \" +\n      \"of lib/mappings.wasm by calling \" +\n      \"SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) \" +\n      \"before using SourceMapConsumer\"\n  );\n};\n\nmodule.exports.initialize = input => {\n  mappingsWasm = input;\n};\n","const readWasm = require(\"../lib/read-wasm\");\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n\n  cachedWasm = readWasm()\n    .then(buffer => {\n      return WebAssembly.instantiate(buffer, {\n        env: {\n          mapping_callback(\n            generatedLine,\n            generatedColumn,\n\n            hasLastGeneratedColumn,\n            lastGeneratedColumn,\n\n            hasOriginal,\n            source,\n            originalLine,\n            originalColumn,\n\n            hasName,\n            name\n          ) {\n            const mapping = new Mapping();\n            // JS uses 1-based line numbers, wasm uses 0-based.\n            mapping.generatedLine = generatedLine + 1;\n            mapping.generatedColumn = generatedColumn;\n\n            if (hasLastGeneratedColumn) {\n              // JS uses inclusive last generated column, wasm uses exclusive.\n              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n            }\n\n            if (hasOriginal) {\n              mapping.source = source;\n              // JS uses 1-based line numbers, wasm uses 0-based.\n              mapping.originalLine = originalLine + 1;\n              mapping.originalColumn = originalColumn;\n\n              if (hasName) {\n                mapping.name = name;\n              }\n            }\n\n            callbackStack[callbackStack.length - 1](mapping);\n          },\n\n          start_all_generated_locations_for() {\n            console.time(\"all_generated_locations_for\");\n          },\n          end_all_generated_locations_for() {\n            console.timeEnd(\"all_generated_locations_for\");\n          },\n\n          start_compute_column_spans() {\n            console.time(\"compute_column_spans\");\n          },\n          end_compute_column_spans() {\n            console.timeEnd(\"compute_column_spans\");\n          },\n\n          start_generated_location_for() {\n            console.time(\"generated_location_for\");\n          },\n          end_generated_location_for() {\n            console.timeEnd(\"generated_location_for\");\n          },\n\n          start_original_location_for() {\n            console.time(\"original_location_for\");\n          },\n          end_original_location_for() {\n            console.timeEnd(\"original_location_for\");\n          },\n\n          start_parse_mappings() {\n            console.time(\"parse_mappings\");\n          },\n          end_parse_mappings() {\n            console.timeEnd(\"parse_mappings\");\n          },\n\n          start_sort_by_generated_location() {\n            console.time(\"sort_by_generated_location\");\n          },\n          end_sort_by_generated_location() {\n            console.timeEnd(\"sort_by_generated_location\");\n          },\n\n          start_sort_by_original_location() {\n            console.time(\"sort_by_original_location\");\n          },\n          end_sort_by_original_location() {\n            console.timeEnd(\"sort_by_original_location\");\n          },\n        },\n      });\n    })\n    .then(Wasm => {\n      return {\n        exports: Wasm.instance.exports,\n        withMappingCallback: (mappingCallback, f) => {\n          callbackStack.push(mappingCallback);\n          try {\n            f();\n          } finally {\n            callbackStack.pop();\n          }\n        },\n      };\n    })\n    .then(null, e => {\n      cachedWasm = null;\n      throw e;\n    });\n\n  return cachedWasm;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String);\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n      const x_google_ignoreList = util.getArg(\n        sourceMap,\n        \"x_google_ignoreList\",\n        null\n      );\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map();\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = ArraySet.fromArray(\n        that._sources.toArray().map(function (s) {\n          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n        }),\n        true\n      );\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that.x_google_ignoreList = x_google_ignoreList;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    }\n\n    // Treat the source as map-relative overall by default.\n    const sourceAsMapRelative = util.computeSourceURL(\n      null,\n      aSource,\n      this._sourceMapURL\n    );\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // Fall back to treating the source as sourceRoot-relative.\n    const sourceAsSourceRootRelative = util.computeSourceURL(\n      this.sourceRoot,\n      aSource,\n      this._sourceMapURL\n    );\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // To avoid this cache growing forever, we do not cache lookup misses.\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    // Interpret signed result of allocate_mappings as unsigned, otherwise\n    // addresses higher than 2GB will be negative.\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size) >>> 0;\n    const mappingsBuf = new Uint8Array(\n      this._wasm.exports.memory.buffer,\n      mappingsBufPtr,\n      size\n    );\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `wasm-mappings`.\n      switch (error) {\n        case 1:\n          msg +=\n            \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n        if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            this._wasm.exports.by_generated_location(this._getMappingsPtr());\n            break;\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            this._wasm.exports.by_original_location(this._getMappingsPtr());\n            break;\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      },\n      () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(\n      aArgs,\n      \"bias\",\n      SourceMapConsumer.GREATEST_LOWER_BOUND\n    );\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(\n      m => (mapping = m),\n      () => {\n        this._wasm.exports.original_location_for(\n          this._getMappingsPtr(),\n          needle.generatedLine - 1,\n          needle.generatedColumn,\n          bias\n        );\n      }\n    );\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name,\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null,\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return (\n      this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) {\n        return sc == null;\n      })\n    );\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null,\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(\n      aArgs,\n      \"bias\",\n      SourceMapConsumer.GREATEST_LOWER_BOUND\n    );\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(\n      m => (mapping = m),\n      () => {\n        this._wasm.exports.generated_location_for(\n          this._getMappingsPtr(),\n          needle.source,\n          needle.originalLine - 1,\n          needle.originalColumn,\n          bias\n        );\n      }\n    );\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null,\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0,\n      };\n      return Promise.all(\n        sections.map(s => {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error(\n              \"Support for url field in sections not implemented.\"\n            );\n          }\n          const offset = util.getArg(s, \"offset\");\n          const offsetLine = util.getArg(offset, \"line\");\n          const offsetColumn = util.getArg(offset, \"column\");\n\n          if (\n            offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)\n          ) {\n            throw new Error(\n              \"Section offsets must be ordered and non-overlapping.\"\n            );\n          }\n          lastOffset = offset;\n\n          const cons = new SourceMapConsumer(\n            util.getArg(s, \"map\"),\n            aSourceMapURL\n          );\n          return cons.then(consumer => {\n            return {\n              generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1,\n              },\n              consumer,\n            };\n          });\n        })\n      ).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(\n      needle,\n      this._sections,\n      function (aNeedle, section) {\n        const cmp =\n          aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        // The generated column is 0-based, but the section offset column is\n        // stored 1-based.\n        return (\n          aNeedle.generatedColumn -\n          (section.generatedOffset.generatedColumn - 1)\n        );\n      }\n    );\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null,\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n      column:\n        needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n          ? section.generatedOffset.generatedColumn - 1\n          : 0),\n      bias: aArgs.bias,\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const { consumer } = this._sections[i];\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    const generatedPosition =\n      section && section.consumer.generatedPositionFor(aArgs);\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (\n        generatedPosition.lastColumn === Infinity &&\n        nextSection &&\n        generatedPosition.line === nextSection.generatedOffset.generatedLine\n      ) {\n        generatedPosition.lastColumn =\n          nextSection.generatedOffset.generatedColumn - 2;\n      }\n      generatedPosition.line += lineShift;\n\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null,\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    if (!section) return [];\n\n    return section.consumer\n      .allGeneratedPositionsFor(aArgs)\n      .map(generatedPosition => {\n        const lineShift = section.generatedOffset.generatedLine - 1;\n        const columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (\n          generatedPosition.lastColumn === Infinity &&\n          nextSection &&\n          generatedPosition.line === nextSection.generatedOffset.generatedLine\n        ) {\n          generatedPosition.lastColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        generatedPosition.line += lineShift;\n\n        return generatedPosition;\n      });\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection =\n        index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      const { generatedOffset } = section;\n\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n\n      section.consumer.eachMapping(\n        function (mapping) {\n          if (mapping.generatedLine === 1) {\n            mapping.generatedColumn += columnShift;\n\n            if (typeof mapping.lastGeneratedColumn === \"number\") {\n              mapping.lastGeneratedColumn += columnShift;\n            }\n          }\n\n          if (\n            mapping.lastGeneratedColumn === Infinity &&\n            nextSection &&\n            mapping.generatedLine === nextSection.generatedOffset.generatedLine\n          ) {\n            mapping.lastGeneratedColumn =\n              nextSection.generatedOffset.generatedColumn - 2;\n          }\n          mapping.generatedLine += lineShift;\n\n          aCallback.call(this, mapping);\n        },\n        aContext,\n        aOrder\n      );\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer =\n    sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator =\n  require(\"./lib/source-map-generator\").SourceMapGenerator;\nexports.SourceMapConsumer =\n  require(\"./lib/source-map-consumer\").SourceMapConsumer;\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\n",null,null,null],"names":["ErrorType","EventType","exports","SourcemapLocatorError","Error","constructor","type","message","details","super","this","name","intToCharMap","split","base64","encode","number","length","TypeError","require$$0","base64Vlq","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","URL","util$3","getArg","aArgs","aName","aDefaultValue","arguments","supportsNullProto","Object","create","identity","s","isProtoString","charCodeAt","i","strcmp","aStr1","aStr2","util","toSetString","aStr","fromSetString","slice","compareByGeneratedPositionsInflated","mappingA","mappingB","cmp","generatedLine","generatedColumn","source","originalLine","originalColumn","parseSourceMapInput","str","JSON","parse","replace","PROTOCOL","PROTOCOL_AND_HOST","createSafeHandler","cb","input","getURLType","base","buildSafeBase","url","result","toString","computeRelativeURL","withBase","maxDotParts","segment","prefix","id","ident","indexOf","buildUniqueSegment","ABSOLUTE_SCHEME","test","rootURL","targetURL","targetParts","pathname","rootParts","pop","shift","map","concat","join","search","hash","ensureDirectory","trimFilename","href","normalize","aRoot","aPath","pathType","rootType","undefined","relative","urlType","root","target","err","protocol","user","password","hostname","port","relativeIfPossible","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","arraySet","ArraySet","_array","_set","Map","fromArray","aArray","aAllowDuplicates","set","len","add","size","isDuplicate","has","idx","push","get","at","aIdx","toArray","mappingList","MappingList","_sorted","_last","unsortedForEach","aCallback","aThisArg","forEach","aMapping","lineA","lineB","columnA","columnB","generatedPositionAfter","sort","base64VLQ","require$$1","require$$2","require$$3","SourceMapGenerator","_file","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","line","column","original","addMapping","sources","sourceFile","sourceRelative","content","sourceContentFor","setSourceContent","_validateMapping","String","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","newNames","originalPositionFor","srcFile","aGenerated","aOriginal","aSource","stringify","_serializeMappings","next","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","_generateSourcesContent","aSources","aSourceRoot","key","prototype","hasOwnProperty","call","toJSON","version","_version","names","sourcesContent","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","index","mappingsWasm","readWasmBrowserModule","fetch","then","response","arrayBuffer","ArrayBuffer","Promise","resolve","initialize","readWasm","Mapping","lastGeneratedColumn","cachedWasm","binarySearch","require$$4","wasm","callbackStack","buffer","WebAssembly","instantiate","env","mapping_callback","hasLastGeneratedColumn","hasOriginal","hasName","start_all_generated_locations_for","end_all_generated_locations_for","start_compute_column_spans","end_compute_column_spans","start_generated_location_for","end_generated_location_for","start_original_location_for","end_original_location_for","start_parse_mappings","end_parse_mappings","start_sort_by_generated_location","end_sort_by_generated_location","start_sort_by_original_location","end_sort_by_original_location","Wasm","instance","withMappingCallback","mappingCallback","f","e","INTERNAL","Symbol","SourceMapConsumer$1","SourceMapConsumer","aSourceMap","aSourceMapURL","sourceMap","consumer","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","_factory","opts","_factoryBSM","rawSourceMap","sourceMapUrl","destroy","aContext","aOrder","allGeneratedPositionsFor","GENERATED_ORDER","ORIGINAL_ORDER","sourceMapConsumer","that","x_google_ignoreList","_sourceLookupCache","_absoluteSources","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","_findSourceIndex","cachedIndex","sourceAsMapRelative","sourceAsSourceRootRelative","_getMappingsPtr","_parseMappings","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","Infinity","by_generated_location","by_original_location","m","lastColumn","all_generated_locations_for","free_mappings","computeColumnSpans","compute_column_spans","needle","bias","original_location_for","hasContentsOfAllSources","some","sc","nullOnMissing","generatedPositionFor","generated_location_for","lastOffset","all","offset","offsetLine","offsetColumn","generatedOffset","_sections","j","sectionIndex","section","every","_findSectionIndex","nextSection","generatedPosition","lineShift","columnShift","SourcemapParser","config","cache","listeners","strict","maxRecursionDepth","addEventListener","eventType","listener","removeEventListener","splice","emitEvent","data","event","timestamp","Date","now","parseSourcemap","sourcemapPath","PARSE_START","CACHE_HIT","CACHE_MISS","existsSync","FILE_NOT_FOUND","sourcemapContent","readFileSync","sourcemapData","validateSourcemap","PARSE_COMPLETE","PARSE_ERROR","originalError","INVALID_SOURCEMAP","requiredFields","field","locate","request","validatePosition","originalPosition","success","MAPPING_FOUND","from","to","resolveSourcePath","sourceContent","getSourceContent","sourceLine","sourceColumn","isOriginal","Number","isInteger","POSITION_OUT_OF_RANGE","sourcemapDir","dirname","embeddedContent","clearCache","values","clear","RecursiveLocator","visitedFiles","Set","parser","maxDepth","locateRecursively","mappingSteps","LOCATE_START","locateWithDepth","LOCATE_COMPLETE","errorMessage","depth","MAX_DEPTH_EXCEEDED","normalizedPath","CIRCULAR_REFERENCE","locateResult","currentResult","mappingStep","stepIndex","fromFile","toFile","fromLine","fromColumn","toLine","toColumn","inputPosition","outputPosition","STEP_COMPLETE","step","totalSteps","nextSourcemapPath","findNextSourcemap","deeperResult","extractedPath","extractSourcemapFromFile","baseName","dir","patterns","pattern","fullPath","sourcemapRegex","match","sourcemapUrl","trim","startsWith","sourceDir","batchLocateRecursively","results","errors","locationRequest","locations","errorMsg","failedResult","successCount","filter","r","totalCount","summary","total","successful","failed","getMappingChainSummary","chain","SourcemapLocatorAPI","locator","locateOnce","batchLocate","requests","batchRequest","valid","getSourcemapInfo","fs","promises","readFile","info","async","api"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12]}
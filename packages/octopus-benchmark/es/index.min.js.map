{"version":3,"file":"index.min.js","sources":["../../octopus-platform/es/index.js","../src/platform.ts","../src/index.ts"],"sourcesContent":["const noop = () => { };\n\nfunction delay(callback, interval) {\n    return new Promise((resolve) => setTimeout(() => resolve(callback()), interval));\n}\nasync function retry(fn, intervals = [], \n/*\n * @private 不建议外部传入\n */\ntimes = 0) {\n    try {\n        return fn();\n    }\n    catch (err) {\n        if (times >= intervals.length) {\n            throw err;\n        }\n        return delay(() => retry(fn, intervals, ++times), intervals[times]);\n    }\n}\n\n// 使用静态缓冲区，避免重复创建\nconst BUFFER_SIZE = 4096; // 更大的缓冲区，减少字符串拼接次数\nconst STATIC_BUFFER = new Uint16Array(BUFFER_SIZE); // 预分配ASCII缓冲区\n/**\n * 优化的 UTF-8 解码函数\n * 主要优化点：\n * 1. 使用静态缓冲区减少内存分配\n * 2. 批量处理 ASCII 字符\n * 3. 优化循环结构和条件判断\n * 4. 使用 Uint16Array 代替普通数组提高性能\n */\nfunction utf8(buffer, start, end) {\n    // 边界检查\n    if (start < 0 || end > buffer.length)\n        throw new RangeError(\"Index out of range\");\n    if (end - start < 1)\n        return \"\";\n    const resultParts = [];\n    let bufferPos = 0;\n    const appendBuffer = (parts) => {\n        resultParts.push(String.fromCharCode.apply(null, Array.from(parts)));\n    };\n    // 快速路径：检查是否全是 ASCII\n    let allAscii = true;\n    for (let i = start; i < end; i++) {\n        if (buffer[i] > 0x7F) {\n            allAscii = false;\n            break;\n        }\n    }\n    // 全 ASCII 优化路径\n    if (allAscii) {\n        for (let i = start; i < end; i += BUFFER_SIZE) {\n            const chunkEnd = Math.min(i + BUFFER_SIZE, end);\n            const len = chunkEnd - i;\n            // 直接复制到 Uint16Array\n            for (let j = 0; j < len; j++) {\n                STATIC_BUFFER[j] = buffer[i + j];\n            }\n            appendBuffer(STATIC_BUFFER.subarray(0, len));\n        }\n        return resultParts.join('');\n    }\n    // 混合内容处理\n    for (let i = start; i < end;) {\n        const byte = buffer[i++];\n        // ASCII 字符处理\n        if (byte < 0x80) {\n            STATIC_BUFFER[bufferPos++] = byte;\n            // 如果缓冲区满了，提交并清空\n            if (bufferPos === BUFFER_SIZE) {\n                appendBuffer(STATIC_BUFFER);\n                bufferPos = 0;\n            }\n            continue;\n        }\n        // 提交之前的 ASCII 字符\n        if (bufferPos > 0) {\n            appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n            bufferPos = 0;\n        }\n        // 变长编码处理 - 使用查表法代替多个条件判断\n        let codePoint;\n        // 2 字节序列: 110xxxxx 10xxxxxx\n        if ((byte & 0xE0) === 0xC0 && i < end) {\n            codePoint = ((byte & 0x1F) << 6) | (buffer[i++] & 0x3F);\n        }\n        // 3 字节序列: 1110xxxx 10xxxxxx 10xxxxxx\n        else if ((byte & 0xF0) === 0xE0 && i + 1 < end) {\n            codePoint = ((byte & 0x0F) << 12) |\n                ((buffer[i++] & 0x3F) << 6) |\n                (buffer[i++] & 0x3F);\n        }\n        // 4 字节序列: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n        else if ((byte & 0xF8) === 0xF0 && i + 2 < end) {\n            codePoint = ((byte & 0x07) << 18) |\n                ((buffer[i++] & 0x3F) << 12) |\n                ((buffer[i++] & 0x3F) << 6) |\n                (buffer[i++] & 0x3F);\n            // 处理 Unicode 代理对\n            if (codePoint > 0xFFFF) {\n                codePoint -= 0x10000;\n                STATIC_BUFFER[bufferPos++] = 0xD800 + (codePoint >> 10);\n                STATIC_BUFFER[bufferPos++] = 0xDC00 + (codePoint & 0x3FF);\n                // 检查缓冲区是否需要提交\n                if (bufferPos >= BUFFER_SIZE - 2) { // 预留空间给下一个可能的代理对\n                    appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n                    bufferPos = 0;\n                }\n                continue;\n            }\n        }\n        // 无效的 UTF-8 序列\n        else {\n            codePoint = 0xFFFD; // Unicode 替换字符\n            // 跳过可能的后续字节\n            while (i < end && (buffer[i] & 0xC0) === 0x80)\n                i++;\n        }\n        STATIC_BUFFER[bufferPos++] = codePoint;\n        // 检查缓冲区是否需要提交\n        if (bufferPos >= BUFFER_SIZE - 3) { // 预留空间给下一个可能的多字节字符\n            appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n            bufferPos = 0;\n        }\n    }\n    // 提交剩余字符\n    if (bufferPos > 0) {\n        appendBuffer(STATIC_BUFFER.subarray(0, bufferPos));\n    }\n    return resultParts.join('');\n}\n\nclass OctopusPlatform {\n    /**\n     * 插件列表\n     */\n    plugins = [];\n    /**\n     * 平台版本\n     */\n    platformVersion = \"0.0.1\";\n    /**\n     * 应用版本\n     */\n    version = \"\";\n    /**\n     * 全局变量\n     */\n    globals = {\n        env: \"unknown\",\n        br: null,\n        dpr: 1,\n        system: \"unknown\",\n    };\n    noop = noop;\n    retry = retry;\n    constructor(plugins, version) {\n        this.version = version || \"\";\n        this.plugins = plugins;\n        this.globals.env = this.autoEnv();\n    }\n    init() {\n        const { globals, plugins } = this;\n        const collection = new Map();\n        const names = [];\n        const installedPlugins = new Set();\n        globals.br = this.useBridge();\n        globals.dpr = this.usePixelRatio();\n        globals.system = this.useSystem();\n        for (const plugin of plugins) {\n            names.push(plugin.name);\n            collection.set(plugin.name, plugin);\n        }\n        this.usePlugins(collection, names, installedPlugins);\n        installedPlugins.clear();\n    }\n    autoEnv() {\n        // FIXME：由于抖音场景支持wx对象，所以需要放在wx对象之前检查\n        if (typeof window !== \"undefined\") {\n            return \"h5\";\n        }\n        if (typeof tt !== \"undefined\") {\n            return \"tt\";\n        }\n        if (typeof my !== \"undefined\") {\n            return \"alipay\";\n        }\n        if (typeof wx !== \"undefined\") {\n            return \"weapp\";\n        }\n        throw new Error(\"Unsupported app\");\n    }\n    useBridge() {\n        switch (this.globals.env) {\n            case \"h5\":\n                return globalThis;\n            case \"alipay\":\n                return my;\n            case \"tt\":\n                return tt;\n            case \"weapp\":\n                return wx;\n        }\n        return {};\n    }\n    usePixelRatio() {\n        const { env, br } = this.globals;\n        if (env === \"h5\") {\n            return devicePixelRatio;\n        }\n        if (\"getWindowInfo\" in br) {\n            return br.getWindowInfo().pixelRatio;\n        }\n        if (\"getSystemInfoSync\" in br) {\n            return br.getSystemInfoSync().pixelRatio;\n        }\n        return 1;\n    }\n    useSystem() {\n        const { env } = this.globals;\n        let system;\n        switch (env) {\n            case \"weapp\":\n                system = wx.getDeviceInfo().platform;\n                break;\n            case \"alipay\":\n                system = my.getDeviceBaseInfo().platform;\n                break;\n            case \"tt\":\n                system = tt.getDeviceInfoSync().platform;\n                break;\n            default:\n                system = \"unknown\";\n        }\n        return system.toLowerCase();\n    }\n    usePlugins(plugins, pluginNames, installedPlugins) {\n        for (const pluginName of pluginNames) {\n            if (!plugins.has(pluginName)) {\n                throw new Error(`Plugin ${pluginName} not found`);\n            }\n            if (installedPlugins.has(pluginName)) {\n                return;\n            }\n            const plugin = plugins.get(pluginName);\n            // 递归调用依赖\n            if (Array.isArray(plugin.dependencies)) {\n                for (const dependency of plugin.dependencies) {\n                    if (typeof plugins.get(dependency)?.install !== \"function\") {\n                        throw new Error(`Plugin ${pluginName} depends on plugin ${dependency}, but ${dependency} is not found`);\n                    }\n                }\n                // 递归加载依赖\n                this.usePlugins(plugins, plugin.dependencies, installedPlugins);\n            }\n            this.installPlugin(plugin);\n            installedPlugins.add(pluginName);\n        }\n    }\n    switch(env) {\n        this.globals.env = env;\n        this.init();\n    }\n}\n\n/**\n * 定义平台插件\n */\nconst definePlugin = (plugin) => plugin;\n\n/**\n * 通过选择器匹配获取canvas实例\n * @returns\n */\nvar pluginCanvas = definePlugin({\n    name: \"getCanvas\",\n    install() {\n        const { retry } = this;\n        const { env, br, dpr } = this.globals;\n        const intervals = [50, 100, 100];\n        function initCanvas(canvas, width, height) {\n            if (!canvas) {\n                throw new Error(\"canvas not found.\");\n            }\n            // const MAX_SIZE = 1365;\n            const context = canvas.getContext(\"2d\");\n            // let virtualWidth = width * dpr;\n            // let virtualHeight = height * dpr;\n            // // 微信小程序限制canvas最大尺寸为 1365 * 1365\n            // if (\n            //   env === \"weapp\" &&\n            //   (virtualWidth > MAX_SIZE || virtualHeight > MAX_SIZE)\n            // ) {\n            //   if (virtualWidth > virtualHeight) {\n            //     virtualHeight = (virtualHeight / virtualWidth) * MAX_SIZE;\n            //     virtualWidth = MAX_SIZE;\n            //   } else {\n            //     virtualWidth = (virtualWidth / virtualHeight) * MAX_SIZE;\n            //     virtualHeight = MAX_SIZE;\n            //   }\n            // }\n            // canvas!.width = virtualWidth;\n            // canvas!.height = virtualHeight;\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            return { canvas, context };\n        }\n        if (env === \"h5\") {\n            const querySelector = (selector) => document.querySelector(selector);\n            return (selector) => retry(() => {\n                // FIXME: Taro 对 canvas 做了特殊处理，canvas 元素的 id 会被加上 canvas-id 的前缀\n                const canvas = (querySelector(`canvas[canvas-id=${selector.slice(1)}]`) || querySelector(selector));\n                return initCanvas(canvas, canvas?.clientWidth, canvas?.clientHeight);\n            }, intervals);\n        }\n        return (selector, component) => retry(() => new Promise((resolve, reject) => {\n            let query = br.createSelectorQuery();\n            if (component) {\n                query = query.in(component);\n            }\n            query\n                .select(selector)\n                .fields({ node: true, size: true }, (res) => {\n                const { node, width, height } = res || {};\n                try {\n                    resolve(initCanvas(node, width, height));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            })\n                .exec();\n        }), intervals);\n    },\n});\n\n/**\n * 用于处理数据解码\n * @returns\n */\nvar pluginDecode = definePlugin({\n    name: \"decode\",\n    install() {\n        const { env, br } = this.globals;\n        const b64Wrap = (b64, type = \"image/png\") => `data:${type};base64,${b64}`;\n        const decode = {\n            toBuffer(data) {\n                const { buffer, byteOffset, byteLength } = data;\n                if (buffer instanceof ArrayBuffer) {\n                    return buffer.slice(byteOffset, byteOffset + byteLength);\n                }\n                const buff = new ArrayBuffer(byteLength);\n                const view = new Uint8Array(buff);\n                view.set(data);\n                return buff;\n            },\n            bytesToString(data) {\n                const chunkSize = 8192; // 安全的块大小\n                let result = \"\";\n                for (let i = 0; i < data.length; i += chunkSize) {\n                    const chunk = data.slice(i, i + chunkSize);\n                    // 在安全的块上使用 String.fromCharCode\n                    result += String.fromCharCode.apply(null, Array.from(chunk));\n                }\n                return result;\n            },\n        };\n        if (env === \"h5\") {\n            const textDecoder = new TextDecoder(\"utf-8\", { fatal: true });\n            return {\n                ...decode,\n                toDataURL: (data) => b64Wrap(btoa(decode.bytesToString(data))),\n                utf8: (data, start, end) => textDecoder.decode(data.subarray(start, end)),\n            };\n        }\n        return {\n            ...decode,\n            toDataURL: (data) => b64Wrap(br.arrayBufferToBase64(decode.toBuffer(data))),\n            utf8,\n        };\n    },\n});\n\n/**\n * 用于处理远程文件读取\n * @returns\n */\nvar pluginDownload = definePlugin({\n    name: \"remote\",\n    install() {\n        const { env, br } = this.globals;\n        const isRemote = (url) => /^(blob:)?http(s)?:\\/\\//.test(url);\n        if (env === \"h5\") {\n            return {\n                is: isRemote,\n                fetch: (url) => fetch(url).then((response) => {\n                    if (response.ok) {\n                        return response.arrayBuffer();\n                    }\n                    throw new Error(`HTTP error, status=${response.status}, statusText=${response.statusText}`);\n                }),\n            };\n        }\n        function download(url, enableCache) {\n            return new Promise((resolve, reject) => {\n                br.request({\n                    url,\n                    // @ts-ignore 支付宝小程序必须有该字段\n                    dataType: \"arraybuffer\",\n                    responseType: \"arraybuffer\",\n                    enableCache,\n                    success: (res) => resolve(res.data),\n                    fail: reject,\n                });\n            }).catch((err) => {\n                const errorMessage = err.errMsg || err.errorMessage || err.message;\n                // FIXME: 可能存在写入网络缓存空间失败的情况，此时重新下载\n                if (errorMessage.includes(\"ERR_CACHE_WRITE_FAILURE\") ||\n                    errorMessage.includes(\"ERR_CACHE_WRITE_FAILED\")) {\n                    return download(url, false);\n                }\n                throw err;\n            });\n        }\n        return {\n            is: isRemote,\n            fetch: (url) => download(url, true),\n        };\n    },\n});\n\n/**\n * 用于处理本地文件存储\n * @returns\n */\nvar pluginFsm = definePlugin({\n    name: \"local\",\n    install() {\n        const { env, br } = this.globals;\n        if (env === \"h5\") {\n            return null;\n        }\n        const fsm = br.getFileSystemManager();\n        return {\n            write: (data, filePath) => {\n                return new Promise((resolve, reject) => {\n                    fsm.writeFile({\n                        filePath,\n                        data,\n                        success: () => resolve(filePath),\n                        fail: reject,\n                    });\n                });\n            },\n            read: (filePath) => {\n                return new Promise((resolve, reject) => {\n                    fsm.readFile({\n                        filePath,\n                        success: (res) => resolve(res.data),\n                        fail: reject,\n                    });\n                });\n            },\n            remove: (filePath) => {\n                return new Promise((resolve, reject) => {\n                    fsm.unlink({\n                        filePath,\n                        success: () => resolve(filePath),\n                        fail: reject,\n                    });\n                });\n            },\n        };\n    },\n});\n\n/**\n * 图片加载插件\n * @package plugin-fsm 本地文件存储能力\n * @package plugin-path 路径处理能力\n * @package plugin-decode 解码能力\n */\nvar pluginImage = definePlugin({\n    name: \"image\",\n    dependencies: [\"local\", \"decode\"],\n    install() {\n        const { local, decode } = this;\n        const { env } = this.globals;\n        let genImageSource = (data, _filepath) => (typeof data === \"string\" ? data : decode.toDataURL(data));\n        /**\n         * 加载图片\n         * @param img\n         * @param url\n         * @returns\n         */\n        function loadImage(img, url) {\n            return new Promise((resolve, reject) => {\n                img.onload = () => resolve(img);\n                img.onerror = () => reject(new Error(`SVGA LOADING FAILURE: ${url}`));\n                img.src = url;\n            });\n        }\n        function releaseImage(img) {\n            img.onload = null;\n            img.onerror = null;\n            img.src = \"\";\n        }\n        if (env === \"h5\") {\n            return {\n                create: (_) => new Image(),\n                load: (createImage, data, filepath) => {\n                    // 由于ImageBitmap在图片渲染上有优势，故优先使用\n                    if (data instanceof Uint8Array && \"createImageBitmap\" in globalThis) {\n                        return createImageBitmap(new Blob([decode.toBuffer(data)]));\n                    }\n                    if (data instanceof ImageBitmap) {\n                        return Promise.resolve(data);\n                    }\n                    return loadImage(createImage(), genImageSource(data, filepath));\n                },\n                release: releaseImage,\n            };\n        }\n        // FIXME: 支付宝小程序IDE保存临时文件会失败;抖音最大用户文件大小为10M\n        if (env === \"weapp\") {\n            genImageSource = async (data, filepath) => {\n                if (typeof data === \"string\") {\n                    return data;\n                }\n                // FIXME: IOS设备 微信小程序 Uint8Array转base64 时间较长，使用图片缓存形式速度会更快\n                return local\n                    .write(decode.toBuffer(data), filepath)\n                    .catch((ex) => {\n                    console.warn(`image write fail: ${ex.errorMessage || ex.errMsg || ex.message}`);\n                    return decode.toDataURL(data);\n                });\n            };\n        }\n        return {\n            create: (canvas) => canvas.createImage(),\n            load: async (createImage, data, filepath) => loadImage(createImage(), await genImageSource(data, filepath)),\n            release: releaseImage,\n        };\n    },\n});\n\nvar pluginNow = definePlugin({\n    name: \"now\",\n    install() {\n        const { env, br } = this.globals;\n        // performance可以提供更高精度的时间测量，且不受系统时间的调整（如更改系统时间或同步时间）的影响\n        const perf = env === \"h5\" || env === \"tt\" ? performance : br.getPerformance();\n        if (typeof perf?.now === \"function\") {\n            // 支付宝小程序的performance.now()获取的是当前时间戳，单位是微秒。\n            if (perf.now() - Date.now() > 1) {\n                return () => perf.now() / 1000;\n            }\n            // H5环境下，performance.now()获取的不是当前时间戳，而是从页面加载开始的时间戳，单位是毫秒。\n            return () => perf.now();\n        }\n        return () => Date.now();\n    },\n});\n\n/**\n * 用于创建离屏canvas\n * @returns\n */\nvar pluginOfsCanvas = definePlugin({\n    name: \"getOfsCanvas\",\n    install() {\n        const { env } = this.globals;\n        let createOffscreenCanvas;\n        if (env === \"h5\") {\n            createOffscreenCanvas = (options) => new OffscreenCanvas(options.width, options.height);\n        }\n        else if (env === \"alipay\") {\n            createOffscreenCanvas = (options) => my.createOffscreenCanvas(options);\n        }\n        else if (env === \"tt\") {\n            createOffscreenCanvas = (options) => {\n                const canvas = tt.createOffscreenCanvas();\n                canvas.width = options.width;\n                canvas.height = options.height;\n                return canvas;\n            };\n        }\n        else {\n            createOffscreenCanvas = (options) => wx.createOffscreenCanvas(options);\n        }\n        return (options) => {\n            const type = options.type || \"2d\";\n            const canvas = createOffscreenCanvas({ ...options, type });\n            const context = canvas.getContext(type);\n            return {\n                canvas,\n                context,\n            };\n        };\n    },\n});\n\n/**\n * 用于处理文件路径\n * @returns\n */\nvar pluginPath = definePlugin({\n    name: \"path\",\n    install() {\n        const { env, br } = this.globals;\n        const filename = (path) => path.substring(path.lastIndexOf(\"/\") + 1);\n        if (env === \"h5\") {\n            return {\n                USER_DATA_PATH: \"\",\n                is: (_) => false,\n                filename,\n                resolve: (filename, prefix) => `${prefix ? `${prefix}__` : \"\"}${filename}`,\n            };\n        }\n        const { USER_DATA_PATH } = env === \"tt\" ? tt.getEnvInfoSync().common : br.env;\n        return {\n            USER_DATA_PATH,\n            is: (filepath) => filepath?.startsWith(USER_DATA_PATH),\n            filename,\n            resolve: (filename, prefix) => `${USER_DATA_PATH}/${prefix ? `${prefix}__` : \"\"}${filename}`,\n        };\n    },\n});\n\n/**\n * 用于处理requestAnimationFrame\n * @returns\n */\nvar pluginRaf = definePlugin({\n    name: \"rAF\",\n    install() {\n        const { env } = this.globals;\n        function requestAnimationFrameImpl() {\n            return (callback) => setTimeout(callback, Math.max(0, 16 - (Date.now() % 16)));\n        }\n        if (env === \"h5\") {\n            const rAF = \"requestAnimationFrame\" in globalThis\n                ? requestAnimationFrame\n                : requestAnimationFrameImpl();\n            return (_, callback) => rAF(callback);\n        }\n        return (canvas, callback) => {\n            // 检查canvas是否存在\n            try {\n                return canvas.requestAnimationFrame(callback);\n            }\n            catch (error) {\n                console.warn(error.message);\n                return requestAnimationFrameImpl()(callback);\n            }\n        };\n    },\n});\n\nexport { OctopusPlatform, definePlugin, pluginCanvas, pluginDecode, pluginDownload, pluginFsm, pluginImage, pluginNow, pluginOfsCanvas, pluginPath, pluginRaf as pluginRAF };\n","import {\n  OctopusPlatform,\n  type OctopusPlatformPlugins,\n  type OctopusPlatformPluginOptions,\n  pluginNow,\n} from \"octopus-platform\";\n\nexport type PlatformProperties = \"now\";\n\nclass EnhancedPlatform extends OctopusPlatform<PlatformProperties> {\n  now!: OctopusPlatformPlugins[\"now\"];\n\n  constructor() {\n    super([pluginNow], __VERSION__);\n\n    this.init();\n  }\n\n  installPlugin(plugin: OctopusPlatformPluginOptions<PlatformProperties>) {\n    const value = plugin.install.call(this);\n\n    Object.defineProperty(this, plugin.name, {\n      get: () => value,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n}\n\nexport const platform = new EnhancedPlatform();\n","import { platform } from \"./platform\";\n\nconst badge = [\n  \"%cBENCHMARK\",\n  \"padding: 2px 4px; background: #68B984; color: #FFFFFF; border-radius: 4px;\",\n];\n\nclass Stopwatch {\n  private readonly timeLabels: Map<string, number> = new Map();\n\n  private readonly markLabels: Map<string, number> = new Map();\n\n  start(label: string) {\n    this.timeLabels.set(label, platform.now());\n  }\n\n  stop(label: string) {\n    const nowTime = platform.now();\n    const { timeLabels } = this;\n\n    if (timeLabels.has(label)) {\n      console.log(`${label}: ${nowTime - timeLabels.get(label)!} ms`);\n      timeLabels.delete(label);\n    }\n  }\n\n  mark(label: string) {\n    const nowTime = platform.now();\n    const { markLabels } = this;\n\n    if (markLabels.has(label)) {\n      console.log(`${label}: ${nowTime - markLabels.get(label)!} ms`);\n    }\n\n    markLabels.set(label, nowTime);\n  }\n\n  reset(label: string) {\n    this.markLabels.delete(label);\n  }\n\n  clear() {\n    this.timeLabels.clear();\n    this.markLabels.clear();\n  }\n}\n\nexport interface Benchmark extends Stopwatch {\n  now: () => number;\n  time: <T extends any = any>(\n    label: string,\n    callback: () => Promise<T> | T\n  ) => Promise<T> | T;\n  line: (size: number) => void;\n  log: (...message: unknown[]) => void;\n}\n\nconst stopwatch = new Stopwatch();\nconst benchmark: Benchmark = Object.create(stopwatch);\n\nbenchmark.now = () => platform.now();\n\nbenchmark.time = async (label, callback) => {\n  stopwatch.start(label);\n  const result = await callback();\n  stopwatch.stop(label);\n\n  return result;\n};\n\nbenchmark.line = (size = 40) => {\n  console.log(\"-\".repeat(size));\n};\n\nbenchmark.log = (...message) => {\n  console.log(...badge, ...message);\n};\n\nexport default benchmark;\n"],"names":["noop","async","retry","fn","intervals","times","err","length","callback","interval","Promise","resolve","setTimeout","OctopusPlatform","plugins","platformVersion","version","globals","env","br","dpr","system","constructor","this","autoEnv","init","collection","Map","names","installedPlugins","Set","useBridge","usePixelRatio","useSystem","plugin","push","name","set","usePlugins","clear","window","tt","my","wx","Error","globalThis","devicePixelRatio","getWindowInfo","pixelRatio","getSystemInfoSync","getDeviceInfo","platform","getDeviceBaseInfo","getDeviceInfoSync","toLowerCase","pluginNames","pluginName","has","get","Array","isArray","dependencies","dependency","install","installPlugin","add","pluginNow","perf","performance","getPerformance","now","Date","super","value","call","Object","defineProperty","enumerable","configurable","badge","stopwatch","timeLabels","markLabels","start","label","stop","nowTime","console","log","delete","mark","reset","benchmark","create","time","result","line","size","repeat","message"],"mappings":"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"}
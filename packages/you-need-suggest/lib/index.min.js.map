{"version":3,"file":"index.min.js","sources":["../src/calculations/levenshtein-distance.ts","../src/index.ts"],"sourcesContent":["export interface DistanceWeightOptions {\n  // 最大的匹配词长度权重\n  continuous: number;\n  // 匹配词总个数权重\n  count: number;\n  // 首个匹配字符的位置权重\n  position: number;\n  // 最短编辑路径权重\n  distance: number;\n}\n\nexport class DistanceCalculator {\n  // 最大的匹配词长度\n  private continuous: number = 0;\n  // 匹配词总个数\n  private count: number = 0;\n  // 首个匹配字符的位置\n  private position: number = 0;\n  // 最短编辑距离\n  private distance: number = 0;\n  // 权重计算配置项\n  private options: DistanceWeightOptions = {\n    continuous: 0.3,\n    count: 0.2,\n    position: 0.1,\n    distance: 0.4,\n  };\n\n  constructor(options?: DistanceWeightOptions) {\n    Object.assign(this.options, options);\n  }\n\n  private initialize(position: number): void {\n    this.continuous = 0;\n    this.count = 0;\n    this.position = position;\n    this.distance = -1;\n  }\n\n  private setContinuous(continuous: number): void {\n    if (this.continuous < continuous) {\n      this.continuous = continuous;\n    }\n  }\n\n  private setCount(count: number): void {\n    this.count = count;\n  }\n\n  private setPosition(position: number): void {\n    this.position = position;\n  }\n\n  private setDistance(distance: number): void {\n    this.distance = distance;\n  }\n\n  private calc(sourceLength: number, targetLength: number): number {\n    const { continuous, count, position, distance, options } = this;\n\n    return (\n      (1 - distance / Math.max(sourceLength, targetLength)) * options.distance +\n      (1 - position / targetLength) * options.position +\n      (continuous / targetLength) * options.continuous +\n      (count / targetLength) * options.count\n    );\n  }\n\n  get(inputValue: string, comparedValue: string): number {\n    const sourceLength: number = inputValue.length;\n    const targetLength: number = comparedValue.length;\n    const space: number[] = new Array(targetLength);\n\n    this.initialize(targetLength - 1);\n\n    // 过滤目标或者比较值为空字符串的情况\n    if (sourceLength === 0) {\n      this.setDistance(targetLength);\n    } else if (targetLength === 0) {\n      this.setDistance(sourceLength);\n    } else {\n      // 保存所有匹配到的字符的index\n      const matchPositionList: number[] = [];\n      // 连续字符长度\n      let continuous = 0;\n      // 0 为不需要做增删改的操作，1 为需要做增删改操作\n      let modifyNum = 0;\n\n      for (let row = 0; row < sourceLength; row++) {\n        const sourceChar: string = inputValue[row];\n        let temp: number = row;\n        let matchIndex = -1;\n\n        for (let col = 0; col < targetLength; col++) {\n          const targetChar: string = comparedValue[col];\n          // 前一个编辑距离\n          const prevDistance: number = col === 0 ? row + 1 : space[col - 1];\n          // 上一个编辑距离\n          const topDistance: number =\n            space[col] === undefined ? col + 1 : space[col];\n\n          if (sourceChar === targetChar) {\n            modifyNum = 0;\n\n            // 解决重复匹配的问题\n            if (matchIndex === -1 && !matchPositionList.includes(col)) {\n              matchIndex = col;\n            }\n\n            // 设置首位匹配到的字符\n            if (this.position === targetLength) {\n              this.setPosition(col);\n            }\n          } else {\n            modifyNum = 1;\n          }\n\n          // 获取增，删，改和不变得到的最小值\n          const min: number = Math.min(\n            prevDistance + 1,\n            topDistance + 1,\n            temp + modifyNum\n          );\n\n          // 保存左上角的数据，计算最小值时需要用到\n          temp = topDistance;\n          space[col] = min;\n        }\n\n        // 如果匹配到了结果\n        if (matchIndex !== -1) {\n          if (\n            row > 0 &&\n            matchIndex > 0 &&\n            inputValue[row - 1] === comparedValue[matchIndex - 1]\n          ) {\n            if (continuous === 0) {\n              continuous = 2;\n            } else {\n              continuous++;\n            }\n          } else if (continuous === 0) {\n            continuous++;\n          } else {\n            // 设置最长的连续字符\n            this.setContinuous(continuous);\n            continuous = 1;\n          }\n\n          matchPositionList.push(matchIndex);\n        } else {\n          // 设置最长的连续字符\n          this.setContinuous(continuous);\n          continuous = 0;\n        }\n      }\n\n      // 设置最长的连续字符\n      this.setContinuous(continuous);\n      // 设置匹配到的数量\n      this.setCount(matchPositionList.length);\n      // 设置编辑距离\n      this.setDistance(space[targetLength - 1]);\n    }\n\n    return this.calc(inputValue.length, comparedValue.length);\n  }\n}\n\nexport const adaptor =\n  (options?: DistanceWeightOptions) =>\n  (inputValue: string, comparedValue: string) =>\n    new DistanceCalculator(options).get(inputValue, comparedValue);\n","import { adaptor } from \"./calculations/levenshtein-distance\";\n\nexport interface YouNeedSuggestionOptions {\n  keyNameList: string | string[];\n  filterEmptyValue: boolean;\n  caseSensitive: boolean;\n  minSimilarity: number;\n  calc: (sourceStr: string, targetStr: string) => number;\n}\n\nexport interface YouNeedSuggestResult<T> {\n  data: T;\n  similarity: number;\n}\n\nexport class YouNeedSuggestion<T> {\n  private keyNameList: string[];\n  private dataSource: T[];\n  private options: YouNeedSuggestionOptions = {\n    // 进行匹配的字段\n    keyNameList: [\"text\"],\n    // 是否过滤空值\n    filterEmptyValue: true,\n    // 是否区分大小写\n    caseSensitive: false,\n    // 最小相似度\n    minSimilarity: 0,\n    // 计算器\n    calc: adaptor(),\n  };\n\n  constructor(dataSource: T[], options: Partial<YouNeedSuggestionOptions>) {\n    Object.assign(this.options, options);\n    this.dataSource = dataSource;\n    this.keyNameList = this.parseKeyNameList(this.options.keyNameList);\n  }\n\n  private parseValue(value: any): string {\n    const { caseSensitive } = this.options;\n\n    if (typeof value !== \"string\") {\n      return \"\";\n    }\n\n    // 不区分大小写时，需要将字符串转换为小写\n    return caseSensitive ? value : value.toLowerCase();\n  }\n\n  private parseKeyNameList(keyNameList?: string | string[]): string[] {\n    if (typeof keyNameList === \"string\") {\n      return keyNameList.split(\",\");\n    }\n\n    if (Array.isArray(keyNameList)) {\n      return keyNameList;\n    }\n\n    return [\"value\"];\n  }\n\n  private getMaxSimilarity(value: string, match: T): number {\n    if (\n      typeof value === \"string\" &&\n      value === \"\" &&\n      this.options.filterEmptyValue\n    ) {\n      return 100;\n    }\n\n    if (typeof match === \"string\") {\n      return this.options.calc(this.parseValue(match), value);\n    }\n\n    return this.keyNameList.reduce((lastSimilarity, key) => {\n      const sourceStr: string = this.parseValue((match as any)[key]);\n      const currentSimilarity: number = this.options.calc(sourceStr, value);\n\n      return Math.max(lastSimilarity, currentSimilarity);\n    }, Number.NEGATIVE_INFINITY);\n  }\n\n  get(val: string): YouNeedSuggestResult<T>[] {\n    const result: YouNeedSuggestResult<T>[] = [];\n    const value = this.parseValue(val);\n\n    for (let i = 0; i < this.dataSource.length; i++) {\n      const match: T = this.dataSource[i];\n      const similarity: number = this.getMaxSimilarity(value, match);\n      if (similarity >= this.options.minSimilarity) {\n        result.push({ data: match, similarity });\n      }\n    }\n\n    return result.sort(\n      (a: YouNeedSuggestResult<T>, b: YouNeedSuggestResult<T>) =>\n        b.similarity - a.similarity\n    );\n  }\n}\n\nexport { adaptor as calcOfLevenshteinDistanceAdaptor };\n"],"names":["DistanceCalculator","options","this","continuous","count","position","distance","Object","assign","prototype","initialize","setContinuous","setCount","setPosition","setDistance","calc","sourceLength","targetLength","_a","Math","max","get","inputValue","comparedValue","length","space","Array","matchPositionList","modifyNum","row","sourceChar","temp","matchIndex","col","targetChar","prevDistance","topDistance","undefined","includes","min","push","adaptor","YouNeedSuggestion","dataSource","keyNameList","filterEmptyValue","caseSensitive","minSimilarity","parseKeyNameList","parseValue","value","toLowerCase","split","isArray","getMaxSimilarity","match","_this","reduce","lastSimilarity","key","sourceStr","currentSimilarity","Number","NEGATIVE_INFINITY","val","result","i","similarity","data","sort","a","b","exports","calcOfLevenshteinDistanceAdaptor","defineProperty"],"mappings":"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"}
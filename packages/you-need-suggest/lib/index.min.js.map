{"version":3,"file":"index.min.js","sources":["../src/compare/levenshtein-distance.ts","../src/index.ts"],"sourcesContent":["export interface DistanceWeightOptions {\n\t// 最大的匹配词长度权重\n\tcontinuous: number;\n\t// 匹配词总个数权重\n\tcount: number;\n\t// 首个匹配字符的位置权重\n\tposition: number;\n\t// 最短编辑路径权重\n\tdistance: number;\n}\n\nexport class DistanceCalculator {\n\t// 最大的匹配词长度\n\tprivate continuous: number = 0;\n\t// 匹配词总个数\n\tprivate count: number = 0;\n\t// 首个匹配字符的位置\n\tprivate position: number = 0;\n\t// 最短编辑距离\n\tprivate distance: number = 0;\n\t// 权重计算配置项\n\tprivate options: DistanceWeightOptions = {\n\t\tcontinuous: 0.3,\n\t\tcount: 0.2,\n\t\tposition: 0.1,\n\t\tdistance: 0.4,\n\t};\n\n\tconstructor(options?: DistanceWeightOptions) {\n\t\tObject.assign(this.options, options);\n\t}\n\n\tprivate initialize(position: number): void {\n\t\tthis.continuous = 0;\n\t\tthis.count = 0;\n\t\tthis.position = position;\n\t\tthis.distance = -1;\n\t}\n\n\tprivate setContinuous(continuous: number): void {\n\t\tif (this.continuous < continuous) {\n\t\t\tthis.continuous = continuous;\n\t\t}\n\t}\n\n\tprivate setCount(count: number): void {\n\t\tthis.count = count;\n\t}\n\n\tprivate setPosition(position: number): void {\n\t\tthis.position = position;\n\t}\n\n\tprivate setDistance(distance: number): void {\n\t\tthis.distance = distance;\n\t}\n\n\tprivate calc(sourceLength: number, targetLength: number): number {\n\t\tconst { continuous, count, position, distance, options } = this;\n\n\t\treturn (\n\t\t\t(1 - distance / Math.max(sourceLength, targetLength)) * options.distance +\n\t\t\t(1 - position / targetLength) * options.position +\n\t\t\t(continuous / targetLength) * options.continuous +\n\t\t\t(count / targetLength) * options.count\n\t\t);\n\t}\n\n\tget(inputValue: string, comparedValue: string): number {\n\t\tconst sourceLength: number = inputValue.length;\n\t\tconst targetLength: number = comparedValue.length;\n\t\tconst space: number[] = new Array(targetLength);\n\n\t\tthis.initialize(targetLength - 1);\n\n\t\t// 过滤目标或者比较值为空字符串的情况\n\t\tif (sourceLength === 0) {\n\t\t\tthis.setDistance(targetLength);\n\t\t} else if (targetLength === 0) {\n\t\t\tthis.setDistance(sourceLength);\n\t\t} else {\n\t\t\t// 保存所有匹配到的字符的index\n\t\t\tconst matchPositionList: number[] = [];\n\t\t\t// 连续字符长度\n\t\t\tlet continuous = 0;\n\t\t\t// 0 为不需要做增删改的操作，1 为需要做增删改操作\n\t\t\tlet modifyNum = 0;\n\n\t\t\tfor (let row = 0; row < sourceLength; row++) {\n\t\t\t\tconst sourceChar: string = inputValue[row];\n\t\t\t\tlet temp: number = row;\n\t\t\t\tlet matchIndex = -1;\n\n\t\t\t\tfor (let col = 0; col < targetLength; col++) {\n\t\t\t\t\tconst targetChar: string = comparedValue[col];\n\t\t\t\t\t// 前一个编辑距离\n\t\t\t\t\tconst prevDistance: number = col === 0 ? row + 1 : space[col - 1];\n\t\t\t\t\t// 上一个编辑距离\n\t\t\t\t\tconst topDistance: number =\n\t\t\t\t\t\tspace[col] === undefined ? col + 1 : space[col];\n\n\t\t\t\t\tif (sourceChar === targetChar) {\n\t\t\t\t\t\tmodifyNum = 0;\n\n\t\t\t\t\t\t// 解决重复匹配的问题\n\t\t\t\t\t\tif (matchIndex === -1 && !matchPositionList.includes(col)) {\n\t\t\t\t\t\t\tmatchIndex = col;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 设置首位匹配到的字符\n\t\t\t\t\t\tif (this.position === targetLength) {\n\t\t\t\t\t\t\tthis.setPosition(col);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmodifyNum = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 获取增，删，改和不变得到的最小值\n\t\t\t\t\tconst min: number = Math.min(\n\t\t\t\t\t\tprevDistance + 1,\n\t\t\t\t\t\ttopDistance + 1,\n\t\t\t\t\t\ttemp + modifyNum,\n\t\t\t\t\t);\n\n\t\t\t\t\t// 保存左上角的数据，计算最小值时需要用到\n\t\t\t\t\ttemp = topDistance;\n\t\t\t\t\tspace[col] = min;\n\t\t\t\t}\n\n\t\t\t\t// 如果匹配到了结果\n\t\t\t\tif (matchIndex !== -1) {\n\t\t\t\t\tif (\n\t\t\t\t\t\trow > 0 &&\n\t\t\t\t\t\tmatchIndex > 0 &&\n\t\t\t\t\t\tinputValue[row - 1] === comparedValue[matchIndex - 1]\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (continuous === 0) {\n\t\t\t\t\t\t\tcontinuous = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinuous++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (continuous === 0) {\n\t\t\t\t\t\tcontinuous++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 设置最长的连续字符\n\t\t\t\t\t\tthis.setContinuous(continuous);\n\t\t\t\t\t\tcontinuous = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatchPositionList.push(matchIndex);\n\t\t\t\t} else {\n\t\t\t\t\t// 设置最长的连续字符\n\t\t\t\t\tthis.setContinuous(continuous);\n\t\t\t\t\tcontinuous = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 设置最长的连续字符\n\t\t\tthis.setContinuous(continuous);\n\t\t\t// 设置匹配到的数量\n\t\t\tthis.setCount(matchPositionList.length);\n\t\t\t// 设置编辑距离\n\t\t\tthis.setDistance(space[targetLength - 1]);\n\t\t}\n\n\t\treturn this.calc(inputValue.length, comparedValue.length);\n\t}\n}\n\nexport const compareAdaptor =\n\t(options?: DistanceWeightOptions) =>\n\t(inputValue: string, comparedValue: string) =>\n\t\tnew DistanceCalculator(options).get(inputValue, comparedValue);\n","import { compareAdaptor } from \"./compare/levenshtein-distance\";\n\nexport interface YouNeedSuggestionOptions {\n\tkeyNameList: string | string[];\n\tfilterEmptyValue: boolean;\n\tcaseSensitive: boolean;\n\tminSimilarity: number;\n\tcompare: (sourceStr: string, targetStr: string) => number;\n}\n\nexport interface YouNeedSuggestResult<T> {\n\tdata: T;\n\tsimilarity: number;\n}\n\nexport class YouNeedSuggestion<T> {\n\tprivate keyNameList: string[];\n\tprivate dataSource: T[];\n\tprivate options: YouNeedSuggestionOptions = {\n\t\t// 进行匹配的字段\n\t\tkeyNameList: [\"text\"],\n\t\t// 是否过滤空值\n\t\tfilterEmptyValue: true,\n\t\t// 是否区分大小写\n\t\tcaseSensitive: false,\n\t\t// 最小相似度\n\t\tminSimilarity: 0,\n\t\t// 计算算法\n\t\tcompare: compareAdaptor(),\n\t};\n\n\tconstructor(dataSource: T[], options: Partial<YouNeedSuggestionOptions>) {\n\t\tObject.assign(this.options, options);\n\t\tthis.dataSource = dataSource;\n\t\tthis.keyNameList = this.parseKeyNameList(this.options.keyNameList);\n\t}\n\n\tprivate parseValue(value: any): string {\n\t\tconst { caseSensitive } = this.options;\n\n\t\tif (typeof value !== \"string\") {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// 不区分大小写时，需要将字符串转换为小写\n\t\treturn caseSensitive ? value : value.toLowerCase();\n\t}\n\n\tprivate parseKeyNameList(keyNameList?: string | string[]): string[] {\n\t\tif (typeof keyNameList === \"string\") {\n\t\t\treturn keyNameList.split(\",\");\n\t\t}\n\n\t\tif (Array.isArray(keyNameList)) {\n\t\t\treturn keyNameList;\n\t\t}\n\n\t\treturn [\"value\"];\n\t}\n\n\tprivate getMaxSimilarity(value: string, match: T): number {\n\t\tif (\n\t\t\ttypeof value === \"string\" &&\n\t\t\tvalue === \"\" &&\n\t\t\tthis.options.filterEmptyValue\n\t\t) {\n\t\t\treturn 100;\n\t\t}\n\n\t\tif (typeof match === \"string\") {\n\t\t\treturn this.options.compare(this.parseValue(match), value);\n\t\t}\n\n\t\treturn this.keyNameList.reduce((lastSimilarity, key) => {\n\t\t\tconst sourceStr: string = this.parseValue((match as any)[key]);\n\t\t\tconst currentSimilarity: number = this.options.compare(sourceStr, value);\n\n\t\t\treturn Math.max(lastSimilarity, currentSimilarity);\n\t\t}, Number.NEGATIVE_INFINITY);\n\t}\n\n\tget(val: string): YouNeedSuggestResult<T>[] {\n\t\tconst result: YouNeedSuggestResult<T>[] = [];\n\t\tconst value = this.parseValue(val);\n\n\t\tfor (let i = 0; i < this.dataSource.length; i++) {\n\t\t\tconst match: T = this.dataSource[i];\n\t\t\tconst similarity: number = this.getMaxSimilarity(value, match);\n\t\t\tif (similarity >= this.options.minSimilarity) {\n\t\t\t\tresult.push({ data: match, similarity });\n\t\t\t}\n\t\t}\n\n\t\treturn result.sort(\n\t\t\t(a: YouNeedSuggestResult<T>, b: YouNeedSuggestResult<T>) =>\n\t\t\t\tb.similarity - a.similarity,\n\t\t);\n\t}\n}\n"],"names":["DistanceCalculator","options","this","continuous","count","position","distance","Object","assign","prototype","initialize","setContinuous","setCount","setPosition","setDistance","calc","sourceLength","targetLength","_a","Math","max","get","inputValue","comparedValue","length","space","Array","matchPositionList","modifyNum","row","sourceChar","temp","matchIndex","col","targetChar","prevDistance","topDistance","undefined","includes","min","push","compareAdaptor","YouNeedSuggestion","dataSource","keyNameList","filterEmptyValue","caseSensitive","minSimilarity","compare","parseKeyNameList","parseValue","value","toLowerCase","split","isArray","getMaxSimilarity","match","_this","reduce","lastSimilarity","key","sourceStr","currentSimilarity","Number","NEGATIVE_INFINITY","val","result","i","similarity","data","sort","a","b","exports","defineProperty"],"mappings":"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"}
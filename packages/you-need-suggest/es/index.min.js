class t{continuous=0;count=0;position=0;distance=0;options={continuous:.3,count:.2,position:.1,distance:.4};constructor(t){Object.assign(this.options,t)}initialize(t){this.continuous=0,this.count=0,this.position=t,this.distance=-1}setContinuous(t){this.continuous<t&&(this.continuous=t)}setCount(t){this.count=t}setPosition(t){this.position=t}setDistance(t){this.distance=t}calc(t,i){const{continuous:s,count:e,position:o,distance:n,options:a}=this;return(1-n/Math.max(t,i))*a.distance+(1-o/i)*a.position+s/i*a.continuous+e/i*a.count}get(t,i){const s=t.length,e=i.length,o=new Array(e);if(this.initialize(e-1),0===s)this.setDistance(e);else if(0===e)this.setDistance(s);else{const n=[];let a=0,r=0;for(let c=0;c<s;c++){const s=t[c];let u=c,h=-1;for(let t=0;t<e;t++){const a=i[t],l=0===t?c+1:o[t-1],p=void 0===o[t]?t+1:o[t];s===a?(r=0,-1!==h||n.includes(t)||(h=t),this.position===e&&this.setPosition(t)):r=1;const m=Math.min(l+1,p+1,u+r);u=p,o[t]=m}-1!==h?(c>0&&h>0&&t[c-1]===i[h-1]?0===a?a=2:a++:0===a?a++:(this.setContinuous(a),a=1),n.push(h)):(this.setContinuous(a),a=0)}this.setContinuous(a),this.setCount(n.length),this.setDistance(o[e-1])}return this.calc(t.length,i.length)}}const i=i=>(s,e)=>new t(i).get(s,e);class s{keyNameList;dataSource;options={keyNameList:["text"],filterEmptyValue:!0,caseSensitive:!1,minSimilarity:0,compare:i()};constructor(t,i){Object.assign(this.options,i),this.dataSource=t,this.keyNameList=this.parseKeyNameList(this.options.keyNameList)}parseValue(t){const{caseSensitive:i}=this.options;return"string"!=typeof t?"":i?t:t.toLowerCase()}parseKeyNameList(t){return"string"==typeof t?t.split(","):Array.isArray(t)?t:["value"]}getMaxSimilarity(t,i){return"string"==typeof t&&""===t&&this.options.filterEmptyValue?100:"string"==typeof i?this.options.compare(this.parseValue(i),t):this.keyNameList.reduce(((s,e)=>{const o=this.parseValue(i[e]),n=this.options.compare(o,t);return Math.max(s,n)}),Number.NEGATIVE_INFINITY)}get(t){const i=[],s=this.parseValue(t);for(let t=0;t<this.dataSource.length;t++){const e=this.dataSource[t],o=this.getMaxSimilarity(s,e);o>=this.options.minSimilarity&&i.push({data:e,similarity:o})}return i.sort(((t,i)=>i.similarity-t.similarity))}}export{s as YouNeedSuggestion};//# sourceMappingURL=index.min.js.map

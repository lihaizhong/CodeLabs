class t{continuous=0;count=0;position=0;distance=0;options={continuous:.3,count:.2,position:.1,distance:.4};constructor(t){Object.assign(this.options,t)}initialize(t){this.continuous=0,this.count=0,this.position=t,this.distance=-1}setContinuous(t){this.continuous<t&&(this.continuous=t)}setCount(t){this.count=t}setPosition(t){this.position=t}setDistance(t){this.distance=t}calc(t,s){const{continuous:i,count:e,position:n,distance:o,options:a}=this;return(1-o/Math.max(t,s))*a.distance+(1-n/s)*a.position+i/s*a.continuous+e/s*a.count}get(t,s){const i=t.length,e=s.length,n=new Array(e);if(this.initialize(e-1),0===i)this.setDistance(e);else if(0===e)this.setDistance(i);else{const o=[];let a=0,c=0;for(let r=0;r<i;r++){const i=t[r];let u=r,h=-1;for(let t=0;t<e;t++){const a=s[t],l=0===t?r+1:n[t-1],p=void 0===n[t]?t+1:n[t];i===a?(c=0,-1!==h||o.includes(t)||(h=t),this.position===e&&this.setPosition(t)):c=1;const y=Math.min(l+1,p+1,u+c);u=p,n[t]=y}-1!==h?(r>0&&h>0&&t[r-1]===s[h-1]?0===a?a=2:a++:0===a?a++:(this.setContinuous(a),a=1),o.push(h)):(this.setContinuous(a),a=0)}this.setContinuous(a),this.setCount(o.length),this.setDistance(n[e-1])}return this.calc(t.length,s.length)}}const s=s=>(i,e)=>new t(s).get(i,e);class i{keyNameList;dataSource;options={keyNameList:["text"],filterEmptyValue:!0,caseSensitive:!1,minSimilarity:0,calc:s()};constructor(t,s){Object.assign(this.options,s),this.dataSource=t,this.keyNameList=this.parseKeyNameList(this.options.keyNameList)}parseValue(t){const{caseSensitive:s}=this.options;return"string"!=typeof t?"":s?t:t.toLowerCase()}parseKeyNameList(t){return"string"==typeof t?t.split(","):Array.isArray(t)?t:["value"]}getMaxSimilarity(t,s){return"string"==typeof t&&""===t&&this.options.filterEmptyValue?100:"string"==typeof s?this.options.calc(this.parseValue(s),t):this.keyNameList.reduce(((i,e)=>{const n=this.parseValue(s[e]),o=this.options.calc(n,t);return Math.max(i,o)}),Number.NEGATIVE_INFINITY)}get(t){const s=[],i=this.parseValue(t);for(let t=0;t<this.dataSource.length;t++){const e=this.dataSource[t],n=this.getMaxSimilarity(i,e);n>=this.options.minSimilarity&&s.push({data:e,similarity:n})}return s.sort(((t,s)=>s.similarity-t.similarity))}}export{i as YouNeedSuggestion,s as calcOfLevenshteinDistanceAdaptor};//# sourceMappingURL=index.min.js.map

class t{continuous=0;count=0;position=0;distance=0;options={continuous:.3,count:.2,position:.1,distance:.4};constructor(t){Object.assign(this.options,t)}initialize(t){this.continuous=0,this.count=0,this.position=t,this.distance=-1}setContinuous(t){this.continuous<t&&(this.continuous=t)}setCount(t){this.count=t}setPosition(t){this.position=t}setDistance(t){this.distance=t}calc(t,s){const{continuous:i,count:e,position:o,distance:n,options:a}=this;return(1-n/Math.max(t,s))*a.distance+(1-o/s)*a.position+i/s*a.continuous+e/s*a.count}get(t,s){const i=t.length,e=s.length,o=new Array(e);if(this.initialize(e-1),0===i)this.setDistance(e);else if(0===e)this.setDistance(i);else{const n=[];let a=0,r=0;for(let c=0;c<i;c++){const i=t[c];let u=c,h=-1;for(let t=0;t<e;t++){const a=s[t],p=0===t?c+1:o[t-1],l=void 0===o[t]?t+1:o[t];i===a?(r=0,-1!==h||n.includes(t)||(h=t),this.position===e&&this.setPosition(t)):r=1;const m=Math.min(p+1,l+1,u+r);u=l,o[t]=m}-1!==h?(c>0&&h>0&&t[c-1]===s[h-1]?0===a?a=2:a++:0===a?a++:(this.setContinuous(a),a=1),n.push(h)):(this.setContinuous(a),a=0)}this.setContinuous(a),this.setCount(n.length),this.setDistance(o[e-1])}return this.calc(t.length,s.length)}}const s=s=>(i,e)=>new t(s).get(i,e);class i{keyNameList;dataSource;options={keyNameList:["text"],filterEmptyValue:!0,caseSensitive:!1,minSimilarity:0,compare:s()};constructor(t,s){Object.assign(this.options,s),this.dataSource=t,this.keyNameList=this.parseKeyNameList(this.options.keyNameList)}parseValue(t){const{caseSensitive:s}=this.options;return"string"!=typeof t?"":s?t:t.toLowerCase()}parseKeyNameList(t){return"string"==typeof t?t.split(","):Array.isArray(t)?t:["value"]}getMaxSimilarity(t,s){return"string"==typeof t&&""===t&&this.options.filterEmptyValue?100:"string"==typeof s?this.options.compare(this.parseValue(s),t):this.keyNameList.reduce(((i,e)=>{const o=this.parseValue(s[e]),n=this.options.compare(o,t);return Math.max(i,n)}),Number.NEGATIVE_INFINITY)}get(t){const s=[],i=this.parseValue(t);for(let t=0;t<this.dataSource.length;t++){const e=this.dataSource[t],o=this.getMaxSimilarity(i,e);o>=this.options.minSimilarity&&s.push({data:e,similarity:o})}return s.sort(((t,s)=>s.similarity-t.similarity))}}export{i as YouNeedSuggestion,s as compareOfLevenshteinDistanceAdaptor};//# sourceMappingURL=index.min.js.map

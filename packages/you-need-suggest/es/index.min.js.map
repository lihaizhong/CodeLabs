{"version":3,"file":"index.min.js","sources":["../src/compare/levenshtein-distance.ts","../src/index.ts"],"sourcesContent":["export interface DistanceWeightOptions {\n  // 最大的匹配词长度权重\n  continuous: number;\n  // 匹配词总个数权重\n  count: number;\n  // 首个匹配字符的位置权重\n  position: number;\n  // 最短编辑路径权重\n  distance: number;\n}\n\nexport class DistanceCalculator {\n  // 最大的匹配词长度\n  private continuous: number = 0;\n  // 匹配词总个数\n  private count: number = 0;\n  // 首个匹配字符的位置\n  private position: number = 0;\n  // 最短编辑距离\n  private distance: number = 0;\n  // 权重计算配置项\n  private options: DistanceWeightOptions = {\n    continuous: 0.3,\n    count: 0.2,\n    position: 0.1,\n    distance: 0.4,\n  };\n\n  constructor(options?: DistanceWeightOptions) {\n    Object.assign(this.options, options);\n  }\n\n  private initialize(position: number): void {\n    this.continuous = 0;\n    this.count = 0;\n    this.position = position;\n    this.distance = -1;\n  }\n\n  private setContinuous(continuous: number): void {\n    if (this.continuous < continuous) {\n      this.continuous = continuous;\n    }\n  }\n\n  private setCount(count: number): void {\n    this.count = count;\n  }\n\n  private setPosition(position: number): void {\n    this.position = position;\n  }\n\n  private setDistance(distance: number): void {\n    this.distance = distance;\n  }\n\n  private calc(sourceLength: number, targetLength: number): number {\n    const { continuous, count, position, distance, options } = this;\n\n    return (\n      (1 - distance / Math.max(sourceLength, targetLength)) * options.distance +\n      (1 - position / targetLength) * options.position +\n      (continuous / targetLength) * options.continuous +\n      (count / targetLength) * options.count\n    );\n  }\n\n  get(inputValue: string, comparedValue: string): number {\n    const sourceLength: number = inputValue.length;\n    const targetLength: number = comparedValue.length;\n    const space: number[] = new Array(targetLength);\n\n    this.initialize(targetLength - 1);\n\n    // 过滤目标或者比较值为空字符串的情况\n    if (sourceLength === 0) {\n      this.setDistance(targetLength);\n    } else if (targetLength === 0) {\n      this.setDistance(sourceLength);\n    } else {\n      // 保存所有匹配到的字符的index\n      const matchPositionList: number[] = [];\n      // 连续字符长度\n      let continuous = 0;\n      // 0 为不需要做增删改的操作，1 为需要做增删改操作\n      let modifyNum = 0;\n\n      for (let row = 0; row < sourceLength; row++) {\n        const sourceChar: string = inputValue[row];\n        let temp: number = row;\n        let matchIndex = -1;\n\n        for (let col = 0; col < targetLength; col++) {\n          const targetChar: string = comparedValue[col];\n          // 前一个编辑距离\n          const prevDistance: number = col === 0 ? row + 1 : space[col - 1];\n          // 上一个编辑距离\n          const topDistance: number =\n            space[col] === undefined ? col + 1 : space[col];\n\n          if (sourceChar === targetChar) {\n            modifyNum = 0;\n\n            // 解决重复匹配的问题\n            if (matchIndex === -1 && !matchPositionList.includes(col)) {\n              matchIndex = col;\n            }\n\n            // 设置首位匹配到的字符\n            if (this.position === targetLength) {\n              this.setPosition(col);\n            }\n          } else {\n            modifyNum = 1;\n          }\n\n          // 获取增，删，改和不变得到的最小值\n          const min: number = Math.min(\n            prevDistance + 1,\n            topDistance + 1,\n            temp + modifyNum\n          );\n\n          // 保存左上角的数据，计算最小值时需要用到\n          temp = topDistance;\n          space[col] = min;\n        }\n\n        // 如果匹配到了结果\n        if (matchIndex !== -1) {\n          if (\n            row > 0 &&\n            matchIndex > 0 &&\n            inputValue[row - 1] === comparedValue[matchIndex - 1]\n          ) {\n            if (continuous === 0) {\n              continuous = 2;\n            } else {\n              continuous++;\n            }\n          } else if (continuous === 0) {\n            continuous++;\n          } else {\n            // 设置最长的连续字符\n            this.setContinuous(continuous);\n            continuous = 1;\n          }\n\n          matchPositionList.push(matchIndex);\n        } else {\n          // 设置最长的连续字符\n          this.setContinuous(continuous);\n          continuous = 0;\n        }\n      }\n\n      // 设置最长的连续字符\n      this.setContinuous(continuous);\n      // 设置匹配到的数量\n      this.setCount(matchPositionList.length);\n      // 设置编辑距离\n      this.setDistance(space[targetLength - 1]);\n    }\n\n    return this.calc(inputValue.length, comparedValue.length);\n  }\n}\n\nexport const compareAdaptor =\n  (options?: DistanceWeightOptions) =>\n  (inputValue: string, comparedValue: string) =>\n    new DistanceCalculator(options).get(inputValue, comparedValue);\n","import { compareAdaptor } from \"./compare/levenshtein-distance\";\n\nexport interface YouNeedSuggestionOptions {\n  keyNameList: string | string[];\n  filterEmptyValue: boolean;\n  caseSensitive: boolean;\n  minSimilarity: number;\n  compare: (sourceStr: string, targetStr: string) => number;\n}\n\nexport interface YouNeedSuggestResult<T> {\n  data: T;\n  similarity: number;\n}\n\nexport class YouNeedSuggestion<T> {\n  private keyNameList: string[];\n  private dataSource: T[];\n  private options: YouNeedSuggestionOptions = {\n    // 进行匹配的字段\n    keyNameList: [\"text\"],\n    // 是否过滤空值\n    filterEmptyValue: true,\n    // 是否区分大小写\n    caseSensitive: false,\n    // 最小相似度\n    minSimilarity: 0,\n    // 计算算法\n    compare: compareAdaptor(),\n  };\n\n  constructor(dataSource: T[], options: Partial<YouNeedSuggestionOptions>) {\n    Object.assign(this.options, options);\n    this.dataSource = dataSource;\n    this.keyNameList = this.parseKeyNameList(this.options.keyNameList);\n  }\n\n  private parseValue(value: any): string {\n    const { caseSensitive } = this.options;\n\n    if (typeof value !== \"string\") {\n      return \"\";\n    }\n\n    // 不区分大小写时，需要将字符串转换为小写\n    return caseSensitive ? value : value.toLowerCase();\n  }\n\n  private parseKeyNameList(keyNameList?: string | string[]): string[] {\n    if (typeof keyNameList === \"string\") {\n      return keyNameList.split(\",\");\n    }\n\n    if (Array.isArray(keyNameList)) {\n      return keyNameList;\n    }\n\n    return [\"value\"];\n  }\n\n  private getMaxSimilarity(value: string, match: T): number {\n    if (\n      typeof value === \"string\" &&\n      value === \"\" &&\n      this.options.filterEmptyValue\n    ) {\n      return 100;\n    }\n\n    if (typeof match === \"string\") {\n      return this.options.compare(this.parseValue(match), value);\n    }\n\n    return this.keyNameList.reduce((lastSimilarity, key) => {\n      const sourceStr: string = this.parseValue((match as any)[key]);\n      const currentSimilarity: number = this.options.compare(sourceStr, value);\n\n      return Math.max(lastSimilarity, currentSimilarity);\n    }, Number.NEGATIVE_INFINITY);\n  }\n\n  get(val: string): YouNeedSuggestResult<T>[] {\n    const result: YouNeedSuggestResult<T>[] = [];\n    const value = this.parseValue(val);\n\n    for (let i = 0; i < this.dataSource.length; i++) {\n      const match: T = this.dataSource[i];\n      const similarity: number = this.getMaxSimilarity(value, match);\n      if (similarity >= this.options.minSimilarity) {\n        result.push({ data: match, similarity });\n      }\n    }\n\n    return result.sort(\n      (a: YouNeedSuggestResult<T>, b: YouNeedSuggestResult<T>) =>\n        b.similarity - a.similarity\n    );\n  }\n}\n\nexport { compareAdaptor as compareOfLevenshteinDistanceAdaptor };\n"],"names":["DistanceCalculator","continuous","count","position","distance","options","constructor","Object","assign","this","initialize","setContinuous","setCount","setPosition","setDistance","calc","sourceLength","targetLength","Math","max","get","inputValue","comparedValue","length","space","Array","matchPositionList","modifyNum","row","sourceChar","temp","matchIndex","col","targetChar","prevDistance","topDistance","undefined","includes","min","push","compareAdaptor","YouNeedSuggestion","keyNameList","dataSource","filterEmptyValue","caseSensitive","minSimilarity","compare","parseKeyNameList","parseValue","value","toLowerCase","split","isArray","getMaxSimilarity","match","reduce","lastSimilarity","key","sourceStr","currentSimilarity","Number","NEGATIVE_INFINITY","val","result","i","similarity","data","sort","a","b"],"mappings":"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"}
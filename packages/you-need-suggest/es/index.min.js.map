{"version":3,"file":"index.min.js","sources":["../src/compare/levenshtein-distance.ts","../src/index.ts"],"sourcesContent":["export interface DistanceWeightOptions {\n\t// 最大的匹配词长度权重\n\tcontinuous: number;\n\t// 匹配词总个数权重\n\tcount: number;\n\t// 首个匹配字符的位置权重\n\tposition: number;\n\t// 最短编辑路径权重\n\tdistance: number;\n}\n\nexport class DistanceCalculator {\n\t// 最大的匹配词长度\n\tprivate continuous: number = 0;\n\t// 匹配词总个数\n\tprivate count: number = 0;\n\t// 首个匹配字符的位置\n\tprivate position: number = 0;\n\t// 最短编辑距离\n\tprivate distance: number = 0;\n\t// 权重计算配置项\n\tprivate options: DistanceWeightOptions = {\n\t\tcontinuous: 0.3,\n\t\tcount: 0.2,\n\t\tposition: 0.1,\n\t\tdistance: 0.4,\n\t};\n\n\tconstructor(options?: DistanceWeightOptions) {\n\t\tObject.assign(this.options, options);\n\t}\n\n\tprivate initialize(position: number): void {\n\t\tthis.continuous = 0;\n\t\tthis.count = 0;\n\t\tthis.position = position;\n\t\tthis.distance = -1;\n\t}\n\n\tprivate setContinuous(continuous: number): void {\n\t\tif (this.continuous < continuous) {\n\t\t\tthis.continuous = continuous;\n\t\t}\n\t}\n\n\tprivate setCount(count: number): void {\n\t\tthis.count = count;\n\t}\n\n\tprivate setPosition(position: number): void {\n\t\tthis.position = position;\n\t}\n\n\tprivate setDistance(distance: number): void {\n\t\tthis.distance = distance;\n\t}\n\n\tprivate calc(sourceLength: number, targetLength: number): number {\n\t\tconst { continuous, count, position, distance, options } = this;\n\n\t\treturn (\n\t\t\t(1 - distance / Math.max(sourceLength, targetLength)) * options.distance +\n\t\t\t(1 - position / targetLength) * options.position +\n\t\t\t(continuous / targetLength) * options.continuous +\n\t\t\t(count / targetLength) * options.count\n\t\t);\n\t}\n\n\tget(inputValue: string, comparedValue: string): number {\n\t\tconst sourceLength: number = inputValue.length;\n\t\tconst targetLength: number = comparedValue.length;\n\t\tconst space: number[] = new Array(targetLength);\n\n\t\tthis.initialize(targetLength - 1);\n\n\t\t// 过滤目标或者比较值为空字符串的情况\n\t\tif (sourceLength === 0) {\n\t\t\tthis.setDistance(targetLength);\n\t\t} else if (targetLength === 0) {\n\t\t\tthis.setDistance(sourceLength);\n\t\t} else {\n\t\t\t// 保存所有匹配到的字符的index\n\t\t\tconst matchPositionList: number[] = [];\n\t\t\t// 连续字符长度\n\t\t\tlet continuous = 0;\n\t\t\t// 0 为不需要做增删改的操作，1 为需要做增删改操作\n\t\t\tlet modifyNum = 0;\n\n\t\t\tfor (let row = 0; row < sourceLength; row++) {\n\t\t\t\tconst sourceChar: string = inputValue[row];\n\t\t\t\tlet temp: number = row;\n\t\t\t\tlet matchIndex = -1;\n\n\t\t\t\tfor (let col = 0; col < targetLength; col++) {\n\t\t\t\t\tconst targetChar: string = comparedValue[col];\n\t\t\t\t\t// 前一个编辑距离\n\t\t\t\t\tconst prevDistance: number = col === 0 ? row + 1 : space[col - 1];\n\t\t\t\t\t// 上一个编辑距离\n\t\t\t\t\tconst topDistance: number =\n\t\t\t\t\t\tspace[col] === undefined ? col + 1 : space[col];\n\n\t\t\t\t\tif (sourceChar === targetChar) {\n\t\t\t\t\t\tmodifyNum = 0;\n\n\t\t\t\t\t\t// 解决重复匹配的问题\n\t\t\t\t\t\tif (matchIndex === -1 && !matchPositionList.includes(col)) {\n\t\t\t\t\t\t\tmatchIndex = col;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 设置首位匹配到的字符\n\t\t\t\t\t\tif (this.position === targetLength) {\n\t\t\t\t\t\t\tthis.setPosition(col);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmodifyNum = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 获取增，删，改和不变得到的最小值\n\t\t\t\t\tconst min: number = Math.min(\n\t\t\t\t\t\tprevDistance + 1,\n\t\t\t\t\t\ttopDistance + 1,\n\t\t\t\t\t\ttemp + modifyNum,\n\t\t\t\t\t);\n\n\t\t\t\t\t// 保存左上角的数据，计算最小值时需要用到\n\t\t\t\t\ttemp = topDistance;\n\t\t\t\t\tspace[col] = min;\n\t\t\t\t}\n\n\t\t\t\t// 如果匹配到了结果\n\t\t\t\tif (matchIndex !== -1) {\n\t\t\t\t\tif (\n\t\t\t\t\t\trow > 0 &&\n\t\t\t\t\t\tmatchIndex > 0 &&\n\t\t\t\t\t\tinputValue[row - 1] === comparedValue[matchIndex - 1]\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (continuous === 0) {\n\t\t\t\t\t\t\tcontinuous = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinuous++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (continuous === 0) {\n\t\t\t\t\t\tcontinuous++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 设置最长的连续字符\n\t\t\t\t\t\tthis.setContinuous(continuous);\n\t\t\t\t\t\tcontinuous = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatchPositionList.push(matchIndex);\n\t\t\t\t} else {\n\t\t\t\t\t// 设置最长的连续字符\n\t\t\t\t\tthis.setContinuous(continuous);\n\t\t\t\t\tcontinuous = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 设置最长的连续字符\n\t\t\tthis.setContinuous(continuous);\n\t\t\t// 设置匹配到的数量\n\t\t\tthis.setCount(matchPositionList.length);\n\t\t\t// 设置编辑距离\n\t\t\tthis.setDistance(space[targetLength - 1]);\n\t\t}\n\n\t\treturn this.calc(inputValue.length, comparedValue.length);\n\t}\n}\n\nexport const compareAdaptor =\n\t(options?: DistanceWeightOptions) =>\n\t(inputValue: string, comparedValue: string) =>\n\t\tnew DistanceCalculator(options).get(inputValue, comparedValue);\n","import { compareAdaptor } from \"./compare/levenshtein-distance\";\n\nexport interface YouNeedSuggestionOptions {\n\tkeyNameList: string | string[];\n\tfilterEmptyValue: boolean;\n\tcaseSensitive: boolean;\n\tminSimilarity: number;\n\tcompare: (sourceStr: string, targetStr: string) => number;\n}\n\nexport interface YouNeedSuggestResult<T> {\n\tdata: T;\n\tsimilarity: number;\n}\n\nexport class YouNeedSuggestion<T> {\n\tprivate keyNameList: string[];\n\tprivate dataSource: T[];\n\tprivate options: YouNeedSuggestionOptions = {\n\t\t// 进行匹配的字段\n\t\tkeyNameList: [\"text\"],\n\t\t// 是否过滤空值\n\t\tfilterEmptyValue: true,\n\t\t// 是否区分大小写\n\t\tcaseSensitive: false,\n\t\t// 最小相似度\n\t\tminSimilarity: 0,\n\t\t// 计算算法\n\t\tcompare: compareAdaptor(),\n\t};\n\n\tconstructor(dataSource: T[], options: Partial<YouNeedSuggestionOptions>) {\n\t\tObject.assign(this.options, options);\n\t\tthis.dataSource = dataSource;\n\t\tthis.keyNameList = this.parseKeyNameList(this.options.keyNameList);\n\t}\n\n\tprivate parseValue(value: any): string {\n\t\tconst { caseSensitive } = this.options;\n\n\t\tif (typeof value !== \"string\") {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// 不区分大小写时，需要将字符串转换为小写\n\t\treturn caseSensitive ? value : value.toLowerCase();\n\t}\n\n\tprivate parseKeyNameList(keyNameList?: string | string[]): string[] {\n\t\tif (typeof keyNameList === \"string\") {\n\t\t\treturn keyNameList.split(\",\");\n\t\t}\n\n\t\tif (Array.isArray(keyNameList)) {\n\t\t\treturn keyNameList;\n\t\t}\n\n\t\treturn [\"value\"];\n\t}\n\n\tprivate getMaxSimilarity(value: string, match: T): number {\n\t\tif (\n\t\t\ttypeof value === \"string\" &&\n\t\t\tvalue === \"\" &&\n\t\t\tthis.options.filterEmptyValue\n\t\t) {\n\t\t\treturn 100;\n\t\t}\n\n\t\tif (typeof match === \"string\") {\n\t\t\treturn this.options.compare(this.parseValue(match), value);\n\t\t}\n\n\t\treturn this.keyNameList.reduce((lastSimilarity, key) => {\n\t\t\tconst sourceStr: string = this.parseValue((match as any)[key]);\n\t\t\tconst currentSimilarity: number = this.options.compare(sourceStr, value);\n\n\t\t\treturn Math.max(lastSimilarity, currentSimilarity);\n\t\t}, Number.NEGATIVE_INFINITY);\n\t}\n\n\tget(val: string): YouNeedSuggestResult<T>[] {\n\t\tconst result: YouNeedSuggestResult<T>[] = [];\n\t\tconst value = this.parseValue(val);\n\n\t\tfor (let i = 0; i < this.dataSource.length; i++) {\n\t\t\tconst match: T = this.dataSource[i];\n\t\t\tconst similarity: number = this.getMaxSimilarity(value, match);\n\t\t\tif (similarity >= this.options.minSimilarity) {\n\t\t\t\tresult.push({ data: match, similarity });\n\t\t\t}\n\t\t}\n\n\t\treturn result.sort(\n\t\t\t(a: YouNeedSuggestResult<T>, b: YouNeedSuggestResult<T>) =>\n\t\t\t\tb.similarity - a.similarity,\n\t\t);\n\t}\n}\n"],"names":["DistanceCalculator","continuous","count","position","distance","options","constructor","Object","assign","this","initialize","setContinuous","setCount","setPosition","setDistance","calc","sourceLength","targetLength","Math","max","get","inputValue","comparedValue","length","space","Array","matchPositionList","modifyNum","row","sourceChar","temp","matchIndex","col","targetChar","prevDistance","topDistance","undefined","includes","min","push","compareAdaptor","YouNeedSuggestion","keyNameList","dataSource","filterEmptyValue","caseSensitive","minSimilarity","compare","parseKeyNameList","parseValue","value","toLowerCase","split","isArray","getMaxSimilarity","match","reduce","lastSimilarity","key","sourceStr","currentSimilarity","Number","NEGATIVE_INFINITY","val","result","i","similarity","data","sort","a","b"],"mappings":"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"}
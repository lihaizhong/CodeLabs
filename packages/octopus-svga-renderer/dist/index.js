class e{pool=[];acquire(){const{pool:e}=this;return e.length>0?e.pop():{x:0,y:0,x1:0,y1:0,x2:0,y2:0}}release(e){e.x=e.y=e.x1=e.y1=e.x2=e.y2=0,this.pool.push(e)}}class t{context;static SVG_PATH=new Set(["M","L","H","V","Z","C","S","Q","m","l","h","v","z","c","s","q"]);pointPool=new e;globalTransform=void 0;constructor(e){this.context=e}setTransform(e){e&&this.context.transform(e.a,e.b,e.c,e.d,e.tx,e.ty)}fillOrStroke(e){if(e){const{context:t}=this;e.fill&&t.fill(),e.stroke&&t.stroke()}}resetShapeStyles(e){if(e){const{context:t}=this;t.strokeStyle=e.stroke||"transparent",e.strokeWidth>0&&(t.lineWidth=e.strokeWidth),e.miterLimit>0&&(t.miterLimit=e.miterLimit),e.lineCap&&(t.lineCap=e.lineCap),e.lineJoin&&(t.lineJoin=e.lineJoin),t.fillStyle=e.fill||"transparent",e.lineDash&&t.setLineDash(e.lineDash)}}drawBezier(e,r,s){const{context:a,pointPool:i}=this,o=i.acquire();if(a.save(),this.resetShapeStyles(s),this.setTransform(r),a.beginPath(),e){const r=e.match(/[a-zA-Z][^a-zA-Z]*/g)||[];for(const e of r){const r=e[0];if(t.SVG_PATH.has(r)){const t=e.substring(1).trim().split(/[\s,]+/).filter(Boolean);this.drawBezierElement(o,r,t)}}}this.fillOrStroke(s),i.release(o),a.restore()}drawBezierElement(e,t,r){const{context:s}=this;switch(t){case"M":e.x=+r[0],e.y=+r[1],s.moveTo(e.x,e.y);break;case"m":e.x+=+r[0],e.y+=+r[1],s.moveTo(e.x,e.y);break;case"L":e.x=+r[0],e.y=+r[1],s.lineTo(e.x,e.y);break;case"l":e.x+=+r[0],e.y+=+r[1],s.lineTo(e.x,e.y);break;case"H":e.x=+r[0],s.lineTo(e.x,e.y);break;case"h":e.x+=+r[0],s.lineTo(e.x,e.y);break;case"V":e.y=+r[0],s.lineTo(e.x,e.y);break;case"v":e.y+=+r[0],s.lineTo(e.x,e.y);break;case"C":e.x1=+r[0],e.y1=+r[1],e.x2=+r[2],e.y2=+r[3],e.x=+r[4],e.y=+r[5],s.bezierCurveTo(e.x1,e.y1,e.x2,e.y2,e.x,e.y);break;case"c":e.x1=e.x+ +r[0],e.y1=e.y+ +r[1],e.x2=e.x+ +r[2],e.y2=e.y+ +r[3],e.x+=+r[4],e.y+=+r[5],s.bezierCurveTo(e.x1,e.y1,e.x2,e.y2,e.x,e.y);break;case"S":void 0!==e.x1&&void 0!==e.y1&&void 0!==e.x2&&void 0!==e.y2?(e.x1=e.x-e.x2+e.x,e.y1=e.y-e.y2+e.y,e.x2=+r[0],e.y2=+r[1],e.x=+r[2],e.y=+r[3],s.bezierCurveTo(e.x1,e.y1,e.x2,e.y2,e.x,e.y)):(e.x1=+r[0],e.y1=+r[1],e.x=+r[2],e.y=+r[3],s.quadraticCurveTo(e.x1,e.y1,e.x,e.y));break;case"s":void 0!==e.x1&&void 0!==e.y1&&void 0!==e.x2&&void 0!==e.y2?(e.x1=e.x-e.x2+e.x,e.y1=e.y-e.y2+e.y,e.x2=e.x+ +r[0],e.y2=e.y+ +r[1],e.x+=+r[2],e.y+=+r[3],s.bezierCurveTo(e.x1,e.y1,e.x2,e.y2,e.x,e.y)):(e.x1=e.x+ +r[0],e.y1=e.y+ +r[1],e.x+=+r[2],e.y+=+r[3],s.quadraticCurveTo(e.x1,e.y1,e.x,e.y));break;case"Q":e.x1=+r[0],e.y1=+r[1],e.x=+r[2],e.y=+r[3],s.quadraticCurveTo(e.x1,e.y1,e.x,e.y);break;case"q":e.x1=e.x+ +r[0],e.y1=e.y+ +r[1],e.x+=+r[2],e.y+=+r[3],s.quadraticCurveTo(e.x1,e.y1,e.x,e.y);break;case"Z":case"z":s.closePath()}}drawEllipse(e,t,r,s,a,i){const{context:o}=this;o.save(),this.resetShapeStyles(i),this.setTransform(a);const x=2*r,y=2*s,l=.5522848,n=x/2*l,h=y/2*l,c=(e-=r)+x,d=(t-=s)+y,T=e+x/2,b=t+y/2;o.beginPath(),o.moveTo(e,b),o.bezierCurveTo(e,b-h,T-n,t,T,t),o.bezierCurveTo(T+n,t,c,b-h,c,b),o.bezierCurveTo(c,b+h,T+n,d,T,d),o.bezierCurveTo(T-n,d,e,b+h,e,b),this.fillOrStroke(i),o.restore()}drawRect(e,t,r,s,a,i,o){const{context:x}=this;x.save(),this.resetShapeStyles(o),this.setTransform(i);let y=a;r<2*y&&(y=r/2),s<2*y&&(y=s/2),x.beginPath(),x.moveTo(e+y,t),x.arcTo(e+r,t,e+r,t+s,y),x.arcTo(e+r,t+s,e,t+s,y),x.arcTo(e,t+s,e,t,y),x.arcTo(e,t,e+r,t,y),x.closePath(),this.fillOrStroke(o),x.restore()}drawShape(e){const{type:t,path:r,transform:s,styles:a}=e;switch(t){case"shape":this.drawBezier(r.d,s,a);break;case"ellipse":this.drawEllipse(r.x??0,r.y??0,r.radiusX??0,r.radiusY??0,s,a);break;case"rect":this.drawRect(r.x??0,r.y??0,r.width??0,r.height??0,r.cornerRadius??0,s,a)}}drawSprite(e,t,r){if(e.alpha<.05)return;const{context:s}=this,{alpha:a,transform:i,layout:o,shapes:x,maskPath:y}=e,{a:l=1,b:n=0,c:h=0,d:c=1,tx:d=0,ty:T=0}=i??{};s.save(),this.setTransform(this.globalTransform),s.globalAlpha=a,s.transform(l,n,h,c,d,T),t&&(y&&(this.drawBezier(y.d,y.transform,y.styles),s.clip()),s.drawImage(t,0,0,o.width,o.height)),r&&s.drawImage(r,(o.width-r.width)/2,(o.height-r.height)/2);for(let e=0;e<x.length;e++)this.drawShape(x[e]);s.restore()}getGlobalTransform(){return this.globalTransform}setGlobalTransform(e){this.globalTransform=e}render(e,t,r,s,a,i){const{sprites:o}=e;let x,y,l,n;for(let e=a;e<i;e++)x=o[e],y=x.imageKey,l=t.get(y),n=r.get(y),this.drawSprite(x.frames[s],l,n)}}export{t as Renderer2D};
//# sourceMappingURL=index.js.map
